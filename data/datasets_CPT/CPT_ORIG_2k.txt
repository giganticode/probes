tr	8	public static int [ ] [ ] readIntMatrix ( ) { while ( true ) { String [ ] lineTokens = readString ( ) . split ( "/" ) ; if ( lineTokens . length > 1 ) { String [ ] [ ] tokens = new String [ lineTokens . length ] [ ] ; int columns = 0 ; for ( int line = 0 ; line < lineTokens . length ; line ++ ) { tokens [ line ] = lineTokens [ line ] . split ( " " ) ; if ( tokens [ line ] . length > columns ) { columns = tokens [ line ] . length ; } } if ( columns > 0 ) { int [ ] [ ] array = new int [ lineTokens . length ] [ columns ] ; try { for ( int line = 0 ; line < tokens . length ; line ++ ) { for ( int column = 0 ; column < tokens [ line ] . length ; column ++ ) { array [ line ] [ column ] = Integer . parseInt ( tokens [ line ] [ column ] ) ; } } return array ; } catch ( NumberFormatException e ) { System . err . println ( ERROR_INVALID_INT ) ; } } else { System . out . println ( ERROR_EMPTY_LINE ) ; } } else { System . out . println ( ERROR_ONE_LINE_ARRAY ) ; } } }
tr	0	public void setTopicsService ( TopicsService topicsService ) { this . topicsService = topicsService ; }
tr	2	@ Override public void removeUser ( Identifier id ) throws DataBaseReadWriteException , IdentifierNotFoundException , InvalidIdentifierException { if ( id == null ) { throw new InvalidIdentifierException ( "Id is invalid" ) ; } if ( Users . remove ( id ) == null ) { throw new IdentifierNotFoundException ( "Id not found" ) ; } Users . remove ( id ) ; write ( USERS ) ; }
tr	2	private void closeSocket ( ) { try { if ( socket != null ) { socket . close ( ) ; socket = null ; } } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not close network socket: " + e . getMessage ( ) ) ; } socket = null ; }
tr	6	public static void main ( String [ ] args ) throws Exception { long start = System . currentTimeMillis ( ) ; Scanner in = new Scanner ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice-1.in" ) ) ; System . setOut ( new PrintStream ( new File ( "d:\\ProgramDATA\\2013\\Fair and Square\\C-large-practice1.out" ) ) ) ; int NumCase = in . nextInt ( ) ; in . nextLine ( ) ; for ( int curCase = 1 ; curCase <= NumCase ; curCase ++ ) { long min , max ; min = in . nextLong ( ) ; max = in . nextLong ( ) ; int count = 0 ; long sqrt_min = ( long ) Math . sqrt ( min ) , sqrt_max = ( long ) Math . sqrt ( max ) ; if ( min > 1 && min < 4 ) sqrt_min += 1 ; for ( long i = sqrt_min ; i <= sqrt_max ; i ++ ) { if ( IsPalin ( i ) && IsPalin ( i * i ) ) { count ++ ; } } System . out . println ( " Case #" + curCase + ": " + count ) ; } long end = System . currentTimeMillis ( ) ; System . out . println ( "\u8FD0\u884C\u65F6\u95F4\uFF1A" + ( end - start ) + "ms" ) ; }
tr	1	public void makeEven ( ) { if ( population . size ( ) % 2 == 1 ) { population . remove ( 0 ) ; } }
tr	1	@ Test public void acceptedTestAStar ( ) { Automaton a = new RegExp ( "a*" ) . toAutomaton ( ) ; String [ ] expected = { "" , "a" , "aa" , "aaa" , "aaaa" , "aaaaa" , "aaaaaa" , "aaaaaaa" , "aaaaaaaa" , "aaaaaaaaa" } ; int i = 0 ; for ( String s : AutomatonHelper . accepted ( a , 10 ) ) { assertEquals ( expected [ i ++ ] , s ) ; } }
tr	7	private Vector [ ] buildHeaders ( JPanel panel , ColumnSet set , boolean blankOut , Vector [ ] refLabels ) { int numParents = set . getNumParents ( ) ; int numChildren = getNumChildren ( set ) ; Vector [ ] headers = new Vector [ 2 ] ; headers [ 0 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; JLabel columnLabel = new JLabel ( ) ; int numColumns = parent . getNumChildren ( ) ; String text = parent . getText ( ) ; Color foreground = parent . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 0 ] . get ( i ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getParentConstraints ( numColumns , ( i == ( numParents - 1 ) ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 0 ] . add ( columnLabel ) ; } int index = 0 ; headers [ 1 ] = new Vector ( ) ; for ( int i = 0 ; i < set . getNumParents ( ) ; i ++ ) { ColumnParent parent = set . getParent ( i ) ; int numColumns = parent . getNumChildren ( ) ; for ( int j = 0 ; j < numColumns ; j ++ ) { ColumnChild child = parent . getChild ( j ) ; JLabel columnLabel = new JLabel ( ) ; String text = child . getText ( ) ; Color foreground = child . getColor ( ) ; if ( blankOut ) { foreground = columnLabel . getBackground ( ) ; columnLabel . setMaximumSize ( new Dimension ( 32000 , 2 ) ) ; if ( refLabels != null ) { JLabel refLabel = ( JLabel ) refLabels [ 1 ] . get ( index ) ; columnLabel . setPreferredSize ( new Dimension ( refLabel . getPreferredSize ( ) . width , 2 ) ) ; } } columnLabel . setText ( text ) ; columnLabel . setForeground ( foreground ) ; columnLabel . setHorizontalAlignment ( SwingConstants . CENTER ) ; GridBagConstraints constraints = getChildConstraints ( index == ( numChildren - 1 ) ) ; gridbag . setConstraints ( columnLabel , constraints ) ; panel . add ( columnLabel ) ; headers [ 1 ] . add ( columnLabel ) ; index ++ ; } } return headers ; }
tr	2	public static void findAll ( ) { try { IUTypeDao _dao = getUTypeDao ( ) ; UType _result [ ] = _dao . findAll ( ) ; for ( int i = 0 ; i < _result . length ; i ++ ) { display ( _result [ i ] ) ; } } catch ( Exception _e ) { _e . printStackTrace ( ) ; } }
tr	6	public void keyPressed ( KeyEvent e ) { int offset = ( e . getKeyCode ( ) == KeyEvent . VK_UP ) ? ( - 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_DOWN ) ? ( + 7 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_LEFT ) ? ( - 1 ) : ( ( e . getKeyCode ( ) == KeyEvent . VK_RIGHT ) ? ( + 1 ) : 0 ) ) ) ; int newDay = getDay ( ) + offset ; if ( ( newDay >= 1 ) && ( newDay <= calendar . getMaximum ( Calendar . DAY_OF_MONTH ) ) ) { setDay ( newDay ) ; } }
tr	5	@ SuppressWarnings ( { "unchecked" } ) public static < T > boolean equalsLists ( List < T > left , List < T > right , class < T > valueType ) { if ( left . size ( ) != right . size ( ) ) { return false ; } boolean equals = true ; if ( valueType . isArray ( ) && valueType . getComponentType ( ) == byte . TYPE ) { for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( Arrays . equals ( ( byte [ ] ) right . get ( i ) , ( byte [ ] ) left . get ( i ) ) == false ) { equals = false ; break ; } } } else { equals = left . equals ( right ) ; } return equals ; }
tr	0	@ Override public String toString ( ) { String dato = this . codigo + "-" + cliente + "-" + saldo + " lps en saldo." ; return dato ; }
tr	5	void deleteActivity ( Component dialogParent , Activity activity ) { if ( activity != null ) { if ( AlertMessages . deleteActivityConfirmation ( dialogParent , activity ) ) { try { Connection conn = Dao . getConnection ( ) ; for ( Time t : timeDao . getTimesByActivity ( conn , activity ) ) { timeDao . deleteTime ( conn , t ) ; } activityDao . deleteActivity ( conn , activity ) ; activityDialog . setActivity ( null ) ; activityListDialog . selectPreviousRow ( ) ; activityDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteActivity()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteActivity()" , ex ) ; } } } else { AlertMessages . noActivitySelectedInTableForDeleting ( activityListDialog ) ; } }
tr	2	public static int foul ( TeamMatch match ) { int x = 0 ; for ( Points p : match . getPoints ( ) ) { if ( p instanceof Points . FoulPoints ) { x += p . getPoints ( ) ; } } return x ; }
tr	0	public InvalidParameterException ( final String message , final Throwable exception ) { super ( message , exception ) ; }
tr	0	@ Override protected void finalize ( ) { close ( ) ; }
tr	8	public boolean initHeaderComponents ( ) { locationLabel = new JLabel ( "Project Location" ) ; locationLabel . setBounds ( 5 , 5 , 100 , 25 ) ; locationField = new JTextField ( ) ; locationField . setBounds ( 105 , 5 , 400 , 25 ) ; includeLabel = new JLabel ( "Include File type" ) ; includeLabel . setBounds ( 5 , 35 , 100 , 25 ) ; includeTextField = new JTextField ( ) ; includeTextField . setBounds ( 105 , 35 , 400 , 25 ) ; nonIncludeLabel = new JLabel ( "Non include" ) ; nonIncludeLabel . setBounds ( 5 , 65 , 100 , 25 ) ; nonIncludeTextField = new JTextField ( ) ; nonIncludeTextField . setBounds ( 105 , 65 , 400 , 25 ) ; configIncludeAndNonInclude ( ) ; openFileButton = new JButton ( "File.." ) ; openFileButton . setBounds ( 515 , 5 , 80 , 25 ) ; openFileButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { JFileChooser fileChooser = new JFileChooser ( new File ( "c:" ) ) ; int i = fileChooser . showOpenDialog ( header ) ; if ( i == JFileChooser . APPROVE_OPTION ) { locationField . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; configButton = new JButton ( "Config.." ) ; configButton . setBounds ( 515 , 45 , 80 , 25 ) ; configButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { configIncludeAndNonInclude ( ) ; } } ) ; loadButton = new JButton ( "Load" ) ; loadButton . setBounds ( 605 , 5 , 80 , 80 ) ; loadButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( locationField . getText ( ) == null || locationField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "File cannot be null!" ) ; return ; } if ( includeTextField . getText ( ) == null || includeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Include cannot be null!" ) ; return ; } if ( nonIncludeTextField . getText ( ) == null || nonIncludeTextField . getText ( ) . isEmpty ( ) ) { UISupport . showMessage ( "Non-Include cannot be null!" ) ; return ; } if ( sourceCounter == null ) { sourceCounter = new SourceCounter ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) , includeTextField . getText ( ) , nonIncludeTextField . getText ( ) ) ; } else { sourceCounter . setFiles ( FileUtils . getFiles ( new File ( locationField . getText ( ) ) ) ) ; sourceCounter . repaint ( ) ; } } } ) ; header . add ( locationLabel ) ; header . add ( locationField ) ; header . add ( includeLabel ) ; header . add ( includeTextField ) ; header . add ( nonIncludeLabel ) ; header . add ( nonIncludeTextField ) ; header . add ( openFileButton ) ; header . add ( configButton ) ; header . add ( loadButton ) ; return false ; }
tr	9X	public void storePast ( PastData past ) { if ( past . zip . equalsIgnoreCase ( "denver co" ) ) past . zip = "80201" ; String prefix = past . zip + " " + timeFormat . format ( past . date ) + " " + past . today + " " + past . occurredDate ; if ( past . overallPast . high != null || past . overallPast . precip != null ) { String str = prefix ; str = str + " " ; if ( past . overallPast . high != null ) str = str + past . overallPast . high . toString ( ) ; str = str + " " ; if ( past . overallPast . precip != null ) str = str + past . overallPast . precip . toString ( ) ; str = str + " " ; DAout . println ( str ) ; } if ( past . hourlyPast . length != 0 ) { for ( int i = 0 ; i < past . hourlyPast . length ; i ++ ) { String str = prefix ; str = str + " " + past . hourlyPast [ i ] . hour ; str = str + " " ; if ( past . hourlyPast [ i ] . temp != null ) str = str + past . hourlyPast [ i ] . temp . toString ( ) ; str = str + " " ; if ( past . hourlyPast [ i ] . conditions != null ) str = str + past . hourlyPast [ i ] . conditions ; str = str + " " ; if ( past . hourlyPast [ i ] . precip != null ) str = str + past . hourlyPast [ i ] . precip . toString ( ) ; str = str + " " ; HAout . println ( str ) ; } } }
tr	1	public Game ( Dimension boardDimension ) { board = new Board ( boardDimension , this ) ; windowFavoriteSize = new Dimension ( 800 , 600 ) ; playerList = new ArrayList < Player > ( ) ; bufferPlayers = new ArrayList < Player > ( ) ; try { bufferBoard = board . clone ( ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( ) ; } }
tr	5	public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Card ) ) return false ; Card aCard = ( Card ) o ; if ( ( aCard . suitID == this . suitID ) && ( aCard . nonTrumpCardValue == this . nonTrumpCardValue ) && ( aCard . trumpCardValue == this . trumpCardValue ) ) return true ; return false ; }
tr	4	public void testFetchGroupsForUser ( ) { Group [ ] groups = ga . fetchGroupsForUser ( 1 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 2 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 3 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 1 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 1 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 1 ] . isIsactive ( ) ) ; } groups = ga . fetchGroupsForUser ( 5 , false ) ; for ( int i = 0 ; i < groups . length ; i ++ ) { assertTrue ( groups [ i ] . getId ( ) == ( i + 2 + 1 ) ) ; assertTrue ( groups [ i ] . getName ( ) . equals ( testgroups [ i + 2 ] . getName ( ) ) ) ; assertTrue ( groups [ i ] . isIsactive ( ) == testgroups [ i + 2 ] . isIsactive ( ) ) ; } }
tr	3	public byte [ ] toBytes ( ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutput out = null ; try { out = new ObjectOutputStream ( bos ) ; out . writeObject ( this ) ; byte [ ] yourBytes = bos . toByteArray ( ) ; return yourBytes ; } finally { try { if ( out != null ) { out . close ( ) ; } } catch ( IOException ex ) { } try { bos . close ( ) ; } catch ( IOException ex ) { } } }
tr	2	private String getKey ( String keyword ) { Set < String > set = nTimesGivenDay . keySet ( ) ; Iterator < String > iter = set . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; if ( key . contains ( keyword ) ) { return key ; } } return new String ( ) ; }
tr	6	public ListNode reverseBetween ( ListNode head , int m , int n ) { if ( m == n ) return head ; ListNode dumy = new ListNode ( 0 ) ; dumy . next = head ; ListNode pre = dumy ; ListNode cur = head ; ListNode tail = null ; ListNode start = null ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) { tail = cur ; start = pre ; start . next = cur . next ; pre = cur ; cur = cur . next ; } else if ( i > m && i < n ) { start . next = cur . next ; cur . next = pre ; pre = cur ; cur = start . next ; } else if ( i == n ) { tail . next = cur . next ; cur . next = pre ; } else { pre = cur ; cur = cur . next ; } } return dumy . next ; }
tr	7	public String reverseWords ( String s ) { if ( s . length ( ) == 0 ) return s ; String [ ] arr = s . split ( " " ) ; ArrayList < String > aa = new ArrayList < String > ( ) ; if ( arr . length == 0 ) return "" ; int i = 0 ; while ( i < arr . length ) { if ( ! ( arr [ i ] . equals ( " " ) || arr [ i ] . equals ( "" ) ) ) { aa . add ( arr [ i ] ) ; } i ++ ; } if ( aa . size ( ) == 0 ) return "" ; String ret = aa . get ( aa . size ( ) - 1 ) ; for ( i = aa . size ( ) - 2 ; i > - 1 ; i -- ) { ret = ret + " " + aa . get ( i ) ; } return ret ; }
tr	9X	public void run ( ) { while ( isWriter ) { int i ; int j ; synchronized ( this ) { if ( buffIndex == writeIndex ) try { wait ( ) ; } catch ( InterruptedException _ex ) { } if ( ! isWriter ) return ; j = writeIndex ; if ( buffIndex >= writeIndex ) i = buffIndex - writeIndex ; else i = 5000 - writeIndex ; } if ( i > 0 ) { try { outputStream . write ( buffer , j , i ) ; } catch ( IOException _ex ) { hasIOError = true ; } writeIndex = ( writeIndex + i ) % 5000 ; try { if ( buffIndex == writeIndex ) outputStream . flush ( ) ; } catch ( IOException _ex ) { hasIOError = true ; } } } }
tr	9X	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int [ ] p1 ; int [ ] p2 ; int p3 ; double p4 ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 5 } ; p3 = 10 ; p4 = 0.5D ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 } ; p1 = new int [ ] { 0 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.0D ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 10 } ; p1 = new int [ ] { 10 } ; p2 = new int [ ] { 10 } ; p3 = 10 ; p4 = 0.4142135623730951D ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 11 , - 11 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 11 , - 11 } ; p2 = new int [ ] { 10 , 10 , 10 , 10 } ; p3 = 31 ; p4 = 0.3548387096774194D ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 100 } ; p1 = new int [ ] { 100 } ; p2 = new int [ ] { 1 } ; p3 = 10 ; p4 = 1.0D ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 1000000000 } ; p1 = new int [ ] { 1000000000 } ; p2 = new int [ ] { 1000000000 } ; p3 = 1000000000 ; p4 = 0.41421356237309503D ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 20 , - 20 , 0 , 0 } ; p1 = new int [ ] { 0 , 0 , 20 , - 20 } ; p2 = new int [ ] { 50 , 50 , 50 , 50 } ; p3 = 100 ; p4 = 0.3D ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { 0 , - 60 , - 62 , - 60 , 63 , - 97 } ; p1 = new int [ ] { - 72 , 67 , 61 , - 8 , - 32 , 89 } ; p2 = new int [ ] { 6 , 7 , 8 , 7 , 5 , 6 } ; p3 = 918 ; p4 = 0.9407071068962471D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 187730043 , 932334096 , 59236807 , - 602044448 , 441157147 , 569003535 , 563472630 , 493784941 , - 928345136 , - 198534684 , - 507361726 , - 486699261 , - 705601684 , - 671249417 , - 79879427 , 71698248 , 146683444 , 414416326 , 53196305 , - 666818573 , 178619454 , - 893182413 , 224302710 , 296990194 , - 885921154 , - 173521881 , - 493092068 , 900325848 , - 353242967 , - 631482448 , 112982750 , 553248219 , 264762102 , - 318102799 , - 836641673 , - 812311860 , - 73259832 , 609869565 , 650010687 , 155243096 , - 107417345 , 634247427 , - 841502473 , - 651719520 , - 958664893 , 480384188 , - 691415372 , 36346544 , 706329659 , 126652235 , 44403422 , - 263265167 , - 349491074 , 120258505 , 485027199 , - 240466308 , - 456782932 , 192953958 , - 261803363 , - 198063552 , 980391799 , 997148607 , 417112854 , - 333017353 , - 945493557 , 371446553 , 251150037 , - 960076588 , - 360362805 , - 305175580 , 208353048 , - 437834549 , - 420355623 , - 668454094 , 180494692 , 755143595 , 249998094 , 537726369 , 343336414 , 495586169 , 35446018 , 131243302 , 501744441 , 739753520 , - 876687692 , 560013605 , - 443087342 , 455209428 , 333669368 , 398118304 , - 695213876 , 527566904 , - 463103162 , - 317355625 , 641069703 , - 947785900 , - 532490870 , - 963111776 , - 727898154 , 748858912 } ; p1 = new int [ ] { 452827103 , 247175647 , 11753377 , - 611873763 , - 531081305 , 859586805 , - 868286674 , - 876539858 , 304963335 , 990345765 , - 859353631 , - 475065113 , - 574709927 , 131112520 , - 846074893 , 464742988 , - 41360301 , 899849149 , - 266820064 , - 251052777 , 226747686 , 876712903 , - 350309643 , 131456902 , - 799664596 , 453822371 , - 617483392 , 755895436 , - 72097080 , 199834107 , - 619495741 , - 922106677 , 229012084 , 419002428 , 38711443 , 293733516 , 633211140 , - 65526196 , - 776215532 , - 491310115 , - 23818472 , 792447417 , 726536324 , - 686011537 , - 140383515 , - 569321731 , - 402939093 , - 125768005 , - 18416939 , 127783325 , - 67341991 , - 322587512 , - 296995968 , - 536590267 , 437613161 , - 206640690 , - 825549222 , 102733497 , - 399947312 , 55751657 , 527107031 , - 152726436 , - 821534503 , 267030010 , - 528297582 , - 897079824 , - 521362885 , 1225411 , 460297398 , 596603062 , - 270748768 , 211858545 , - 654848212 , - 353416243 , 955853430 , - 447642704 , 739273996 , - 118039293 , 583896289 , - 253276293 , 632398992 , 560349797 , 222539806 , 677153439 , - 804423594 , - 285780470 , 782032960 , 23986706 , - 812231058 , 344193048 , 491603558 , 956077657 , - 97237599 , - 644202406 , - 311702606 , 645844112 , 47834815 , - 802896183 , 472801824 , 658244534 } ; p2 = new int [ ] { 4 , 7 , 4 , 4 , 5 , 1 , 8 , 4 , 5 , 7 , 8 , 3 , 5 , 5 , 9 , 5 , 8 , 5 , 6 , 7 , 7 , 8 , 10 , 6 , 10 , 6 , 3 , 4 , 5 , 1 , 5 , 8 , 9 , 8 , 2 , 3 , 1 , 9 , 8 , 5 , 8 , 6 , 9 , 2 , 2 , 9 , 9 , 2 , 6 , 4 , 8 , 2 , 4 , 9 , 7 , 5 , 5 , 2 , 1 , 9 , 2 , 5 , 6 , 10 , 4 , 9 , 4 , 4 , 10 , 1 , 10 , 9 , 8 , 10 , 2 , 2 , 9 , 10 , 3 , 4 , 6 , 10 , 5 , 1 , 9 , 3 , 5 , 5 , 4 , 5 , 5 , 5 , 1 , 10 , 6 , 7 , 1 , 1 , 10 , 2 } ; p3 = 1000000000 ; p4 = 0.999999094D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; p0 = new int [ ] { - 196 , 450 , 79 , - 220 , - 916 , 991 , - 451 , 462 , - 58 , - 353 , - 500 , 783 , 816 , 511 } ; p1 = new int [ ] { 188 , 681 , - 234 , - 330 , - 14 , 991 , - 969 , 347 , - 458 , - 940 , 454 , - 28 , 767 , - 620 } ; p2 = new int [ ] { 64 , 31 , 60 , 49 , 65 , 100 , 1 , 98 , 33 , 66 , 52 , 45 , 69 , 2 } ; p3 = 1484 ; p4 = 0.22007657635156566D ; all_right = KawigiEdit_RunTest ( 7 , p0 , p1 , p2 , p3 , true , p4 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	8	public int minimumTotal ( ArrayList < ArrayList < Integer >> triangle ) { int out = 0 ; int min ; if ( triangle == null || triangle . size ( ) == 0 ) return out ; int tLevel = triangle . size ( ) ; out = triangle . get ( 0 ) . get ( 0 ) ; ArrayList < Integer > candidate = new ArrayList < Integer > ( ) ; candidate . add ( out ) ; ArrayList < Integer > next ; for ( int level = 1 ; level < tLevel ; level ++ ) { next = new ArrayList < Integer > ( ) ; int k ; for ( int i = 0 ; i <= level ; i ++ ) { if ( i == 0 ) k = triangle . get ( level ) . get ( 0 ) + candidate . get ( 0 ) ; else if ( i == level ) k = triangle . get ( level ) . get ( i ) + candidate . get ( i - 1 ) ; else { k = triangle . get ( level ) . get ( i ) ; k += Math . min ( candidate . get ( i - 1 ) , candidate . get ( i ) ) ; } next . add ( k ) ; } candidate . clear ( ) ; candidate = next ; } if ( candidate . size ( ) != 0 ) { min = candidate . get ( 0 ) ; for ( int c : candidate ) { min = Math . min ( min , c ) ; } out = min ; } return out ; }
tr	9X	public static void arraycopy ( final ObjectLargeArray src , final long srcPos , final ObjectLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length()" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . set ( destPos + k , src . get ( srcPos + k ) ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long i = srcPos , j = destPos ; i < srcPos + length ; i ++ , j ++ ) { dest . set ( j , src . get ( i ) ) ; } } } }
tr	4	private static Object [ ] subseq ( Object [ ] ary , int lo , int hi ) { if ( lo >= hi ) return null ; else if ( lo == 0 && hi == ary . length ) return ary ; else { int len = hi - lo ; Object [ ] a = new Object [ len ] ; for ( int i = 0 ; i < len ; ++ i ) a [ i ] = ary [ i + lo ] ; return a ; } }
tr	4	public static void create ( String [ ] args ) { Vector < vslFileDataChunk > chunks = null ; if ( args . length < 3 ) { System . err . println ( "Missings args: create <dbfile> <source>" ) ; System . exit ( 1 ) ; } source = args [ 2 ] ; try { chunks = handler . chunkFile ( source ) ; vslDataType < vslFileDataChunk > fileData = new vslDataType < vslFileDataChunk > ( ) ; StringTokenizer st = new StringTokenizer ( source , "/" ) ; String fname = "UNSET" ; while ( st . hasMoreTokens ( ) ) { fname = st . nextToken ( ) ; } fileData . setName ( fname ) ; for ( vslFileDataChunk chunk : chunks ) { fileData . addNewChunk ( chunk ) ; } core . addEntry ( fileData ) ; core . debugShow ( ) ; core . save ( ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } }
tr	5	@ Override public double [ ] GetDiscreteFunction ( double [ ] x , double [ ] paramsMF ) { if ( this . paramsMF . length == paramsMF . length ) this . paramsMF = paramsMF ; else return null ; int n = x . length ; double [ ] func = new double [ n ] ; double a = paramsMF [ 0 ] , b = paramsMF [ 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( x [ i ] < a ) { func [ i ] = 1.0 ; } else if ( x [ i ] < ( a + b ) / 2.0 ) { func [ i ] = 1 - 2.0 * Math . pow ( ( x [ i ] - a ) / ( b - a ) , 2 ) ; } else if ( x [ i ] < b ) { func [ i ] = 2.0 * Math . pow ( ( x [ i ] - b ) / ( b - a ) , 2 ) ; } else func [ i ] = 0.0 ; } return func ; }
tr	2	public void requestOpenPose ( int id ) { boolean continueToOpen = true ; if ( ! saved ) { continueToOpen = promptToSave ( ) ; } if ( continueToOpen ) { promptToOpen ( id ) ; } }
tr	0	public Shader build ( ) { String vsh = _vsh . build ( ) ; String fsh = _fsh . build ( ) ; int vID = createShader ( GL20 . GL_VERTEX_SHADER , vsh ) ; int fID = createShader ( GL20 . GL_FRAGMENT_SHADER , fsh ) ; int pID = linkShader ( vID , fID ) ; return new Shader ( pID , _manager ) ; }
tr	0	public ScoreLevel ( ) { this . Id = 0 ; this . message = "" ; this . whole = true ; this . half = true ; this . dottedhalf = false ; this . quarter = false ; this . eighth = false ; this . silence = true ; this . triplet = false ; this . currentKey = "treble" ; this . randomtonality = false ; this . currenttonality = new Tonality ( 0 , "" ) ; this . pitcheslist = new ArrayList < Integer > ( ) ; this . notetype = "notes" ; this . nbnotes = 9 ; this . timeSignNumerator = 4 ; this . timeSignDenominator = 4 ; this . timeDivision = 1 ; this . speed = 28 ; this . metronome = true ; this . beats = false ; }
tr	1	private int getMaxLen ( ) throws ValidationException { String text = this . maxLenTextField . getText ( ) ; try { int M = Integer . parseInt ( text ) ; return M ; } catch ( Exception e ) { String message = "The maximum length is not an integer number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } }
tr	7	@ Override public LinkedList < Individual > crossover ( int [ ] parents , Population pop ) { LinkedList < Individual > children = new LinkedList < Individual > ( ) ; Random r = new Random ( ) ; int r1 = r . nextInt ( parents . length ) ; int r2 = r . nextInt ( parents . length ) ; Individual p1 = pop . people [ parents [ r1 ] ] ; Individual p2 = pop . people [ parents [ r2 ] ] ; int dna1 [ ] [ ] = new int [ 9 ] [ 9 ] ; int dna2 [ ] [ ] = new int [ 9 ] [ 9 ] ; Sudoku parent1 = ( ( Sudoku ) p1 ) ; Sudoku parent2 = ( ( Sudoku ) p2 ) ; for ( int row = 0 ; row < 9 ; row ++ ) { int cut1 = r . nextInt ( 9 ) ; int cut2 = r . nextInt ( 9 ) ; if ( cut2 < cut1 ) { int temp = cut1 ; cut1 = cut2 ; cut2 = temp ; } for ( int col = 0 ; col < 9 ; col ++ ) { if ( col <= cut1 || col >= cut2 ) { dna1 [ row ] [ col ] = parent2 . rows [ row ] [ col ] ; dna2 [ row ] [ col ] = parent1 . rows [ row ] [ col ] ; } else { int a = parent1 . rows [ row ] [ col ] ; if ( ! contains ( a , dna2 [ row ] ) ) dna2 [ row ] [ col ] = a ; int b = parent2 . rows [ row ] [ col ] ; if ( ! contains ( b , dna1 [ row ] ) ) dna1 [ row ] [ col ] = b ; } } } children . add ( new Sudoku ( dna1 ) ) ; children . add ( new Sudoku ( dna2 ) ) ; return children ; }
tr	4	public void equipWeapon ( Survivor survivor , Weapon weapon ) throws CantEquipWeaponException { if ( ! this . survivors . contains ( survivor ) ) { throw new CantEquipWeaponException ( CantEquipWeaponException . notInTheTeam ( survivor ) ) ; } else if ( ! this . mainBase . getAvailableWeapons ( ) . contains ( weapon ) ) { throw new CantEquipWeaponException ( "Weapon must be one of those stored in base to equip" ) ; } else { Survivor owner = this . alreadyEquipped ( weapon ) ; if ( owner != null ) { throw new CantEquipWeaponException ( "Weapon is already equipped by " + owner . getName ( ) ) ; } else { Weapon oldWeapon = survivor . getWeapon ( ) ; this . mainBase . getAvailableWeapons ( ) . remove ( weapon ) ; survivor . setWeapon ( weapon ) ; if ( oldWeapon != null ) { this . mainBase . getAvailableWeapons ( ) . add ( oldWeapon ) ; } } } }
tr	3	public static Integer BuildJob ( String receptor , String ownerID , VinaParams vinaParams , FilterParams filterParams , String dispatchQueueLoc ) throws SQLException , AmazonServiceException , JAXBException , AmazonClientException , FileNotFoundException , IOException { Integer jobID = Initializer . getInstance ( null ) . getMaxJobID ( ownerID ) + 1 ; Initializer . getInstance ( null ) . putJobOnServer ( ownerID , jobID , new HashMap < Integer , wUStatus > ( ) ) ; DetermineWorkToDo jobWork = new DetermineWorkToDo ( receptor , ownerID , filterParams ) ; String receptorID = jobWork . PutReceptorInDatabase ( ) ; List < String > compoundIDs = jobWork . FilterCompoundsInDatabase ( ) ; Integer workUnitId = 0 ; List < SendMessageBatchRequestEntry > batch = new ArrayList < SendMessageBatchRequestEntry > ( ) ; Integer iter = 0 ; for ( String i : compoundIDs ) { SendMessageBatchRequestEntry entry = putWorkUnitInSQSBatch ( BuildWorkUnit ( receptorID , i , ownerID , jobID , workUnitId , vinaParams ) ) ; batch . add ( entry ) ; Initializer . getInstance ( ) . putWorkUnit ( ownerID , jobID , workUnitId , wUStatus . INFLIGHT ) ; workUnitId ++ ; iter ++ ; if ( iter >= 10 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; iter = 0 ; batch . removeAll ( batch ) ; } } if ( batch . size ( ) > 0 ) { SendMessageBatchRequest request = new SendMessageBatchRequest ( dispatchQueueLoc , batch ) ; Initializer . getInstance ( ) . getSqsClient ( ) . sendMessageBatch ( request ) ; System . out . println ( "batch sent" ) ; } return jobID ; }
tr	9X	private boolean r_mark_suffix_with_optional_n_consonant ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; int v_6 ; int v_7 ; lab0 : do { v_1 = limit - cursor ; lab1 : do { v_2 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab1 ; } cursor = limit - v_2 ; if ( cursor <= limit_backward ) { break lab1 ; } cursor -- ; v_3 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { break lab1 ; } cursor = limit - v_3 ; break lab0 ; } while ( false ) ; cursor = limit - v_1 ; { v_4 = limit - cursor ; lab2 : do { v_5 = limit - cursor ; if ( ! ( eq_s_b ( 1 , "n" ) ) ) { break lab2 ; } cursor = limit - v_5 ; return false ; } while ( false ) ; cursor = limit - v_4 ; } v_6 = limit - cursor ; if ( cursor <= limit_backward ) { return false ; } cursor -- ; v_7 = limit - cursor ; if ( ! ( in_grouping_b ( g_vowel , 97 , 305 ) ) ) { return false ; } cursor = limit - v_7 ; cursor = limit - v_6 ; } while ( false ) ; return true ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; IdentNode other = ( IdentNode ) obj ; if ( identName == null ) { if ( other . identName != null ) return false ; } else if ( ! identName . equals ( other . identName ) ) return false ; return true ; }
tr	4	public synchronized void updatedTTL ( ShareAvailability file ) { int row = 0 ; for ( String [ ] col : shares ) { if ( col [ 5 ] . equals ( file . getFile ( ) . getHash ( ) ) && col [ 4 ] . equals ( file . getHost ( ) . getAddress ( ) . getHostAddress ( ) ) ) { col [ 6 ] = String . valueOf ( file . getTtl ( ) ) ; } row ++ ; if ( shares . size ( ) > row ) { this . fireTableCellUpdated ( row , 6 ) ; } else { this . fireTableStructureChanged ( ) ; } } }
tr	2	@ Test public void testGet ( ) { for ( int i = 0 ; i < A . length ; ++ i ) { for ( int j = 0 ; j < A [ 0 ] . length ; ++ j ) { assertTrue ( matrixA . get ( i , j ) . equals ( A [ i ] [ j ] ) ) ; } } }
tr	6	public static ConsumptionModel getConsumptionModelForWashingMachine ( String type ) { if ( ! type . equals ( "p" ) && ! type . equals ( "q" ) ) { System . err . println ( "non-existent consumption model" ) ; System . exit ( 15 ) ; } if ( type . equals ( "p" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"p\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "p" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } else if ( type . equals ( "q" ) ) { String message = "{\"n\":0 \"params\":[{\"n\":1 \"values\":[{\"q\":107.74000000000001 \"d\":10 \"s\":0}]}]}" ; try { return new ConsumptionModel ( message , "q" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return null ; }
tr	5	public int solution ( String input ) { final Deque < Character > stack = new LinkedList < Character > ( ) ; final int nbChars = input . length ( ) ; for ( int i = 0 ; i < nbChars ; i ++ ) { final char c = input . charAt ( i ) ; if ( c == ( ) { stack . push ( c ) ; } else if ( c == ) ) { if ( stack . isEmpty ( ) ) { return 0 ; } else { stack . pop ( ) ; } } } return stack . isEmpty ( ) ? 1 : 0 ; }
tr	5	@ Override public Object visit ( ASTattr_stmt node , Object data ) { commonProcessing ( node , this ) ; if ( node . jjtGetValue ( ) . equals ( "node" ) ) { for ( int i = 0 ; i < node . jjtGetNumChildren ( ) ; i ++ ) { Node child = node . jjtGetChild ( i ) ; if ( child instanceof ASTattr_list ) { String childNodeShape = ( String ) child . jjtAccept ( this , data ) ; if ( childNodeShape . equals ( "doublecircle" ) || childNodeShape . equals ( "box" ) ) this . accept = true ; else this . accept = false ; } else { child . jjtAccept ( this , data ) ; } } } else node . childrenAccept ( this , data ) ; return null ; }
tr	3	public void eval ( Environment e ) { switch ( type ) { case Value : e . value ( e . thing ( this ) ) ; break ; case Name : e . value ( this ) ; break ; case Call : e . call ( this ) ; break ; default : throw new Error ( String . format ( "Primitive '%s' not implemented!" , value ) ) ; } }
tr	7	public static void lockInstance ( int port ) { if ( lockserver == null ) { try { lockserver = new ServerSocket ( port ) ; new Thread ( ) { @ Override public void run ( ) { while ( true ) { try { Socket socket = lockserver . accept ( ) ; ObjectInputStream in = new ObjectInputStream ( socket . getInputStream ( ) ) ; if ( window != null && in . readBoolean ( ) ) { window . setVisible ( true ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { window . setVisible ( true ) ; window . toFront ( ) ; window . requestFocus ( ) ; } } ) ; } in . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; } catch ( IOException e ) { try { Socket socket = new Socket ( Strings . getString ( InstanceLock . class , "0" ) , port ) ; ObjectOutputStream out = new ObjectOutputStream ( socket . getOutputStream ( ) ) ; out . writeBoolean ( true ) ; out . close ( ) ; socket . close ( ) ; } catch ( Exception e1 ) { } System . exit ( 0 ) ; } } }
tr	6	private void comparePackageParts ( TIPP p1 , TIPP p2 ) throws Exception { Collection < TIPPSection > s1 = p1 . getSections ( ) ; Collection < TIPPSection > s2 = p2 . getSections ( ) ; assertNotNull ( s1 ) ; assertNotNull ( s2 ) ; for ( TIPPSection s : s1 ) { TIPPSectionType type = s . getType ( ) ; List < ? extends TIPPFile > o1 = s . getFileResources ( ) ; TIPPSection _s = p2 . getSection ( type ) ; assertEquals ( s , _s ) ; List < ? extends TIPPFile > o2 = _s . getFileResources ( ) ; assertNotNull ( o1 ) ; assertNotNull ( o2 ) ; assertEquals ( o1 , o2 ) ; Iterator < ? extends TIPPFile > fit1 = o1 . iterator ( ) ; Iterator < ? extends TIPPFile > fit2 = o2 . iterator ( ) ; while ( fit1 . hasNext ( ) ) { TIPPFile f1 = fit1 . next ( ) ; assertTrue ( fit2 . hasNext ( ) ) ; TIPPFile f2 = fit2 . next ( ) ; assertEquals ( f1 , f2 ) ; try ( InputStream is1 = p1 . getFile ( f1 ) ; InputStream is2 = p2 . getFile ( f2 ) ) { verifyBytes ( is1 , is2 ) ; } } } }
tr	2	public void run ( ) { while ( true ) { try { Socket cli = serversocket . accept ( ) ; playback = new Playback ( cli ) ; playback . start ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	3	public DictionarySet ( ) { isCounting = false ; dicts = new Dictionary [ DictionaryTypes . TYPE_END . ordinal ( ) ] ; tot = dicts . length ; for ( int i = 0 ; i < tot ; ++ i ) { dicts [ i ] = new Dictionary ( ) ; int id = dicts [ i ] . lookupIndex ( unseen ) ; Utils . assert ( id == 1 ) ; if ( i == DictionaryTypes . POS . ordinal ( ) ) initDict ( DictionaryTypes . POS , dicts [ i ] ) ; if ( i == DictionaryTypes . WORD . ordinal ( ) ) initDict ( DictionaryTypes . WORD , dicts [ i ] ) ; } }
tr	7	public RegisterFrame ( ServerManager theServer , String theUrl , int thePort , int theListenPort ) { super ( "Registrar Usuario" ) ; controller = new RegisterController ( theServer , theUrl , thePort ) ; server = theServer ; url = theUrl ; port = thePort ; listenPort = theListenPort ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { createLoginFrame ( ) ; } } ) ; setBounds ( 100 , 100 , 661 , 403 ) ; contentPane = new JPanel ( ) ; contentPane . setBackground ( Color . WHITE ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( new BorderLayout ( 0 , 10 ) ) ; JLabel lblRegistrarUsuario = new JLabel ( "Registrar Usuario" ) ; lblRegistrarUsuario . setFont ( new Font ( "Tahoma" , Font . BOLD , 18 ) ) ; lblRegistrarUsuario . setHorizontalAlignment ( SwingConstants . CENTER ) ; contentPane . add ( lblRegistrarUsuario , BorderLayout . NORTH ) ; JPanel panelBotton = new JPanel ( ) ; panelBotton . setBackground ( Color . WHITE ) ; contentPane . add ( panelBotton , BorderLayout . SOUTH ) ; panelBotton . setLayout ( new FlowLayout ( FlowLayout . RIGHT , 5 , 5 ) ) ; JButton btnRegister = new JButton ( "Registrarse" ) ; btnRegister . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { try { controller . register ( usernameTxt . getText ( ) , new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) , firstNameTxt . getText ( ) , lastNameTxt . getText ( ) , emailTxt . getText ( ) ) ; JOptionPane . showMessageDialog ( null , "Registro exitoso!  ahora podra usar el servicio de chat" , "Registro exitoso" , JOptionPane . INFORMATION_MESSAGE ) ; createLoginFrame ( ) ; } catch ( RegisterException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } ) ; btnRegister . setIcon ( new ImageIcon ( RegisterFrame . class . getResource ( "/chat/client/view/resources/registerIcon.png" ) ) ) ; panelBotton . add ( btnRegister ) ; JButton btnCancel = new JButton ( "Cancelar" ) ; btnCancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { createLoginFrame ( ) ; } } ) ; panelBotton . add ( btnCancel ) ; JPanel panel = new JPanel ( ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; panel . setLayout ( new GridLayout ( 0 , 2 , 0 , 0 ) ) ; ImagePanel imagePanel = new ImagePanel ( Toolkit . getDefaultToolkit ( ) . getImage ( RegisterFrame . class . getResource ( "/chat/client/view/resources/ico2.jpg" ) ) ) ; panel . add ( imagePanel ) ; JPanel panel_1 = new JPanel ( ) ; panel_1 . setBackground ( Color . WHITE ) ; panel . add ( panel_1 ) ; GridBagLayout gbl_panel_1 = new GridBagLayout ( ) ; gbl_panel_1 . columnWidths = new int [ ] { 0 , 150 , 10 } ; gbl_panel_1 . rowHeights = new int [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 20 } ; gbl_panel_1 . columnWeights = new double [ ] { 0.0 , 1.0 , 0.0 } ; gbl_panel_1 . rowWeights = new double [ ] { 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 } ; panel_1 . setLayout ( gbl_panel_1 ) ; JLabel label = new JLabel ( "Nombre de Usuario:" ) ; label . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label = new GridBagConstraints ( ) ; gbc_label . anchor = GridBagConstraints . EAST ; gbc_label . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label . gridx = 0 ; gbc_label . gridy = 0 ; panel_1 . add ( label , gbc_label ) ; usernameTxt = new JTextField ( ) ; usernameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidUsername ( usernameTxt . getText ( ) ) ) { lblUserNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblUserNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; usernameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; usernameTxt . setColumns ( 20 ) ; GridBagConstraints gbc_usernameTxt = new GridBagConstraints ( ) ; gbc_usernameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_usernameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_usernameTxt . gridx = 1 ; gbc_usernameTxt . gridy = 0 ; panel_1 . add ( usernameTxt , gbc_usernameTxt ) ; lblUserNameError = new JLabel ( "" ) ; lblUserNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblUserNameError = new GridBagConstraints ( ) ; gbc_lblUserNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblUserNameError . gridx = 2 ; gbc_lblUserNameError . gridy = 0 ; panel_1 . add ( lblUserNameError , gbc_lblUserNameError ) ; JLabel label_1 = new JLabel ( "Contrase\u00F1a:" ) ; label_1 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_1 = new GridBagConstraints ( ) ; gbc_label_1 . anchor = GridBagConstraints . EAST ; gbc_label_1 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_1 . gridx = 0 ; gbc_label_1 . gridy = 1 ; panel_1 . add ( label_1 , gbc_label_1 ) ; passwordTxt = new JPasswordField ( ) ; passwordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent arg0 ) { if ( ! controller . isValidPassword ( new String ( passwordTxt . getPassword ( ) ) ) ) { lblPasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblPasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; passwordTxt . setColumns ( 20 ) ; passwordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_passwordTxt = new GridBagConstraints ( ) ; gbc_passwordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_passwordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_passwordTxt . gridx = 1 ; gbc_passwordTxt . gridy = 1 ; panel_1 . add ( passwordTxt , gbc_passwordTxt ) ; lblPasswordError = new JLabel ( "" ) ; lblPasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblPasswordError = new GridBagConstraints ( ) ; gbc_lblPasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblPasswordError . gridx = 2 ; gbc_lblPasswordError . gridy = 1 ; panel_1 . add ( lblPasswordError , gbc_lblPasswordError ) ; JLabel label_2 = new JLabel ( "Repetir contrase\u00F1a:" ) ; label_2 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_2 = new GridBagConstraints ( ) ; gbc_label_2 . anchor = GridBagConstraints . EAST ; gbc_label_2 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_2 . gridx = 0 ; gbc_label_2 . gridy = 2 ; panel_1 . add ( label_2 , gbc_label_2 ) ; rePasswordTxt = new JPasswordField ( ) ; rePasswordTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isRePasswordEqualToPassword ( new String ( passwordTxt . getPassword ( ) ) , new String ( rePasswordTxt . getPassword ( ) ) ) ) { lblRepasswordError . setText ( "*" ) ; lblError . setText ( "La contrase\uFFFDa es invalida" ) ; } else { lblRepasswordError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; rePasswordTxt . setColumns ( 20 ) ; rePasswordTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_rePasswordTxt = new GridBagConstraints ( ) ; gbc_rePasswordTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_rePasswordTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_rePasswordTxt . gridx = 1 ; gbc_rePasswordTxt . gridy = 2 ; panel_1 . add ( rePasswordTxt , gbc_rePasswordTxt ) ; lblRepasswordError = new JLabel ( "" ) ; lblRepasswordError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblRepasswordError = new GridBagConstraints ( ) ; gbc_lblRepasswordError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblRepasswordError . gridx = 2 ; gbc_lblRepasswordError . gridy = 2 ; panel_1 . add ( lblRepasswordError , gbc_lblRepasswordError ) ; JLabel label_3 = new JLabel ( "Nombre(s):" ) ; label_3 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_3 = new GridBagConstraints ( ) ; gbc_label_3 . anchor = GridBagConstraints . EAST ; gbc_label_3 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_3 . gridx = 0 ; gbc_label_3 . gridy = 3 ; panel_1 . add ( label_3 , gbc_label_3 ) ; firstNameTxt = new JTextField ( ) ; firstNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidFirstName ( firstNameTxt . getText ( ) ) ) { lblFirstNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblFirstNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; firstNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; firstNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_firstNameTxt = new GridBagConstraints ( ) ; gbc_firstNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_firstNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_firstNameTxt . gridx = 1 ; gbc_firstNameTxt . gridy = 3 ; panel_1 . add ( firstNameTxt , gbc_firstNameTxt ) ; lblFirstNameError = new JLabel ( "" ) ; lblFirstNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblFirstNameError = new GridBagConstraints ( ) ; gbc_lblFirstNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblFirstNameError . gridx = 2 ; gbc_lblFirstNameError . gridy = 3 ; panel_1 . add ( lblFirstNameError , gbc_lblFirstNameError ) ; JLabel label_4 = new JLabel ( "Apellido(s):" ) ; label_4 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_4 = new GridBagConstraints ( ) ; gbc_label_4 . anchor = GridBagConstraints . EAST ; gbc_label_4 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_4 . gridx = 0 ; gbc_label_4 . gridy = 4 ; panel_1 . add ( label_4 , gbc_label_4 ) ; lastNameTxt = new JTextField ( ) ; lastNameTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidLastName ( lastNameTxt . getText ( ) ) ) { lblLastNameError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblLastNameError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; lastNameTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; lastNameTxt . setColumns ( 30 ) ; GridBagConstraints gbc_lastNameTxt = new GridBagConstraints ( ) ; gbc_lastNameTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_lastNameTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_lastNameTxt . gridx = 1 ; gbc_lastNameTxt . gridy = 4 ; panel_1 . add ( lastNameTxt , gbc_lastNameTxt ) ; lblLastNameError = new JLabel ( "" ) ; lblLastNameError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblLastNameError = new GridBagConstraints ( ) ; gbc_lblLastNameError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblLastNameError . gridx = 2 ; gbc_lblLastNameError . gridy = 4 ; panel_1 . add ( lblLastNameError , gbc_lblLastNameError ) ; JLabel label_5 = new JLabel ( "E-mail:" ) ; label_5 . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; GridBagConstraints gbc_label_5 = new GridBagConstraints ( ) ; gbc_label_5 . anchor = GridBagConstraints . EAST ; gbc_label_5 . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_label_5 . gridx = 0 ; gbc_label_5 . gridy = 5 ; panel_1 . add ( label_5 , gbc_label_5 ) ; emailTxt = new JTextField ( ) ; emailTxt . addFocusListener ( new FocusAdapter ( ) { @ Override public void focusLost ( FocusEvent e ) { if ( ! controller . isValidEmail ( emailTxt . getText ( ) ) ) { lblEmailError . setText ( "*" ) ; lblError . setText ( "El nombre de usuario es invalido" ) ; } else { lblEmailError . setText ( "" ) ; lblError . setText ( "" ) ; } } } ) ; emailTxt . setFont ( new Font ( "Tahoma" , Font . PLAIN , 12 ) ) ; emailTxt . setColumns ( 50 ) ; GridBagConstraints gbc_emailTxt = new GridBagConstraints ( ) ; gbc_emailTxt . insets = new Insets ( 0 , 0 , 5 , 5 ) ; gbc_emailTxt . fill = GridBagConstraints . HORIZONTAL ; gbc_emailTxt . gridx = 1 ; gbc_emailTxt . gridy = 5 ; panel_1 . add ( emailTxt , gbc_emailTxt ) ; lblEmailError = new JLabel ( "" ) ; lblEmailError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblEmailError = new GridBagConstraints ( ) ; gbc_lblEmailError . insets = new Insets ( 0 , 0 , 5 , 0 ) ; gbc_lblEmailError . gridx = 2 ; gbc_lblEmailError . gridy = 5 ; panel_1 . add ( lblEmailError , gbc_lblEmailError ) ; lblError = new JLabel ( "" ) ; lblError . setForeground ( Color . RED ) ; GridBagConstraints gbc_lblError = new GridBagConstraints ( ) ; gbc_lblError . gridwidth = 3 ; gbc_lblError . insets = new Insets ( 0 , 0 , 0 , 5 ) ; gbc_lblError . gridx = 0 ; gbc_lblError . gridy = 6 ; panel_1 . add ( lblError , gbc_lblError ) ; }
tr	8	public static void main ( String [ ] args ) { int port = 4444 ; Queue < String > arguments = new LinkedList < String > ( Arrays . asList ( args ) ) ; try { while ( ! arguments . isEmpty ( ) ) { String flag = arguments . remove ( ) ; try { if ( flag . equals ( "--port" ) ) { port = Integer . parseInt ( arguments . remove ( ) ) ; if ( port < 0 || port > 65535 ) { throw new IllegalArgumentException ( "port " + port + " out of range" ) ; } } else { throw new IllegalArgumentException ( "unknown option: \"" + flag + "\"" ) ; } } catch ( NoSuchElementException nsee ) { throw new IllegalArgumentException ( "missing argument for " + flag ) ; } catch ( NumberFormatException nfe ) { throw new IllegalArgumentException ( "unable to parse number for " + flag ) ; } } } catch ( IllegalArgumentException iae ) { System . err . println ( iae . getMessage ( ) ) ; System . err . println ( "usage: WhiteboardServer [--port PORT]" ) ; return ; } try { runWhiteboardServer ( port ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	0	public boolean isNull ( String key ) { return JSONObject . null . equals ( this . opt ( key ) ) ; }
tr	6	public Integer checkFields ( ) { if ( buttonGroup . getSelection ( ) == null ) { return null ; } else { final Enumeration < AbstractButton > elements = buttonGroup . getElements ( ) ; Integer num = null ; while ( elements . hasMoreElements ( ) ) { final JRadioButton button = ( JRadioButton ) elements . nextElement ( ) ; if ( button != null ) { if ( button . isSelected ( ) ) { num = Integer . parseInt ( button . getText ( ) . substring ( button . getText ( ) . lastIndexOf ( # ) + 1 ) ) ; } } } if ( num != null ) { if ( checkFields ( num ) ) { return num ; } else { JOptionPane . showMessageDialog ( null , "***ERROR***: Incorrect search options" ) ; } } } return null ; }
tr	7	public void killHappenedAt ( PointI p , int mobSize , boolean wasSplashDamage ) { if ( ( p . x < 0 ) || ( p . y < 0 ) || ( p . x >= w ) || ( p . y >= h ) ) return ; double amount = 1f / mobSize / mobSize ; for ( int y = 0 ; y < mobSize ; y ++ ) { for ( int x = 0 ; x < mobSize ; x ++ ) { if ( wasSplashDamage ) { splashKillCounts [ p . y + y ] [ p . x + x ] += amount ; } else { normalKillCounts [ p . y + y ] [ p . x + x ] += amount ; } } } }
tr	1	public int getComponetType ( boolean disregardScrollPane ) { if ( compType == TYPE_UNSET ) compType = checkType ( disregardScrollPane ) ; return compType ; }
tr	0	@ Override public String execute ( ) throws Exception { String consequence = ERROR ; long id = input . getLong ( "id" ) ; CategoriaDespesa categoriaDespesa = ServiceLocator . getCategoriaDespesaService ( ) . readById ( id ) ; ServiceLocator . getCategoriaDespesaService ( ) . delete ( id ) ; consequence = SUCCESS ; return consequence ; }
tr	3	@ Override public int search ( E data ) { int centerint , left , right ; left = 0 ; right = _lenght - 1 ; E center ; while ( left <= right ) { centerint = ( left + right ) / 2 ; center = get ( centerint ) ; if ( _comparator . isHigher ( center , data ) ) { right = centerint - 1 ; } else if ( _comparator . isLess ( center , data ) ) { left = centerint + 1 ; } else { return ( left + right ) / 2 ; } } return - 1 ; }
tr	5	public void plotElements ( view3D view ) { for ( int pass = 0 ; pass < 2 ; pass ++ ) { DArray list = ( pass == 0 ) ? vertices : elements ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Renderable e = ( Renderable ) ( list . get ( i ) ) ; if ( e . deleted ( ) || ! e . visible ( ) ) continue ; e . transform ( view , viewVert , panelVert ) ; } } }
tr	7	public Level ( ) { Bitmap bmp = Art . load ( "/levels/level.png" ) ; int w = bmp . w + 8 ; int h = bmp . h + 8 ; this . w = w ; this . h = h ; xs = w ; ys = h ; blockmap = new Blockmap ( w * 16 , h * 16 , 32 ) ; tiles = new int [ xs * ys ] ; for ( int y = 0 ; y < ys ; y ++ ) { for ( int x = 0 ; x < xs ; x ++ ) { int xx = x - 4 ; int yy = y - 4 ; if ( xx < 0 || yy < 0 || xx >= bmp . w || yy >= bmp . h ) { tiles [ x + y * xs ] = 1 ; } else { int col = bmp . pixels [ xx + yy * bmp . w ] ; if ( col == ff000000 ) { tiles [ x + y * xs ] = 1 ; } else { tiles [ x + y * xs ] = 0 ; } } } } redPlayer = new Player ( this , Team . allied ) ; bluPlayer = new Player ( this , Team . soviet ) ; }
tr	0	@ Override public void close ( ) throws IOException { in . close ( ) ; }
tr	7	public static File getWorkingDirectory ( String applicationName ) { String userHome = System . getProperty ( "user.home" , "." ) ; File workingDirectory ; switch ( getPlatform ( ) . ordinal ( ) ) { case 0 : case 1 : workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 2 : String applicationData = System . getenv ( "APPDATA" ) ; if ( applicationData != null ) workingDirectory = new File ( applicationData , "." + applicationName + / ) ; else workingDirectory = new File ( userHome , . + applicationName + / ) ; break ; case 3 : workingDirectory = new File ( userHome , "Library/Application Support/" + applicationName ) ; break ; default : workingDirectory = new File ( userHome , applicationName + / ) ; } if ( ( ! workingDirectory . exists ( ) ) && ( ! workingDirectory . mkdirs ( ) ) ) throw new RuntimeException ( "The working directory could not be created: " + workingDirectory ) ; return workingDirectory ; }
tr	5	@ Override public boolean onRequest ( HttpRequest request , HttpResponse response ) throws Exception { String filePath = request . getRequestedFilePath ( ) ; if ( urlToMapTo != null ) { if ( ! filePath . startsWith ( urlToMapTo ) ) return false ; filePath = filePath . substring ( urlToMapTo . length ( ) ) ; } File file = new File ( directory , filePath ) ; if ( ! file . isFile ( ) || ! file . canRead ( ) || ! file . getAbsolutePath ( ) . startsWith ( directory . getAbsolutePath ( ) ) ) return false ; IOFileChannelInputBuffer buffer = new IOFileChannelInputBuffer ( new FileInputStream ( file ) . getChannel ( ) ) ; response . setHeader ( "content-type" , mimeNameMap . getContentTypeFor ( file . getAbsolutePath ( ) ) ) ; response . setBodyBuffer ( buffer ) ; buffer . free ( ) ; return true ; }
tr	7	public void onEnable ( ) { Server = getServer ( ) ; log = Server . getLogger ( ) ; setPdfFile ( this . getDescription ( ) ) ; moveFiles ( ) ; setupPermissions ( ) ; questPlayerStorage = new iProperty ( "plugins/uQuest/uQuest_Players.txt" ) ; if ( new File ( "plugins/uQuest/uQuest_Quests.txt" ) . exists ( ) ) new QuestConverter ( ) ; if ( isUseDefaultUQuest ( ) ) { Cmd_uquest cmd_uquest = new Cmd_uquest ( this ) ; getCommand ( "uquest" ) . setExecutor ( cmd_uquest ) ; getCommand ( "quest" ) . setExecutor ( cmd_uquest ) ; try { getCommand ( "q" ) . setExecutor ( cmd_uquest ) ; } catch ( NullPointerException npe ) { useDefaultHelp = false ; } } setupEconomy ( ) ; Cmd_reloadquests cmd_reloadquests = new Cmd_reloadquests ( this ) ; getCommand ( "reloadquests" ) . setExecutor ( cmd_reloadquests ) ; Cmd_reloadquestconfig cmd_reloadquestconfig = new Cmd_reloadquestconfig ( this ) ; getCommand ( "reloadquestconfig" ) . setExecutor ( cmd_reloadquestconfig ) ; readConfig ( ) ; theQuestsLoadAllIntoArray ( ) ; if ( this . theQuests . isEmpty ( ) ) { System . err . println ( "\n\n\n" + pluginNameBracket ( ) + " You have an empty quest list!\n Disabling plugin.\n\n\n" ) ; Server . getPluginManager ( ) . disablePlugin ( this ) ; return ; } if ( isUseSQLite ( ) == true ) { this . setDB ( new SqLiteKeyValStor < Quester > ( "questers" , "plugins/uQuest/uQuestQuesters" ) ) ; System . out . println ( pluginNameBracket ( ) + " Loaded with SQLite!" ) ; } if ( firstLoad == true && isUseSQLite ( ) == false ) { timerSavePlayers ( ) ; firstLoad = false ; System . out . println ( pluginNameBracket ( ) + " Loaded with Flatfile!" ) ; } registerEvents ( ) ; System . out . println ( pluginNameBracket ( ) + " v" + getPdfFile ( ) . getVersion ( ) + " enabled! With " + this . getQuestInteraction ( ) . getQuestTotal ( ) + " quests loaded!" ) ; }
tr	1	public void drawButtons ( ) { for ( int x = 0 ; x < buttons . size ( ) ; x ++ ) { buttons . get ( x ) . draw ( ScreenX , ScreenY ) ; } }
tr	5	private long removeRefAskData ( long lIndex ) { AskData refActualElement = GetAskData ( lIndex ) ; if ( refActualElement == null ) return lIndex ; for ( int intIndex = 0 ; intIndex < elementList . size ( ) ; intIndex ++ ) { Object theObject = elementList . get ( intIndex ) ; if ( ( theObject == null ) || ! ( theObject instanceof AskData ) ) continue ; AskData tempRef = ( AskData ) ( theObject ) ; if ( ( AskData . getCPtr ( tempRef ) == AskData . getCPtr ( refActualElement ) ) ) { elementList . remove ( tempRef ) ; break ; } } return lIndex ; }
tr	5	public static Integer convertStringToNumber ( String str ) { str = str . toLowerCase ( ) ; int num = ones . indexOf ( str ) ; if ( num > - 1 ) { return num ; } num = tens . indexOf ( str ) ; if ( num > - 1 ) { return num * 10 ; } String arr [ ] = str . split ( " |-" ) ; if ( arr . length == 2 ) { num = tens . indexOf ( arr [ 0 ] ) * 10 ; if ( num > - 1 ) { num += ones . indexOf ( arr [ 1 ] ) ; if ( num > 20 ) { return num ; } } } return null ; }
tr	8	public SocketThread ( Socket skt ) { this . socket = skt ; this . reader = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { input = new XMLReader ( new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { messages . add ( input . readMessage ( ) ) ; fireEvent ( ) ; } catch ( XMLStreamException e ) { if ( Thread . interrupted ( ) ) { System . out . println ( "Reader closed." ) ; return ; } else { e . printStackTrace ( ) ; } } } } } ) ; this . writer = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { output = new XMLWriter ( new PrintWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) , "UTF-8" ) ) ) ; } catch ( XMLStreamException | IOException e ) { e . printStackTrace ( ) ; return ; } while ( true ) { try { Message m = msgQueue . take ( ) ; output . writeMessage ( m ) ; } catch ( InterruptedException e ) { System . out . println ( "Writer closed." ) ; return ; } catch ( XMLStreamException e ) { e . printStackTrace ( ) ; } } } } ) ; }
tr	3	private void timeButtonMouseClicked ( java . awt . event . MouseEvent evt ) { JOptionPane infoPopup = new JOptionPane ( ) ; int n = JOptionPane . showConfirmDialog ( null , "Are you sure you want to quit?" , "End game" , JOptionPane . YES_NO_OPTION ) ; Result r = new Result ( ) ; ResultContainer cont = new ResultContainer ( ) ; String s = new String ( ) ; if ( n == JOptionPane . YES_OPTION ) { s = JOptionPane . showInputDialog ( null , "Please type your name below: " , "Type your name" , JOptionPane . PLAIN_MESSAGE ) ; System . out . println ( s ) ; if ( s != null ) r . setName ( s ) ; if ( this . empire . getTotalSeconds ( ) > 0 ) r . setSeconds ( this . empire . getTotalSeconds ( ) ) ; infoPopup . setVisible ( false ) ; cont . addAndSerialize ( r ) ; System . exit ( 0 ) ; } }
tr	9X	public static void main ( String [ ] args ) throws IOException , ClassNotFoundException , ParseException { Properties properties = new Properties ( ) ; properties . load ( Client . class . getClassLoader ( ) . getResourceAsStream ( "client.properties" ) ) ; Integer serverPort = Integer . valueOf ( properties . getProperty ( "client.server_port" , "1234" ) ) ; String serverAddress = properties . getProperty ( "client.server_address" , "localhost" ) ; ObjectOutputStream toServer = null ; ObjectInputStream fromServer = null ; Socket connectionSocket = null ; try { connectionSocket = new Socket ( serverAddress , serverPort ) ; Scanner scanner = new Scanner ( System . in ) ; toServer = new ObjectOutputStream ( connectionSocket . getOutputStream ( ) ) ; fromServer = new ObjectInputStream ( connectionSocket . getInputStream ( ) ) ; log . info ( "Connection created!" ) ; while ( ! start ( toServer , fromServer , scanner ) ) ; while ( homePage ( toServer , fromServer , scanner ) ) ; } catch ( IOException e ) { log . error ( "Can't connect to server." , e ) ; } catch ( NoSuchElementException e ) { log . error ( "User terminated session" , e ) ; } finally { if ( toServer != null ) { try { toServer . close ( ) ; } catch ( IOException e ) { log . error ( "To server stream closing error" , e ) ; } } if ( fromServer != null ) { try { fromServer . close ( ) ; } catch ( IOException e ) { log . error ( "From server stream closing error" , e ) ; } } if ( connectionSocket != null ) { try { connectionSocket . close ( ) ; } catch ( IOException e ) { log . error ( "Connection socket closing error" , e ) ; } } } }
tr	2	protected void execute ( ) { if ( shooter . left . getD ( ) - accuracy > pos ) { shooter . set ( - holdVel ) ; } else if ( shooter . left . getD ( ) + accuracy < pos ) { shooter . set ( holdVel ) ; } else { shooter . set ( 0.0 ) ; } }
tr	5	public static Pair < Integer , Integer > linearCongruence ( int a , int b , final int n ) { positiveCheck ( n ) ; a = normalizeIntModulo ( a , n ) ; b = normalizeIntModulo ( b , n ) ; if ( ( ( a == 0 ) && ( b == 0 ) ) || ( n == 1 ) ) return new Pair < > ( 0 , 1 ) ; final int numberOfSolutions = gcd ( a , n ) ; if ( b % numberOfSolutions != 0 ) return new Pair < > ( ) ; int bezoutCoefficientA ; if ( a > n ) bezoutCoefficientA = bezout ( a , n ) . get ( 1 ) ; else bezoutCoefficientA = bezout ( n , a ) . get ( 2 ) ; final int shiftedModulus = n / numberOfSolutions ; int x = ( bezoutCoefficientA * b ) / numberOfSolutions ; x = normalizeIntModulo ( x , shiftedModulus ) ; return new Pair < > ( x , shiftedModulus ) ; }
tr	2	private void whileChatting ( ) throws IOException { ableToType ( true ) ; do { try { message = ( String ) in . readObject ( ) ; displayMessage ( message , INCOMMINGMESSAGE ) ; } catch ( ClassNotFoundException classNotFoundException ) { displayMessage ( "Invalid Input" , MESSAGE ) ; } } while ( ! message . equals ( "SERVER - END" ) ) ; }
tr	1	@ Override public boolean equals ( Object other ) { if ( other instanceof NewId ) { return this . equals ( ( NewId ) other ) ; } return false ; }
tr	0	public List < Campaign > getCamlist ( ) { return camlist ; }
tr	5	private void drawGhosts ( ) { for ( int index = 0 ; index < G . NUM_GHOSTS ; index ++ ) { int loc = game . getCurGhostLoc ( index ) ; int x = game . getX ( loc ) ; int y = game . getY ( loc ) ; if ( game . getEdibleTime ( index ) > 0 ) { if ( game . getEdibleTime ( index ) < _G_ . EDIBLE_ALERT && ( ( game . getTotalTime ( ) % 6 ) / 3 ) == 0 ) bufferGraphics . drawImage ( ghostsImgs [ 5 ] [ 0 ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; else bufferGraphics . drawImage ( ghostsImgs [ 4 ] [ 0 ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; } else { if ( game . getLairTime ( index ) > 0 ) bufferGraphics . drawImage ( ghostsImgs [ index ] [ G . UP ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 + ( index * 5 ) , y * MAG + 3 , null ) ; else bufferGraphics . drawImage ( ghostsImgs [ index ] [ game . getCurGhostDir ( index ) ] [ ( game . getTotalTime ( ) % 6 ) / 3 ] , x * MAG - 1 , y * MAG + 3 , null ) ; } } }
tr	9X	@ Override public PixelArray getPixels ( int w , int h ) { PixelArray pixels = new PixelArray ( w , h ) ; int count = 0 ; for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 2 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 2 ; y < pixels . getHeight ( ) ; y += 4 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 0 ; x < pixels . getWidth ( ) ; x += 4 ) { if ( x + 2 < pixels . getWidth ( ) ) pixels . setPixel ( count ++ , x + 2 , y ) ; if ( y + 1 < pixels . getHeight ( ) ) pixels . setPixel ( count ++ , x , y + 1 ) ; } for ( int y = 0 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } for ( int y = 1 ; y < pixels . getHeight ( ) ; y += 2 ) for ( int x = 1 ; x < pixels . getWidth ( ) ; x += 2 ) { pixels . setPixel ( count ++ , x , y ) ; } return pixels ; }
tr	9X	private void planForAgent ( Agent agent ) { TaskDispenser td = agent . td ; Node node = agent . node ; if ( agent . request != null ) { if ( agent . request . requestBox . atField == agent . request . requestGoal ) { agent . request = null ; } } if ( agent . taskQueue != null && agent . taskQueue . size ( ) > 0 && ( agent . taskQueue . peek ( ) . commandQueue == null || agent . taskQueue . peek ( ) . commandQueue . size ( ) == 0 ) ) { if ( agent . taskQueue . peek ( ) instanceof DockTask ) { DockTask t = ( DockTask ) agent . taskQueue . peek ( ) ; t . box . reserved = false ; t . moveBoxTo . reserved = false ; } agent . taskQueue . poll ( ) ; } if ( agent . taskQueue . size ( ) == 0 ) { agent . taskQueue . clear ( ) ; if ( agent . td . agents . size ( ) == 1 ) { agent . taskQueue . addAll ( td . newDispenseTaskForAgent ( agent ) ) ; } else { agent . taskQueue . addAll ( td . simpleDispenseTaskForAgent ( agent ) ) ; } } }
tr	9X	public static AbstractUIItem createItem ( FeatureType t , Panel panel ) { switch ( t ) { case Constant : return new ConstantUIItem ( panel ) ; case Sink : return new SinkUIItem ( panel ) ; case Source : return new SourceUIItem ( panel ) ; case Saddle : return new SaddleUIItem ( panel ) ; case Center : return new CenterUIItem ( panel ) ; case Focus : return new FocusUIItem ( panel ) ; case ConvergingElement : return new ConvergingElementUIItem ( panel ) ; case DivergingElement : return new DivergingElementUIItem ( panel ) ; case Generic : return new GenericUIItem ( panel ) ; } assert false : "Unhandled type: " + t ; return null ; }
tr	2	public boolean checkStatic ( ) { boolean result = true ; double [ ] values = getValues ( ) ; for ( int i = 0 ; i < values . length - 1 ; i ++ ) { if ( values [ i ] . doubleValue ( ) != values [ i + 1 ] . doubleValue ( ) ) { result = false ; break ; } } return result ; }
tr	5	@ Override public void handleEvent ( IParserEvent event ) { if ( event . getType ( ) == ParserEventType . DOCUMENT_END_EVENT ) { flushEvents ( ) ; event . fire ( listener ) ; } else { IParserEvent lastEvent = events . peekLast ( ) ; if ( lastEvent != null && lastEvent . getType ( ) == ParserEventType . STRING_EVENT && event . getType ( ) == ParserEventType . STRING_EVENT ) { event = mergeStringEvents ( ( StringEvent ) event ) ; } events . add ( event ) ; if ( events . size ( ) > MAX_EVENTS ) { events . removeFirst ( ) . fire ( listener ) ; } } }
tr	8	static int entrance ( List < Point > points , int k ) { int size = points . size ( ) ; Map < String , Integer > indexHash = new HashMap < > ( ) ; Map < String , Point > pointHash = new HashMap < > ( ) ; for ( int i = 0 ; i < size ; ++ i ) { Point p = points . get ( i ) ; indexHash . put ( p . x + " " + p . y , i ) ; pointHash . put ( p . x + " " + p . y , p ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { Point from = points . get ( i ) ; int max = 0 ; Set < Point > rangePoints = rangePonints ( from , k , pointHash ) ; for ( Point p : rangePoints ) { Integer index = indexHash . get ( p . x + " " + p . y ) ; if ( index != null && index > i && p . maxPathValue > max ) { max = p . maxPathValue ; } } from . maxPathValue = max + from . value ; if ( from . x == 0 && from . y == 0 ) return from . maxPathValue ; } return - 1 ; }
tr	8	public static void main ( String [ ] args ) { if ( args . length < 1 ) { System . err . println ( "Usage: java FollowPointers input-file" ) ; return ; } String filename = args [ 0 ] ; Scanner scanner = null ; int [ ] array = null ; int size = 0 ; try { scanner = new Scanner ( new FileInputStream ( filename ) ) ; int i = 0 ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; if ( null == line || line . length ( ) == 0 ) break ; if ( 0 == i ) { size = Integer . parseInt ( line ) ; array = new int [ size ] ; } else { int val = Integer . parseInt ( line ) ; array [ i - 1 ] = val ; } i ++ ; } if ( 0 == array . length ) { System . err . println ( "Cannot process pointers" ) ; return ; } int result = followPointers ( array ) ; System . out . println ( result ) ; } catch ( Exception e ) { System . err . println ( "Error processing input file " + filename ) ; e . printStackTrace ( ) ; } finally { if ( null != scanner ) { scanner . close ( ) ; } } }
tr	7	private String getMPatternCode ( ) { int posIni = _position ; for ( ; ; ) { if ( _mumpsPattern . length ( ) <= _position ) { break ; } if ( isQuantifier ( _mumpsPattern . charAt ( _position ) ) || ( _mumpsPattern . charAt ( _position ) == ( ) || ( _mumpsPattern . charAt ( _position ) ==   ) || ( _mumpsPattern . charAt ( _position ) == ) ) ) { break ; } if ( ! patternAtomTranslateTable . containsKey ( _mumpsPattern . charAt ( _position ) ) ) { throw new IllegalArgumentException ( "Code Pattern inv\u00E1lido encontrado: " . concat ( _mumpsPattern . substring ( _position , _position + 1 ) ) . concat ( ". Na posi\u00E7\u00E3o: " . concat ( String . valueOf ( _position ) ) ) ) ; } _position ++ ; } return _mumpsPattern . substring ( posIni , _position ) ; }
tr	7	@ Override public void run ( ) throws Exception { try { ConfigFile importFile = new ConfigFile ( plugin ) ; ConfigSQL importSQL = new ConfigSQL ( plugin ) ; if ( ! importSQL . checkDatabase ( ) ) { throw new Exception ( "Could not connect to database !" ) ; } for ( String player : importFile . getAllPlayers ( ) ) { for ( String group : importFile . getPlayerGroups ( player ) ) { importSQL . addPlayerGroup ( player , group ) ; } for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , permission . getKey ( ) , permission . getValue ( ) ) ; } for ( String world : importFile . getPlayerWorlds ( player ) ) { for ( Entry < String , boolean > permission : importFile . getPlayerPermissions ( player , world ) . entrySet ( ) ) { importSQL . addPlayerPermission ( player , world , permission . getKey ( ) , permission . getValue ( ) ) ; } } } } catch ( Exception e ) { throw e ; } }
tr	7	private void btnApostarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( carreraAbierta != null ) { Jugador j = new Jugador ( 0 , txtUsuario . getText ( ) . toString ( ) , txtPass . getText ( ) . toString ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarMonto ( ) ) { CaballoEnCarrera caballo = ( CaballoEnCarrera ) lstCaballos . getSelectedValue ( ) ; Apuesta a = new Apuesta ( Integer . parseInt ( txtMonto . getText ( ) ) , j ) ; if ( a . validar ( ) ) { ErroresApuesta ret = caballo . agregarApuesta ( a ) ; switch ( ret ) { case OK : messageBox ( "Apuesta realizada correctamente" ) ; borrarDatosJugador ( ) ; break ; case SaldoInsuficiente : messageBox ( "Saldo insuficiente" ) ; break ; case ErrorGenerico : messageBox ( "Error inesperado" ) ; break ; } } else { messageBox ( "El monto debe ser mayor que cero" ) ; } } else { messageBox ( "El monto debe ser num\u00E9rico" ) ; } } else { messageBox ( "Login incorrecto" ) ; } } else { messageBox ( "No hay carreras abiertas" ) ; } }
tr	5	private static interface getHID ( Device dev ) throws IOException { Configuration config ; interface retval = null ; DeviceDescriptor info = dev . getDeviceDescriptor ( ) ; if ( info . getDeviceClass ( ) != 0 ) throw new IllegalArgumentException ( "dev class" ) ; config = dev . getConfiguration ( ) ; for ( int i = config . getNumInterfaces ( ) ; i -- != 0 ; ) { interface intf = config . getInterface ( i , 0 ) ; if ( intf . getInterfaceClass ( ) == intf . CLASS_HID ) { if ( retval != null ) throw new IllegalArgumentException ( "multi-hid" ) ; retval = intf ; } } if ( retval == null ) throw new IllegalArgumentException ( "not hid" ) ; return retval ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Consulta_datos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Consulta_datos ( ) . setVisible ( true ) ; } } ) ; }
tr	0	private PlayerPanel buildSecondPlayerPanel ( ) { return new ComputerPlayerPanel ( controller , PlayerSide . RIGHT ) ; }
tr	3	private static String intToKOrMilLongName ( int i ) { String s = String . valueOf ( i ) ; for ( int k = s . length ( ) - 3 ; k > 0 ; k -= 3 ) s = s . substring ( 0 , k ) + " " + s . substring ( k ) ; if ( s . length ( ) > 8 ) s = "@gre@" + s . substring ( 0 , s . length ( ) - 8 ) + " million @whi@(" + s + ")" ; else if ( s . length ( ) > 4 ) s = "@cya@" + s . substring ( 0 , s . length ( ) - 4 ) + "K @whi@(" + s + ")" ; return " " + s ; }
tr	8	private void loadingStages ( ) { if ( lowMemory && loadingStage == 2 && Region . plane != plane ) { gameScreenImageProducer . initDrawingArea ( ) ; fontPlain . drawCentredText ( "Loading - please wait." , 257 , 151 , 0 ) ; fontPlain . drawCentredText ( "Loading - please wait." , 256 , 150 , ffffff ) ; gameScreenImageProducer . drawGraphics ( 4 , super . gameGraphics , 4 ) ; loadingStage = 1 ; loadRegionTime = System . currentTimeMillis ( ) ; } if ( loadingStage == 1 ) { int successful = initialiseRegionLoading ( ) ; if ( successful != 0 && System . currentTimeMillis ( ) - loadRegionTime > 360000 ) { signlink . reporterror ( enteredUsername + " glcfb " + serverSessionKey + " " + successful + " " + lowMemory + " " + caches [ 0 ] + " " + onDemandFetcher . immediateRequestCount ( ) + " " + plane + " " + regionX + " " + regionY ) ; loadRegionTime = System . currentTimeMillis ( ) ; } } if ( loadingStage == 2 && plane != lastRegionId ) { lastRegionId = plane ; renderMinimap ( plane ) ; } }
tr	4	private void mnuSaveAsTemplateActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser jfc = new JFileChooser ( ) ; jfc . setFileFilter ( new FileNameExtensionFilter ( "xml Datei" , "xml" ) ) ; if ( jfc . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File f = jfc . getSelectedFile ( ) ; if ( ! f . getName ( ) . endsWith ( ".xml" ) ) f = new File ( f . getAbsolutePath ( ) + ".xml" ) ; try { SemesterLoader . saveAsTemplate ( f , semesterList ) ; } catch ( JDOMException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( MainFrame . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
tr	7	@ Override public String filterInsertedString ( FilterBypass fb , int offs , String str , AttributeSet a ) { String result = new String ( ) ; if ( negative && offs == 0 && str . charAt ( 0 ) == - ) { result = "-" ; } try { Document doc = fb . getDocument ( ) ; int firstDecimal = str . indexOf ( . ) ; if ( decimal && firstDecimal != - 1 && doc . getText ( 0 , doc . getLength ( ) ) . indexOf ( . ) == - 1 ) { result += str . substring ( 0 , firstDecimal ) . replaceAll ( "\\D" , "" ) ; result += . ; result += str . substring ( firstDecimal + 1 ) . replaceAll ( "\\D" , "" ) ; } else { result += str . replaceAll ( "\\D" , "" ) ; } } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } return result ; }
tr	9X	public void updateRender ( ) { GridSquare [ ] [ ] gridData = controller . getGrid ( ) ; for ( int col = 0 ; col < gridData . length ; col ++ ) { for ( int row = 0 ; row < gridData [ col ] . length ; row ++ ) { String text = "" ; if ( gridData [ col ] [ row ] . player == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . player == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( gridData [ col ] [ row ] . turnNumber >= 0 ) text += gridData [ col ] [ row ] . turnNumber . toString ( ) ; if ( gridData [ col ] [ row ] . undefinedTurns . size ( ) > 0 ) { text += "(" ; for ( Integer it : gridData [ col ] [ row ] . undefinedTurns . keySet ( ) ) { if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . None ) text += "-" ; else if ( gridData [ col ] [ row ] . undefinedTurns . get ( it ) == EPlayer . P1 ) text += "o" ; else text += "x" ; if ( it >= 0 ) text += it . toString ( ) ; } text += ")" ; } gridBtn [ col ] [ row ] . setText ( text ) ; } } }
tr	2	private static void loadConfig ( ) { VMConfiguration . config = new VMConfiguration ( ) ; InputStream conf_file ; try { conf_file = new FileInputStream ( new File ( CONF_FILE ) ) ; Properties props = new Properties ( ) ; props . load ( conf_file ) ; config . weightNumber = Integer . parseInt ( props . getProperty ( Constants . WEIGHT_NUMBER ) ) ; config . learnFileName = props . getProperty ( Constants . LEARN_FILE_NAME ) ; config . topologyModelType = props . getProperty ( Constants . TOPOLOGY_MODEL ) ; config . rows = Integer . parseInt ( props . getProperty ( Constants . ROWS ) ) ; config . cols = Integer . parseInt ( props . getProperty ( Constants . COLS ) ) ; config . radius = Integer . parseInt ( props . getProperty ( Constants . RADIUS ) ) ; config . numberofWeights = Integer . parseInt ( props . getProperty ( Constants . NUMBER_OF_WEIGHTS ) ) ; config . maxWeight = Integer . parseInt ( props . getProperty ( Constants . MAX_WEIGHT ) ) ; config . maxIteration = Integer . parseInt ( props . getProperty ( Constants . MAX_ITERATION ) ) ; config . trainMetricType = props . getProperty ( Constants . TRAIN_METRIC_TYPE ) ; config . predictMetricType = props . getProperty ( Constants . PREDICT_METRIC_TYPE ) ; config . learningFactor = Integer . parseInt ( props . getProperty ( Constants . LEARN_FACTOR ) ) ; config . neighbourFactor = double . parseDouble ( props . getProperty ( Constants . NEIGHBOUR_FACTOR ) ) ; config . kFoldValue = Integer . parseInt ( props . getProperty ( Constants . K_FOLD_VALUE ) ) ; config . delimiter = props . getProperty ( Constants . DELIMITER ) ; config . pythonFileLocation = props . getProperty ( Constants . PYTHON_FILE ) ; config . normalizedFileName = props . getProperty ( Constants . NORMALIZED_FILE ) ; config . normalNeurons = Integer . parseInt ( props . getProperty ( Constants . NORMAL_NEURONS ) ) ; config . predictDataFile = props . getProperty ( Constants . PREDICT_DATA_FILE ) ; config . lookAheadSize = Integer . parseInt ( props . getProperty ( Constants . LOOK_AHEAD_SIZE ) ) ; config . predictAheadStep = Integer . parseInt ( props . getProperty ( Constants . PREDICT_AHEAD_STEP ) ) ; config . gaussianHeight = Integer . parseInt ( props . getProperty ( Constants . GAUSSIAN_HEIGHT ) ) ; config . mem_log_file = props . getProperty ( Constants . MEM_LOG_FILE ) ; config . metric_log_file = props . getProperty ( Constants . METRIC_LOG_FILE ) ; config . train_mem_log_file = props . getProperty ( Constants . TRAIN_MEM_LOG_FILE ) ; config . train_metric_log_file = props . getProperty ( Constants . TRAIN_METRIC_LOG_FILE ) ; config . dotest = Integer . parseInt ( props . getProperty ( Constants . DO_TEST ) ) ; config . vm_name = props . getProperty ( Constants . VM_NAME ) ; config . predictFile = props . getProperty ( Constants . PREDICT_FILE ) ; config . annotateFile = props . getProperty ( Constants . ANN_FILE ) ; config . faultInterval = Integer . parseInt ( props . getProperty ( Constants . FAULT ) ) ; } catch ( FileNotFoundException e ) { logger . error ( "Error while opening configuration file" ) ; } catch ( IOException e ) { logger . error ( "Error while loading configuration file" ) ; } }
tr	9X	public void initConvexe ( ) { Iterator < Classe > iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; next . convexe = new Convexe ( ) ; } if ( enveloppe == 1 ) { for ( int i = 0 ; i < points . length ; i ++ ) { Classe classe = vectClasses . elementAt ( classes [ i ] ) ; if ( classe . envDessinee ) { classe . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } else { for ( int i = 0 ; i < points . length ; i ++ ) { iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . index == classes [ i ] || ( next . index < classes [ i ] && ecm . getK ( ) [ next . index ] [ classes [ i ] ] != 0 ) ) next . convexe . ajoute ( points [ i ] [ 0 ] , points [ i ] [ 1 ] ) ; } } } iter = vectClasses . iterator ( ) ; while ( iter . hasNext ( ) ) { Classe next = iter . next ( ) ; if ( next . envDessinee ) { next . convexe . calculBarycentre ( ) ; next . convexe . enveloppe ( ) ; } } }
tr	8	public void executePowerUp ( PowerupNode node ) { PowerupPlayer powerup = node . powerup ; if ( powerup == null ) return ; switch ( powerup . addsFeature ) { case BOMB_MAX_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , powerup . amount , null ) ; break ; case BOMB_TEMP_COUNT : combatSystem . updateBombLayer ( node . entity_target , null , null , null , powerup . amount ) ; break ; case CAN_JUMP : break ; case CAN_PUSH : break ; case FLAME_LENGTH : combatSystem . updateBombLayer ( node . entity_target , powerup . amount , null , null , null ) ; break ; case SPEED : movementSystem . updateMoveable ( node . entity_target , powerup . amount ) ; break ; case DAMAGE : combatSystem . updateBombLayer ( node . entity_target , null , powerup . amount , null , null ) ; } }
tr	7	public static List < String > getProperties ( Object bean ) throws RemoteException { List < String > result = new ArrayList < String > ( ) ; if ( bean == null ) return result ; if ( bean instanceof GenericObject ) { GenericObject o = ( GenericObject ) bean ; result . addAll ( Arrays . asList ( o . getAttributeNames ( ) ) ) ; return result ; } Method [ ] methods = bean . getClass ( ) . getMethods ( ) ; if ( methods == null || methods . length == 0 ) return result ; for ( Method m : methods ) { String name = m . getName ( ) ; if ( name . startsWith ( "get" ) && name . length ( ) > 3 ) result . add ( toProperty ( name ) ) ; } return result ; }
tr	2	public OptionSet getMatchingSet ( boolean ignoreUnmatched , boolean requireDataLast ) { for ( String setName : optionSets . keySet ( ) ) if ( check ( setName , ignoreUnmatched , requireDataLast ) ) return optionSets . get ( setName ) ; return null ; }
tr	4	private List < Word > getCandidates ( Word word , Map < Character , Character > l2lEncrypt ) { List < Word > candidates = new LinkedList < Word > ( ) ; Map < Integer , List < Word >> wordsMap = dict . get ( word . getLength ( ) ) ; if ( wordsMap == null ) { return candidates ; } List < Word > words = wordsMap . get ( word . getNbrSimilarLetters ( ) ) ; if ( words == null ) { return candidates ; } for ( Word w : words ) { if ( w . equals ( word , l2lEncrypt ) ) { candidates . add ( w ) ; } } return candidates ; }
tr	8	private void bfs ( State s ) { s . id = - 1 ; Loc f = map . finish ; int counter = 0 ; LinkedList < Node > frontier = new LinkedList < Node > ( ) ; Set < State > explored = new HashSet < State > ( ) ; LinkedList < State > solution = new LinkedList < State > ( ) ; frontier . addLast ( new Node ( s , null , 0 ) ) ; while ( ! frontier . isEmpty ( ) ) { Node current = frontier . removeFirst ( ) ; if ( goalTest ( current . state , f ) ) { for ( Node node = current ; node != null ; node = node . parent ) { solution . addFirst ( node . state ) ; } System . out . println ( "found goal!" ) ; System . out . println ( "moves: " + solution . size ( ) ) ; mSolutions . addAll ( solution ) ; return ; } explored . add ( current . state ) ; if ( counter % 5000 == 0 ) { System . out . print ( "\n" ) ; } ; if ( counter % 50 == 0 ) { System . out . print ( "." ) ; } ; ArrayList < State > possibles = getMovesCorrectlyPlease ( current . state ) ; for ( int i = 0 ; i < possibles . size ( ) ; i ++ ) { State possib = possibles . get ( i ) ; if ( ! explored . contains ( possib ) ) { frontier . addLast ( new Node ( possib , current , current . distance + 1 ) ) ; } } counter ++ ; } if ( solution . isEmpty ( ) ) { System . out . println ( "FAILED TO FIND SOLUTION" ) ; } }
tr	0	@ Override public T evaluate ( T x , T y , T z ) throws AbstractException { T resFirst = first . evaluate ( x , y , z ) ; T resSecond = second . evaluate ( x , y , z ) ; return resFirst . sum ( resSecond ) ; }
tr	0	public void paintComponent ( Graphics g2 ) { g2 . drawImage ( bgImage , 0 , 0 , null ) ; }
tr	2	private ArrayList < AtomExecutableCommand > populateExecutableCommandList ( String serverId , ArrayList < AtomExecutableCommand > commandList ) { AtomExecutableCommand _commandDet ; ArrayList < AtomExecutableCommand > _commandList ; int index = 0 ; int _countExecutables ; _commandList = new ArrayList < AtomExecutableCommand > ( ) ; _countExecutables = commandList . size ( ) ; while ( _countExecutables > index ) { _commandDet = commandList . get ( index ) ; if ( serverId . equals ( _commandDet . getServerID ( ) ) ) { _commandList . add ( _commandDet ) ; } index ++ ; } return _commandList ; }
tr	5	public static void swap ( int [ ] data , int i , int j ) { if ( data == null || i < 0 || j < 0 || data . length <= i || data . length <= j ) { throw new IllegalArgumentException ( ) ; } int tmp = data [ i ] ; data [ i ] = data [ j ] ; data [ j ] = tmp ; }
tr	2	public AdditionalGradeEntries read ( Integer id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; AdditionalGradeEntries instance = null ; try { instance = ( AdditionalGradeEntries ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
tr	9X	public void paintComponents ( Board newBoard , boolean turn ) { board = newBoard ; pane . removeAll ( ) ; JButton [ ] buttons = new JButton [ 64 ] ; pane . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; ButtonListener bl = new ButtonListener ( this , game ) ; ButtonObserver bo = new ButtonObserver ( game ) ; LinkedList < Coordinate > allowedFields = board . getAllowedFields ( game . orderMark ) ; for ( Integer index = 0 ; index < 64 ; index ++ ) { buttons [ index ] = new JButton ( index . toString ( ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = board . coordinates [ index ] . getY ( ) ; c . gridy = board . coordinates [ index ] . getX ( ) ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 3 , 3 , 3 ) ; buttons [ index ] . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; buttons [ index ] . setText ( "" ) ; buttons [ index ] . setBackground ( board . getField ( board . coordinates [ index ] ) . getColor ( ) ) ; buttons [ index ] . setActionCommand ( index . toString ( ) ) ; buttons [ index ] . addActionListener ( bl ) ; bl . addObserver ( bo ) ; buttons [ index ] . setEnabled ( false ) ; for ( Coordinate coord : allowedFields ) { int field = coord . getIndex ( ) ; if ( field == index && turn ) { buttons [ index ] . setEnabled ( true ) ; buttons [ index ] . setBackground ( new Color ( 200 , 200 , 200 ) ) ; } if ( field == index && index == hint && turn ) { buttons [ index ] . setBackground ( Color . magenta ) ; } } pane . add ( buttons [ index ] , c ) ; } JButton button ; button = new JButton ( "Current Mark" ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 1 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 0 , 15 , 0 , 15 ) ; button . setPreferredSize ( new Dimension ( 50 , 50 ) ) ; button . setText ( "" ) ; button . setBackground ( game . orderMark . getColor ( ) ) ; button . setEnabled ( false ) ; pane . add ( button , c ) ; button = new JButton ( "Hint" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 4 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { giveHint ( board ) ; } } ) ; pane . add ( button , c ) ; if ( mainGUI . multiplayer ) { button = new JButton ( "Lobby" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; LobbyGUI . lobbyGUI . startLobbyGUI ( ) ; } } ) ; pane . add ( button , c ) ; } if ( ! mainGUI . multiplayer ) { button = new JButton ( "Restart Game" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 5 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; game . restartGame ( ) ; } } ) ; pane . add ( button , c ) ; } button = new JButton ( "Main Menu" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 6 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { MainGUI . mainGUI . numberOfPlayers = "4" ; MainGUI . mainGUI . startMainGUI ( ) ; frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; button = new JButton ( "Quit" ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . gridx = 8 ; c . gridy = 7 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 3 , 15 ) ; button . setPreferredSize ( new Dimension ( 150 , 50 ) ) ; button . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { frame . dispose ( ) ; } } ) ; pane . add ( button , c ) ; JLabel label ; label = new JLabel ( "Current Player:" ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; label . setPreferredSize ( new Dimension ( 300 , 50 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 0 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; label = new JLabel ( game . order . get ( game . orderMark ) . getUsername ( ) ) ; label . setFont ( new Font ( "SANS_SERIF" , Font . PLAIN , 18 ) ) ; c . fill = GridBagConstraints . BOTH ; c . gridx = 8 ; c . gridy = 2 ; c . weightx = 0.5 ; c . weighty = 0.5 ; c . insets = new Insets ( 3 , 15 , 0 , 15 ) ; pane . add ( label , c ) ; pane . repaint ( ) ; pane . revalidate ( ) ; }
tr	5	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newTriangle . length ; i ++ ) { int previousLevelMinPath = 20000 * SIZE ; for ( int n = 0 ; n < i ; n ++ ) if ( newTriangle [ i - n - 1 ] [ n ] < previousLevelMinPath ) previousLevelMinPath = newTriangle [ i - n - 1 ] [ n ] ; for ( int n = 0 ; n <= i ; n ++ ) { int currentHeight = i - n ; int currentWidth = n ; int currentMinPath ; if ( n < ( i + 1 ) / 2 ) currentMinPath = newTriangle [ currentHeight - 1 ] [ currentWidth ] ; else currentMinPath = newTriangle [ currentHeight ] [ currentWidth - 1 ] ; currentMinPath = minPathLength ( i - 1 , currentHeight , currentWidth , currentMinPath , previousLevelMinPath , 0 , newTriangle ) ; newTriangle [ currentHeight ] [ currentWidth ] += currentMinPath ; } } return newTriangle ; }
tr	1	public static String SQLdecrypted ( String decrypt ) { String decrypted = "" ; try { SecretKeyFactory keyFactory = SecretKeyFactory . getInstance ( "DES" ) ; DESKeySpec keySpec = new DESKeySpec ( secretSalt . getBytes ( ) ) ; SecretKey key = keyFactory . generateSecret ( keySpec ) ; DesEncrypter encrypter = new DesEncrypter ( key ) ; decrypted = encrypter . decrypt ( decrypt ) ; } catch ( Exception e ) { Error_Frame . Error ( e . toString ( ) ) ; } return decrypted ; }
tr	1	void dispatch ( SelectionKey key ) { Runnable r = ( Runnable ) key . attachment ( ) ; if ( r != null ) { r . run ( ) ; } }
tr	0	private static String trad4 ( TreeNode tree ) { return tree . getStringValue ( ) ; }
tr	8	private SemanticFrame sequentialSampling ( SemanticFrame goldFrame , int [ ] goldlbids , SRLFeatureData sfd , int p , TIntArrayList args ) { SemanticFrame predict = new SemanticFrame ( goldFrame ) ; predict . arglbids = new int [ goldlbids . length ] ; for ( int i = 0 , L = predict . arglbids . length ; i < L ; ++ i ) predict . arglbids [ i ] = - 1 ; int N = args . size ( ) , M = sfd . L ; int T = N + M ; boolean [ ] usedRel = new boolean [ T ] ; double [ ] score = new double [ T ] ; for ( int a = 0 ; a < N ; ++ a ) { for ( int r = 0 ; r < T ; ++ r ) { if ( usedRel [ r ] ) { score [ r ] = - double . MAX_VALUE ; } else { score [ r ] = r < M ? sfd . getArcScore ( goldFrame . predid , args . get ( a ) , r ) : nullWeight ; if ( addLoss ) score [ r ] += loss ( goldlbids [ args . get ( a ) ] , r < M ? r : - 1 ) ; } } int sample = samplePoint ( score , usedRel ) ; usedRel [ sample ] = true ; predict . arglbids [ args . get ( a ) ] = sample < M ? sample : - 1 ; } return predict ; }
tr	1	public void disconnect ( ) { try { running = false ; handler . removeClient ( user ) ; reader . close ( ) ; writer . close ( ) ; socket . close ( ) ; } catch ( IOException e ) { } }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	7	public void actionPerformed ( ActionEvent ae ) { ADocument aDoc = ( ADocument ) textPane . getDocument ( ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; ^ ^ = textPane . getCaret ( ) ; int . = ^ . getDot ( ) ; int mark = ^ . getMark ( ) ; if ( . != mark ) return ; ADocumentFragment fragment = null ; try { Transferable tr = clipboard . getContents ( this ) ; DataFlavor flavor = new DataFlavor ( ADocumentFragment . MIME_TYPE ) ; if ( tr . isDataFlavorSupported ( flavor ) ) fragment = ( ADocumentFragment ) tr . getTransferData ( flavor ) ; else { flavor = new DataFlavor ( "application/x-java-serialized-object; class=java.lang.String" ) ; if ( tr . isDataFlavorSupported ( flavor ) ) { String s = new String ( ( ( ( String ) tr . getTransferData ( flavor ) ) ) ) ; fragment = new ADocumentFragment ( s , null , null ) ; } } } catch ( UnsupportedFlavorException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } if ( fragment == null ) return ; aDoc . startCompoundEdit ( ) ; ADocument . pasteADocFragment ( aDoc , . , fragment ) ; aDoc . endCompoundEdit ( null ) ; aDoc . fireADocumentChanged ( ) ; }
tr	0	public Client ( String dni , String nom , String cognoms , String email ) { this . dni = dni ; this . nom = nom ; this . cognoms = cognoms ; this . email = email ; }
tr	3	@ Override public void setInitialized ( short mask , float value ) { switch ( mask ) { case Constants . F_MASK : f = value ; break ; case Constants . X_MASK : x = value ; break ; case Constants . Y_MASK : y = value ; break ; default : break ; } }
tr	4	protected boolean isInGrabBar ( int mouseX , int mouseY ) { mouseY = Standards . W_HEIGHT - mouseY - 1 ; if ( ( mouseX > ScreenX ) && ( mouseX < ScreenX + Width ) ) { if ( ( mouseY > ScreenY ) && ( mouseY < ScreenY + GrabBarHeight ) ) { return true ; } } return false ; }
tr	1	@ Override public Set < java . util . Map . Entry < K , V >> entrySet ( ) { if ( this . entrySet == null ) { this . entrySet = new EntrySet ( ) ; } return this . entrySet ; }
tr	1	public void renderLow ( Parameters params ) { if ( renderer == null ) { throw new IllegalStateException ( "renderer not set" ) ; } image = newImage ( ) ; showImage ( image ) ; int width = image . getWidth ( null ) ; int height = image . getHeight ( null ) ; params . adjustAspect ( width , height ) ; setParameters ( params ) ; imageComponent . setCursor ( waitCursor ) ; renderThread = new Thread ( new RenderRunner ( image , params , renderer ) ) ; renderThread . start ( ) ; }
tr	7	protected void notifyReceivedAck ( MqttAck ack ) throws MqttException { final String methodName = "notifyReceivedAck" ; this . lastInboundActivity = System . currentTimeMillis ( ) ; log . fine ( className , methodName , "627" , new Object [ ] { new Integer ( ack . getMessageId ( ) ) , ack } ) ; MqttToken token = tokenStore . getToken ( ack ) ; MqttException mex = null ; if ( ack instanceof MqttPubRec ) { MqttPubRel rel = new MqttPubRel ( ( MqttPubRec ) ack ) ; this . send ( rel , token ) ; } else if ( ack instanceof MqttPubAck || ack instanceof MqttPubComp ) { notifyResult ( ack , token , mex ) ; } else if ( ack instanceof MqttPingResp ) { pingOutstanding = false ; notifyResult ( ack , token , mex ) ; tokenStore . removeToken ( ack ) ; } else if ( ack instanceof MqttConnack ) { int rc = ( ( MqttConnack ) ack ) . getReturnCode ( ) ; if ( rc == 0 ) { synchronized ( queueLock ) { if ( cleanSession ) { clearState ( ) ; tokenStore . saveToken ( token , ack ) ; } inFlightPubRels = 0 ; actualInFlight = 0 ; restoreInflightMessages ( ) ; connected ( ) ; } } else { mex = ExceptionHelper . createMqttException ( rc ) ; throw mex ; } clientComms . connectComplete ( ( MqttConnack ) ack , mex ) ; notifyResult ( ack , token , mex ) ; tokenStore . removeToken ( ack ) ; synchronized ( queueLock ) { queueLock . notifyAll ( ) ; } } else { notifyResult ( ack , token , mex ) ; releaseMessageId ( ack . getMessageId ( ) ) ; tokenStore . removeToken ( ack ) ; } checkQuiesceLock ( ) ; }
tr	2	private void selectElement ( MouseEvent e ) { if ( e . getButton ( ) == MouseEvent . BUTTON1 && e . getSource ( ) != table ) table . clearSelection ( ) ; }
tr	0	public byte getNotSettable ( ) { return notSettable ; }
tr	5	private final char med3 ( char a , char b , char c ) { char m ; if ( a < b ) { m = b <= c ? b : a < c ? c : a ; } else { m = c >= a ? a : c > b ? c : b ; } return m ; }
tr	6	public static int getUTF8 ( byte [ ] str , int start , MutableInteger ch ) { int c , n , i , bytes ; c = ( ( int ) str [ start ] ) & FF ; if ( ( c & E0 ) == C0 ) { n = c & 31 ; bytes = 2 ; } else if ( ( c & F0 ) == E0 ) { n = c & 15 ; bytes = 3 ; } else if ( ( c & F8 ) == F0 ) { n = c & 7 ; bytes = 4 ; } else if ( ( c & FC ) == F8 ) { n = c & 3 ; bytes = 5 ; } else if ( ( c & FE ) == FC ) { n = c & 1 ; bytes = 6 ; } else { ch . value = c ; return 0 ; } for ( i = 1 ; i < bytes ; ++ i ) { c = ( ( int ) str [ start + i ] ) & FF ; n = ( n << 6 ) | ( c & 3F ) ; } ch . value = n ; return bytes - 1 ; }
tr	5	private void howMany ( int [ ] [ ] paper , int n1 , int n2 , int m1 , int m2 ) { if ( counter . contains ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ) return ; counter . add ( Arrays . asList ( n1 , n2 , m1 , m2 ) ) ; for ( int d = m1 ; d <= m2 - 1 ; d ++ ) { if ( foldsVertically ( paper , n1 , n2 , m1 , m2 , d ) ) { if ( d <= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , d + 1 , m2 ) ; } if ( d >= ( m1 + m2 - 1 ) / 2 ) { howMany ( paper , n1 , n2 , m1 , d ) ; } } } }
tr	4	public static boolean maybeTwoPairs ( List < Card > sourceCards , HandCombinationSink handCombinationSink ) { final Holder < Hand > bestHandHolder = new Holder < Hand > ( ) ; CardCombinator . iterate ( sourceCards , new CardCombinationCallback ( ) { @ Override public boolean process ( List < Card > cards ) { Collections . sort ( cards , new RankComparator ( ) ) ; final Rank rank0 = cards . get ( 0 ) . getRank ( ) ; if ( rank0 != cards . get ( 1 ) . getRank ( ) ) { return false ; } final Rank rank1 = cards . get ( 2 ) . getRank ( ) ; if ( rank1 != cards . get ( 3 ) . getRank ( ) ) { return false ; } final int rating = RATING_FLAG_MAP . get ( rank0 ) | RATING_FLAG_MAP . get ( rank1 ) ; if ( bestHandHolder . value == null || bestHandHolder . value . getRating ( ) < rating ) { bestHandHolder . value = new DefaultHand ( rating , HandRank . TWO_PAIRS , cards ) ; } return false ; } } , TWO_PAIRS_HAND_SIZE ) ; return provideBestHand ( bestHandHolder , handCombinationSink ) ; }
tr	2	public Rectangle union ( Rectangle rect ) { if ( rect == null || rect . isEmpty ( ) ) return this ; return union ( rect . x , rect . y , rect . width , rect . height ) ; }
tr	3	@ Override public void tick ( ) { counter ++ ; if ( counter == tickDivider ) { counter = 0 ; if ( enemyUnits . size ( ) > 0 ) { Slime slime = new Slime ( ) ; rune . modifySlime ( slime ) ; for ( EnemyUnit enemy : enemyUnits ) { enemy . gotSlowed ( slime ) ; } } } }
tr	8	private final boolean isNumeric ( class < ? > clazz ) { if ( Number . class . isAssignableFrom ( clazz ) ) { return true ; } if ( clazz . isPrimitive ( ) ) { return clazz == long . TYPE || clazz == Integer . TYPE || clazz == double . TYPE || clazz == float . TYPE || clazz == short . TYPE || clazz == byte . TYPE ; } return false ; }
tr	4	void deleteTime ( Component dialogParent , Time time ) { if ( time != null ) { if ( AlertMessages . deleteTimeConfirmation ( dialogParent , time ) ) { try { timeDao . deleteTime ( Dao . getConnection ( ) , time ) ; timeDialog . setTime ( null ) ; timeListDialog . selectPreviousRow ( ) ; timeDialog . setVisible ( false ) ; } catch ( SQLException ex ) { ErrorMessages . sqlExceptionError ( "deleteTime()" , ex ) ; } catch ( ClassNotFoundException ex ) { ErrorMessages . classNotFoundError ( "deleteTime()" , ex ) ; } } } else { AlertMessages . noTimeSelectedInTableForDeleting ( timeListDialog ) ; } }
tr	3	public RegularAnalyzer ( List < Rule > rules ) { Set < String > definedRuleNames = new HashSet < String > ( ) ; List < Rule > observedRules = new ArrayList < Rule > ( ) ; observedRules . addAll ( rules ) ; boolean foundRegular ; do { foundRegular = false ; for ( int index = observedRules . size ( ) - 1 ; index >= 0 ; index -- ) { Set < String > dependent = observedRules . get ( index ) . getElements ( ) . getDependentRuleNames ( ) ; if ( definedRuleNames . containsAll ( dependent ) ) { definedRuleNames . add ( observedRules . get ( index ) . getRuleName ( ) . toString ( ) ) ; regularRules . add ( observedRules . get ( index ) ) ; observedRules . remove ( index ) ; foundRegular = true ; continue ; } } } while ( foundRegular ) ; observedRules . clear ( ) ; }
tr	4	private static class < ? > getPrimitiveClass ( final class < ? > componentType ) { if ( Integer . class . isAssignableFrom ( componentType ) ) { return int . class ; } if ( double . class . isAssignableFrom ( componentType ) ) { return double . class ; } throw new UnsupportedOperationException ( "Mapping not implemented" ) ; }
tr	8	public Holdable removeStackedItem ( Character itemID , int count ) throws InvalidKeyException { Holdable item ; Holdable returnItem ; if ( weapons . containsKey ( itemID ) ) { item = weapons . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { weapons . remove ( itemID ) ; size -- ; } } else if ( armours . containsKey ( itemID ) ) { item = armours . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { armours . remove ( itemID ) ; size -- ; } } else if ( foods . containsKey ( itemID ) ) { item = foods . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { foods . remove ( itemID ) ; size -- ; } } else if ( misc . containsKey ( itemID ) ) { item = misc . get ( itemID ) ; returnItem = item . reduceStack ( count ) ; if ( item . stackSize ( ) == 0 ) { misc . remove ( itemID ) ; size -- ; } } else { throw new InvalidKeyException ( ) ; } return returnItem ; }
tr	5	public boolean fireballCollideCheck ( Fireball fireball ) { if ( deadTime != 0 ) return false ; float xD = fireball . x - x ; float yD = fireball . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < fireball . height ) { return true ; } } return false ; }
tr	7	public List < String > getUnionList ( List < String > list1 , List < String > list2 ) { List < String > totalList = new ArrayList < > ( ) ; if ( list1 . size ( ) > list2 . size ( ) ) { for ( String obj : list1 ) { totalList . add ( obj ) ; } for ( String obj : list2 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } else { for ( String obj : list2 ) { totalList . add ( obj ) ; } for ( String obj : list1 ) { if ( ! totalList . contains ( obj ) ) { totalList . add ( obj ) ; } } } return totalList ; }
tr	6	protected KeyboardEventListener parseKeyboardListener ( String keyboardListenerString ) { KeyboardEventListener rc = null ; if ( ! "" . equals ( keyboardListenerString ) ) { switch ( keyboardListenerString ) { case ( "SplashScreenKeyboardEventListener" ) : rc = new SplashScreenKeyboardEventListener ( ) ; break ; case ( "MenuKeyboardEventListener" ) : rc = new MenuKeyboardEventListener ( ) ; break ; case ( "OptionsMenuItemKeyboardEventListener" ) : rc = new OptionsMenuItemKeyboardEventListener ( ) ; break ; case ( "ExitMenuItemKeyboardEventListener" ) : rc = new ExitMenuItemKeyboardEventListener ( ) ; break ; case ( "OptionsMenuBackKeyboardEventListener" ) : rc = new OptionsMenuBackKeyboardEventListener ( ) ; break ; default : } } return rc ; }
tr	6	@ Override public Object getValueAt ( int row , int column ) { Vehicle vehicle = vehicles . elementAt ( row ) ; switch ( column ) { case 0 : return vehicle . getLicencePlate ( ) ; case 1 : return vehicle . getStartDate ( ) ; case 2 : return vehicle . getOwner ( ) . getFirstName ( ) + " " + vehicle . getOwner ( ) . getFamilyName ( ) . toUpperCase ( ) ; case 3 : return vehicle . getModel ( ) . getDesignation ( ) ; case 4 : if ( this . deleteIcon == null ) { return "Supprimer" ; } return this . deleteIcon ; default : break ; } return null ; }
tr	2	private int findMove ( int index1 , int index2 ) { int index = - 1 ; for ( int i = 0 ; i < _steps [ index1 ] [ index2 ] . theColors . length ; i ++ ) { if ( _steps [ index1 ] [ index2 ] . theColors [ i ] == Colors . BAR_SHIFT ) { index = i ; break ; } } return index ; }
tr	7	private static void load ( final ClassLoader loader , final LinkedList < IRCPluginDefinition > plugins , final File file , final String prefix ) { if ( file . isDirectory ( ) ) { if ( ! file . getName ( ) . startsWith ( "." ) ) { for ( final File f : file . listFiles ( ) ) { FilePluginSource . load ( loader , plugins , f , prefix + file . getName ( ) + "." ) ; } } } else { String name = prefix + file . getName ( ) ; final String ext = ".class" ; if ( name . endsWith ( ext ) && ! name . startsWith ( "." ) && ! name . contains ( "!" ) && ! name . contains ( "$" ) ) { name = name . substring ( 0 , name . length ( ) - ext . length ( ) ) ; FilePluginSource . load ( loader , plugins , name , file . getAbsolutePath ( ) ) ; } } }
tr	7	public static boolean logIn ( String username , String password , JFrame frame ) { try { System . out . println ( "Checking username and password with my boss..." ) ; if ( username . equals ( "" ) || username . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The username is invalid  please try an other one." , "Invalid Username" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( password . equals ( "" ) || password . contains ( " " ) ) { JOptionPane . showMessageDialog ( frame , "The password is invalid  please try an other one." , "Invalid Password" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=existsPlayer&name=" + username ) ) { JOptionPane . showMessageDialog ( frame , "The player does not exits." + "Please try an other username." , "Player does not exist" , JOptionPane . ERROR_MESSAGE ) ; return false ; } if ( ! getReturnString ( "req=login&name=" + username + "&pass=" + password ) ) { JOptionPane . showMessageDialog ( frame , "The combination of username and passowrd is incorrect." + System . lineSeparator ( ) + "Please try again.'" + System . lineSeparator ( ) + "If you have forgotten your password  visit sinius15.com." , "Invalid login" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( IOException e ) { e . printStackTrace ( ) ; JOptionPane . showMessageDialog ( frame , "There seems to be a problem with the connection to the server" + System . lineSeparator ( ) + "You can start the game in offline mode if you still want to play." + System . lineSeparator ( ) + "We are verry sorry for the inconvenience caused." , "Problem" , JOptionPane . ERROR_MESSAGE ) ; return false ; } return true ; }
tr	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof ProjectUser ) ) { return false ; } ProjectUser other = ( ProjectUser ) object ; if ( ( this . projectUserPK == null && other . projectUserPK != null ) || ( this . projectUserPK != null && ! this . projectUserPK . equals ( other . projectUserPK ) ) ) { return false ; } return true ; }
tr	2	public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case GET_LANG : return isSetGetLang ( ) ; } throw new IllegalStateException ( ) ; }
tr	1	protected void checkKey ( K k ) { if ( k == null ) { throw new InvalidKeyException ( "Invalid key: null." ) ; } }
tr	3	private void constructTextOutput ( final Vector < ScoredDocument > docs , StringBuffer response ) { for ( ScoredDocument doc : docs ) { response . append ( response . length ( ) > 0 ? "\n" : "" ) ; response . append ( doc . asTextResult ( ) ) ; } response . append ( response . length ( ) > 0 ? "\n" : "" ) ; }
tr	9X	@ Override public Orientation getStepOrientation ( int lineIndex ) { switch ( lineIndex ) { case 0 : case 5 : return Orientation . DOWN_LEFT ; case 1 : case 6 : return Orientation . UP_LEFT ; case 2 : case 7 : return Orientation . CENTER ; case 3 : case 8 : return Orientation . UP_RIGHT ; case 4 : case 9 : return Orientation . DOWN_RIGHT ; default : return Orientation . NONE ; } }
tr	6	private boolean r_Step_3 ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_4 , 7 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : slice_from ( "al" ) ; break ; case 2 : slice_from ( "ic" ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	4	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
tr	5	public Plugin ( String name ) { this . name = name ; this . propertyChange = new PropertyChangeSupport ( this ) ; if ( name . startsWith ( "serendipity_plugin" ) ) { setType ( PluginType . sidebar ) ; } else if ( name . startsWith ( "serendipity_event" ) ) { setType ( PluginType . event ) ; } else if ( name . equals ( "system" ) ) { setType ( PluginType . system ) ; } else { setType ( PluginType . template ) ; } intern = false ; if ( type . equals ( PluginType . system ) ) { intern = true ; } if ( name . equals ( "homepage" ) ) { System . out . println ( "contructor: hompage plugin type = " + getType ( ) ) ; } }
tr	3	public static boolean hasSubmitParameter ( ServletRequest request , String name ) { assert . notNull ( request , "Request must not be null" ) ; if ( request . getParameter ( name ) != null ) { return true ; } for ( String suffix : SUBMIT_IMAGE_SUFFIXES ) { if ( request . getParameter ( name + suffix ) != null ) { return true ; } } return false ; }
tr	4	public void read ( org . apache . thrift . protocol . TProtocol iprot , inserir_result struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 0 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRUCT ) { struct . success = new Registro ( ) ; struct . success . read ( iprot ) ; struct . setSuccessIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; struct . validate ( ) ; }
tr	0	@ Override public void setText ( String Text ) { this . SetText ( Text , Color . white ) ; }
tr	5	@ Override public void setCell ( int x , int y , boolean live ) { if ( y < 0 || y >= getHeight ( ) ) return ; if ( x < 0 || x >= getWidth ( ) ) return ; if ( live ) world [ y ] [ x ] = 0 ; }
tr	9X	private void drawMenu ( ) { int i = menuOffsetX ; int j = menuOffsetY ; int k = menuWidth ; int l = menuHeight + 1 ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 706a5e , menuWidth , menuOffsetX ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 706a5e , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY , menuHeight , 200 , 706a5e , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 1 , menuHeight - 2 , 250 , 2d2822 , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method338 ( menuOffsetY + 2 , menuHeight - 4 , 250 , 2d2822 , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 3 , menuHeight - 6 , 250 , 2d2822 , menuWidth - 2 , menuOffsetX + 1 ) ; DrawingArea . method338 ( menuOffsetY + 19 , menuHeight - 22 , 250 , 524a3d , menuWidth - 4 , menuOffsetX + 2 ) ; DrawingArea . method338 ( menuOffsetY + 20 , menuHeight - 22 , 250 , 524a3d , menuWidth - 6 , menuOffsetX + 3 ) ; DrawingArea . method335 ( 112329 , j + 20 , k - 6 , l - 23 , 170 , i + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 2a291b , menuOffsetY + 2 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a261b , menuOffsetY + 3 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 252116 , menuOffsetY + 4 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 211e15 , menuOffsetY + 5 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1e1b12 , menuOffsetY + 6 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 1a170e , menuOffsetY + 7 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 2 , 15120b , menuOffsetY + 8 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 100d08 , menuOffsetY + 10 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 11 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 080703 , menuOffsetY + 12 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 13 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 14 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 15 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 070802 , menuOffsetY + 16 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 090a04 , menuOffsetY + 17 ) ; DrawingArea . fillPixels ( menuOffsetX + 2 , menuWidth - 4 , 1 , 2a291b , menuOffsetY + 18 ) ; DrawingArea . fillPixels ( menuOffsetX + 3 , menuWidth - 6 , 1 , 564943 , menuOffsetY + 19 ) ; chatTextDrawingArea . method385 ( c6b895 , "Choose Option" , menuOffsetY + 14 , menuOffsetX + 3 ) ; int j1 = super . mouseX ; int k1 = super . mouseY ; if ( menuScreenArea == 0 ) { j1 -= 4 ; k1 -= 4 ; } if ( menuScreenArea == 1 ) { j1 -= 519 ; k1 -= 168 ; } if ( menuScreenArea == 2 ) { j1 -= 17 ; k1 -= 338 ; } if ( menuScreenArea == 3 ) { j1 -= 516 ; k1 -= 0 ; } for ( int l1 = 0 ; l1 < menuActionRow ; l1 ++ ) { int i2 = j + 31 + ( menuActionRow - 1 - l1 ) * 15 ; int j2 = c6b895 ; if ( j1 > i && j1 < i + k && k1 > i2 - 13 && k1 < i2 + 3 ) { DrawingArea . drawPixels ( 15 , i2 - 11 , i + 3 , 26566C , menuWidth - 6 ) ; j2 = eee5c6 ; } chatTextDrawingArea . method389 ( true , i + 4 , AAA184 , menuActionName [ l1 ] , i2 + 1 ) ; } }
tr	0	public void isiOperan2 ( double x ) { op2 = x ; }
tr	0	public List < Calificacion > getCalificaciones ( ) { return calificaciones ; }
tr	8	public void setActivePanel ( final PanelType type ) { if ( this . frame != null ) { this . frame . dispose ( ) ; } switch ( type ) { case START : this . frame = new PlainPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case CLUBS : this . frame = new ClubPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case GYM : this . frame = new GymPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG : this . frame = new GamePanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case SPIELTAG_DIR : this . frame = new AllGamesPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case TEAMS : this . frame = new TeamPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; case RANKING : this . frame = new RankingPanel ( this . sfb , SWT . FILL , CompositeBrick . default ) ; break ; } this . sfb . setWeights ( new int [ ] { 30 , 70 } ) ; }
tr	9X	public MidiFile ( File file ) throws InvalidMidiDataException , IOException { this . tracks = new ArrayList < MidiTrack > ( ) ; Sequence sequence = MidiSystem . getSequence ( file ) ; resolution = sequence . getResolution ( ) ; int trackNo = 0 ; for ( Track track : sequence . getTracks ( ) ) { heldNotes . clear ( ) ; trackNo += 1 ; MidiTrack t = new MidiTrack ( trackNo ) ; for ( int i = 0 ; i < track . size ( ) ; i ++ ) { MidiEvent event = track . get ( i ) ; int time = ( int ) event . getTick ( ) ; MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { ShortMessage shortMessage = ( ShortMessage ) message ; if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_ON ) { noteOn ( t , shortMessage , time - 16 ) ; } else if ( shortMessage . getCommand ( ) == ShortMessage . NOTE_OFF ) { noteOff ( t , shortMessage , time - 16 ) ; } } else if ( message instanceof MetaMessage ) { MetaMessage metaMessage = ( MetaMessage ) message ; if ( metaMessage . getType ( ) == 3 ) { String trackName = new String ( metaMessage . getData ( ) , "ascii" ) ; if ( trackName . length ( ) > 0 ) { t . setName ( trackName ) ; } } else if ( metaMessage . getType ( ) == 58 ) { byte [ ] data = metaMessage . getData ( ) ; this . timeSignature = new TimeSignature ( data [ 0 ] , 1 << data [ 1 ] ) ; } } } if ( t . hasNotes ( ) ) { tracks . add ( t ) ; } } }
tr	2	public Set < Point > getPossibleMoves ( PlayerToken player ) { Set < Point > result = new HashSet < Point > ( ) ; Point loc = tokenLocs . get ( player ) ; for ( Point p : getAdjacentSquares ( player ) ) { if ( isMovable ( loc , p ) ) { result . add ( p ) ; } } return result ; }
tr	4	public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; frame . setSize ( 1500 , 1000 ) ; frame . setLocationRelativeTo ( null ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . setVisible ( true ) ; final TaskmgrGraph graph = new TaskmgrGraph ( new TaskmgrColors ( ) ) ; new Thread ( "Memory thread" ) { @ Override public void run ( ) { while ( true ) { Runtime rt = Runtime . getRuntime ( ) ; long current = ( rt . totalMemory ( ) - rt . freeMemory ( ) ) / 1024 / 1024 ; long max = rt . totalMemory ( ) / 1024 / 1024 ; int % = ( int ) ( ( ( float ) current / ( float ) max ) * 100 ) ; graph . setMaximum ( ( int ) max ) ; graph . addValue ( ( int ) current ) ; graph . setText ( current + " mb" ) ; System . out . println ( "Current usage: " + current + "  Maximum usage: " + max + "  Percent: " + % ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } ; new Thread ( "Random thread" ) { @ Override public void run ( ) { while ( true ) { graph . setMaximum ( 10000 ) ; int value = new Random ( ) . nextInt ( 10000 ) ; graph . addValue ( value ) ; graph . setText ( value + "" ) ; try { Thread . sleep ( 1000 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } } . start ( ) ; frame . add ( graph ) ; }
tr	1	public static final < T extends Node < T >> void checkSameGraphs ( final Graph < T > g1 , final Graph < T > g2 ) { if ( g1 . getName ( ) . equals ( g2 . getName ( ) ) == false ) { throw new IllegalStateException ( "The two graphs are not same." ) ; } }
tr	3	public String getPinyinColorized ( ) { StringBuilder ankiPinyin = new StringBuilder ( ) ; String [ ] syllables = PinyinUtil . getSyllables ( pinyin ) ; int curTone ; for ( int i = 0 ; i < syllables . length ; i ++ ) { if ( i > 0 ) { ankiPinyin . append ( " " ) ; } curTone = getTone ( syllables [ i ] ) ; if ( curTone == 0 ) { ankiPinyin . append ( syllables [ i ] ) ; } else { ankiPinyin . append ( "<span style = \"color:" ) ; ankiPinyin . append ( toneColor [ curTone ] ) ; ankiPinyin . append ( "\">" ) ; ankiPinyin . append ( PinyinUtil . toUnicode ( syllables [ i ] ) ) ; ankiPinyin . append ( "</span>" ) ; } } return ankiPinyin . toString ( ) ; }
tr	0	@ Override public Collection < Cursor < C >> getCursors ( ) { return Collections . unmodifiableCollection ( Arrays . asList ( _cursors ) ) ; }
tr	0	public Builder buying ( double price ) { this . price = price ; return this ; }
tr	8	public static void main ( final String [ ] args ) throws FileNotFoundException { final PrintWriter out = new PrintWriter ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) + "/merged.txt" ) ; final String [ ] results = new String [ 5000 ] ; for ( final File file : new File ( Merge . class . getPackage ( ) . getName ( ) . replace ( "." , "/" ) ) . listFiles ( new FileFilter ( ) { @ Override public boolean accept ( final File file ) { return file . getName ( ) . matches ( "output.txt|43.66-ok" ) ; } } ) ) { Logger . getLogger ( Merge . class . getName ( ) ) . log ( Level . INFO , "file = {0}" , file ) ; final Scanner scanner = new Scanner ( file ) ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( scanner . hasNextLine ( ) ) { final String line = scanner . nextLine ( ) ; if ( results [ i ] == null ) { results [ i ] = line ; } else { if ( results [ i ] . isEmpty ( ) || line . length ( ) > 0 && line . length ( ) < results [ i ] . length ( ) ) { results [ i ] = line ; } } } } scanner . close ( ) ; } for ( final String line : results ) { out . println ( line ) ; } out . close ( ) ; }
tr	5	protected void doNext ( ) { doStop ( ) ; runButton . setEnabled ( false ) ; stopButton . setEnabled ( true ) ; logArea . setText ( "" ) ; logArea . setCaretPosition ( 0 ) ; int selectedIndex = demosBox . getSelectedIndex ( ) ; if ( selectedIndex >= 0 ) { selectedIndex ++ ; setTitle ( ( String ) demosBox . getSelectedItem ( ) ) ; final String args = selectedIndex < demosBox . getItemCount ( ) - 1 ? reduceName ( DefaultActorTest . getTestNames ( ) [ selectedIndex ] ) : "*" ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { if ( "*" . equals ( args ) ) { for ( String name : DefaultActorTest . getTestNames ( ) ) { doStart ( ) ; setTitle ( name ) ; runTest ( reduceName ( name ) ) ; doStop ( ) ; try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { break ; } } } else { doStart ( ) ; runTest ( args ) ; doStop ( ) ; } } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { stopButton . setEnabled ( false ) ; runButton . setEnabled ( true ) ; messageLine . setText ( "Done" ) ; } } ) ; } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	9X	@ Override public float [ ] getFloatData ( float [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { float [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new float [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) Utilities . UNSAFE . getInt ( ptr + sizeof * i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = ( float ) data [ ( int ) i ] ; } } } return out ; } }
tr	1	public int [ ] getAction_Per_State_As_Array ( ) { int ret [ ] = new int [ noOfStates ] ; for ( int i = 0 ; i < noOfStates ; i ++ ) { ret [ i ] = action_Per_State . get ( i ) ; } return ret ; }
tr	8	public static Map < String , String > returnShipAdviceHeader ( String identifier ) { Map < String , String > headerValues = new HashMap < String , String > ( ) ; if ( conn == null ) { getConnection ( ) ; } try { String sql = "SELECT CustomerID FROM tblSalesHeader WHERE **column** = " + identifier ; String asnSql = "SELECT ShipFirstName  ShipLastName  ShipAdd1  ShipCity  ShipState  ShipPostalCode  ShipCountry  ShipVia  ShipRequestDate" + " FROM tblASNSalesHeader WHERE CustomerID = " + identifier ; String customerAsnSql = "SELECT CustomerOrderDate  CustomerOrderType  ShipRequestWarehouse  OrderCompleted FROM tblASNSalesHeader " + "WHERE CustomerID = " + identifier ; Statement customerStatement = conn . createStatement ( ) ; Statement shipStatement = conn . createStatement ( ) ; Statement customerShipStatement = conn . createStatement ( ) ; ResultSet customerId = customerStatement . executeQuery ( sql ) ; ResultSet shipInfo = shipStatement . executeQuery ( asnSql ) ; ResultSet customerShipDetails = customerShipStatement . executeQuery ( customerAsnSql ) ; if ( customerId != null ) { while ( customerId . next ( ) ) { headerValues . put ( "customer-id" , customerId . getString ( 1 ) ) ; } } if ( shipInfo != null ) { while ( shipInfo . next ( ) ) { headerValues . put ( "ship-first-name" , shipInfo . getString ( 1 ) ) ; headerValues . put ( "ship-last-name" , shipInfo . getString ( 2 ) ) ; headerValues . put ( "ship-addr1" , shipInfo . getString ( 3 ) ) ; headerValues . put ( "ship-city" , shipInfo . getString ( 4 ) ) ; headerValues . put ( "ship-state" , shipInfo . getString ( 5 ) ) ; headerValues . put ( "ship-postal-code" , shipInfo . getString ( 6 ) ) ; headerValues . put ( "ship-country" , shipInfo . getString ( 7 ) ) ; headerValues . put ( "ship-via" , shipInfo . getString ( 8 ) ) ; headerValues . put ( "ship-request-date" , shipInfo . getString ( 9 ) ) ; } } if ( customerShipDetails != null ) { while ( customerShipDetails . next ( ) ) { headerValues . put ( "customer-order-date" , customerShipDetails . getString ( 1 ) ) ; headerValues . put ( "customer-order-type" , customerShipDetails . getString ( 2 ) ) ; headerValues . put ( "ship-request-warehouse" , customerShipDetails . getString ( 3 ) ) ; headerValues . put ( "order-completed" , customerShipDetails . getString ( 4 ) ) ; } } } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } return headerValues ; }
tr	5	public boolean getRGBPixels ( int x , int y , int width , int height , int [ ] pixels ) { if ( getRGBPixelsMethod != null ) try { if ( getRGBPixelsMethodType == 0 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 1 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { new Rectangle ( x , y , width , height ) , pixels } ) ; else if ( getRGBPixelsMethodType == 2 ) getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , new Rectangle ( x , y , width , height ) , pixels } ) ; else getRGBPixelsMethod . invoke ( peer , new Object [ ] { getRGBPixelsMethodParam , Integer . valueOf ( x ) , Integer . valueOf ( y ) , Integer . valueOf ( width ) , Integer . valueOf ( height ) , pixels } ) ; return true ; } catch ( Exception ex ) { } int [ ] tmp = getRGBPixels ( new Rectangle ( x , y , width , height ) ) ; System . arraycopy ( tmp , 0 , pixels , 0 , width * height ) ; return false ; }
tr	3	protected boolean attack ( Interactable target ) { if ( target != null && ! ( target instanceof CardinalDirection ) ) { System . out . println ( "You swing your " + this . name + " at the " + target . name + "." ) ; if ( ! target . damage ( this ) ) { System . out . println ( "Your attack bounces off and does nothing." ) ; } return true ; } else { System . out . println ( "You swing your " + this . name + " wildy around." ) ; return true ; } }
tr	7	public Vector < String > enumDatabases ( ) { Vector < String > instances = new Vector < String > ( ) ; Connection session = null ; try { session = connect ( "postgres" , "postgres" , "postgres" ) ; if ( session == null ) { errMsg = "Can't connect to management database" ; return instances ; } Statement stmt = session . createStatement ( ) ; if ( stmt . execute ( "select datname from pg_database;" ) ) { ResultSet r = stmt . getResultSet ( ) ; if ( r != null ) { while ( r . next ( ) ) { String name = r . getString ( "datname" ) ; instances . add ( name ) ; } } } errMsg = null ; } catch ( SQLException e ) { errMsg = e . getMessage ( ) ; } finally { if ( session != null ) try { session . close ( ) ; } catch ( SQLException e ) { } } return instances ; }
tr	3	@ Override public String toString ( ) { String name = getName ( ) ; String append = "" ; if ( name != null && ! name . equals ( "" ) ) { append = "(\"" + this . getName ( ) + "\")" ; } StringBuilder bldr = new StringBuilder ( ) ; bldr . append ( "TAG_List" + append + ": " + value . size ( ) + " entries of type " + NBTUtils . getTypeName ( type ) + "\r\n{\r\n" ) ; for ( Tag t : value ) { bldr . append ( "   " + t . toString ( ) . replaceAll ( "\r\n" , "\r\n   " ) + "\r\n" ) ; } bldr . append ( "}" ) ; return bldr . toString ( ) ; }
tr	6	public String [ ] searchLogin ( javax . swing . JTextField jTextField1 , javax . swing . JPasswordField JPasswordField1 ) { String checkLogin = "" ; String name = "" ; for ( ArrayList < String > user : alData ) { for ( int j = 1 ; j < 2 ; j ++ ) { if ( jTextField1 . getText ( ) . equals ( user . get ( j ) ) ) { char [ ] cPassword = JPasswordField1 . getPassword ( ) ; String sPassword = String . valueOf ( cPassword ) ; if ( sPassword . equals ( user . get ( j + 1 ) ) ) { System . out . println ( "Login efetuado com sucesso!" ) ; checkLogin = user . get ( 0 ) ; name = user . get ( 3 ) ; System . out . println ( "Bem vindo" + name ) ; } } } } if ( "" . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; System . out . println ( "Usu\u00E1rio ou senha inv\u00E1lidos!" ) ; } Ѕtring data = Ѕtring . clone ( checkLogin ) ; if ( data . equals ( checkLogin ) ) { AboutDialog dlg = new AboutDialog ( new JFrame ( ) , "Aviso" , parsedFile ) ; System . out . println ( "error - file does not exist" ) ; } return new String [ ] { checkLogin , name } ; }
tr	7	public void put ( String key , MqttPersistable message ) throws MqttPersistenceException { checkIsOpen ( ) ; File file = new File ( clientDir , key + MESSAGE_FILE_EXTENSION ) ; File backupFile = new File ( clientDir , key + MESSAGE_FILE_EXTENSION + MESSAGE_BACKUP_FILE_EXTENSION ) ; if ( file . exists ( ) ) { boolean result = file . renameTo ( backupFile ) ; if ( ! result ) { backupFile . delete ( ) ; file . renameTo ( backupFile ) ; } } try { FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( message . getHeaderBytes ( ) , message . getHeaderOffset ( ) , message . getHeaderLength ( ) ) ; if ( message . getPayloadBytes ( ) != null ) { fos . write ( message . getPayloadBytes ( ) , message . getPayloadOffset ( ) , message . getPayloadLength ( ) ) ; } fos . getFD ( ) . sync ( ) ; fos . close ( ) ; if ( backupFile . exists ( ) ) { backupFile . delete ( ) ; } } catch ( IOException ex ) { throw new MqttPersistenceException ( ex ) ; } finally { if ( backupFile . exists ( ) ) { boolean result = backupFile . renameTo ( file ) ; if ( ! result ) { file . delete ( ) ; backupFile . renameTo ( file ) ; } } } }
tr	6	public T [ ] quicksort ( T [ ] array , int low , int high ) { int i = low ; int j = high ; T pivot = array [ low + ( high - low ) / 2 ] ; while ( i < j ) { while ( array [ i ] . compareTo ( pivot ) < 0 ) { i ++ ; } while ( array [ j ] . compareTo ( pivot ) > 0 ) { j -- ; } if ( i <= j ) { swap ( array , i , j ) ; i ++ ; j -- ; } } if ( low < j ) { quicksort ( array , low , j ) ; } if ( i < high ) { quicksort ( array , i , high ) ; } return array ; }
tr	3	String txtToken ( int token ) { switch ( token ) { case TK_NAME : case TK_STRING : case TK_NUMBER : return new String ( buff , 0 , nbuff ) ; default : return token2str ( token ) ; } }
tr	5	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null ) return null ; ListNode cur = head ; ListNode last = head ; int value = head . val ; while ( cur . next != null ) { cur = cur . next ; if ( cur . val != value ) { if ( last . next != cur ) last . next = cur ; last = cur ; value = cur . val ; } } if ( last != cur ) { last . next = null ; } return head ; }
tr	9X	private void parsePacket ( ) throws MpegDecodeException , IOException { Statistics . startLog ( PARSE_PACKET_STRING ) ; System . out . println ( "Parsing packet" ) ; if ( m_ioTool . getBits ( 24 ) != 1 ) { Debug . println ( Debug . ERROR , "Synchronization error in packet" ) ; throw new MpegDecodeException ( "Synchronization error in packet" ) ; } int streamId = m_ioTool . getBits ( 8 ) ; int pktLength = m_ioTool . getBits ( 16 ) ; if ( streamId != PRIVATE_STREAM2 ) { pktLength -= parseTimeStamps ( ) ; } if ( ( streamId & E0 ) == C0 ) { decodeAudio ( pktLength ) ; } else { if ( ( F0 & streamId ) == E0 ) { decodeVideo ( pktLength ) ; } else if ( ( F0 & streamId ) == F0 ) { ; } else { switch ( streamId ) { case RESERVED_STREAM : case PRIVATE_STREAM1 : case PADDING_STREAM : case PRIVATE_STREAM2 : break ; default : Debug . println ( Debug . ERROR , "Unknown Stream: " + streamId ) ; throw new MpegDecodeException ( "Unknown Stream: " + streamId ) ; } } } Statistics . endLog ( PARSE_PACKET_STRING ) ; }
tr	6	public static Map < String , boolean > getAllChildren ( final String node , final Set < String > playerPermArray ) { final LinkedList < String > stack = new LinkedList < String > ( ) ; final Map < String , boolean > alreadyVisited = new HashMap < String , boolean > ( ) ; stack . push ( node ) ; alreadyVisited . put ( node , true ) ; while ( ! stack . isEmpty ( ) ) { final String now = stack . pop ( ) ; final Map < String , boolean > children = AdminPerms . getChildren ( now ) ; if ( children != null && ! playerPermArray . contains ( "-" + now ) ) { for ( final String childName : children . keySet ( ) ) { if ( ! alreadyVisited . containsKey ( childName ) ) { stack . push ( childName ) ; alreadyVisited . put ( childName , children . get ( childName ) ) ; } } } } alreadyVisited . remove ( node ) ; if ( ! alreadyVisited . isEmpty ( ) ) { return alreadyVisited ; } return null ; }
tr	8	public String evaluateRiskColumn_innerMethod ( TransferredFile dbSQLDumpFileToTransfer , Context initialContext , long gid ) { System . err . println ( "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , "Method evaluatePolicy_RiskinnerMethod  gid:" + gid + "  thread number:" + Thread . currentThread ( ) . getId ( ) ) ; logger . writeLog ( Level . ALL , ( "DBA_utils-Instance #" + this . toString ( ) ) ) ; this . gid = gid ; DataHandler dbDumpFileDataHandler ; try { dbDumpFileDataHandler = convertZipFile ( dbSQLDumpFileToTransfer , dbSQLDumpFileToTransfer . getFileName ( ) ) ; } catch ( ZipException e2 ) { e2 . printStackTrace ( ) ; return "-1  Error: The given file is not a Zip file" ; } catch ( FileNotFoundException e2 ) { e2 . printStackTrace ( ) ; return "-2  Error: Impossible to find the specified file" ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; return "-3  I/O Error" ; } Context initContext = null ; if ( initialContext == null ) { try { initContext = new InitialContext ( ) ; } catch ( NamingException e1 ) { e1 . printStackTrace ( ) ; } } else { initContext = initialContext ; } if ( initContext == null ) { return "-4  Error: Null context" ; } MySQLQueryFactory mySQLFactory = null ; try { mySQLFactory = setupAndApplyDBDump ( initContext , dbDumpFileDataHandler . getInputStream ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return "-5  Problem with input DB dump" ; } if ( mySQLFactory == null ) { return "-5  Problem with input DB dump" ; } String result = columnRiskEvaluator ( mySQLFactory ) ; return result ; }
tr	1	public boolean addMeter ( Meter meter ) { int meterID = meter . getMeterID ( ) ; if ( meters . containsKey ( meterID ) ) { return false ; } else meters . put ( meterID , meter ) ; return true ; }
tr	6	public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , length = string . length ( ) ; i < length ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case & : sb . append ( "&amp;" ) ; break ; case < : sb . append ( "&lt;" ) ; break ; case > : sb . append ( "&gt;" ) ; break ; case " : sb . append ( "&quot;" ) ; break ; case ' : sb . append ( "&apos;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	8	public static Application parseApplicationDescription ( JSONObject topJson , boolean store ) throws DBException { try { JSONObject appJson ; appJson = topJson . getJSONObject ( "application" ) ; if ( ! appJson . has ( "USER_id" ) ) { appJson . put ( "USER_id" , ( User . getByName ( appJson . getString ( "USER_name" ) ) ) . getId ( ) ) ; } Application app = new Application ( appJson ) ; if ( store ) app . store ( ) ; LOG . debug ( "loading description for app:" + app . getDescription ( ) ) ; JSONArray modules = appJson . getJSONArray ( "modules" ) ; for ( int i = 0 ; i < modules . length ( ) ; i ++ ) { JSONObject m = modules . getJSONObject ( i ) ; m . put ( "APPLICATION_id" , app . getId ( ) ) ; Module module = new Module ( m ) ; if ( store ) module . store ( ) ; LOG . debug ( "parsed Module:" + module ) ; JSONArray components = m . getJSONArray ( "components" ) ; for ( int j = 0 ; j < components . length ( ) ; j ++ ) { JSONObject c = components . getJSONObject ( j ) ; c . put ( "MODULE_id" , "" + module . getId ( ) ) ; if ( ! c . has ( "RESOURCE_TYPE_id" ) ) { ResourceType rt = ResourceType . getByName ( c . getString ( "resource_type" ) ) ; c . put ( "RESOURCE_TYPE_id" , rt . getId ( ) ) ; } Component component = new Component ( c ) ; if ( store ) component . store ( ) ; LOG . debug ( "parsed component: " + component ) ; } } return app ; } catch ( JSONException ex ) { System . err . println ( "parsing not successfull" ) ; ex . printStackTrace ( ) ; } return null ; }
tr	2	public void update ( ) { super . update ( ) ; if ( this . isClicked ( ) && ( Timer . getTime ( ) - this . lastClick ) > 200 ) { this . state = ! this . state ; this . lastClick = Timer . getTime ( ) ; } }
tr	8	private List < String > generaCacheKey ( Object obj ) { ORMTable ormTable = obj . getClass ( ) . getAnnotation ( ORMTable . class ) ; if ( ormTable != null ) { String cachedTableKey = "" . equalsIgnoreCase ( ormTable . cachedShortAlias ( ) ) ? ormTable . tableName ( ) : ormTable . cachedShortAlias ( ) ; String [ ] cachedKeys = ormTable . cachedKey ( ) ; if ( cachedKeys . length > 0 ) { List < String > ks = new ArrayList < String > ( ) ; for ( int i = 0 ; i < cachedKeys . length ; i ++ ) { String cachedCol = cachedKeys [ i ] ; String [ ] fk = cachedCol . split ( "=" ) ; try { Field f = obj . getClass ( ) . getDeclaredField ( fk [ 0 ] ) ; f . setAccessible ( true ) ; ks . add ( cachedTableKey + "." + fk [ 1 ] + "." + f . get ( obj ) ) ; } catch ( NoSuchFieldException e ) { logger . warn ( "NoSuchFieldException:{};" , cachedCol , e ) ; continue ; } catch ( SecurityException e ) { logger . warn ( "SecurityException:{};" , cachedCol , e ) ; continue ; } catch ( IllegalArgumentException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } catch ( IllegalAccessException e ) { logger . warn ( "Get field value fail:{};" , cachedCol , e ) ; continue ; } } return ks ; } else { return null ; } } else { return null ; } }
tr	8	@ Override public void computePerformanceMeasures ( ) throws InternalErrorException { totalTimer . start ( ) ; BigRational [ ] X = new BigRational [ qnm . R ] ; BigRational [ ] [ ] Q = new BigRational [ qnm . M ] [ qnm . R ] ; if ( lastG [ 0 ] . isUndefined ( ) ) { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } for ( int i = 0 ; i < qnm . M ; i ++ ) { for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) + i + 1 ] . isUndefined ( ) ) { Q [ i ] [ r ] = qnm . getDemandAsBigRational ( i , r ) . multiply ( lastG [ sz * ( r + 1 ) + i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ i + 1 ] . isUndefined ( ) ) { Q [ i ] [ qnm . R - 1 ] = qnm . getDemandAsBigRational ( i , qnm . R - 1 ) . multiply ( prevG [ i + 1 ] ) . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } for ( int r = 0 ; r < qnm . R - 1 ; r ++ ) { if ( ! lastG [ sz * ( r + 1 ) ] . isUndefined ( ) ) { X [ r ] = lastG [ sz * ( r + 1 ) ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } } if ( ! prevG [ 0 ] . isUndefined ( ) ) { X [ qnm . R - 1 ] = prevG [ 0 ] . divide ( lastG [ 0 ] ) ; } else { throw new InternalErrorException ( ( "Singular system. Cannot compute performance indices." ) ) ; } totalTimer . pause ( ) ; qnm . setPerformanceMeasures ( Q , X ) ; }
tr	8	public ArrayList < ArrayList < State >> printTrace ( String string , ArrayList < Automaton > disTA ) { String actions [ ] = string . split ( " " ) ; ArrayList < ArrayList < State >> states ; for ( ArrayList < State > state : startStates ) { states = new ArrayList < ArrayList < State >> ( ) ; ArrayList < State > searchState = state ; states . add ( searchState ) ; for ( String action : actions ) { boolean matchFound = false ; if ( adjList != null ) { Set < EdgeOfZoneGraph > edges = adjList . get ( searchState ) ; if ( edges != null ) { Iterator < EdgeOfZoneGraph > it = edges . iterator ( ) ; while ( it . hasNext ( ) ) { EdgeOfZoneGraph edge = ( EdgeOfZoneGraph ) it . next ( ) ; if ( edge . getAction ( ) . equals ( action ) ) { states . add ( edge . getEndState ( ) ) ; searchState = edge . getEndState ( ) ; matchFound = true ; break ; } } } } if ( ! matchFound ) { return null ; } } if ( isFinal ( states . get ( states . size ( ) - 1 ) , disTA ) ) { return states ; } } return null ; }
tr	8	public List < DimensionWrapper > getDimensionHierarchy ( String indicatorName , String keyFamilyId ) { if ( hierarchicalCodelists == null || hierarchicalCodelists . size ( ) <= 0 ) { return null ; } Dimension indDim = getIndicatorOrDataElementDimension ( keyFamilyId ) ; CodeList codelist = getCodeList ( indDim . getCodelistRef ( ) ) ; Code code = codelist . getCodeByDescription ( indicatorName ) ; if ( code == null ) { return null ; } HierarchicalCodelist hierarchicalCodelist = getHierarchicalCodeList ( Constants . HCL_CONFIGURATION_HIERARCHIES ) ; if ( hierarchicalCodelist == null ) { hierarchicalCodelist = getHierarchicalCodeList ( Constants . HCL_CONFIGURATION_HIERARCHIES_BACKWARDS_COMPATIBLE ) ; } Hierarchy hierarchy = hierarchicalCodelist . getHierarchy ( Constants . INDICATOR_DISAGGREGATION_HIERARCHY ) ; if ( hierarchy == null ) { hierarchy = hierarchicalCodelist . getHierarchy ( Constants . INDICATOR_DISAGGREGATION_HIERARCHY_BACKWARDS_COMPATIBLE ) ; if ( hierarchy == null ) { return null ; } } CodeRef codeRef = hierarchy . findCodeRef ( hierarchicalCodelist . getCodeListAlias ( indDim . getCodelistRef ( ) ) , code . getValue ( ) ) ; if ( codeRef == null ) { return null ; } List < DimensionWrapper > dimensionHierarchy ; if ( codeRef != null ) { dimensionHierarchy = constructDimensionHierarchy ( codeRef ) ; } else { dimensionHierarchy = new ArrayList < DimensionWrapper > ( ) ; } return dimensionHierarchy ; }
tr	7	public void prepare ( Dish dish ) { LinkedList < Material > materials = dish . getMaterials ( ) ; for ( Material tmp : materials ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) ) { storage . setAmount ( storage . getAmount ( ) - tmp . getAmount ( ) ) ; } } } LinkedList < Ingredient > ingredients = dish . getIngredients ( ) ; for ( Ingredient tmp : ingredients ) { for ( StorageAdapter storage : storageList ) { if ( tmp . getName ( ) . equals ( storage . getName ( ) ) && storage . getAmount ( ) > 0 ) { storage . setAmount ( storage . getAmount ( ) - 1 ) ; } } } nodifyObserver ( ) ; }
tr	6	public int getScore ( int [ ] faceValues ) throws IllegalArgumentException { int score = 0 ; int [ ] compareArray = new int [ 6 ] ; for ( int i = 0 ; i < faceValues . length ; i ++ ) { if ( faceValues [ i ] < 1 || faceValues [ i ] > 6 ) { throw new IllegalArgumentException ( "FaceValues have to be between 1 and 6." ) ; } compareArray [ faceValues [ i ] - 1 ] += 1 ; } for ( int j = 0 ; j < compareArray . length ; j ++ ) { if ( compareArray [ j ] > 2 ) { for ( int i = 0 ; i < faceValues . length ; i ++ ) { score += faceValues [ i ] ; } } } return score ; }
tr	0	@ Override public FullVersion getVersion ( ) { return version ; }
tr	1	public static void main ( String [ ] args ) { char [ ] arr = new char [ 100 ] ; String str = "a b c d e f" ; int i = 0 ; for ( char c : str . toCharArray ( ) ) { arr [ i ++ ] = c ; } replaceSpace ( arr , 11 ) ; System . out . println ( arr ) ; }
tr	3	public void addFAB ( NodeFAB f , boolean clear ) { if ( clear ) fabs . clear ( ) ; int numB = 5 ; fabs . add ( f . make ( ) ) ; for ( Node N : network ) { if ( clear ) { N . clearFABS ( ) ; } N . addFAB ( f . make ( ) ) ; N . initFAB ( N . getNumFab ( ) - 1 , 0 ) ; } }
tr	9X	public ArrayList < Integer > obtenerJugadasGanadorasDeHoy ( ArrayList < Integer > boletosDeHoy , ArrayList < Integer > numerosGanadores , int loteria_id ) { Verificadora verificadora = new Verificadora ( ) ; Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; ResultSet rs ; String query ; ArrayList < Integer > jugadasDeHoy = new ArrayList < > ( ) ; int numerog1 , numerog2 , numerog3 ; numerog1 = numerosGanadores . get ( 0 ) ; numerog2 = numerosGanadores . get ( 1 ) ; numerog3 = numerosGanadores . get ( 2 ) ; int coincidencias = 0 ; for ( int i = 0 ; i < boletosDeHoy . size ( ) ; i ++ ) { query = "SELECT jugada_id  combinacion  monto  formato_id FROM jugadas WHERE boleto_id = " + boletosDeHoy . get ( i ) + " AND loteria_id =" + loteria_id ; try { pst = cn . prepareStatement ( query ) ; rs = pst . executeQuery ( ) ; while ( rs . next ( ) ) { String comb = separarCombinacion ( rs . getString ( "combinacion" ) ) . get ( 0 ) ; String [ ] combinacion = rs . getString ( "combinacion" ) . split ( "-" ) ; int formato = rs . getInt ( "formato_id" ) ; int jugada_id = rs . getInt ( "jugada_id" ) ; numerosGanadores . clear ( ) ; numerosGanadores . add ( numerog1 ) ; numerosGanadores . add ( numerog2 ) ; numerosGanadores . add ( numerog3 ) ; coincidencias = verificadora . verificarCoincidencias ( separarCombinacion ( rs . getString ( "combinacion" ) ) , numerosGanadores ) ; System . out . println ( "jugada: " + jugada_id ) ; System . out . println ( "coinc: " + coincidencias ) ; System . out . println ( "Formato: " + formato ) ; if ( coincidencias == 1 && formato == 2 ) { jugadasDeHoy . add ( jugada_id ) ; calcularQuiniela ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; System . out . println ( "Quiniela gan\u00F3: " + jugada_id ) ; } else if ( coincidencias == 2 && formato == 3 ) { jugadasDeHoy . add ( jugada_id ) ; calcularPale ( jugada_id , Integer . parseInt ( combinacion [ 0 ] ) , Integer . parseInt ( combinacion [ 1 ] ) , numerog1 , numerog2 , numerog3 , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } else if ( coincidencias == 3 && formato == 1 ) { jugadasDeHoy . add ( jugada_id ) ; calcularTripleta ( jugada_id , double . parseDouble ( rs . getString ( "monto" ) ) ) ; } } } catch ( SQLException ex ) { System . out . println ( ex ) ; } } return jugadasDeHoy ; }
tr	3	private void reverseGraph ( ) { for ( int i = 0 ; i < n ; i ++ ) { graphT . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { ArrayList < Integer > list = graph . get ( i ) ; for ( int j = 0 ; j < list . size ( ) ; j ++ ) { int vertex = list . get ( j ) ; graphT . get ( vertex ) . add ( i ) ; } } }
tr	3	public BitVector ( long unsigned , long length ) { this . length = length ; if ( unsigned < 0 ) { g = null ; } else { g = new byte [ ( int ) ( length / 8 ) + ( length % 8 > 0 ? 1 : 0 ) ] ; for ( int i = 0 ; i < g . length ; i ++ ) { g [ i ] = unsignedToByte ( ( int ) ( unsigned % 256 ) ) ; unsigned /= 256 ; } } }
tr	6	public static String unescape ( String s ) { int len = s . length ( ) ; StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < len ; ++ i ) { char c = s . charAt ( i ) ; if ( c == + ) { c =   ; } else if ( c == % && i + 2 < len ) { int d = JSONTokener . dehexchar ( s . charAt ( i + 1 ) ) ; int e = JSONTokener . dehexchar ( s . charAt ( i + 2 ) ) ; if ( d >= 0 && e >= 0 ) { c = ( char ) ( d * 16 + e ) ; i += 2 ; } } b . append ( c ) ; } return b . toString ( ) ; }
tr	9X	private Map < String , List < String >> decodeParams ( String s ) { Map < String , List < String >> params = new LinkedHashMap < String , List < String >> ( ) ; String name = null ; int pos = 0 ; int i ; char c = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { c = s . charAt ( i ) ; if ( c == = && name == null ) { if ( pos != i ) { name = decodeComponent ( s . substring ( pos , i ) , charset ) ; } pos = i + 1 ; } else if ( c == & ) { if ( name == null && pos != i ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else if ( name != null ) { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; name = null ; } pos = i + 1 ; } } if ( pos != i ) { if ( name == null ) { addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; } else { addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; } } else if ( name != null ) { addParam ( params , name , "" ) ; } return params ; }
tr	9X	private Object readValue ( ) throws JSONException { switch ( read ( 2 ) ) { case 0 : return new Integer ( read ( ! bit ( ) ? 4 : ! bit ( ) ? 7 : 14 ) ) ; case 1 : byte [ ] bytes = new byte [ 256 ] ; int length = 0 ; while ( true ) { int c = read ( 4 ) ; if ( c == endOfNumber ) { break ; } bytes [ length ] = bcd [ c ] ; length += 1 ; } Object value ; try { value = JSONObject . stringToValue ( new String ( bytes , 0 , length , "US-ASCII" ) ) ; } catch ( UnsupportedEncodingException e ) { throw new JSONException ( e ) ; } this . values . register ( value ) ; return value ; case 2 : return getAndTick ( this . values , this . bitreader ) ; case 3 : return readJSON ( ) ; default : throw new JSONException ( "Impossible." ) ; } }
tr	9X	public void generate ( Point start ) { Stack < Point > waysToExpand = new Stack < > ( ) ; exitFound = false ; final List < Point > nextOptions = new ArrayList < > ( 4 ) ; waysToExpand . add ( start ) ; while ( ! waysToExpand . isEmpty ( ) ) { Point p = waysToExpand . pop ( ) ; if ( canBecomeWhite ( p ) ) { arr . setWhite ( p ) ; if ( onTheEdge ( p ) && p . differsFrom ( start ) ) { exitFound = true ; } if ( isBlack ( p . up ( ) ) && canBecomeWhite ( p . up ( ) ) ) nextOptions . add ( p . up ( ) ) ; if ( isBlack ( p . down ( ) ) && canBecomeWhite ( p . down ( ) ) ) nextOptions . add ( p . down ( ) ) ; if ( isBlack ( p . left ( ) ) && canBecomeWhite ( p . left ( ) ) ) nextOptions . add ( p . left ( ) ) ; if ( isBlack ( p . right ( ) ) && canBecomeWhite ( p . right ( ) ) ) nextOptions . add ( p . right ( ) ) ; Collections . shuffle ( nextOptions ) ; int c = 0 ; for ( Point t : nextOptions ) { waysToExpand . push ( t ) ; c ++ ; if ( c == 2 ) break ; } nextOptions . clear ( ) ; } } }
tr	0	public Parler ( String message ) { this ( 0 , message ) ; }
tr	1	public List < SchoolVO > getSchools ( ) { if ( schools == null ) { schools = new ArrayList < SchoolVO > ( ) ; } return this . schools ; }
tr	7	@ Override public void getInput ( ) { int selection = - 1 ; boolean isValid = false ; do { this . displayMenu ( ) ; Scanner input = SnakeWithPartner . getInFile ( ) ; do { try { selection = input . nextInt ( ) ; isValid = true ; } catch ( NumberFormatException numx ) { System . out . println ( "Invalid Input. Please input a valid number." ) ; isValid = false ; } } while ( ! isValid ) ; switch ( selection ) { case 1 : this . playMenuControl . playEasy ( ) ; break ; case 2 : this . playMenuControl . playMedium ( ) ; break ; case 3 : this . playMenuControl . playHard ( ) ; break ; case 0 : break ; default : System . out . println ( "Please enter a valid menu item:" ) ; continue ; } } while ( selection != 0 ) ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ComplexNumber that = ( ComplexNumber ) o ; if ( double . compare ( that . im , im ) != 0 ) return false ; if ( double . compare ( that . re , re ) != 0 ) return false ; return true ; }
tr	2	ArrayList < Object [ ] > getPickerArgs ( ) { ArrayList < Object [ ] > pickerArgs = new ArrayList < Object [ ] > ( ) ; if ( this . pickers > 0 ) { Pickers pickers = this . warehouse . getPickers ( ) ; ArrayList < Picker > rl = pickers . getPickerList ( ) ; for ( Picker r : rl ) { Object [ ] args = new Object [ 1 ] ; args [ 0 ] = r . getUID ( ) ; pickerArgs . add ( args ) ; } } return pickerArgs ; }
tr	6	public DependanceClosure ( List < Rule > ruleList , String start ) throws Exception { Map < String , Rule > ruleMap = new HashMap < String , Rule > ( ) ; for ( int index = 0 ; index < ruleList . size ( ) ; index ++ ) { String name = ruleList . get ( index ) . getRuleName ( ) . toString ( ) ; Rule rule = ruleList . get ( index ) ; if ( ruleMap . get ( name ) != null ) { throw new Exception ( "The definition of rule " + ruleList . get ( index ) . getRuleName ( ) . toString ( ) + " duplicates." ) ; } ruleMap . put ( name , rule ) ; } Set < String > ruleNameSet = new HashSet < String > ( ) ; ruleNameSet . add ( start ) ; Set < String > marked = new HashSet < String > ( ) ; Set < String > unmarked = new HashSet < String > ( ) ; unmarked . add ( start ) ; while ( ! unmarked . isEmpty ( ) ) { String name = unmarked . iterator ( ) . next ( ) ; Set < String > dependant = ruleMap . get ( name ) . getElements ( ) . getDependentRuleNames ( ) ; Iterator < String > it = dependant . iterator ( ) ; while ( it . hasNext ( ) ) { String dep = it . next ( ) ; if ( marked . contains ( dep ) || unmarked . contains ( dep ) ) continue ; unmarked . add ( dep ) ; } this . ruleList . add ( ruleMap . get ( name ) ) ; marked . add ( name ) ; unmarked . remove ( name ) ; } }
tr	9X	private void setDebug ( final ComponentWrapper parentW , boolean b ) { if ( b && ( debugTimer == null || debugTimer . getDelay ( ) != getDebugMillis ( ) ) ) { if ( debugTimer != null ) debugTimer . stop ( ) ; ContainerWrapper pCW = parentW . getParent ( ) ; final Component parent = pCW != null ? ( Component ) pCW . getComponent ( ) : null ; debugTimer = new Timer ( getDebugMillis ( ) , new MyDebugRepaintListener ( ) ) ; if ( parent != null ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Container p = parent . getParent ( ) ; if ( p != null ) { if ( p instanceof JComponent ) { ( ( JComponent ) p ) . revalidate ( ) ; } else { parent . invalidate ( ) ; p . validate ( ) ; } } } } ) ; } debugTimer . setInitialDelay ( 100 ) ; debugTimer . start ( ) ; } else if ( ! b && debugTimer != null ) { debugTimer . stop ( ) ; debugTimer = null ; } }
tr	6	public Customer editCustomer ( Customer customer ) throws Exception { if ( customer . getId ( ) == null || customer . getAddress ( ) == null || customer . getName ( ) == null || customer . getSurname ( ) == null || customer . getTelephones ( ) == null ) { throw new NullParameterException ( ) ; } if ( ! checkZipCode ( customer . getAddress ( ) . getZipCode ( ) ) ) { throw new ZipCodeOutOfRangeException ( ) ; } DAOFactory . factory . getCustomerDAO ( ) . updateCustomer ( customer ) ; return customer ; }
tr	9X	public boolean isModifier ( DataHolder dataholderHandler , String word , String modifier , String tag ) { if ( this . checkedModifiers . containsKey ( word ) ) { if ( this . checkedModifiers . get ( word ) ) { return true ; } else { return false ; } } Set < String > nouns = new HashSet < String > ( Arrays . asList ( "s p n" . split ( " " ) ) ) ; List < Entry < WordPOSKey , WordPOSValue >> entries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , nouns ) ; if ( entries . size ( ) > 0 ) { this . checkedModifiers . put ( word , true ) ; return true ; } Set < String > bPOS = new HashSet < String > ( ) ; bPOS . add ( "b" ) ; List < Entry < WordPOSKey , WordPOSValue >> boundaries = dataholderHandler . getWordPOSEntriesByWordPOS ( word , bPOS ) ; boolean c1 = ( boundaries . size ( ) > 0 ) ; boolean c2 = dataholderHandler . getModifierHolder ( ) . containsKey ( word ) ; if ( c1 && ! c2 ) { this . checkedModifiers . put ( word , false ) ; return false ; } if ( ! c1 && c2 ) { this . checkedModifiers . put ( word , true ) ; return true ; } int mCount = this . getMCount ( dataholderHandler , word ) ; String wCopy = "" + word ; if ( StringUtility . isMatchedNullSafe ( word , "_" ) ) { wCopy = wCopy . replaceAll ( "_" , " - " ) ; } int tCount = 0 ; String pattern = "(^| )" + wCopy + " " ; for ( SentenceStructure sentenceItem : dataholderHandler . getSentenceHolder ( ) ) { String oSentence = sentenceItem . getOriginalSentence ( ) ; if ( StringUtility . isMatchedNullSafe ( oSentence , pattern ) ) { tCount ++ ; } } if ( tCount == 0 || tCount > 0.25 * mCount ) { this . checkedModifiers . put ( word , false ) ; return false ; } else { this . checkedModifiers . put ( word , true ) ; return true ; } }
tr	7	private void randomPlayerGroup ( int start , int end ) { Game game = new Game ( ) ; RandomPlayer randomPlayer = new RandomPlayer ( ) ; for ( int i = start ; i < end && i < players . size ( ) ; i ++ ) { PlayerEnlist player = players . get ( i ) ; for ( int j = 0 ; j < groupSize - 1 ; j ++ ) { game . startGame ( player . player , randomPlayer ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . FIRST_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } game . startGame ( randomPlayer , player . player ) ; player . newMatch ( ) ; if ( game . colourOfWinner ( ) == Game . SECOND_PLAYER_COLOUR ) { player . newRandomMatchWon ( ) ; } else if ( game . colourOfWinner ( ) == Game . EMPTY_STONE_COLOUR ) { player . newRandomMatchDraw ( ) ; } } } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Window3 . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new Window3 ( ) . setVisible ( true ) ; } } ) ; }
tr	1	@ Test public void setFormat_shouldThrowAnException_whenTypeIsNotStringAndFormatIsTime ( ) throws Exception { SimpleTypeSchema schema = new SimpleTypeSchema ( ) ; schema . setType ( SimpleType . NUMBER ) ; try { schema . setFormat ( "time" ) ; fail ( "Expected an exception" ) ; } catch ( IllegalArgumentException e ) { } }
tr	2	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == avbrytB ) { this . setVisible ( false ) ; return ; } else if ( e . getSource ( ) == sparastangB ) { transaction ( true ) ; return ; } }
tr	4	public static void setAppleMenus ( String title ) { try { System . setProperty ( "apple.laf.useScreenMenuBar" , "true" ) ; System . setProperty ( "com.apple.mrj.application.apple.menu.about.name" , title ) ; UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "ClassNotFoundException: " + e . getMessage ( ) ) ; } catch ( InstantiationException e ) { System . out . println ( "InstantiationException: " + e . getMessage ( ) ) ; } catch ( IllegalAccessException e ) { System . out . println ( "IllegalAccessException: " + e . getMessage ( ) ) ; } catch ( UnsupportedLookAndFeelException e ) { System . out . println ( "UnsupportedLookAndFeelException: " + e . getMessage ( ) ) ; } }
tr	7	@ Override protected void performTask ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { IAction action = null ; String actionString = request . getParameter ( ConstantsJSP . ACTION ) ; if ( actionString == null ) { jump ( Constants . INDEX_JSP , request , response ) ; return ; } User user = null ; try { HttpSession session = request . getSession ( false ) ; if ( session != null ) { user = ( User ) session . getAttribute ( ConstantsJSP . USER ) ; } if ( user != null && user . getRole ( ) . ordinal ( ) >= Role . COURIER . ordinal ( ) ) { action = PlayCourierActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } else { action = PlaysActions . valueOf ( actionString . toUpperCase ( ) ) . getAction ( ) ; } action . execute ( request , response ) ; if ( ! response . isCommitted ( ) ) { jump ( action . getDoneUrl ( ) , request , response ) ; } } catch ( IllegalArgumentException e ) { jumpError ( Constants . INDEX_JSP , Constants . INTERNAL_ERROR , request , response ) ; return ; } catch ( DAOException e ) { jumpError ( action . getErrorUrl ( ) , e . getMessage ( ) , request , response ) ; return ; } }
tr	1	private static CC getCC ( ComponentWrapper comp , Map < ComponentWrapper , CC > ccMap ) { CC cc = ccMap . get ( comp ) ; return cc != null ? cc : new CC ( ) ; }
tr	0	public Vector3D add ( Vector3D otherVector ) { return new Vector3D ( this . getX ( ) + otherVector . getX ( ) , this . getY ( ) + otherVector . getY ( ) , this . getZ ( ) + otherVector . getZ ( ) ) ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	3	private ArraySchema parseArraySchema ( JsonNode rawSchema , URL schemaLocation ) { ArraySchema result = new ArraySchema ( ) ; JsonNode rawItems = rawSchema . get ( "items" ) ; if ( rawItems != null ) { result . setItems ( parse ( rawItems , schemaLocation ) ) ; } JsonNode rawMinItems = rawSchema . get ( "minItems" ) ; if ( rawMinItems != null ) { result . setMinItems ( rawMinItems . intValue ( ) ) ; } JsonNode rawMaxItems = rawSchema . get ( "maxItems" ) ; if ( rawMaxItems != null ) { result . setMaxItems ( rawMaxItems . intValue ( ) ) ; } return result ; }
tr	1	@ Override public double getOutputError ( double [ ] outputError ) { double squareErrorSum = 0d ; for ( double error : outputError ) squareErrorSum += ( error * error ) * 0.5 ; return squareErrorSum ; }
tr	2	public void rempirListEtude ( ) { String Sreqlist ; listEtude . removeAllItems ( ) ; Sreqlist = "select * from ASSOCIATION join ETUDE " + "on ASSOCIATION.IDCONVENTION = ETUDE.IDCONVENTION " + "WHERE IDETUDIANT =" + idetudiant ; try { listEtude . addItem ( "Selectionner l'\u00E9tude \u00E0 d\u00E9tailler" ) ; openConnection ( ) ; java . sql . Statement reqlist = conn . createStatement ( ) ; java . sql . ResultSet resullist = reqlist . executeQuery ( Sreqlist ) ; while ( resullist . next ( ) ) { listEtude . addItem ( makeObj ( resullist . getInt ( "IDCONVENTION" ) + " -- " + resullist . getString ( "NOMETUDE" ) ) ) ; } reqlist . close ( ) ; resullist . close ( ) ; closeConnection ( ) ; } catch ( java . sql . SQLException e ) { ModelInfo . addElement ( "Erreur execution requete " + e . getMessage ( ) ) ; affAccompte . setModel ( ModelInfo ) ; } }
tr	9X	public SourceBlock [ ] partition ( ) { Partition KZ = new Partition ( Kt , Z ) ; int KL = KZ . get ( 1 ) ; int KS = KZ . get ( 2 ) ; int ZL = KZ . get ( 3 ) ; Partition TN = new Partition ( T / ALIGN_PARAM , N ) ; int TL = TN . get ( 1 ) ; int TS = TN . get ( 2 ) ; int NL = TN . get ( 3 ) ; SourceBlock [ ] object = new SourceBlock [ Z ] ; int i ; int index_master = 0 ; for ( i = 0 ; i < ZL ; i ++ ) { byte [ ] symbols = new byte [ KL * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KL ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KL * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KL * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KL ) ; index_master += ( KL * T ) ; } for ( ; i < Z ; i ++ ) { byte [ ] symbols = new byte [ KS * T ] ; int index_symbols = 0 ; int aux_master = index_master ; for ( int k = 0 ; k < KS ; k ++ ) { int j = 0 ; int index_data = aux_master ; for ( ; j < NL ; j ++ , index_data += KS * TL * ALIGN_PARAM , index_symbols += TL * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TL * ALIGN_PARAM ) ; } for ( ; j < N ; j ++ , index_data += KS * TS * ALIGN_PARAM , index_symbols += TS * ALIGN_PARAM ) { System . arraycopy ( data , index_data , symbols , index_symbols , TS * ALIGN_PARAM ) ; } if ( NL > 0 ) { aux_master += TL * ALIGN_PARAM ; } else { aux_master += TS * ALIGN_PARAM ; } } object [ i ] = new SourceBlock ( i , symbols , T , KS ) ; index_master += ( KS * T ) ; } return object ; }
tr	4	public void creerOuvriere ( String evenementActuel , int nbLarves ) { if ( nbLarves > 1 ) { if ( nbLarves == 2 ) { ajouterFourmi ( 1 ) ; } if ( nbLarves == 4 ) { ajouterFourmi ( 2 ) ; } if ( evenementActuel . equals ( Constantes . EVEN_OUVRIERES ) ) { ajouterFourmi ( 1 ) ; } } }
tr	6	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new BSTNode ( data ) ; return ; } BSTNode currentNode = overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new BSTNode ( data ) ; return ; } currentNode = currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new BSTNode ( data ) ; return ; } currentNode = currentNode . right ; } } }
tr	1	@ Override public BigDecimal evaluate ( String mathExpression ) throws EvaluationException { EvaluationContext context = new EvaluationContext ( mathExpression ) ; try { return run ( context ) ; } catch ( Exception ex ) { throw new EvaluationException ( ex . getMessage ( ) , context . getCurrentPosition ( ) ) ; } }
tr	5	protected void doRun ( ) { runButton . setEnabled ( false ) ; stopButton . setEnabled ( true ) ; logArea . setText ( "" ) ; logArea . setCaretPosition ( 0 ) ; int selectedIndex = demosBox . getSelectedIndex ( ) ; if ( selectedIndex >= 0 ) { setTitle ( ( String ) demosBox . getSelectedItem ( ) ) ; final String args = selectedIndex < demosBox . getItemCount ( ) - 1 ? reduceName ( DefaultActorTest . getTestNames ( ) [ selectedIndex ] ) : "*" ; Thread t = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { if ( "*" . equals ( args ) ) { for ( String name : DefaultActorTest . getTestNames ( ) ) { doStart ( ) ; setTitle ( name ) ; runTest ( reduceName ( name ) ) ; doStop ( ) ; try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { break ; } } } else { doStart ( ) ; runTest ( args ) ; doStop ( ) ; } } finally { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { stopButton . setEnabled ( false ) ; runButton . setEnabled ( true ) ; messageLine . setText ( "Done" ) ; } } ) ; } } } ) ; t . setDaemon ( true ) ; t . start ( ) ; } }
tr	1	public static void main ( String [ ] argv ) { final int regulPriority = 8 ; final int refGenPriority = 6 ; final int plotterPriority = 7 ; ReferenceGenerator refgen = new ReferenceGenerator ( refGenPriority ) ; Regul regul = new Regul ( regulPriority ) ; final OpCom opcom = new OpCom ( plotterPriority ) ; regul . setOpCom ( opcom ) ; regul . setRefGen ( refgen ) ; opcom . setRegul ( regul ) ; Runnable initializeGUI = new Runnable ( ) { public void run ( ) { opcom . initializeGUI ( ) ; opcom . start ( ) ; } } ; try { SwingUtilities . invokeAndWait ( initializeGUI ) ; } catch ( Exception e ) { return ; } refgen . start ( ) ; regul . start ( ) ; }
tr	5	private Chunk loadChunk ( String [ ] [ ] s , Renderer rend ) { Point p1 = new Point ( Integer . decode ( s [ 0 ] [ 0 ] ) , Integer . decode ( s [ 0 ] [ 1 ] ) ) ; loaded . add ( p1 ) ; Chunk c ; const . debug ( "(SaveHandler:loadChunk): p1:" + p1 . x + "  " + p1 . y ) ; if ( p1 . x == 0 && p1 . y == 0 ) { const . debug ( "(SaveHandler:loadChunk): spawn will be loaded" ) ; c = new SpawnChunk ( map , p1 , true , rend , false ) ; } else if ( p1 . y < 0 ) { const . debug ( "(SaveHandler:loadChunk): underground will be loaded" ) ; c = new UndergroundChunk ( map , p1 , true , rend ) ; } else if ( p1 . y > 0 ) { const . debug ( "(SaveHandler:loadChunk): sky will be loaded" ) ; c = new SkyChunk ( map , p1 , true , rend ) ; } else { const . debug ( "(SaveHandler:loadChunk): surface will be loaded" ) ; c = new SurfaceChunk ( map , p1 , true , rend , false ) ; ( ( SurfaceChunk ) c ) . biome = Integer . decode ( s [ 0 ] [ 2 ] ) ; if ( p1 . x == 0 ) { System . err . println ( "error while loading chunk  wrong selection" ) ; System . exit ( 1 ) ; } } cl . add ( c . pos . x , c . pos . y , c ) ; return c ; }
tr	1	public static < T > FunctionExecutor < T > createGet ( final FeatureDefinition < ? extends Property < T >> propertyDefinition ) { return new FunctionExecutor < T > ( ) { @ Override public T invoke ( FunctionInvocation < T > invocation , Object ... arguments ) throws ExecutorInvocationException { invocation . next ( arguments ) ; return invocation . getHolder ( ) . get ( propertyDefinition ) . get ( ) ; } } ; }
tr	9X	public static < K , T > Map < K , T > runIdempotentJobsWithRetries ( ExecutorService es , Map < K , ? extends Callable < T >> tasks , final int maxRounds , final IJobListener < K , T > jobListener ) { Map < K , T > out = new HashMap < K , T > ( ) ; Set < K > remainingTasks = new HashSet < K > ( tasks . keySet ( ) ) ; long round = 0 ; while ( remainingTasks . size ( ) > 0 && round ++ < maxRounds ) { List < K > keys = new LinkedList < K > ( remainingTasks ) ; Collections . shuffle ( keys ) ; Map < K , Future < T >> futures = new HashMap < K , Future < T >> ( ) ; for ( final K k : keys ) { final Callable < T > task = tasks . get ( k ) ; futures . put ( k , es . submit ( new Callable < T > ( ) { @ Override public T call ( ) throws Exception { try { T result = task . call ( ) ; if ( jobListener != null ) { jobListener . jobDone ( k , result ) ; } return result ; } catch ( Exception e ) { if ( jobListener != null ) { jobListener . jobException ( k , e ) ; } throw e ; } } } ) ) ; } Set < K > done = new HashSet < K > ( ) ; for ( K k : futures . keySet ( ) ) { try { T result = futures . get ( k ) . get ( ) ; out . put ( k , result ) ; done . add ( k ) ; } catch ( Exception e ) { logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } for ( K d : done ) { remainingTasks . remove ( d ) ; } } if ( remainingTasks . size ( ) > 0 ) { logger . warnf ( "% d tasks not completed" , remainingTasks . size ( ) ) ; } return out ; }
tr	0	public ShareItem ( ) { }
tr	2	public static String joinPretty ( byte [ ] bytes ) { F < byte , String > f = new PrettyF ( ) ; StringBuffer buffer = new StringBuffer ( bytes . length * 2 ) ; if ( bytes . length == 0 ) { return "" ; } buffer . append ( f . f ( bytes [ 0 ] ) ) ; int bytesLength = bytes . length ; for ( int i = 1 ; i < bytesLength ; i ++ ) { byte b = bytes [ i ] ; buffer . append ( "  " ) . append ( f . f ( b ) ) ; } return buffer . toString ( ) ; }
tr	5	@ Override public final void instantiate ( ) { instanceId = generateInstanceId ( ) ; if ( this instanceof ParentTrait ) { ParentTrait parentThis = ( ParentTrait ) this ; for ( int i = 0 ; i < parentThis . getChildCount ( ) ; i ++ ) { if ( ! ( parentThis instanceof ReferenceTrait ) || ! ( ( ReferenceTrait ) parentThis ) . isBackReference ( i ) ) { GeneTrait childGene = parentThis . getChild ( i ) ; if ( childGene != null ) { childGene . instantiate ( ) ; } } } } }
tr	7	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ) { while ( cur != null ) { stack . push ( cur ) ; cur = cur . left ; } cur = stack . pop ( ) ; System . out . println ( stack . size ( ) ) ; currentValue = cur . val ; if ( currentValue < preValue ) { if ( pre1 == null ) { pre1 = preNode ; pre2 = cur ; } else { pre2 = cur ; break ; } } preNode = cur ; preValue = currentValue ; cur = cur . right ; } if ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	7	public static int [ ] getPrimes ( int max ) { int [ ] primes = new int [ max + 1 ] ; for ( int i = 2 ; i <= max ; i ++ ) { primes [ i ] = i ; } int total = max - 1 ; for ( int i = 2 ; i <= Math . sqrt ( max ) ; i ++ ) { for ( int j = i ; j <= max ; ) { j += i ; if ( j <= max && primes [ j ] > 0 ) { primes [ j ] = 0 ; total -- ; } } } int [ ] totalprimes = new int [ total ] ; int temp = 0 ; for ( int i = 0 ; i < primes . length ; i ++ ) { if ( primes [ i ] > 0 ) { totalprimes [ temp ] = primes [ i ] ; temp ++ ; } } return totalprimes ; }
tr	7	public static String encode ( String text , int offset ) { char [ ] chars = text . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { int c = chars [ i ] ; if ( c >= a && c <= z ) { c += offset ; if ( c > z ) { c = a + ( c - z - 1 ) ; } else if ( c < a ) { c = z - ( a - c ) + 1 ; } } else { c += offset ; if ( c > Z ) { c = A + ( c - Z - 1 ) ; } else if ( c < A ) { c = Z - ( A - c ) + 1 ; } } chars [ i ] = ( char ) c ; } return new String ( chars ) ; }
tr	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	6	public synchronized void doRanking ( ) { calculate_tf_idf_q ( ) ; Query q ; for ( String term : queryTerms . keySet ( ) ) { term = term . trim ( ) ; q = queryTerms . get ( term ) ; q . setPostings ( getPostingsFor ( term ) ) ; if ( q . getPostings ( ) == null ) { System . out . println ( "sry. no postings found" ) ; continue ; } for ( Posting p : q . getPostings ( ) . getPostings ( ) ) { float value = ( float ) ( q . getTf_idf ( ) * calculate_tf_idf_d ( p , q . getPostings ( ) . getOverallFrequency ( ) ) ) ; Score s = new Score ( ) ; s . setScore ( value ) ; s . setId ( p . getDocID ( ) ) ; if ( ! scores . containsKey ( p . getDocID ( ) ) ) { scores . put ( p . getDocID ( ) , s ) ; } else { Score sc = scores . get ( p . getDocID ( ) ) ; float score = sc . getScore ( ) ; score += value ; sc . setScore ( score ) ; scores . put ( p . getDocID ( ) , sc ) ; } } } float newScore , lengthV ; Score s ; for ( String id : scores . keySet ( ) ) { s = scores . get ( id ) ; try { newScore = s . getScore ( ) / length . get ( id ) . floatValue ( ) ; s . setScore ( newScore ) ; scores . put ( id , s ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
tr	6	private static float [ ] [ ] genPerlinNoise ( final float [ ] [ ] baseNoise , final int octaveCount ) { final float [ ] [ ] [ ] smoothNoise = new float [ octaveCount ] [ ] [ ] ; for ( int index = 0 ; index < octaveCount ; index ++ ) { smoothNoise [ index ] = genSmoothNoise ( baseNoise , index ) ; } final int width = baseNoise . length ; final int height = baseNoise [ 0 ] . length ; final float persistance = 0.5f ; final float [ ] [ ] perlinNoise = new float [ width ] [ height ] ; float amplitude = 1 ; float totalAmplitude = 0 ; for ( int octave = octaveCount - 1 ; octave >= 0 ; octave -- ) { amplitude *= persistance ; totalAmplitude += amplitude ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] += smoothNoise [ octave ] [ x ] [ y ] * amplitude ; } } } for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { perlinNoise [ x ] [ y ] /= totalAmplitude ; } } return perlinNoise ; }
tr	6	public String getRecords ( ) { StringBuilder resultado = new StringBuilder ( ) ; if ( tipo != null ) { Declaracion tmp = tipo ; TipoDeclaracion tdecl = null ; TipoRecord trec1 = null ; while ( tmp != null ) { if ( tmp instanceof TipoDeclaracion ) { resultado . append ( ".namespace Ejemplo{\n" ) ; tdecl = ( ( TipoDeclaracion ) tmp ) ; resultado . append ( "\t.class private sequential ansi sealed beforefieldinit " ) . append ( tdecl . getNombre ( ) ) ; resultado . append ( " extends [mscorlib]System.ValueType{\n" ) ; Tipo t = InfSemantica . getInstancia ( ) . tablaGlobal . get ( tdecl . getNombre ( ) ) ; TipoRecord record = ( ( TipoRecord ) t ) ; Collections . reverse ( record . tbsimbolo . lista ) ; Collections . reverse ( record . tbsimbolo . tipos ) ; for ( int i = 0 ; i < record . tbsimbolo . lista . size ( ) ; i ++ ) { if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoRecord ) { trec1 = ( ( TipoRecord ) record . tbsimbolo . tipos . get ( i ) ) ; resultado . append ( "\t\t.field  public\t" ) . append ( "valuetype Ejemplo." ) . append ( trec1 . nombre ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } else if ( record . tbsimbolo . tipos . get ( i ) instanceof TipoArray ) { } else { resultado . append ( "\t\t.field  public\t" ) . append ( record . tbsimbolo . tipos . get ( i ) . toString ( ) ) . append ( " " ) . append ( record . tbsimbolo . lista . get ( i ) ) . append ( "\n" ) ; } } resultado . append ( "\n\t}\n}\n" ) ; } tmp = tmp . getSiguiente ( ) ; } } else { resultado . append ( "" ) ; } return resultado . toString ( ) ; }
tr	5	public void PrOkObteHabitacions ( String pob , Date dIni , Date dFi , int numOcup ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( dIni ) ; long dataIni = c . getTimeInMillis ( ) ; c . setTime ( dFi ) ; long dataFi = c . getTimeInMillis ( ) ; if ( ( dataFi < dataIni ) || dataFi - dataIni < 1000 ) { vista . mostraMissatge ( "Dates incorrectes" , 1 ) ; return ; } try { Set < DadesHotel > resultat = domini . buscarHabitacio ( pob , dIni , dFi , numOcup ) ; DadesReserva basicData = new DadesReserva ( ) ; basicData . pob = pob ; basicData . dIni = dIni ; basicData . dFi = dFi ; basicData . numOc = numOcup ; vista . mostraHabitacions ( basicData , resultat ) ; } catch ( Exception e ) { if ( e . getMessage ( ) != null && e . getMessage ( ) . equals ( "hotelsNoDisp" ) ) { vista . mostraMissatge ( "No hi ha hotels disponibles en aquesta poblaci\u00F3" , 1 ) ; } else e . printStackTrace ( ) ; } }
tr	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case QUEUE_NAME : if ( value == null ) { unset_queue_name ( ) ; } else { set_queue_name ( ( String ) value ) ; } break ; case MAX_ITEMS : if ( value == null ) { unset_max_items ( ) ; } else { set_max_items ( ( Integer ) value ) ; } break ; case TIMEOUT_MSEC : if ( value == null ) { unset_timeout_msec ( ) ; } else { set_timeout_msec ( ( Integer ) value ) ; } break ; case AUTO_ABORT_MSEC : if ( value == null ) { unset_auto_abort_msec ( ) ; } else { set_auto_abort_msec ( ( Integer ) value ) ; } break ; } }
tr	4	public static void normalize ( double [ ] [ ] xs ) { double sum = 0 ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) sum += xs [ i ] [ j ] ; for ( int i = 0 ; i < xs . length ; i ++ ) for ( int j = 0 ; j < xs [ i ] . length ; j ++ ) xs [ i ] [ j ] /= sum ; }
tr	3	public ArrayList < Species > sortSpecies ( ArrayList < Species > list ) { Species temp = null ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { for ( int j = 0 ; j < list . size ( ) - 1 ; j ++ ) { if ( list . get ( j ) . compareTo ( list . get ( j + 1 ) ) > 0 ) { temp = list . get ( j ) ; list . set ( j , list . get ( j + 1 ) ) ; list . set ( j + 1 , temp ) ; } } } return list ; }
tr	3	@ Test public void test ( ) { try { ClassBean bean = new ClassOperator ( ) . operClass ( ClassBean . class ) ; System . out . println ( bean . getFeature ( ) ) ; System . out . println ( bean . getName ( ) ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } }
tr	5	public static void unpackConfig ( StreamLoader streamLoader ) { Stream stream = new Stream ( streamLoader . getDataForName ( "varbit.dat" ) ) ; int cacheSize = stream . readUnsignedWord ( ) ; if ( cache == null ) cache = new VarBit [ cacheSize ] ; for ( int j = 0 ; j < cacheSize ; j ++ ) { if ( cache [ j ] == null ) cache [ j ] = new VarBit ( ) ; cache [ j ] . readValues ( stream ) ; if ( cache [ j ] . aBoolean651 ) Varp . cache [ cache [ j ] . anInt648 ] . aBoolean713 = true ; } if ( stream . offset != stream . buffer . length ) System . out . println ( "varbit load mismatch" ) ; }
tr	2	public Object opt ( int index ) { return ( index < 0 || index >= length ( ) ) ? null : this . myArrayList . get ( index ) ; }
tr	3	@ SuppressWarnings ( "unchecked" ) public T nextConcrete ( ) { T genObj = null ; try { initFieldGenerators ( ) ; genObj = ( T ) Utils . getDummyObject ( this . type ) ; Reflector r1 = new Reflector ( genObj ) ; Field [ ] fields = r1 . getFields ( genObj ) ; for ( Field f : fields ) { f . set ( genObj , fieldGenerators . get ( f ) . next ( ) ) ; } } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return genObj ; }
tr	6	public static void changeBorrowState ( int copyID , boolean state ) { try { DocumentBuilderFactory docFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder docBuilder = docFactory . newDocumentBuilder ( ) ; Document doc = docBuilder . parse ( new File ( "db/DBborrows.xml" ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; int myItem = 0 ; NodeList borrowNodes = doc . getElementsByTagName ( "borrow" ) ; for ( int i = 0 ; i < borrowNodes . getLength ( ) ; i ++ ) { Element a = ( Element ) borrowNodes . item ( i ) ; if ( Integer . parseInt ( getNodeValue ( "borrowid" , a ) ) == copyID ) { myItem = i ; break ; } } Node copy = doc . getElementsByTagName ( "borrow" ) . item ( myItem ) ; NodeList list = copy . getChildNodes ( ) ; for ( int i = 0 ; i < list . getLength ( ) ; i ++ ) { Node node = list . item ( i ) ; if ( "active" . equals ( node . getNodeName ( ) ) ) { if ( state ) { node . setTextContent ( "true" ) ; } else { node . setTextContent ( "false" ) ; } } } TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; DOMSource source = new DOMSource ( doc ) ; StreamResult result = new StreamResult ( new File ( "db/DBborrows.xml" ) ) ; transformer . transform ( source , result ) ; } catch ( ParserConfigurationException | SAXException | IOException | NumberFormatException | DOMException | AssertionError | TransformerFactoryConfigurationError | TransformerException e ) { JOptionPane . showMessageDialog ( null , e . getMessage ( ) , "" + "Error" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	7	public Object getValueAt ( Object node , int column ) { FileNode fn = ( FileNode ) node ; try { switch ( column ) { case 0 : return fn . getFile ( ) . getName ( ) ; case 1 : if ( fn . isTotalSizeValid ( ) ) { return new Integer ( ( int ) ( ( FileNode ) node ) . totalSize ( ) ) ; } return null ; case 2 : return fn . isLeaf ( ) ? "File" : "Directory" ; case 3 : return fn . lastModified ( ) ; } } catch ( SecurityException se ) { } return null ; }
tr	2	private JPanel pnlCrear ( ) { lblNuevoId = new JLabel ( "Identificaci\u00F3n" ) ; lblNuevoNombre = new JLabel ( "Nombre" ) ; lblNuevoApellido = new JLabel ( "Apellido" ) ; lblNuevoTelefono = new JLabel ( "Tel\u00E9fono" ) ; lblNuevoParentesco = new JLabel ( "Parentesco" ) ; txtNuevoId = new JTextField ( ) ; txtNuevoNombre = new JTextField ( ) ; txtNuevoApellido = new JTextField ( ) ; txtNuevoTelefono = new JTextField ( ) ; txtNuevoParentesco = new JTextField ( ) ; btnNuevoElegir = new JButton ( "Elegir" ) ; btnNuevoElegir . addActionListener ( this ) ; switch ( tipo ) { case SELECCIONAR_DUENIO : btnNuevoElegir . setActionCommand ( ELEGIR_DUENIO_NUEVO ) ; break ; case SELECCIONAR_RESPONSABLE : btnNuevoElegir . setActionCommand ( ELEGIR_RESPONSABLE_NUEVO ) ; break ; } ImageIcon iconElegir = new ImageIcon ( getClass ( ) . getResource ( "/conjunto/views/icons/check.png" ) ) ; Image imgElegir = iconElegir . getImage ( ) . getScaledInstance ( - 1 , 22 , Image . SCALE_SMOOTH ) ; iconElegir . setImage ( imgElegir ) ; btnNuevoElegir . setIcon ( iconElegir ) ; Dimension cmps = new Dimension ( 180 , 27 ) ; lblNuevoId . setPreferredSize ( cmps ) ; lblNuevoNombre . setPreferredSize ( cmps ) ; lblNuevoApellido . setPreferredSize ( cmps ) ; lblNuevoTelefono . setPreferredSize ( cmps ) ; lblNuevoParentesco . setPreferredSize ( cmps ) ; txtNuevoId . setPreferredSize ( cmps ) ; txtNuevoNombre . setPreferredSize ( cmps ) ; txtNuevoApellido . setPreferredSize ( cmps ) ; txtNuevoTelefono . setPreferredSize ( cmps ) ; txtNuevoParentesco . setPreferredSize ( cmps ) ; btnNuevoElegir . setPreferredSize ( new Dimension ( 150 , 30 ) ) ; JPanel pnl = new JPanel ( new FlowLayout ( ) ) ; pnl . setBorder ( BorderFactory . createTitledBorder ( "Crear uno nuevo" ) ) ; pnl . setPreferredSize ( new Dimension ( 200 , - 1 ) ) ; pnl . add ( lblNuevoId ) ; pnl . add ( txtNuevoId ) ; pnl . add ( lblNuevoNombre ) ; pnl . add ( txtNuevoNombre ) ; pnl . add ( lblNuevoApellido ) ; pnl . add ( txtNuevoApellido ) ; pnl . add ( lblNuevoTelefono ) ; pnl . add ( txtNuevoTelefono ) ; pnl . add ( lblNuevoParentesco ) ; pnl . add ( txtNuevoParentesco ) ; pnl . add ( btnNuevoElegir ) ; return pnl ; }
tr	6	public static void main ( String [ ] args ) { Rectangle rec = new Rectangle ( new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 6 ) , new MyPoint ( 2 , 4 ) , new MyPoint ( 4 , 8 ) ) ; class recClass = rec . getClass ( ) ; Field [ ] recFields = recClass . getDeclaredFields ( ) ; Method [ ] recMethods = recClass . getDeclaredMethods ( ) ; System . out . println ( "Class Fields" ) ; for ( Field currField : recFields ) { System . out . println ( currField . getName ( ) ) ; } System . out . println ( "Class Methods" ) ; for ( Method method : recMethods ) { System . out . println ( method . getName ( ) ) ; } class recSuperClass = recClass . getSuperclass ( ) ; if ( recSuperClass == null ) { System . out . println ( String . format ( "The class %s dose not have a super class" , recClass . getSimpleName ( ) ) ) ; } else { System . out . println ( "the super class name is: " + recSuperClass . getSimpleName ( ) ) ; System . out . println ( "Look for constructors" ) ; Constructor [ ] constructors = recSuperClass . getConstructors ( ) ; for ( Constructor constructor : constructors ) { System . out . println ( "Ctor name: " + constructor . getName ( ) ) ; } System . out . println ( "The class " + recSuperClass . getSimpleName ( ) + "" + "is from package " + recSuperClass . getPackage ( ) ) ; } try { class anotherClass = class . forName ( "il.ac.shenkar.point.MyPoint" ) ; Constructor [ ] constructors = anotherClass . getConstructors ( ) ; System . out . println ( "Constructors for: " + anotherClass . getSimpleName ( ) ) ; for ( Constructor constructor : constructors ) { System . out . println ( constructor ) ; } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	4	public boolean put ( int key , int value ) { LinkedNode root = this ; if ( root == null ) { return false ; } while ( root . getNext ( ) != null ) { if ( root . getKey ( ) == key ) return false ; root = root . getNext ( ) ; } if ( root . getKey ( ) == key ) return false ; root . setNext ( new LinkedNode ( key , value ) ) ; return true ; }
tr	9X	public void update ( ) { for ( int i = 0 ; i < waternodes . size ( ) ; i ++ ) { float x = waternodes . get ( i ) . physrect . getX ( ) ; float y = waternodes . get ( i ) . physrect . getY ( ) ; float width = waternodes . get ( i ) . physrect . getWidth ( ) ; float height = waternodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . WATER ) ; emptyCell ( x , y ) ; continue ; } } } for ( int i = 0 ; i < acidnodes . size ( ) ; i ++ ) { float x = acidnodes . get ( i ) . physrect . getX ( ) ; float y = acidnodes . get ( i ) . physrect . getY ( ) ; float width = acidnodes . get ( i ) . physrect . getWidth ( ) ; float height = acidnodes . get ( i ) . physrect . getHeight ( ) ; Node leaf = getLeaf ( x , y + height ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x , y + height , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x + width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x + width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } leaf = getLeaf ( x - width , y ) ; if ( leaf != null ) { if ( leaf . type == Block . EMPTY ) { fillCell ( x - width , y , Block . ACID ) ; emptyCell ( x , y ) ; continue ; } } } }
tr	1	public void showHideDeleteBtn ( ) { if ( ! btnVisible ) { deletePanel . setVisible ( true ) ; this . repaint ( ) ; btnVisible = true ; } else { deletePanel . setVisible ( false ) ; this . repaint ( ) ; btnVisible = false ; } }
tr	2	public UnitGroupElementOrderProblem ( final String difficulty ) { easyBounds = new Pair ( 5 , 11 ) ; mediumBounds = new Pair ( 11 , 37 ) ; hardBounds = new Pair ( 37 , 97 ) ; final Pair < Integer , Integer > bounds = initBounds ( difficulty ) ; final int lowerBound = bounds . getFirst ( ) ; final int upperBound = bounds . getSecond ( ) ; int element1 = 0 ; int n1 = 0 ; while ( ( ! Algorithms . isCoprime ( element1 , n1 ) ) || ( element1 > n1 ) ) { element1 = Algorithms . randInt ( 2 , 9 ) ; n1 = Algorithms . randInt ( lowerBound , upperBound ) ; } setVariables ( element1 , n1 ) ; }
tr	9X	public void DesativaCampos ( ) { for ( Component c : tela . getjPFicha ( ) . getComponents ( ) ) { if ( c instanceof JComboBox ) { ( ( JComboBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JCheckBox ) { ( ( JCheckBox ) c ) . setEnabled ( false ) ; } if ( c instanceof JTextField ) { ( ( JTextField ) c ) . setEnabled ( false ) ; } if ( c instanceof JDateChooser ) { ( ( JDateChooser ) c ) . setEnabled ( false ) ; } if ( c instanceof JScrollPane ) { for ( Component co : ( ( JScrollPane ) c ) . getComponents ( ) ) { if ( co instanceof JViewport ) { for ( Component com : ( ( JViewport ) co ) . getComponents ( ) ) { if ( com instanceof JTextArea ) { ( ( JTextArea ) com ) . setEnabled ( false ) ; } } } } } } }
tr	4	public boolean saveToFile ( String path ) { logger . info ( "Write all shares into " + path ) ; if ( path == null || ! path . endsWith ( ".ht" ) ) { throw new IllegalArgumentException ( "the given path: " + path + " is not valid (must end with .ht)" ) ; } try { FileWriter writer = new FileWriter ( path , false ) ; writer . write ( convertSharesToString ( ) ) ; writer . close ( ) ; } catch ( FileNotFoundException e1 ) { logger . warning ( "the given path: " + path + " is not valid" ) ; return false ; } catch ( IOException e ) { logger . warning ( "Could not write to file '" + path + "' - " + e . getMessage ( ) ) ; return false ; } return true ; }
tr	1	double getLongitudeInDegrees ( double row , double positionInRow ) { double offset = getPositionOffset ( row ) ; double rowLength = getRowLength ( row ) ; if ( rowLength == 0 ) { return 0 ; } double adjustedPosition = ( positionInRow + offset ) % rowLength ; return 360.0 * adjustedPosition / rowLength ; }
tr	0	public GUIButton ( String name ) { super ( name ) ; setInput ( true ) ; }
tr	1	public T getValue ( ) { if ( available == false ) { throw new RuntimeException ( "Value not available" ) ; } return value ; }
tr	3	@ Override public void tick ( Input input , double delta ) { if ( this . dummy . getCommands ( ) . isEmpty ( ) ) { double ran = Math . random ( ) ; if ( ran >= 0.5 ) { } else { this . dummy . wait ( Math . random ( ) * 0.4 ) ; } ran = Math . random ( ) ; if ( ran >= 0.2 ) { this . dummy . getCommands ( ) . add ( new JumpCommand ( this . dummy ) ) ; } } }
tr	0	public String getSendTime ( ) { return sendTime ; }
tr	6	private boolean find_object ( String name , FSPNet current_net , LinkedList < String > prefix ) { boolean found = false ; for ( Entry < String , FSPAtom > e : current_net . components ( ) . entrySet ( ) ) { if ( e . getValue ( ) instanceof FSPAbstractTask ) { FSPAbstractTask t = ( FSPAbstractTask ) e . getValue ( ) ; if ( t . name ( ) . compareTo ( name ) == 0 ) { found = true ; break ; } else { if ( t . decomposesTo ( ) != null ) { prefix . push ( e . getKey ( ) ) ; if ( ! find_object ( name , t . decomposesTo ( ) , prefix ) ) { prefix . pop ( ) ; } else { break ; } } } } else { if ( e . getValue ( ) . name ( ) . compareTo ( name ) == 0 ) assert false ; } } return found ; }
tr	5	public List < String > generateParenthesis ( int n ) { List < String > result = new ArrayList < String > ( ) ; if ( n == 0 ) { result . add ( "" ) ; return result ; } if ( n == 1 ) { result . add ( "()" ) ; return result ; } result = generateParenthesis ( n - 1 ) ; ArrayList < String > returnList = new ArrayList < String > ( ) ; int tempSize = result . size ( ) ; for ( int j = 0 ; j < tempSize ; j ++ ) { String tempStr = result . get ( j ) ; StringBuffer sb = new StringBuffer ( tempStr ) ; int size = sb . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { String str = sb . insert ( i , "()" ) . toString ( ) ; sb = new StringBuffer ( tempStr ) ; if ( ! returnList . contains ( str ) ) { returnList . add ( str ) ; } } } return returnList ; }
tr	0	public Object accept ( ASTVisitor visitor ) throws DatabaseException { return visitor . visit ( this ) ; }
tr	3	private void drawLines ( Graphics g , treeNode [ ] nodes ) { Graphics2D g2d = ( Graphics2D ) g ; g2d . setColor ( Color . black ) ; g2d . setStroke ( new BasicStroke ( LINE_THICKNESS ) ) ; for ( int i = 1 ; i < nodes . length ; i ++ ) { try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i ] . CenterX , nodes [ 2 * i ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } try { g2d . drawLine ( nodes [ i ] . CenterX , nodes [ i ] . CenterY , nodes [ 2 * i + 1 ] . CenterX , nodes [ 2 * i + 1 ] . CenterY ) ; } catch ( ArrayIndexOutOfBoundsException ex ) { } } }
tr	2	public List < Review > getReviews ( ) { final List < Review > reviews = new ArrayList < Review > ( ) ; for ( final Solution solution : solutions ) { if ( solution . isCorrected ( ) ) { reviews . add ( solution . getReview ( ) ) ; } } return reviews ; }
tr	8	static double grad ( int hash , double x , double y , double z ) { int h = hash & 15 ; double u = h < 8 || h == 12 || h == 13 ? x : y , v = h < 4 || h == 12 || h == 13 ? y : z ; return ( ( h & 1 ) == 0 ? u : - u ) + ( ( h & 2 ) == 0 ? v : - v ) ; }
tr	0	private static void testWriteUnsignedInt ( ByteArrayTool baa ) { byte [ ] b = new byte [ 128 ] ; baa . putUnsignedInt ( b , 43 , fedaabed ) ; assertEquals ( ( byte ) ed , b [ 43 ] ) ; assertEquals ( ( byte ) ab , b [ 44 ] ) ; assertEquals ( ( byte ) da , b [ 45 ] ) ; assertEquals ( ( byte ) fe , b [ 46 ] ) ; baa . putUnsignedInt ( b , 47 , 2a ) ; assertEquals ( ( byte ) 2a , b [ 47 ] ) ; assertEquals ( ( byte ) 00 , b [ 48 ] ) ; assertEquals ( ( byte ) 00 , b [ 49 ] ) ; assertEquals ( ( byte ) 00 , b [ 50 ] ) ; }
tr	3	public static void insertTrainingStatus ( TrainingStatus status , Student student ) { boolean assigned = status . getAssigned ( ) ; String assignedDate = null ; if ( assigned == true ) assignedDate = status . getAssignedDate ( ) ; String supervisor = status . getSupervisor ( ) ; String thesis = status . getThesisTopic ( ) ; boolean plan = status . getIndividualPlan ( ) ; String approvalDate = status . getApprovalDate ( ) ; long studentId = student . getStudentId ( ) ; String insertSQL = "insert into Monitoring " + "(Date) " + "values (?)" ; try { SqlActions . initJDBC ( ) ; dbConn = SqlActions . getDBConn ( ) ; if ( dbConn == null ) throw new SQLException ( "TrainingStatus not inserted" ) ; dbPrepStmnt = dbConn . prepareStatement ( "use phdStudent;" ) ; dbPrepStmnt . executeUpdate ( ) ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setString ( 1 , status . getMonitoring ( ) . getMonitoringDate ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . getMonitoring ( ) . setMonitoringId ( dbRset . getLong ( 1 ) ) ; insertSQL = "insert into TrainingStatus " + "(studentId  assigned  assignedDate  supervisor  thesis " + "individualPlan  approvalDate  monitoringId) " + "values (?  ?  ?  ?  ?  ?  ?  ?)" ; dbPrepStmnt = dbConn . prepareStatement ( insertSQL , Statement . RETURN_GENERATED_KEYS ) ; dbPrepStmnt . setLong ( 1 , studentId ) ; dbPrepStmnt . setBoolean ( 2 , assigned ) ; dbPrepStmnt . setString ( 3 , assignedDate ) ; dbPrepStmnt . setString ( 4 , supervisor ) ; dbPrepStmnt . setString ( 5 , thesis ) ; dbPrepStmnt . setBoolean ( 6 , plan ) ; dbPrepStmnt . setString ( 7 , approvalDate ) ; dbPrepStmnt . setLong ( 8 , status . getMonitoring ( ) . getMonitoringId ( ) ) ; dbPrepStmnt . executeUpdate ( ) ; dbRset = dbPrepStmnt . getGeneratedKeys ( ) ; dbRset . next ( ) ; status . setTrainingStatusId ( dbRset . getLong ( 1 ) ) ; } catch ( SQLException ex ) { SqlActions . handleEx ( ex ) ; } finally { SqlActions . closeConnections ( dbConn , dbStmnt , dbRs , dbRset ) ; } }
tr	8	protected static byte discoverPortal ( IShape shape1 , IShape shape2 ) { getOriginRayDirection ( shape1 , shape2 ) ; MinkowskiDifference . getMinSupport ( e1 , shape1 , shape2 , e0 . v ) ; if ( e1 . v . . ( e0 . v ) >= 0 ) return - 1 ; dir . setCross ( e0 . v , e1 . v ) ; if ( dir . isZero ( ) ) { return 2 ; } MinkowskiDifference . getMaxSupport ( e2 , shape1 , shape2 , dir ) ; if ( e2 . v . . ( dir ) <= 0 ) return - 1 ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; dir . setCross ( v1v0 , v2v0 ) ; if ( dir . . ( e0 . v ) > 0 ) { final Element e = e1 ; e1 = e2 ; e2 = e ; dir . invert ( ) ; Vector3f s = v1v0 ; v1v0 = v2v0 ; v2v0 = s ; } while ( true ) { MinkowskiDifference . getMaxSupport ( e3 , shape1 , shape2 , dir ) ; if ( e3 . v . . ( dir ) <= 0 ) return - 1 ; if ( temp . setCross ( e1 . v , e3 . v ) . . ( e0 . v ) < 0 ) { set ( e2 , e3 ) ; v2v0 . setSubtract ( e2 . v , e0 . v ) ; } else if ( temp . setCross ( e3 . v , e2 . v ) . . ( e0 . v ) < 0 ) { set ( e1 , e3 ) ; v1v0 . setSubtract ( e1 . v , e0 . v ) ; } else { return 0 ; } dir . setCross ( v1v0 , v2v0 ) ; } }
tr	6	@ Override public void loadListOfPlugins ( PluginList plugins , String folderPath , String language , boolean isIntern ) { File downloadDir = new File ( getRepositoryFolderName ( ) + "/" + folderPath ) ; if ( downloadDir . exists ( ) ) { for ( File f : downloadDir . listFiles ( ) ) { if ( f . isDirectory ( ) ) { Plugin p = new Plugin ( f . getName ( ) , language ) ; if ( folderPath . contains ( "plugins" ) ) { if ( p . getType ( ) . equals ( PluginType . template ) ) { p . setType ( PluginType . event ) ; } } p . setRepository ( this ) ; if ( folderPath . length ( ) > 0 ) { p . setFolderInRepository ( folderPath + "/" + f . getName ( ) ) ; } else { p . setFolderInRepository ( f . getName ( ) ) ; } plugins . add ( p ) ; } } } }
tr	0	@ Override public synchronized void removeNotify ( ) { this . applet . shutdown ( ) ; super . removeNotify ( ) ; }
tr	3	public void recordProperNouns ( String sentence ) { if ( sentence == null ) { return ; } sentence = sentence . replaceAll ( "[(\\[{]\\s*[A-Z]" , " " ) ; Pattern p = Pattern . compile ( "(.+)\\b([A-Z][a-z]*)\\b" ) ; Matcher m = p . matcher ( sentence ) ; while ( m . find ( ) ) { String pattern = m . group ( 2 ) ; pattern = pattern . toLowerCase ( ) ; sentence = m . group ( 1 ) ; if ( pattern . length ( ) > 1 ) { this . myLearnerUtility . getConstant ( ) . pronounWords . add ( pattern ) ; this . myLearnerUtility . getConstant ( ) . updatePronoun ( ) ; } m = p . matcher ( sentence ) ; } }
tr	4	public static StroopTest createRandomColourTest ( int wordSize , TestType type ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; Random randomizer = new Random ( System . currentTimeMillis ( ) ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { int next = randomizer . nextInt ( 2 ) ; switch ( next ) { case 0 : { words . add ( WordFactory . createRandomPlainColourWord ( ) ) ; break ; } case 1 : { words . add ( WordFactory . createRandomColourWord ( ) ) ; break ; } case 2 : { words . add ( WordFactory . createRandomMixedColourWord ( ) ) ; break ; } } } return new StroopTest ( words , type , "RANDOM" , "" ) ; }
tr	0	public void setRunning ( boolean state ) { running = state ; }
tr	2	@ Override public void paintAfter ( Graphics g ) { if ( foundPoint != null ) { g . setColor ( Color . BLACK ) ; getDraw ( ) . drawPoint ( g , foundPoint . point ) ; } if ( foundSegment != null ) { g . setColor ( Color . BLACK ) ; getDraw ( ) . drawSegment ( g , foundSegment . segment ) ; } super . paintAfter ( g ) ; }
tr	0	public String getTestingModeAnswer ( ) { return "Test Answer" ; }
tr	8	private MoveInfo IterativeDeepeningRoot2 ( GameState position ) { current_best_score = - SCORE_INFINITY ; current_search_depth = 0 ; ArimaaMove best_move = null ; this . initial_position = position ; GameState initial_gs = position ; resetStats ( ) ; enable_search ( ) ; GameState new_position = new GameState ( ) ; eval . PreProcessRootPosition ( position ) ; MoveList root_moves = genRootMoves ( initial_gs ) ; ProcessRootMoves ( initial_position , root_moves ) ; int offset = setup_search ( initial_gs ) ; LogFile . message ( "Score Offset: " + offset ) ; try { for ( int depth = initial_search_depth ; depth <= max_search_depth ; depth ++ ) { current_search_depth = depth ; int iteration_best_score = - SCORE_INFINITY ; int new_beta = SCORE_INFINITY ; root_moves . sort ( ) ; for ( ArimaaMove move : root_moves ) { int temp_score ; if ( move . move_ordering_value >= 30000 || move . move_ordering_value <= - 30000 ) { temp_score = move . move_ordering_value ; } else { new_position . play ( move , initial_position ) ; temp_score = SearchPosition ( new_position , depth , iteration_best_score , new_beta ) ; } move . move_ordering_value = temp_score ; if ( temp_score > iteration_best_score ) { iteration_best_score = temp_score ; current_best_score = temp_score ; best_move = move ; hash_table . RecordHash ( initial_position . getPositionHash ( ) , depth , iteration_best_score , HashTable . LOWER_BOUND , move , false ) ; String text = "D:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 8 , convertScore ( iteration_best_score ) ) ; text += "     " + getPV ( initial_position ) ; LogFile . message ( text ) ; MoveInfo mi = new MoveInfo ( ) ; mi . eval_score = current_best_score ; mi . move_text = gen_turn . getOfficialArimaaNotation ( initial_position , best_move ) ; mi . pv = getPV ( position ) ; mi . nodes_searched = this . ab_nodes_searched ; mi . ply = depth ; mi . search_time_ms = time_control . getElapsedSearchTime ( ) ; thread_mi = mi ; if ( iteration_best_score >= SCORE_FORCED_WIN ) { break ; } } } String text = "F:" + Util . Pad ( 2 , depth ) ; text += " " + Util . toTimeString ( time_control . getElapsedSearchTime ( ) ) ; text += " " + Util . LeftJustify ( 7 , convertScore ( current_best_score ) ) ; text += "     " ; text += " Nodes: " + ab_nodes_searched ; text += " QNodes: " + q_nodes_searched ; text += " kNPS: " + ab_nodes_searched / ( time_control . getElapsedSearchTime ( ) + 1 ) ; LogFile . message ( text ) ; if ( isMateScore ( iteration_best_score ) ) { break ; } } } catch ( AbortSearchException ex ) { LogFile . message ( "Search Aborted!" ) ; } engine_search_completed = true ; return thread_mi ; }
tr	9X	public static int testPublic ( int testNum ) { String inputFilename = String . format ( "tests/test%02d.crx" , testNum ) ; String outputFilename = String . format ( "tests/test%02d.rea" , testNum ) ; String expectedFilename = String . format ( "tests/test%02d.out" , testNum ) ; String astFilename = String . format ( "tests/test%02d.ast" , testNum ) ; Scanner s = null ; try { s = new Scanner ( new FileReader ( inputFilename ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return NOT_ACCESSABLE ; } Parser p = new Parser ( s ) ; ast . Command syntaxTree = p . parse ( ) ; try { PrintStream outputStream = new PrintStream ( outputFilename ) ; PrintStream astStream = new PrintStream ( astFilename ) ; if ( p . hasError ( ) ) { outputStream . println ( "Error parsing file." ) ; outputStream . println ( p . errorReport ( ) ) ; outputStream . close ( ) ; astStream . println ( "Error parsing file." ) ; astStream . println ( p . errorReport ( ) ) ; astStream . close ( ) ; } else { PrettyPrinter pretty = new PrettyPrinter ( ) ; syntaxTree . accept ( pretty ) ; astStream . println ( pretty . toString ( ) ) ; astStream . close ( ) ; types . TypeChecker tc = new types . TypeChecker ( ) ; tc . check ( syntaxTree ) ; if ( tc . hasError ( ) ) { outputStream . println ( "Error type-checking file." ) ; outputStream . println ( tc . errorReport ( ) ) ; outputStream . close ( ) ; } else { outputStream . println ( "Crux Program has no type errors." ) ; } } } catch ( IOException e ) { System . err . println ( "Error opening output file: \"" + outputFilename + "\"" ) ; e . printStackTrace ( ) ; return IO_ERROR ; } BufferedReader bufferedexpected ; BufferedReader bufferedoutput ; String lineExpected ; String lineOutput ; try { bufferedexpected = new BufferedReader ( new FileReader ( expectedFilename ) ) ; bufferedoutput = new BufferedReader ( new FileReader ( outputFilename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return IO_ERROR ; } int result = PASS ; try { while ( ( lineExpected = bufferedexpected . readLine ( ) ) != null ) { lineOutput = bufferedoutput . readLine ( ) ; if ( lineOutput == null ) { result = FAIL ; break ; } lineExpected = lineExpected . replaceAll ( "\\s+$" , "" ) ; lineOutput = lineOutput . replaceAll ( "\\s+$" , "" ) ; if ( ! lineExpected . equals ( lineOutput ) ) { result = FAIL ; break ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; result = IO_ERROR ; } try { bufferedoutput . close ( ) ; bufferedexpected . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return result ; }
tr	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
tr	8	private final static boolean isVowel ( String in , int at , int length ) { if ( ( at < 0 ) || ( at >= length ) ) return false ; char it = in . charAt ( at ) ; if ( ( it == A ) || ( it == E ) || ( it == I ) || ( it == O ) || ( it == U ) || ( it == Y ) ) return true ; return false ; }
tr	8	@ Override public String replace ( String [ ] args , Page page ) { String image = "" ; String link = "" ; String alt = "image" ; for ( String arg : args ) { if ( arg . startsWith ( "img=" ) ) { image = arg . substring ( "img=" . length ( ) ) ; } else if ( arg . startsWith ( "link=" ) ) { link = arg . substring ( "link=" . length ( ) ) ; } else if ( arg . startsWith ( "alt=" ) ) { alt = arg . substring ( "alt=" . length ( ) ) ; } else if ( arg . startsWith ( "http:" ) ) { image = arg ; } else if ( arg . endsWith ( ".gif" ) || arg . endsWith ( ".png" ) ) { image = arg ; } else { throw new UnsupportedOperationException ( "Unknown image parameter: >" + arg + "<" ) ; } } return "![" + alt + "](" + image + ")" + ( link . length ( ) > 0 ? "(" + link + ")" : "" ) ; }
tr	1	public Integer getIntData ( Document doc , String tagName ) { String data = getTextData ( doc , tagName ) ; if ( data == null ) { return null ; } else { return Integer . parseInt ( data ) ; } }
tr	9X	public String SimplifyPath ( String path ) { if ( path == null || path . length ( ) == 0 ) return null ; if ( path . charAt ( 0 ) != / ) return path ; List < String > buf = new ArrayList < String > ( ) ; int pathLen = path . length ( ) ; int start = 0 ; int end ; while ( true ) { while ( start < pathLen && path . charAt ( start ) == / ) start ++ ; if ( start == pathLen ) break ; for ( end = start ; end < pathLen ; end ++ ) { if ( path . charAt ( end ) == / ) break ; } String curr = path . substring ( start , end ) ; if ( curr . equals ( "." ) ) { } else if ( curr . equals ( ".." ) ) { if ( buf . size ( ) > 0 ) buf . remove ( buf . size ( ) - 1 ) ; } else { buf . add ( curr ) ; } start = end ; } if ( buf . size ( ) == 0 ) return "/" ; else { StringBuilder builder = new StringBuilder ( ) ; for ( String dir : buf ) { builder . append ( / ) ; builder . append ( dir ) ; } return builder . toString ( ) ; } }
tr	4	@ Override public void run ( GameManager gameManager , Game ata , MessageInfo msgInfo , List < Message > responses ) { responses . add ( MSG ( msgInfo . ROOM , msgInfo . NICK + " has been marked as away.  Use !back to rejoin." ) ) ; Name name = gameManager . m_nickToNameMap . get ( msgInfo . NICK ) ; ata . m_activePlayers . remove ( name ) ; if ( ata . m_activePlayers . size ( ) < 3 ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botendgame " + msgInfo . ROOM ) ) ; } if ( ata . m_judge . equals ( msgInfo . NICK ) ) { ata . m_state = State . LOCK ; responses . add ( MSG ( gameManager . getName ( ) , "!botcleanup " + msgInfo . ROOM ) ) ; } else if ( ata . m_state == State . PLAY ) { ata . m_waiting . remove ( name ) ; if ( ata . m_waiting . size ( ) == 0 ) { ata . m_waiting . remove ( name ) ; responses . add ( MSG ( gameManager . getName ( ) , "!botchoose " + msgInfo . ROOM ) ) ; } } }
tr	3	public JSONArray toJSONArray ( JSONArray names ) throws JSONException { if ( names == null || names . length ( ) == 0 ) { return null ; } JSONArray ja = new JSONArray ( ) ; for ( int i = 0 ; i < names . length ( ) ; i += 1 ) { ja . put ( this . opt ( names . getString ( i ) ) ) ; } return ja ; }
tr	8	public boolean equals ( consultar_result that ) { if ( that == null ) return false ; boolean this_present_success = true && this . isSetSuccess ( ) ; boolean that_present_success = true && that . isSetSuccess ( ) ; if ( this_present_success || that_present_success ) { if ( ! ( this_present_success && that_present_success ) ) return false ; if ( ! this . success . equals ( that . success ) ) return false ; } return true ; }
tr	6	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
tr	5	@ Override public void remove ( int index ) { if ( index < 0 || _lenght <= index ) { if ( 0 == _lenght ) { return ; } throw new IndexOutOfBoundsException ( "No se puede remover el dato \n " + "pues esta fuera de los limites de la lista" ) ; } else if ( index == 0 ) { removeFirst ( ) ; } else if ( index == _lenght - 1 ) { removeLast ( ) ; } else { Node < E > tmp = getIndex ( index - 1 ) ; tmp . setNext ( tmp . getNext ( ) . getNext ( ) ) ; _lenght -- ; } }
tr	1	public < T > T getInstance ( class < T > c , String [ ] args ) throws Exception { AnnotatedConstructor ctor = ctors . get ( c ) ; AnnotatedCLI . ParsedCLI cli = parse ( args ) ; T obj ; if ( ctor != null ) { obj = ( T ) ctor . newInstance ( cli ) ; } else { obj = ( T ) c . newInstance ( ) ; } cli . inject ( obj ) ; return obj ; }
tr	8	@ Override public Object cresciDinosauro ( String token , String idDinosauro ) { try { if ( myLogica . isMioTurno ( token ) ) { if ( myLogica . doCresciDinosauro ( token , idDinosauro ) ) { return "@ok" ; } return "@no @idNonValido" ; } else return "@no @nonIlTuoTurno" ; } catch ( InvalidTokenException e ) { return returnInvalidToken ( ) ; } catch ( NonInPartitaException e ) { return "@no @nonInPartita" ; } catch ( GenericDinosauroException e ) { if ( e . getMessage ( ) . equals ( "mortePerInedia" ) ) return "@no @mortePerInedia" ; if ( e . getMessage ( ) . equals ( "raggiuntaDimensioneMax" ) ) return "@no @raggiuntaDimensioneMax" ; if ( e . getMessage ( ) . equals ( "raggiuntoLimiteMosseDinosauro" ) ) return "@no @raggiuntoLimiteMosseDinosauro" ; } return "@no" ; }
tr	9X	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { request . setCharacterEncoding ( "utf-8" ) ; response . setContentType ( "text/xml;charset=UTF-8" ) ; String pillName = request . getParameter ( "pillName" ) ; String pillNum = request . getParameter ( "pillNum" ) ; String pillId = request . getParameter ( "pillId" ) ; String standard = request . getParameter ( "standard" ) ; String price = request . getParameter ( "price" ) ; String number = request . getParameter ( "number" ) ; String pillType = request . getParameter ( "pillType" ) ; double priceo = 0.00 ; int numbero = 0 ; infoReg ptreg = new infoReg ( ) ; boolean result = false ; if ( pillNum == null || pillNum . equals ( "" ) ) { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillInsert ( pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } else { if ( price == null || price . equals ( "" ) ) { } else { priceo = double . parseDouble ( request . getParameter ( "price" ) ) ; } if ( number == null || number . equals ( "" ) ) { } else { numbero = Integer . parseInt ( request . getParameter ( "number" ) ) ; } result = ptreg . pillUpdate ( pillNum , pillName , standard , priceo , numbero , pillId , pillType ) ; PrintWriter out = response . getWriter ( ) ; if ( result ) { response . sendRedirect ( request . getContextPath ( ) + "/infoSearch/commonSearch/pillSearch.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } } }
tr	7	public void keyPressed ( KeyEvent keyEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( shouldHandleKeys ) { if ( comp . shouldHandleKeys ( ) ) comp . keyPressed ( keyEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceKeys ( ) ) component . keyPressed ( keyEvent ) ; } else if ( comp . forceKeys ( ) ) comp . keyPressed ( keyEvent ) ; } } }
tr	9X	public Map < String , Object > toConfigurationNode ( ) { Map < String , Object > output = new LinkedHashMap < String , Object > ( ) ; output . put ( "group" , group ) ; if ( subgroups != null && subgroups . size ( ) != 0 ) { output . put ( "subgroups" , subgroups ) ; } if ( permissions != null && permissions . size ( ) != 0 ) { Map < String , List < String >> tmp = new LinkedHashMap < String , List < String >> ( ) ; for ( String world : permissions . keySet ( ) ) { tmp . put ( world , internalFormatToFile ( permissions . get ( world ) ) ) ; } output . put ( "permissions" , tmp ) ; } if ( info != null && info . size ( ) != 0 ) { output . put ( "info" , info ) ; } if ( globalPermissions != null && globalPermissions . size ( ) != 0 ) { output . put ( "globalpermissions" , internalFormatToFile ( globalPermissions ) ) ; } return output ; }
tr	5	@ Override public int hashCode ( ) { int result = iduser ; result = 31 * result + ( firstName != null ? firstName . hashCode ( ) : 0 ) ; result = 31 * result + ( lastName != null ? lastName . hashCode ( ) : 0 ) ; result = 31 * result + ( email != null ? email . hashCode ( ) : 0 ) ; result = 31 * result + ( password != null ? password . hashCode ( ) : 0 ) ; result = 31 * result + ( activateKey != null ? activateKey . hashCode ( ) : 0 ) ; return result ; }
tr	1	public List < MessageVO > getMessageVOs ( ) { if ( messageVOs == null ) { messageVOs = new ArrayList < MessageVO > ( ) ; } return this . messageVOs ; }
tr	2	public void initNew ( ) { if ( aDataMap == null ) aDataMap = new HashMap < ASection , AData > ( ) ; else aDataMap . clear ( ) ; try { this . replace ( 0 , getLength ( ) , "" , defaultStyle ) ; } catch ( BadLocationException e ) { System . out . println ( "Error in ADocument.initNew() :\n" ) ; e . printStackTrace ( ) ; } putProperty ( ( Object ) TitleProperty , ( Object ) DEFAULT_TITLE ) ; putProperty ( ( Object ) ExpertProperty , ( Object ) "" ) ; putProperty ( ( Object ) ClientProperty , ( Object ) "" ) ; Date date = new Date ( ) ; putProperty ( ( Object ) DateProperty , ( Object ) date . toLocaleString ( ) ) ; putProperty ( ( Object ) CommentProperty , "" ) ; setCharacterAttributes ( 0 , 1 , defaultStyle , true ) ; fireADocumentChanged ( ) ; Analyst . initUndoManager ( ) ; }
tr	1	protected String [ ] getFontStyleNames ( ) { if ( fontStyleNames == null ) { int i = 0 ; fontStyleNames = new String [ 4 ] ; fontStyleNames [ i ++ ] = ( "Plain" ) ; fontStyleNames [ i ++ ] = ( "Bold" ) ; fontStyleNames [ i ++ ] = ( "Italic" ) ; fontStyleNames [ i ++ ] = ( "BoldItalic" ) ; } return fontStyleNames ; }
tr	9X	public void checkCollisionsWithEnemies ( ArrayList < Enemy > list , Level1State state ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { double w = .5 * ( list . get ( i ) . getCWidth ( ) + getWidth ( ) ) ; double h = .5 * ( list . get ( i ) . getCHeight ( ) + getHeight ( ) ) ; double dx = list . get ( i ) . getCCenterX ( ) - getCenterX ( ) ; double dy = list . get ( i ) . getCCenterY ( ) - getCenterY ( ) ; if ( Math . abs ( dx ) <= w && Math . abs ( dy ) <= h ) { boolean hack = false ; double wy = w * dy ; double hx = h * dx ; if ( wy > hx ) { if ( wy > - hx ) { if ( list . get ( i ) . getKilledByTop ( ) ) { hack = true ; if ( list . get ( i ) . hit ( state . getPlayerState ( ) , this ) ) { } } else hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } else { if ( wy > - hx ) { if ( ! hack ) hit ( ) ; } else { if ( ! hack ) hit ( ) ; } } } } }
tr	3	@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { PlayXMLEnum playXMLEnum = PlayXMLEnum . valueOf ( qName . toUpperCase ( ) ) ; if ( playXMLEnum == PlayXMLEnum . DATE ) { int curId ; synchronized ( XMLPlaysHandler . class ) { curId = ++ dateId ; } currentPlay . addDate ( curId , parseTime ( currPlayDate ) ) ; } else if ( playXMLEnum == PlayXMLEnum . PLAY ) { addPlay ( currentPlay ) ; } else if ( playXMLEnum == PlayXMLEnum . DESCRIPTION ) { currentPlay . setDescription ( currentDesc . toString ( ) ) ; } currPlayEnum = null ; }
tr	0	public char nextChar ( ) { return ( char ) ( next ( 16 ) ) ; }
tr	4	public static void main ( String [ ] args ) { Conn con = PoolManager . getInstance ( ) . getConnection ( ) ; Connection conn = con . getConn ( ) ; Statement stmt = null ; ResultSet rs = null ; try { stmt = conn . createStatement ( ) ; rs = stmt . executeQuery ( "select * from article " ) ; int c = rs . getMetaData ( ) . getColumnCount ( ) ; for ( int i = 1 ; i <= c ; ++ i ) { System . out . println ( rs . getMetaData ( ) . getColumnName ( i ) ) ; } while ( rs . next ( ) ) { System . out . print ( rs . getString ( "title" ) ) ; System . out . print ( rs . getString ( "author" ) ) ; System . out . println ( ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } finally { try { stmt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } PoolManager . getInstance ( ) . releaseConnection ( con ) ; } }
tr	0	public int delete ( int id ) { String SQL1 = "DELETE FROM sig_reserves where id=" + id ; int nup = client . getMysql ( ) . executeUpdate ( SQL1 ) ; return nup ; }
tr	4	public static String readAsString ( File file ) { final long length = file . length ( ) ; final byte [ ] bytes = new byte [ ( int ) length ] ; InputStream is = null ; try { is = new FileInputStream ( file ) ; is . read ( bytes ) ; } catch ( IOException e ) { } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException ex ) { return null ; } } try { return new String ( bytes , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { return null ; } }
tr	4	@ Override public IBSTree < T > delete ( T value ) { BSTree < T > parent = null ; BSTree < T > curr = this ; for ( int cmp = value . compareTo ( curr . data ) ; cmp != 0 ; cmp = value . compareTo ( curr . data ) ) { if ( cmp < 0 ) { if ( curr . left == null ) { return null ; } parent = curr ; curr = curr . getTypedLeft ( ) ; } else { if ( curr . right == null ) { return null ; } parent = curr ; curr = curr . getTypedRight ( ) ; } } return curr . delete ( parent ) ; }
tr	1	@ Override public void propertyChange ( PropertyChangeEvent evt ) { setModelProperty ( evt . getPropertyName ( ) , evt . getNewValue ( ) ) ; for ( AbstractPageView view : registeredViews ) { view . modelPropertyChange ( evt ) ; } }
tr	0	public static ByteBuffer stringToBuffer ( int id ) { String s = Integer . valueOf ( id ) . toString ( ) ; return stringToBuffer ( s ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof DescribeComponentsResult == false ) return false ; DescribeComponentsResult other = ( DescribeComponentsResult ) obj ; if ( other . getComponentInfos ( ) == null ^ this . getComponentInfos ( ) == null ) return false ; if ( other . getComponentInfos ( ) != null && other . getComponentInfos ( ) . equals ( this . getComponentInfos ( ) ) == false ) return false ; return true ; }
tr	5	public void update ( UTypePk pk , UType dto ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_UPDATE + " with DTO: " + dto ) ; } stmt = conn . prepareStatement ( SQL_UPDATE ) ; int index = 1 ; stmt . setString ( index ++ , dto . getUType ( ) ) ; stmt . setString ( 2 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; reset ( dto ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	2	static float fromdBlook ( float a ) { int i = ( int ) ( a * ( ( float ) ( - ( 1 << FROMdB2_SHIFT ) ) ) ) ; return ( i < 0 ) ? 1.f : ( ( i >= ( FROMdB_LOOKUP_SZ << FROMdB_SHIFT ) ) ? 0.f : FROMdB_LOOKUP [ i >>> FROMdB_SHIFT ] * FROMdB2_LOOKUP [ i & FROMdB2_MASK ] ) ; }
tr	1	public void drawPoint ( Vertex vertex ) { init ( ) ; double x = vertex . getPoint ( ) . getX ( ) * SCALE_X ; double y = vertex . getPoint ( ) . getY ( ) * SCALE_Y ; Ellipse2D el = new Ellipse2D . double ( x - pointSize / 2. , y - pointSize / 2. , pointSize , pointSize ) ; ensureHasSize ( el . getBounds2D ( ) ) ; Graphics2D g = getGraphicsObject ( ) ; g . setStroke ( new BasicStroke ( ( float ) penSize ) ) ; g . setColor ( penColor ) ; g . setColor ( pointFill ) ; g . fill ( el ) ; g . setColor ( pointBorder ) ; g . draw ( el ) ; if ( showVertexNumbers ) g . drawString ( "" + vertex . getVertexIndex ( ) , ( float ) x - 5 , ( float ) y + 5 ) ; repaint ( ) ; }
tr	4	public String getKeterangan ( ) { char idx = getIndex ( ) ; switch ( idx ) { case A : return "Sangat Baik" ; case B : return "Baik" ; case C : return "Cukup" ; case D : return "Kurang" ; default : return "Sangat Kurang" ; } }
tr	8	protected boolean getPolyOrientation ( ) { if ( vertices . size ( ) < 3 ) return true ; int index = 0 ; IColumnVector < float > currentPoint = vertices . get ( 0 ) ; for ( int i = 1 ; i < vertices . size ( ) ; i ++ ) { if ( vertices . get ( i ) . get ( 0 , 0 ) < currentPoint . get ( 0 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } else if ( vertices . get ( i ) . get ( 0 , 0 ) == currentPoint . get ( 0 , 0 ) && vertices . get ( i ) . get ( 1 , 0 ) > currentPoint . get ( 1 , 0 ) ) { currentPoint = vertices . get ( i ) ; index = i ; } } final IColumnVector < float > previousPoint = ( index == 0 ) ? vertices . get ( vertices . size ( ) - 1 ) : vertices . get ( index - 1 ) ; final IColumnVector < float > v1 = new ColumnVector ( currentPoint . get ( 0 , 0 ) - previousPoint . get ( 0 , 0 ) , currentPoint . get ( 1 , 0 ) - previousPoint . get ( 1 , 0 ) ) ; final IColumnVector < float > nextPoint = ( index == vertices . size ( ) - 1 ) ? vertices . get ( 0 ) : vertices . get ( index + 1 ) ; final float result = nextPoint . get ( 0 , 0 ) * v1 . get ( 1 , 0 ) - nextPoint . get ( 1 , 0 ) * v1 . get ( 0 , 0 ) + v1 . get ( 0 , 0 ) * previousPoint . get ( 1 , 0 ) - v1 . get ( 1 , 0 ) * previousPoint . get ( 0 , 0 ) ; return ( result <= 0 ? true : false ) ; }
tr	0	public Tela_Usuario_Cadastro ( ) { initComponents ( ) ; }
tr	6	private void method130 ( int j , int k , int l , int i1 , int j1 , int k1 , int l1 , int i2 , int j2 ) { Class30_Sub1 class30_sub1 = null ; for ( Class30_Sub1 class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetFirst ( ) ; class30_sub1_1 != null ; class30_sub1_1 = ( Class30_Sub1 ) aClass19_1179 . reverseGetNext ( ) ) { if ( class30_sub1_1 . anInt1295 != l1 || class30_sub1_1 . anInt1297 != i2 || class30_sub1_1 . anInt1298 != j1 || class30_sub1_1 . anInt1296 != i1 ) continue ; class30_sub1 = class30_sub1_1 ; break ; } if ( class30_sub1 == null ) { class30_sub1 = new Class30_Sub1 ( ) ; class30_sub1 . anInt1295 = l1 ; class30_sub1 . anInt1296 = i1 ; class30_sub1 . anInt1297 = i2 ; class30_sub1 . anInt1298 = j1 ; method89 ( class30_sub1 ) ; aClass19_1179 . insertHead ( class30_sub1 ) ; } class30_sub1 . anInt1291 = k ; class30_sub1 . anInt1293 = k1 ; class30_sub1 . anInt1292 = l ; class30_sub1 . anInt1302 = j2 ; class30_sub1 . anInt1294 = j ; }
tr	7	public String dTDetailSearch ( String id ) { String docName = "" ; String docTellContent = "" ; String excuteDate = "" ; String stopDate = "" ; String docTellStatus = "" ; String docTellType = "" ; String sd = "" ; String pn = "" ; String str = "select u.user_name dt.doc_tell_content dt.excute_date dt.stop_date dt.doc_tell_type dt.doc_tell_status from doc_tell dt user u where dt.id='" + id + "' and dt.doc_id=u.user_id;" ; System . out . println ( "docTellDetailSearch_______________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; while ( num . next ( ) ) { excuteDate = num . getString ( "excute_date" ) ; stopDate = num . getString ( "stop_date" ) ; docName = num . getString ( "user_name" ) ; docTellStatus = num . getString ( "doc_tell_status" ) ; docTellType = num . getString ( "doc_tell_type" ) ; docTellContent = num . getString ( "doc_tell_content" ) ; sb . append ( " <tr><input type=\"text\" value=\"<%=session.getAttribute('userId') %>\" style=\"display:none\" id=\"excuteId\"/><input type=\"text\" value=\"" + id + "\" id=\"id\" style=\"display:none\"/> <td>\u4E3B\u6CBB\u533B\u751F:" + docName + "</td>  <td>\u4F5C\u7528\u65F6\u95F4:" + excuteDate + "~" + stopDate + "</td> </tr>" ) ; sb . append ( "<tr> <td colspan=\"2\">\u533B\u5631\u5185\u5BB9\uFF1A <textarea readonly rows=\"6\" cols=\"80\" name=\"docTellContent\" id=\"docTellContent\" onpropertychange=\"if(this.scrollHeight>80) this.style.posHeight=this.scrollHeight+5\">" + docTellContent + "</textarea></td> </tr><td colspan=\"2\">" ) ; if ( docTellType . equals ( "1" ) ) { switch ( Integer . parseInt ( docTellStatus ) ) { case 1 : sb . append ( "<input type=button  id=\"nurseCheck\" onclick=\"save(2)\" value=\"\u62A4\u58EB\u6821\u5BF9\" class=\"btn blue\"/>" ) ; break ; case 2 : sb . append ( "<input type=button id=\"docStop\"  onclick=\"save(3)\" value=\"\u505C\u6B62\u533B\u5631\"  class=\"btn blue\"/>" ) ; break ; case 3 : sb . append ( "<input type=button  id=\"nurseConfirm\" onclick=\"save(4)\"  value=\"\u62A4\u58EB\u786E\u8BA4\"   class=\"btn blue\"/>" ) ; break ; } } else if ( docTellType . equals ( "2" ) ) { sb . append ( "<input type=button  id=\"nurseConfirm\"  value=\"\u62A4\u58EB\u786E\u8BA4\" onclick=\"save(4)\"  class=\"btn blue\"/>" ) ; } sb . append ( "</td>  </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
tr	0	public int getPeopleOnStation ( ) { return peopleOnStation ; }
tr	2	public Image getImage ( URL url ) { try { Object content = url . getContent ( ) ; if ( content instanceof ImageProducer ) { return applet . createImage ( ( ImageProducer ) content ) ; } } catch ( IOException ex ) { } return null ; }
tr	1	public void set_wheelchair_boarding ( String in ) { try { _wheelchair_boarding = Integer . parseInt ( in ) ; } catch ( NumberFormatException e ) { ; } }
tr	0	public Prenotazione ( ) { super ( ) ; }
tr	1	public String toString ( ) { StringBuilder out = new StringBuilder ( ) ; for ( ArrayPlace arrayPlace : arrayPlaces ) out . append ( arrayPlace ) . append ( "=" ) ; out . append ( expression ) ; return out . toString ( ) ; }
tr	8	public void decode ( InputStream stream , int length , CharBuffer buffer ) throws IllegalArgumentException , IOException { if ( stream == null ) throw new IllegalArgumentException ( "stream cannot be null" ) ; if ( length < 0 ) throw new IllegalArgumentException ( "length [" + length + "] must be >= 0." ) ; if ( buffer == null ) throw new IllegalArgumentException ( "buffer cannot be null and must be a CharBuffer with a large enough capacity to hold at least 'length' (" + length + ") characters." ) ; if ( length > buffer . capacity ( ) ) throw new IllegalArgumentException ( "length [" + length + "] is larger than the capacity [" + buffer . capacity ( ) + "] of the given buffer; the CharBuffer must be big enough to contain all the characters decoded from the given InputStream." ) ; if ( length == 0 ) buffer . clear ( ) ; else { bBuffer . clear ( ) ; buffer . clear ( ) ; decoder . reset ( ) ; int read = 0 ; while ( length > 0 && ( read = stream . read ( rBuffer , 0 , length ) ) != - 1 ) { length -= read ; bBuffer . position ( 0 ) ; bBuffer . limit ( read ) ; decoder . decode ( bBuffer , buffer , ( length == 0 ) ) ; } if ( length > 0 ) throw new IOException ( "End of Stream encountered before all requested bytes [" + ( length + read ) + "] could be read. Unable to read the last " + length + " remaining bytes." ) ; decoder . flush ( buffer ) ; } }
tr	0	public void updateRhythm ( boolean r , boolean b , boolean bp , boolean n , boolean c , boolean s , boolean t ) { this . whole = r ; this . half = b ; this . dottedhalf = bp ; this . quarter = n ; this . eighth = c ; this . silence = s ; this . triplet = t ; }
tr	3	public boolean matches ( KeyComponent other , Map < String , Object > bindings ) { List < KeyComponent > keyComponents = ( ( CompositeComponent ) other ) . components ; List < KeyComponent > ruleComponents = this . components ; if ( keyComponents . size ( ) != ruleComponents . size ( ) ) { return false ; } for ( int i = 0 ; i < keyComponents . size ( ) ; i ++ ) { if ( ! ruleComponents . get ( i ) . matches ( keyComponents . get ( i ) , bindings ) ) { return false ; } } return true ; }
tr	7	private JPanel createFillInTheBlanksQuestion ( ) { _questionLabel . setText ( _fillInTheBlanks . getAnswer ( ) ) ; final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _optionsStrings = _fillInTheBlanks . getBlanks ( ) ; final int [ ] randomList = MathUtilities . generateRandomArray ( _optionsStrings . size ( ) ) ; _answers = new ArrayList < String > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final String value = _optionsStrings . get ( randomList [ x ] ) ; _answers . add ( _optionsStrings . get ( _optionsStrings . indexOf ( value ) ) ) ; } _optionComboBoxes = new ArrayList < JComboBox > ( ) ; for ( int x = 0 ; x < _optionsStrings . size ( ) ; x ++ ) { final JLabel label = new JLabel ( "Choose #" ) ; final String choice = _optionsStrings . get ( randomList [ x ] ) . toLowerCase ( ) ; springLayout . putConstraint ( SpringLayout . WEST , label , 15 , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , label , 45 + x * 35 , SpringLayout . NORTH , jPanel ) ; jPanel . add ( label ) ; Object [ ] choices = new Object [ _optionsStrings . size ( ) + 1 ] ; choices [ 0 ] = "--" ; for ( int y = 0 ; y < choices . length - 1 ; y ++ ) { choices [ y + 1 ] = "[" + y + "]" ; } final JComboBox combobox = new JComboBox ( choices ) ; springLayout . putConstraint ( SpringLayout . WEST , combobox , 10 , SpringLayout . EAST , label ) ; springLayout . putConstraint ( SpringLayout . NORTH , combobox , - 20 , SpringLayout . SOUTH , label ) ; _optionComboBoxes . add ( combobox ) ; combobox . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( final ActionEvent arg0 ) { String question = "" ; if ( _choicesMade . containsKey ( choice ) ) { _choicesMade . remove ( choice ) ; } String begin = "Question #" + new Integer ( _questionData . getQuestionNumber ( ) ) . toString ( ) + ": " ; question = begin + _questionData . getQuestionString ( ) ; final Set < String > keys = _choicesMade . keySet ( ) ; for ( final String key : keys ) { question = replace ( _choicesMade . get ( key ) , question , key ) ; } final int indexToLookFor = combobox . getSelectedIndex ( ) - 1 ; if ( indexToLookFor >= 0 ) { _choicesMade . put ( choice , "[" + indexToLookFor + "]" ) ; question = replace ( "[" + indexToLookFor + "]" , question , choice ) ; } _beginLabel . setText ( question ) ; } private String replace ( final String needle , final String haystack , final String newNeedle ) { String result = haystack ; while ( result . indexOf ( needle ) != - 1 ) { result = result . replace ( needle , newNeedle ) ; } return result ; } } ) ; jPanel . add ( combobox ) ; final JLabel option = new JLabel ( choice ) ; springLayout . putConstraint ( SpringLayout . WEST , option , 10 , SpringLayout . EAST , combobox ) ; springLayout . putConstraint ( SpringLayout . NORTH , option , 1 , SpringLayout . NORTH , combobox ) ; jPanel . add ( option ) ; } final JLabel temp = new JLabel ( ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , 600 , SpringLayout . WEST , temp ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , 250 , SpringLayout . SOUTH , temp ) ; jPanel . setOpaque ( true ) ; return jPanel ; }
tr	8	@ Before public void setUp ( ) throws Exception { mapa = new boolean [ 60 ] [ 60 ] ; for ( int i = 0 ; i < 60 ; i ++ ) { for ( int j = 0 ; j < 60 ; j ++ ) mapa [ i ] [ j ] = false ; } for ( int i = 19 ; i <= 31 ; i ++ ) { for ( int j = 35 ; j <= 51 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 7 ; i <= 15 ; i ++ ) { for ( int j = 15 ; j <= 23 ; j ++ ) mapa [ j ] [ i ] = true ; } for ( int i = 34 ; i <= 46 ; i ++ ) { for ( int j = 19 ; j <= 27 ; j ++ ) mapa [ j ] [ i ] = true ; } }
tr	7	public static String extractTitleFrom ( String filePath ) { String title = null ; try { Mp3File mp3File = new Mp3File ( filePath ) ; if ( mp3File . hasId3v2Tag ( ) ) { ID3v2 id3v2Tag = mp3File . getId3v2Tag ( ) ; title = id3v2Tag . getTitle ( ) ; } else if ( mp3File . hasId3v1Tag ( ) ) { ID3v1 id3v1Tag = mp3File . getId3v1Tag ( ) ; title = id3v1Tag . getTitle ( ) ; } } catch ( UnsupportedTagException e ) { e . printStackTrace ( ) ; } catch ( InvalidDataException e ) { System . out . print ( "Invalid Data" ) ; return " - Unknown Title" ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( title == null ) { int lastSlash = filePath . lastIndexOf ( \ ) ; if ( filePath . lastIndexOf ( / ) > lastSlash ) lastSlash = filePath . lastIndexOf ( / ) ; title = filePath . substring ( lastSlash + 1 ) . replaceAll ( "\\.mp3$" , "" ) ; } return title ; }
tr	6	private void createUnits ( ) { ArrayList < Building > buildings = g . map . getPlayersBuildings ( this ) ; boolean hasMoney = true ; while ( hasMoney ) { for ( Building building : buildings ) { if ( building instanceof Factory ) { ( ( Factory ) building ) . recruitTank ( g . map , building . getCell ( ) , true ) ; } if ( building instanceof Barracks ) { ( ( Barracks ) building ) . recruitMarine ( g . map , building . getCell ( ) , true ) ; } } if ( buildings . contains ( Barracks . class ) ) { hasMoney = this . getMoney ( ) >= Marine . cost ; } else if ( buildings . contains ( Factory . class ) ) { hasMoney = this . getMoney ( ) >= Tank . cost ; } else { hasMoney = false ; } } }
tr	2	private boolean isPreconditionsFilled ( Path absFilePath ) { if ( ! canWriteSelectedFile ( absFilePath ) ) { return false ; } if ( ! canWriteWithDefaultOriginalClassConstructor ( ) ) { return false ; } return true ; }
tr	4	static void createNewPearltree ( Panel panel , boolean active ) { final Label item = createLabel ( ) ; final FlowPanel description = new FlowPanel ( ) ; item . setText ( "a new pearltree" ) ; if ( WebContent . onIpad ) { description . setStylePrimaryName ( PRIMARY_STYLE_NEWPEARLTREE ) ; panel . add ( description ) ; HTML newPearltreeBox = PopupElements . createHtml ( ) ; newPearltreeBox . setStylePrimaryName ( PopupElements . PRIMARY_STYLE_AVATARBOX ) ; newPearltreeBox . addStyleDependentName ( PopupElements . STYLE_SPECIAL_PADDING ) ; newPearltreeBox . setHTML ( NEW_PEARLTREE ) ; description . add ( newPearltreeBox ) ; description . add ( item ) ; } else { panel . add ( item ) ; } if ( ! WebContent . onIpad ) { item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_BOLD ) ; item . addStyleDependentName ( STYLE_PADDING ) ; } item . addStyleDependentName ( STYLE_SELECTABLE ) ; item . addStyleDependentName ( STYLE_ITEM ) ; if ( active ) { item . addClickHandler ( new ClickHandler ( ) { @ Override public void onClick ( ClickEvent event ) { if ( WebContent . onIpad ) { description . addStyleDependentName ( STYLE_SELECTED_TIMER ) ; Timer t = new Timer ( ) { @ Override public void run ( ) { DOM . removeElementAttribute ( TreeListUI . panelInside . getElement ( ) , "id" ) ; PopupControl . changeUI ( PopupUIs . NewTree ) ; } } ; t . schedule ( 120 ) ; } else { PopupControl . changeUI ( PopupUIs . NewTree ) ; } } } ) ; } else { item . addStyleDependentName ( STYLE_INACTIVE ) ; } }
tr	0	public int getLineNumber ( ) { return TokenStream . this . getLineNumber ( beg ) ; }
tr	4	public void update ( final Observable obj , final Object arg ) { final String line = ( String ) arg ; final int startOfTag = line . indexOf (   ) + 1 ; final int endOfTag = line . indexOf (   , startOfTag + 1 ) ; if ( startOfTag < 1 || endOfTag < 1 ) { return ; } final String strTimeTag = line . substring ( startOfTag , endOfTag ) ; try { final double timeLong = double . parseDouble ( strTimeTag ) ; final Date timeTag = new Date ( ( long ) timeLong . doubleValue ( ) * 1000 ) ; if ( timeTag . getTime ( ) > lastSeen . getTime ( ) ) { lastSeen = timeTag ; parent . setLastDateTag ( dataVisualizer . format ( lastSeen ) ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	4	public void render ( Graphics g ) { i ++ ; if ( i >= 8 ) { animationStep ++ ; animationStep %= 9 ; image = sheet . getSprite ( "monster_0" + animationStep + ".png" ) ; if ( getDirectionDroite ( ) ) { image = image . getFlippedCopy ( true , false ) ; } i = 0 ; } if ( toucherDmg ) { image . setAlpha ( 0.001f ) ; if ( i >= 5 ) { image . setAlpha ( 1.f ) ; toucherDmg = false ; } } image . drawCentered ( getX ( ) , getY ( ) ) ; renderVie ( g ) ; }
tr	8	public boolean stateEquals ( Object o ) { if ( o == this ) return true ; if ( o == null || ! ( o instanceof MersenneTwister ) ) return false ; MersenneTwister other = ( MersenneTwister ) o ; if ( mti != other . mti ) return false ; for ( int x = 0 ; x < mag01 . length ; x ++ ) if ( mag01 [ x ] != other . mag01 [ x ] ) return false ; for ( int x = 0 ; x < mt . length ; x ++ ) if ( mt [ x ] != other . mt [ x ] ) return false ; return true ; }
tr	7	private String [ ] getStringArray ( JComponent comp ) { if ( comp instanceof JComboBox ) { JComboBox comboBox = ( JComboBox ) comp ; List < String > list = new ArrayList < String > ( ) ; if ( comboBox . getItemCount ( ) > 0 ) { for ( int i = 0 ; i < comboBox . getItemCount ( ) ; i ++ ) { if ( ! isEmpty ( comboBox . getItemAt ( i ) ) ) { add ( list , comboBox . getItemAt ( i ) ) ; } else if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; } } if ( list . size ( ) > 0 ) { return list . toArray ( new String [ 1 ] ) ; } else { return null ; } } else { if ( ! isEmpty ( comboBox . getSelectedItem ( ) ) ) { add ( list , comboBox . getSelectedItem ( ) ) ; return list . toArray ( new String [ 1 ] ) ; } } } return null ; }
tr	7	public DraftGenerator ( ) { setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; setBounds ( 100 , 100 , 450 , 399 ) ; contentPane = new JPanel ( ) ; contentPane . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; setContentPane ( contentPane ) ; contentPane . setLayout ( null ) ; JLabel lblChooseTheDraft = new JLabel ( "Choose the draft file" ) ; lblChooseTheDraft . setBounds ( 38 , 26 , 175 , 16 ) ; contentPane . add ( lblChooseTheDraft ) ; addressText = new JTextField ( ) ; addressText . setBounds ( 38 , 62 , 218 , 28 ) ; contentPane . add ( addressText ) ; addressText . setColumns ( 10 ) ; JButton btnChoose = new JButton ( "Choose" ) ; btnChoose . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JFileChooser chooser = new JFileChooser ( ) ; FileNameExtensionFilter filter1 = new FileNameExtensionFilter ( "Text file" , "txt" ) ; chooser . addChoosableFileFilter ( filter1 ) ; chooser . setFileFilter ( filter1 ) ; int returnVal = chooser . showOpenDialog ( getParent ( ) ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { addressText . setText ( chooser . getSelectedFile ( ) . getPath ( ) ) ; } } } ) ; btnChoose . setBounds ( 291 , 63 , 117 , 29 ) ; contentPane . add ( btnChoose ) ; JButton btnGenerate = new JButton ( "Generate" ) ; btnGenerate . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String file = addressText . getText ( ) ; int x = 0 , y = 0 ; int length = 3000 ; int x_distance = 200 ; int y_distance = 150 ; String position = "{" + x + " " + y + "}" ; BufferedReader input ; try { input = new BufferedReader ( new FileReader ( file ) ) ; } catch ( FileNotFoundException e1 ) { JOptionPane . showMessageDialog ( getParent ( ) , "File is not found!" ) ; return ; } String line = "" ; String tag = "" ; String shape = "" ; String canvas = canvasText . getText ( ) ; String layer = layerText . getText ( ) ; try { while ( ( line = input . readLine ( ) ) != null ) { if ( line . startsWith ( "%" ) ) { tag = line . substring ( 1 ) ; continue ; } else if ( line . equals ( "" ) ) { continue ; } else { shape = InfoEnum . reverse_req_elem_type_map . get ( tag ) ; AppleScript . drawArbitraryRequirementElement ( canvas , layer , shape , InfoEnum . NORMAL_SIZE , position , "0" , line , "0" , "1" ) ; if ( x < length ) { x += x_distance ; } else { x = 0 ; y += y_distance ; } position = "{" + x + " " + y + "}" ; } } } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerate . setBounds ( 291 , 130 , 117 , 29 ) ; contentPane . add ( btnGenerate ) ; JLabel lblCanvas = new JLabel ( "Canvas" ) ; lblCanvas . setBounds ( 24 , 135 , 61 , 16 ) ; contentPane . add ( lblCanvas ) ; canvasText = new JTextField ( ) ; canvasText . setText ( "Test" ) ; canvasText . setBounds ( 79 , 130 , 77 , 28 ) ; contentPane . add ( canvasText ) ; canvasText . setColumns ( 10 ) ; JLabel lblLayer = new JLabel ( "Layer" ) ; lblLayer . setBounds ( 24 , 189 , 61 , 16 ) ; contentPane . add ( lblLayer ) ; layerText = new JTextField ( ) ; layerText . setText ( "none" ) ; layerText . setBounds ( 79 , 183 , 134 , 28 ) ; contentPane . add ( layerText ) ; layerText . setColumns ( 10 ) ; JLabel lblTargetAttackPattern = new JLabel ( "Target Attack Pattern" ) ; lblTargetAttackPattern . setBounds ( 38 , 294 , 156 , 16 ) ; contentPane . add ( lblTargetAttackPattern ) ; txtPatternid = new JTextField ( ) ; txtPatternid . setBounds ( 38 , 322 , 134 , 28 ) ; contentPane . add ( txtPatternid ) ; txtPatternid . setColumns ( 10 ) ; JButton btnGenerateTree = new JButton ( "Generate tree" ) ; btnGenerateTree . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { CAPECModelGeneration model = new CAPECModelGeneration ( ) ; model . generatePatternHierarchyModel ( txtPatternid . getText ( ) ) ; JOptionPane . showMessageDialog ( getParent ( ) , "Successfully generate graphs!" ) ; } } ) ; btnGenerateTree . setBounds ( 218 , 323 , 117 , 29 ) ; contentPane . add ( btnGenerateTree ) ; }
tr	0	public static void main ( String [ ] args ) { List < Integer > set = new ArrayList < > ( ) ; set . add ( - 7 ) ; set . add ( - 3 ) ; set . add ( - 2 ) ; set . add ( 5 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 0 ) ) ; set = new ArrayList < > ( ) ; set . add ( 2 ) ; set . add ( 3 ) ; set . add ( 6 ) ; set . add ( 8 ) ; System . out . println ( getSubsets ( set , 11 ) ) ; }
tr	7	@ Override public synchronized int registerClient ( String client_name , String first_tag , String second_tag ) { try { final NameComponent [ ] clientName = { new NameComponent ( client_name , "Object" ) } ; final Client client = ClientHelper . narrow ( namingContext . resolve ( clientName ) ) ; if ( first_tag . equals ( "T" ) || second_tag . equals ( "T" ) ) { clientUpdater . appendTemperatureClient ( client ) ; } if ( first_tag . equals ( "P" ) || second_tag . equals ( "P" ) ) { clientUpdater . appendPressureClient ( client ) ; } if ( first_tag . equals ( "H" ) || second_tag . equals ( "H" ) ) { clientUpdater . appendHumidityClient ( client ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return 0 ; }
tr	4	public Tile cross ( Tile currentTile , Character crosser ) { if ( crosser == null || currentTile == null ) { throw new IllegalArgumentException ( "currentTile and crosser cannot be null" ) ; } if ( ! crosser . equals ( currentTile . getCharacter ( ) ) ) { throw new IllegalArgumentException ( "The given character must be on the given tile" ) ; } if ( ! canCross ( crosser ) ) { throw new IllegalArgumentException ( "The given character is not capable of crossing this edge" ) ; } Tile destination = getOtherTile ( currentTile ) ; currentTile . removeCharacter ( ) ; destination . addCharacter ( crosser ) ; return destination ; }
tr	1	public void clearFeedback ( ) { for ( ValueSource vs : valueSources ) { vs . clearFeedback ( ) ; } }
tr	0	@ Override public PLType getType ( ) { return PLType . PLNull ; }
tr	6	@ Test public void testEncodingSchemeCompleteSerialisationVoice ( ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . MULAW_8 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 01 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/MuLaw-8 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . CVSD ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 02 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/CVSD Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . ADPCM ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 03 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/ADPCM Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . PCM_16 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 04 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/PCM-16 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . PCM_8 ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 05 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/PCM-8 Encoding Scheme record" , e ) ; } try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DISOutputStream dos = new DISOutputStream ( baos ) ; EncodingScheme scheme = new EncodingScheme ( ) ; scheme . setEncodingClass ( EncodingClass . ENCODED_VOICE ) ; scheme . setEncodingType ( EncodingType . VQ ) ; scheme . write ( dos ) ; byte [ ] asBytes = baos . toByteArray ( ) ; assert . assertEquals ( asBytes [ 0 ] , ( byte ) 00 ) ; assert . assertEquals ( asBytes [ 1 ] , ( byte ) 06 ) ; } catch ( Exception e ) { assert . fail ( "Unexpected exception while serialising a Voice/VQ Encoding Scheme record" , e ) ; } }
tr	3	public int maximum ( Node root ) { int root_val , left_val , right_val , max = Integer . MIN_VALUE ; if ( root != null ) { root_val = root . key ; left_val = maximum ( root . left ) ; right_val = maximum ( root . right ) ; if ( left_val > right_val ) max = left_val ; else max = - right_val ; if ( root_val > max ) max = root_val ; } return max ; }
tr	6	public byte [ ] readControl ( byte type , byte request , short value , short index , short length ) throws IOException { byte data [ ] = new byte [ length & ffff ] ; long status ; if ( length >= MAX_CONTROL_LENGTH || ( type & ControlMessage . DIR_TO_HOST ) == 0 ) throw new IllegalArgumentException ( ) ; if ( fd < 0 ) { throw new USBException ( "Dev.readControl aborted" , - USBException . IO_NotOpen ) ; } if ( MacOSX . trace ) System . out . println ( path + ": Dev.readControl  rqt 0x" + Integer . toHexString ( ff & type ) + "  req 0x" + Integer . toHexString ( ff & request ) + "  value 0x" + Integer . toHexString ( ffff & value ) + "  index 0x" + Integer . toHexString ( ffff & index ) + "  len " + Integer . toString ( ffff & length ) ) ; status = controlMsg ( fd , type , request , value , index , data , 0 , ( short ) data . length ) ; if ( status >= 0 ) { int length_when_done = ( int ) status ; if ( length_when_done != data . length ) { byte temp [ ] = new byte [ length_when_done ] ; System . arraycopy ( data , 0 , temp , 0 , length_when_done ) ; data = temp ; } return data ; } else throw new USBException ( "control read error" , ( int ) ( - status ) ) ; }
tr	7	public static ArrayList < String > from ( File f , boolean readBlanks ) { ArrayList < String > strings = new ArrayList < String > ( ) ; if ( ! f . exists ( ) ) { System . err . println ( "File " + f . getPath ( ) + " not found!" ) ; return strings ; } while ( true ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( f ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( "#" ) && ( ! line . isEmpty ( ) || readBlanks ) ) { strings . add ( line ) ; } } reader . close ( ) ; break ; } catch ( IOException e ) { System . err . println ( "Error reading file " + f . getName ( ) + ".... attempting Again" ) ; } } return strings ; }
tr	3	@ Override public void delete ( TypeAttribute typeAttribute ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . delete ( typeAttribute ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	7	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; xa = shell . facing * 2 ; ya = - 5 ; flyDeath = true ; if ( spriteTemplate != null ) spriteTemplate . isDead = true ; deadTime = 100 ; winged = false ; hPic = - hPic ; yPicO = - yPicO + 16 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	3	public int getPieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int count = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) || Draughts . isBlack ( piece ) ) { count ++ ; } } return count ; }
tr	5	public int getPerceptIndex ( String percept ) { if ( percept . equals ( SOLVED ) ) { return ( getPerceptsNumber ( ) - 1 ) ; } else { int [ ] values = new int [ 2 ] ; int k = 0 ; try { StreamTokenizer tokenizer = new StreamTokenizer ( new StringReader ( percept ) ) ; while ( k < 2 && tokenizer . nextToken ( ) != StreamTokenizer . TT_EOF ) { if ( tokenizer . ttype == StreamTokenizer . TT_NUMBER ) { values [ k ] = ( int ) ( tokenizer . nval ) ; k ++ ; } } return values [ 0 ] * DIGITS + values [ 1 ] ; } catch ( Exception e ) { return - 1 ; } } }
tr	8	private void method117 ( Stream stream ) { stream . initBitAccess ( ) ; int j = stream . readBits ( 1 ) ; if ( j == 0 ) return ; int k = stream . readBits ( 2 ) ; if ( k == 0 ) { anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 1 ) { int l = stream . readBits ( 3 ) ; myPlayer . moveInDir ( false , l ) ; int k1 = stream . readBits ( 1 ) ; if ( k1 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 2 ) { int i1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , i1 ) ; int l1 = stream . readBits ( 3 ) ; myPlayer . moveInDir ( true , l1 ) ; int j2 = stream . readBits ( 1 ) ; if ( j2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; return ; } if ( k == 3 ) { plane = stream . readBits ( 2 ) ; int j1 = stream . readBits ( 1 ) ; int i2 = stream . readBits ( 1 ) ; if ( i2 == 1 ) anIntArray894 [ anInt893 ++ ] = myPlayerIndex ; int k2 = stream . readBits ( 7 ) ; int l2 = stream . readBits ( 7 ) ; myPlayer . setPos ( l2 , k2 , j1 == 1 ) ; } }
tr	7	public static double doDefAbilityBasePowerMod ( ActivePokemon defender , Move move , double damage ) { if ( defender . hasAbility ( Ability . THICK_FAT ) && ( move . isType ( Type . ICE ) || move . isType ( Type . FIRE ) ) ) { damage *= 0.5 ; } else if ( defender . hasAbility ( Ability . HEATPROOF ) && move . isType ( Type . FIRE ) ) { damage *= 0.5 ; } else if ( defender . hasAbility ( Ability . DRY_SKIN ) && move . isType ( Type . FIRE ) ) { damage *= 1.25 ; } damage = ( int ) damage ; return damage ; }
tr	1	public Set < String > keySet ( ) { if ( mode == Mode . Map ) { return map . keySet ( ) ; } throw new PerlHashTypeException ( "Not a map" ) ; }
tr	8	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += 0 ; break ; case 1 : total += 100 ; break ; case 2 : total -= 100 ; break ; case 3 : total += 300 ; break ; case 4 : total -= 300 ; break ; case 5 : total += 0 ; break ; } } if ( ! white ) { total = - total ; } return total ; }
tr	7	@ Override public void notificarCicloFinalizado ( ) { Tablero tablero = this . vp . obtenerTablero ( ) ; GameLoop gameLoop = this . vp . obtenerGameLoop ( ) ; ArrayList < Barco > listaBarco = tablero . getDestruidos ( ) ; for ( Barco barco : listaBarco ) { for ( Parte parte : barco . getCuerpo ( ) ) { ObjetoDibujable vista = MapaDeVistasDePartes . get ( parte ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( parte ) ; } } } ArrayList < Disparo > listaDisparo = tablero . getDisparosDetonados ( ) ; for ( Disparo disparo : listaDisparo ) { ObjetoDibujable vista = MapaDeVistasDeDisparos . get ( disparo ) ; if ( vista != null ) { gameLoop . remover ( vista ) ; MapaDeVistasDePartes . remove ( disparo ) ; } } listaDisparo . clear ( ) ; this . vp . obtenerEtiquetaPuntaje ( ) . setText ( "Puntaje: " + tablero . getPuntos ( ) ) ; if ( tablero . estaPerdido ( ) ) { JOptionPane . showMessageDialog ( null , "Lamentablemente Usted Perdio" ) ; this . reiniciarTablero ( ) ; } else if ( tablero . estaGanado ( ) ) { JOptionPane . showMessageDialog ( null , "Gano!!!!" ) ; this . reiniciarTablero ( ) ; } }
tr	4	public void actionPerformed ( ActionEvent e ) { String login = principal . getLogin ( ) ; String senha = principal . getSenha ( ) ; LoginInterface loginInterface = new LoginInterface ( ) ; Funcionario funcionario = null ; try { funcionario = loginInterface . logarUsuario ( login , senha ) ; } catch ( SQLException ex ) { Logger . getLogger ( ButtonHandlerLogin . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } String respostaUsuario = "" ; if ( funcionario != null ) { if ( funcionario . getNivelAcesso ( ) ) { try { UsuarioLogado usuarioLogado = UsuarioLogado . getInstancia ( ) ; usuarioLogado . setUsuarioLogado ( funcionario ) ; OperacaoLog log = new OperacaoLog ( ) ; log . setData ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; log . setDescricao ( "Logon de Administrador: " + funcionario . getNome ( ) ) ; log . setFuncionario ( UsuarioLogado . getInstancia ( ) . getUsuarioLogado ( ) ) ; log . setOperacao ( "Logon de Administrador" ) ; OperacaoLogDao operacaoLogDao = new OperacaoLogDao ( ) ; operacaoLogDao . persiste ( log ) ; } catch ( SQLException ex ) { Logger . getLogger ( ButtonHandlerLogin . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } principal . dispose ( ) ; Administrador . main ( null ) ; } else { respostaUsuario = "Erro  acesso n\u00E3o permitido!" ; JOptionPane . showMessageDialog ( null , respostaUsuario ) ; } } else { respostaUsuario = "Erro  Credenciais inv\u00E1lidas!" ; JOptionPane . showMessageDialog ( null , respostaUsuario ) ; } e . getActionCommand ( ) ; }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandAusgang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	7	public void mousePress ( MouseEvent e , Canvas canvas , Palette p ) { if ( active != null ) { if ( e . getButton ( ) == button ) finish ( canvas , p ) ; else cancel ( canvas ) ; return ; } if ( ! isValid ( e , canvas , p ) ) return ; button = e . getButton ( ) ; mouseTime = e . getWhen ( ) ; Color c1 = p . getLeft ( ) ; Color c2 = p . getRight ( ) ; if ( button != MouseEvent . BUTTON1 ) { c1 = c2 ; c2 = p . getLeft ( ) ; } switch ( type ) { case OUTLINE : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , null ) ; break ; case BOTH : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c2 ) ; break ; case FILL : canvas . active = active = new RoundRectangleAction ( canvas , e . getPoint ( ) , c1 , c1 ) ; break ; } canvas . repaint ( ) ; }
tr	9X	public final ExpressaoContext expressao ( int _p ) throws RecognitionException { ParserRuleContext _parentctx = _ctx ; int _parentState = getState ( ) ; ExpressaoContext _localctx = new ExpressaoContext ( _ctx , _parentState , _p ) ; ExpressaoContext _prevctx = _localctx ; int _startState = 6 ; enterRecursionRule ( _localctx , RULE_expressao ) ; try { int _alt ; enterOuterAlt ( _localctx , 1 ) ; { setState ( 54 ) ; switch ( _input . LA ( 1 ) ) { case int : { _localctx = new InteiroContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 47 ) ; match ( int ) ; } break ; case 16 : { _localctx = new LeiaContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 48 ) ; match ( 16 ) ; } break ; case ID : { _localctx = new IdContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 49 ) ; match ( ID ) ; } break ; case 10 : { _localctx = new ExpParContext ( _localctx ) ; _ctx = _localctx ; _prevctx = _localctx ; setState ( 50 ) ; match ( 10 ) ; setState ( 51 ) ; expressao ( 0 ) ; setState ( 52 ) ; match ( 2 ) ; } break ; default : throw new NoViableAltException ( this ) ; } _ctx . stop = _input . < ( - 1 ) ; setState ( 67 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; while ( _alt != 2 && _alt != - 1 ) { if ( _alt == 1 ) { if ( _parseListeners != null ) triggerExitRuleEvent ( ) ; _prevctx = _localctx ; { setState ( 65 ) ; switch ( getInterpreter ( ) . adaptivePredict ( _input , 3 , _ctx ) ) { case 1 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 56 ) ; if ( ! ( 4 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "4 >= $_p" ) ; setState ( 57 ) ; match ( 7 ) ; setState ( 58 ) ; expressao ( 5 ) ; } break ; case 2 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 59 ) ; if ( ! ( 3 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "3 >= $_p" ) ; setState ( 60 ) ; match ( 6 ) ; setState ( 61 ) ; expressao ( 4 ) ; } break ; case 3 : { _localctx = new OpBinContext ( new ExpressaoContext ( _parentctx , _parentState , _p ) ) ; pushNewRecursionContext ( _localctx , _startState , RULE_expressao ) ; setState ( 62 ) ; if ( ! ( 2 >= _localctx . _p ) ) throw new FailedPredicateException ( this , "2 >= $_p" ) ; setState ( 63 ) ; match ( 8 ) ; setState ( 64 ) ; expressao ( 3 ) ; } break ; } } } setState ( 69 ) ; _errHandler . sync ( this ) ; _alt = getInterpreter ( ) . adaptivePredict ( _input , 4 , _ctx ) ; } } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { unrollRecursionContexts ( _parentctx ) ; } return _localctx ; }
tr	3	private void removeOutTransferActionPerformed ( java . awt . event . ActionEvent evt ) { int items_to_delete [ ] = null ; if ( ! outgoingTransferList . isSelectionEmpty ( ) ) { items_to_delete = outgoingTransferList . getSelectedIndices ( ) ; } else { return ; } if ( items_to_delete != null ) { for ( int i = items_to_delete . length - 1 ; i >= 0 ; i -- ) { outgoingItems . elementAt ( i ) . cancel ( ) ; outgoingItems . elementAt ( i ) . cleanup ( ) ; outgoingItems . remove ( items_to_delete [ i ] ) ; } } }
tr	3	private DefaultTreeModel getGroups ( ) { DefaultMutableTreeNode root = new DefaultMutableTreeNode ( Constants . STR_GROUP ) ; String userNo = String . valueOf ( user . get ( Constants . USER_NO ) ) ; List < Map < String , Object >> groupList = userDao . getGroup ( userNo ) ; for ( int i = 0 , len = groupList . size ( ) ; i < len ; ++ i ) { Map < String , Object > group = groupList . get ( i ) ; DefaultMutableTreeNode child = new DefaultMutableTreeNode ( String . valueOf ( group . get ( Constants . GROUP_NAME ) ) ) ; Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . USER_NO , String . valueOf ( group . get ( Constants . USER_NO ) ) ) ; param . put ( Constants . GROUP_NO , String . valueOf ( group . get ( Constants . GROUP_NO ) ) ) ; List < Map < String , Object >> friendList = userDao . getFriend ( param ) ; if ( Constants . NUM_ZERO != friendList . size ( ) ) { for ( int j = 0 , size = friendList . size ( ) ; j < size ; ++ j ) { Map < String , Object > friend = friendList . get ( j ) ; String friendNo = String . valueOf ( friend . get ( Constants . FRIEND_NO ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( userDao . getUserInfo ( friendNo ) ) ; sb . append ( "(" ) ; sb . append ( friendNo ) ; sb . append ( ")" ) ; sb . append ( "  <" ) ; int status = userDao . getStatus ( friendNo ) ; sb . append ( userStatus . getItemAt ( status ) . toString ( ) ) ; sb . append ( ">" ) ; DefaultMutableTreeNode childschild = new DefaultMutableTreeNode ( sb . toString ( ) ) ; child . add ( childschild ) ; } } root . add ( child ) ; } return new DefaultTreeModel ( root ) ; }
tr	2	public OfficeObject getByValue ( String selectedValue ) { for ( OfficeObject curObj : data ) { if ( curObj . getName ( ) . equals ( selectedValue ) ) { return curObj ; } } return null ; }
tr	2	public void Insertar ( String dato , String cuentaBancaria ) { NodoDeLista nuevo ; nuevo = new NodoDeLista ( ) ; nuevo . setDato ( dato ) ; nuevo . setCuentaBancaria ( cuentaBancaria ) ; if ( raiz == null ) { nuevo . setSiguiente ( null ) ; raiz = nuevo ; } else { NodoDeLista auxiliar = raiz ; while ( auxiliar . getSiguiente ( ) != null ) { auxiliar = auxiliar . getSiguiente ( ) ; } auxiliar . setSiguiente ( nuevo ) ; } }
tr	8	public < T > Put insert ( T instance ) { try { Field key = clazz . getField ( "key" ) ; byte [ ] keyRow = ( byte [ ] ) key . get ( instance ) ; Put update = new Put ( keyRow ) ; Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field f : fields ) { if ( f . isAnnotationPresent ( HRowKey . class ) ) { continue ; } else if ( f . isAnnotationPresent ( HMapFamily . class ) ) { Map m = ( Map ) f . get ( instance ) ; HMapFamily annotation = f . getAnnotation ( HMapFamily . class ) ; update = insertMapFamily ( update , m , annotation ) ; } else if ( f . isAnnotationPresent ( HProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HProperty annotation = f . getAnnotation ( HProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HMapProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HMapProperty annotation = f . getAnnotation ( HMapProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else if ( f . isAnnotationPresent ( HListProperty . class ) ) { byte [ ] value = convertToBytes ( f . get ( instance ) ) ; HListProperty annotation = f . getAnnotation ( HListProperty . class ) ; update . add ( annotation . family ( ) . getBytes ( ) , annotation . identifier ( ) . getBytes ( ) , value ) ; } else { log . debug ( String . format ( "Skipping field %s as it has no supported annotations" , f . getName ( ) ) ) ; } } return update ; } catch ( NoSuchFieldException e ) { log . error ( "Field not found" , e ) ; return null ; } catch ( IllegalAccessException e ) { log . error ( "Access exception" , e ) ; return null ; } }
tr	9X	private Hashtable < Character , String > build_box ( int [ ] perm , String k ) { int [ ] row = new int [ 2 ] ; row [ 0 ] = perm [ 0 ] ; row [ 1 ] = perm [ 1 ] ; int [ ] col = new int [ 8 ] ; for ( int i = 0 ; i < 8 ; i ++ ) { col [ i ] = perm [ i + 2 ] ; } boolean [ ] filled = new boolean [ 26 ] ; String k_u = k . toUpperCase ( ) ; Hashtable < Character , String > result = new Hashtable < Character , String > ( ) ; int cur_row = 0 ; int cur_col = 0 ; for ( int i = 0 ; i < k_u . length ( ) ; i ++ ) { char cur_c = k_u . charAt ( i ) ; if ( cur_c == J ) { cur_c = I ; } else if ( cur_c == Z ) { cur_c = Y ; } int pos = cur_c - A ; if ( ! filled [ pos ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ pos ] = true ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 25 || i == 9 ) continue ; if ( ! filled [ i ] ) { String r ; if ( cur_row == 0 ) { r = Integer . toString ( col [ cur_col ] ) ; } else { r = Integer . toString ( row [ cur_row - 1 ] ) + Integer . toString ( col [ cur_col ] ) ; } char cur_c = ( char ) ( A + i ) ; result . put ( Character . valueOf ( cur_c ) , r ) ; if ( cur_col == 7 ) { cur_row ++ ; cur_col = 0 ; } else { cur_col ++ ; } filled [ i ] = true ; } } return result ; }
tr	1	public boolean offerFirst ( E e ) { if ( contains ( e ) ) { return false ; } linkFirst ( e ) ; return true ; }
tr	2	public List < UsuarioSistema > listarTodos ( ) throws ErroValidacaoException , Exception { try { PreparedStatement comando = banco . getConexao ( ) . prepareStatement ( "select p.id as idpessoa nome cpf rg " + "data_nascimento u.id as idusuario  usuario from pessoas " + "p inner join usuarios_sistema u on u.id_pessoa = p.id" ) ; ResultSet consulta = comando . executeQuery ( ) ; comando . getConnection ( ) . commit ( ) ; List < UsuarioSistema > Lista = new LinkedList < > ( ) ; while ( consulta . next ( ) ) { UsuarioSistema tmp = new UsuarioSistema ( ) ; tmp . setCpf ( consulta . getInt ( "CPF" ) ) ; tmp . setDataNascimento ( consulta . getDate ( "Data_Nascimento" ) ) ; tmp . setNome ( consulta . getString ( "Nome" ) ) ; tmp . setId ( consulta . getInt ( "Id_Pessoa" ) ) ; tmp . setId ( consulta . getInt ( "Id_Usuario" ) ) ; tmp . setRg ( consulta . getString ( "RG" ) ) ; tmp . setUsuario ( consulta . getString ( "Usuario" ) ) ; Lista . add ( tmp ) ; } return Lista ; } catch ( SQLException ex ) { ex . printStackTrace ( ) ; return null ; } }
tr	0	public double getUnnormalisedInterpolatedHeightAt ( Vec pp ) { return getInterpolatedHeightAt ( pp ) * range + min ; }
tr	7	public static void main ( String [ ] args ) { BigInteger totalSum = BigInteger . ZERO ; for ( int i = 2 ; i <= 4 ; i ++ ) { BigInteger [ ] [ ] arrangements = new BigInteger [ 51 ] [ 50 ] ; for ( int j = 0 ; j <= 50 ; j ++ ) for ( int k = 0 ; k < 50 ; k ++ ) arrangements [ j ] [ k ] = BigInteger . ZERO ; arrangements [ 1 ] [ 0 ] = BigInteger . ONE ; for ( int j = 1 ; j < 50 ; j ++ ) { for ( int k = 1 ; k <= 50 ; k ++ ) arrangements [ k ] [ j ] = arrangements [ k - 1 ] [ j - 1 ] ; for ( int k = i ; k <= 50 ; k ++ ) arrangements [ 0 ] [ j ] = arrangements [ 0 ] [ j ] . add ( arrangements [ k ] [ j ] ) ; } for ( int j = 0 ; j < 50 ; j ++ ) totalSum = totalSum . add ( arrangements [ j ] [ 49 ] ) ; } System . out . println ( totalSum ) ; }
tr	7	public static double tanh ( double x ) { boolean negate = false ; if ( x != x ) { return x ; } if ( x > 20.0 ) { return 1.0 ; } if ( x < - 20 ) { return - 1.0 ; } if ( x == 0 ) { return x ; } if ( x < 0.0 ) { x = - x ; negate = true ; } double result ; if ( x >= 0.5 ) { double hiPrec [ ] = new double [ 2 ] ; exp ( x * 2.0 , 0.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = - 1.0 + ya ; double nb = - ( na + 1.0 - ya ) ; double temp = na + yb ; nb += - ( temp - na - yb ) ; na = temp ; double da = 1.0 + ya ; double db = - ( da - 1.0 - ya ) ; temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } else { double hiPrec [ ] = new double [ 2 ] ; expm1 ( x * 2.0 , hiPrec ) ; double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ; double na = ya ; double nb = yb ; double da = 2.0 + ya ; double db = - ( da - 2.0 - ya ) ; double temp = da + yb ; db += - ( temp - da - yb ) ; da = temp ; temp = da * HEX_40000000 ; double daa = da + temp - temp ; double dab = da - daa ; double ratio = na / da ; temp = ratio * HEX_40000000 ; double ratioa = ratio + temp - temp ; double ratiob = ratio - ratioa ; ratiob += ( na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob ) / da ; ratiob += nb / da ; ratiob += - db * na / da / da ; result = ratioa + ratiob ; } if ( negate ) { result = - result ; } return result ; }
tr	6	public int [ ] likertJakauma ( ) { int [ ] jakaumat = new int [ 5 ] ; int ykkoset = 0 ; int kakkoset = 0 ; int kolmoset = 0 ; int neloset = 0 ; int vitoset = 0 ; for ( int arvo : this . aineisto ) { if ( arvo == 1 ) { ykkoset ++ ; } else if ( arvo == 2 ) { kakkoset ++ ; } else if ( arvo == 3 ) { kolmoset ++ ; } else if ( arvo == 4 ) { neloset ++ ; } else if ( arvo == 5 ) { vitoset ++ ; } } double summa = ykkoset + kakkoset + kolmoset + neloset + vitoset ; jakaumat [ 0 ] = ( int ) ( 100 * ( 1.0 * ykkoset / summa ) ) ; jakaumat [ 1 ] = ( int ) ( 100 * ( 1.0 * kakkoset / summa ) ) ; jakaumat [ 2 ] = ( int ) ( 100 * ( 1.0 * kolmoset / summa ) ) ; jakaumat [ 3 ] = ( int ) ( 100 * ( 1.0 * neloset / summa ) ) ; jakaumat [ 4 ] = ( int ) ( 100 * ( 1.0 * vitoset / summa ) ) ; return jakaumat ; }
tr	1	private void putStash ( int key , V value ) { if ( stashSize == stashCapacity ) { resize ( capacity << 1 ) ; put ( key , value ) ; return ; } int index = capacity + stashSize ; keyTable [ index ] = key ; valueTable [ index ] = value ; stashSize ++ ; size ++ ; }
tr	4	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
tr	3	public List < PayloadSubjectExceptionData > getExceptions ( ) throws Exception { if ( this . exceptions == null ) { this . exceptions = new ArrayList < PayloadSubjectExceptionData > ( ) ; NodeList exceptions = Utilities . selectNodes ( this . getDocument ( ) , "/dc:DCTransaction/dc:GetDataBySubjectRs/dc:PayloadSubjectExceptions/dc:PayloadSubjectException" , XMLLabels . STANDARD_NAMESPACES ) ; if ( exceptions != null ) { for ( int i = 0 ; i < exceptions . getLength ( ) ; ++ i ) { Node exception = exceptions . item ( i ) ; this . exceptions . add ( new PayloadSubjectExceptionData ( exception ) ) ; } } } return this . exceptions ; }
tr	1	public static Image [ ] loadStills ( int numSprites , String imgPath ) { Image [ ] stills = new Image [ numSprites ] ; String path = Item . charPath + imgPath ; for ( int i = 0 ; i < numSprites ; i ++ ) { stills [ i ] = Item . loadImage ( path + i + "/0.png" ) ; } return stills ; }
tr	0	public static String getPassword ( String password ) { return getProperty ( "weibo4j.password" , password ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Agregar . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Agregar ( ) . setVisible ( true ) ; } } ) ; }
tr	0	public void windowDeiconified ( WindowEvent e ) { }
tr	4	private static String readLine ( int lineNumber ) { BufferedReader reader = null ; String line = "" ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; int i = 0 ; for ( String curLine ; ( curLine = reader . readLine ( ) ) != null ; i ++ ) { if ( i == lineNumber ) line = curLine ; } } catch ( IOException e ) { } finally { try { reader . close ( ) ; } catch ( Exception e ) { } } return line ; }
tr	4	public static ArrayList < String > getCluster ( String token ) { if ( singleton == null ) { singleton = new BrownFeaturizer ( ) ; singleton . init ( new Model ( ) ) ; } ArrayList < String > list = new ArrayList < String > ( ) ; String cluster = singleton . mappingS . get ( token ) ; if ( cluster == null ) { cluster = "NONE" ; } else { for ( int len : LEN ) { if ( cluster . length ( ) >= len ) { String pf = cluster . substring ( 0 , len ) ; list . add ( "CLUST_" + len + "_" + pf ) ; } } list . add ( "CLUST_ALL_" + cluster ) ; } return list ; }
tr	2	private void botonEliminarUsuarioActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . tablaAdministracionUsuarios . getSelectedRow ( ) > - 1 ) { String codigo = ( String ) this . conectorTablaUsuarios . getValueAt ( this . tablaAdministracionUsuarios . getSelectedRow ( ) , 0 ) ; int respuesta = JOptionPane . showConfirmDialog ( this . botonEliminarUsuario , "\u00BFRealmente desea eliminar \n al usuario " + codigo + "?" , "Confirme eliminaci\u00F3n" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( respuesta == JOptionPane . YES_OPTION ) { Usuario u = this . modeloApp . obtenerUsuarioConCodigo ( codigo ) ; this . modeloApp . eliminarUsuario ( u ) ; this . conectorTablaUsuarios . cargarUsuarios ( ) ; } } else { JOptionPane . showMessageDialog ( this , "Debe seleccionar un\nusuario de la tabla" , "Usuario no seleccionado" , JOptionPane . INFORMATION_MESSAGE ) ; } }
tr	1	public ArrayList < String > getDependencies ( ) { ArrayList < String > dep = new ArrayList < String > ( ) ; for ( JsonValue v : object . get ( "dependencies" ) . asArray ( ) . values ( ) ) dep . add ( v . asString ( ) ) ; return dep ; }
tr	2	public static boolean isPrime ( int checkNumber ) { double root = Math . sqrt ( checkNumber ) ; for ( int i = 2 ; i <= root ; i ++ ) { if ( checkNumber % i == 0 ) { return false ; } } return true ; }
tr	5	@ Override public void run ( ) { String author = item . getAuthor ( ) ; String title = item . getTitle ( ) ; String dir = "./cache" ; String localCover = dir + "/cover/" + title + "-" + author + ".jpg" ; String localSong = dir + "/song/" + title + "-" + author + ".mp3" ; try { if ( item . getCover ( ) != null && item . getCover ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localCover , item . getCover ( ) ) ; item . setCover ( localCover ) ; } onCoverComplete ( item ) ; if ( item . getCover ( ) != null && item . getPath ( ) . startsWith ( "http" ) ) { HttpUtil . downloadByByte ( localSong , item . getPath ( ) ) ; item . setPath ( localSong ) ; item . setLocal ( true ) ; } onSongComplete ( item ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	9X	String formatOption ( OptionMetadata metadata , CommandLineConfiguration config ) { String formattedOption = null ; if ( metadata . isParameterAccepted ( ) ) { boolean isParamRequired = ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . isRequired ( ) ) ; String paramDelim = StringUtil . formatDelimValue ( config . getCommandLineProperties ( ) . getOptionParameterDelim ( ) ) ; String paramUsageStr = "" ; if ( metadata . getParameterMetadata ( ) != null && metadata . getParameterMetadata ( ) . getParameterType ( ) != ParameterType . NONE ) { String paramName = "" ; if ( metadata . getParameterMetadata ( ) . getParameterType ( ) == ParameterType . CUSTOM ) { paramName = metadata . getParameterMetadata ( ) . getIdentifier ( ) ; } else { paramName = metadata . getParameterMetadata ( ) . getParameterType ( ) . name ( ) ; } paramUsageStr = String . format ( ( isParamRequired ) ? "%s<%s>" : "[%s<%s>]" , paramDelim , paramName ) ; if ( metadata . isMultiValued ( ) ) { paramUsageStr += "..." ; } } String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) , paramUsageStr ) ; } else { formattedOption = String . format ( "%s%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , paramUsageStr ) ; } } else { String longIdentifier = metadata . getIdentifier ( IdentifierType . long ) ; if ( longIdentifier != null && ! longIdentifier . isEmpty ( ) ) { formattedOption = String . format ( "%s%s  %s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) , config . getCommandLineProperties ( ) . getOptionLongPrefix ( ) , metadata . getIdentifier ( IdentifierType . long ) ) ; } else { formattedOption = String . format ( "%s%s" , config . getCommandLineProperties ( ) . getOptionPrefix ( ) , metadata . getIdentifier ( ) ) ; } } return formattedOption ; }
tr	4	public boolean equals ( Object o ) { if ( o == null || ! ( o instanceof Tir ) ) return false ; Tir tmp = ( Tir ) o ; if ( ! tmp . position . equals ( position ) ) return false ; if ( tmp . joueur != joueur ) return false ; return true ; }
tr	6	private StringBuilder getSubGalleries ( Gallery gallery ) throws ClassNotFoundException , SQLException { StringBuilder sb = new StringBuilder ( ) ; List < SubGallery > subGalleries = gallery . getSubGalleries ( ) ; for ( SubGallery subGallery : subGalleries ) { sb . append ( "<h4>" ) ; sb . append ( subGallery . getName ( ) ) ; sb . append ( "</h4>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"row\">" ) ; Utils . appendNewLine ( sb ) ; List < SubGalleryPhoto > photos = subGallery . getPhotos ( ) ; int pocet = 0 ; for ( SubGalleryPhoto photo : photos ) { pocet ++ ; sb . append ( "<div class=\"col-xs-6 col-sm-4 col-md-3 text-center\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<a href=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\"" ) ; sb . append ( " class=\"thumbnail\"" ) ; sb . append ( " style=\"margin-bottom: 5px;\"" ) ; sb . append ( " rel=\"prettyPhoto[pp1]\"" ) ; sb . append ( " title=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"><img src=\"" ) ; sb . append ( gallery . getUrl ( ) ) ; sb . append ( subGallery . getUrl ( ) ) ; sb . append ( photo . getFileName ( ) ) ; sb . append ( "\" alt=\"" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "\"></a>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<p class=\"small\">" ) ; sb . append ( photo . getTitle ( ) ) ; sb . append ( "</p>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; if ( pocet % 2 == 0 ) { sb . append ( "<div class=\"clearfix visible-xs\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 3 == 0 ) { sb . append ( "<div class=\"clearfix visible-sm\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-md\"></div>" ) ; Utils . appendNewLine ( sb ) ; } if ( pocet % 4 == 0 ) { sb . append ( "<div class=\"clearfix visible-lg\"></div>" ) ; Utils . appendNewLine ( sb ) ; } } sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; } return sb ; }
tr	9X	@ Override public void actionPerformed ( ActionEvent ae ) { if ( ae . getActionCommand ( ) . compareTo ( "comboBoxChanged" ) == 0 ) { if ( ae . getSource ( ) == combo_url ) { loadUrlData ( ) ; } else if ( ae . getSource ( ) == combo_grantType ) { if ( combo_grantType . getSelectedIndex ( ) == AUTHORIZATION_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . AUTHORIZATION_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == PASSWORD_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . PASWORD_GRANT ) ; setupPanels ( ) ; } else if ( combo_grantType . getSelectedIndex ( ) == CLIENT_GRANT_INDEX ) { OAuthPropertyBean . getInstance ( ) . setGrantType ( OAuthPropertyBean . CLIENT_CREDENTIALS_GRANT ) ; setupPanels ( ) ; } } } else if ( ae . getActionCommand ( ) . compareTo ( ABOUT_MENUITEM ) == 0 ) { JOptionPane . showMessageDialog ( applicationFrame , "OAuthTestClient\nAn OAuth 2.0 Test Application\nWritten by Ronnie Mitra.\n\nhttps://github.com/mitraman/OAuthTestClient    \n\n" , "About OAuthTestClient" , JOptionPane . QUESTION_MESSAGE ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SETTINGS_MENUITEM ) == 0 ) { SettingsDialog settingsDialog = new SettingsDialog ( applicationFrame ) ; settingsDialog . setVisible ( true ) ; } else if ( ae . getActionCommand ( ) . compareTo ( SAVE_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( "./OAuthTestClient.cfg" ) ; if ( fileChooser . showSaveDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . saveProperties ( file ) ; } } else if ( ae . getActionCommand ( ) . compareTo ( LOAD_CONFIG_MENUITEM ) == 0 ) { JFileChooser fileChooser = new JFileChooser ( ) ; if ( fileChooser . showOpenDialog ( this ) == JFileChooser . APPROVE_OPTION ) { File file = fileChooser . getSelectedFile ( ) ; ConfigManager . loadProperties ( file ) ; } } else { System . out . println ( ae . getActionCommand ( ) + " " + ae . getID ( ) ) ; } }
tr	8	private int getKingAxisVal ( int loc ) { switch ( loc ) { case 0 : case 7 : return - 4 ; case 1 : case 6 : return - 2 ; case 2 : case 5 : return 2 ; case 3 : case 4 : return 4 ; default : return 0 ; } }
tr	2	@ Override protected void drawComponentName ( Graphics2D g ) { String name = getName ( ) ; if ( name != null ) { g . setColor ( Color . blue ) ; int fontSize = ( int ) ( ( width ) / name . length ( ) ) ; if ( fontSize > 16 ) fontSize = 16 ; g . setFont ( new Font ( Font . DIALOG , Font . PLAIN , fontSize ) ) ; float px , py ; FontMetrics fm = g . getFontMetrics ( ) ; int h = height / 10 ; px = ( int ) ( width - fm . stringWidth ( name ) ) / 2 ; py = h + ( int ) ( height - 3.6 * h - fm . getHeight ( ) ) / 2 ; int xx = ( int ) ( x ) ; int yy = ( int ) ( y ) ; g . drawString ( name , xx + px , yy + py + fm . getAscent ( ) ) ; } }
tr	0	public boolean isSchoolAnnouncements ( ) { return schoolAnnouncements ; }
tr	8	private boolean r_tidy_up ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_7 , 4 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } bra = cursor ; if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 2 : if ( ! ( eq_s_b ( 1 , "\u043D" ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_del ( ) ; break ; } return true ; }
tr	6	public static List < Integer > detectColorsWithThr ( DigitInput in , double thr1 , double thr2 ) { List < ColorsUtils . Color > colors ; Integer [ ] [ ] [ ] image ; if ( in . options [ Opts . oColorsDetectOn . id ] . is ( Opts . oColorsDetectOn . LEGEND ) && in . legend != null ) image = ImageUtils . bitmapToArray ( in . legend ) ; else image = ImageUtils . bitmapToArray ( in . graph ) ; List < Integer > set = ColorsUtils . getColorSet ( image , true ) ; List < Integer > cols = new ArrayList < > ( ) ; for ( Integer x : set ) { if ( CIELab . delta ( in . background , x ) > 10 ) cols . add ( x ) ; } colors = ColorsUtils . detectColors ( cols , thr1 ) ; cols . clear ( ) ; for ( ColorsUtils . Color c : colors ) { cols . add ( c . mean ) ; } colors = ColorsUtils . detectColorsBetter ( cols , thr2 ) ; List < Integer > result = new ArrayList < > ( ) ; for ( ColorsUtils . Color colRes : colors ) result . add ( colRes . mean ) ; return result ; }
tr	9X	public static void main ( String argv [ ] ) { try { if ( argv . length != 1 ) { System . err . println ( "USBD [ start | stop ]" ) ; System . exit ( 1 ) ; } if ( "start" . equals ( argv [ 0 ] ) ) { Host host = HostFactory . getHost ( ) ; if ( host == null ) { System . err . println ( "USBD:  USB is not available." ) ; System . exit ( 1 ) ; } if ( host instanceof Remote ) { System . err . println ( "USBD: proxy already registered" ) ; System . exit ( 1 ) ; } try { HostProxy proxy = new HostProxy ( host ) ; Naming . bind ( rmiName , proxy ) ; System . err . println ( "USBD:  Bound RMI name " + rmiName ) ; } catch ( Exception e ) { System . err . println ( "USBD:  Couldn't bind to: " + rmiName ) ; if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } } else if ( "stop" . equals ( argv [ 0 ] ) ) { System . err . println ( "USBD: no 'stop' yet ... " + "use 'ps' and 'kill' for now" ) ; } else { System . err . println ( "USBD: no '" + argv [ 0 ] + "' command" ) ; System . exit ( 1 ) ; } } catch ( Exception e ) { if ( debug ) e . printStackTrace ( ) ; else System . err . println ( e . getMessage ( ) ) ; } }
tr	0	public Holder ( ) { System . out . println ( "Holder created" ) ; }
tr	2	private byte getFlags ( ) { byte b = 0 ; if ( isRoot ) { b |= 01 ; } if ( isOrdered ) { b |= 02 ; } return b ; }
tr	4	public void testFileContent ( ) throws IOException { long start = System . currentTimeMillis ( ) ; byte [ ] buf1 = new byte [ 1024 ] ; byte [ ] buf2 = new byte [ 1024 ] ; int size1 , size2 ; String fileName1 = "test1.class" ; String fileName2 = "test2.class" ; File file1 = new File ( fileName1 ) ; File file2 = new File ( fileName2 ) ; BufferedInputStream bis1 = new BufferedInputStream ( new FileInputStream ( file1 ) ) ; BufferedInputStream bis2 = new BufferedInputStream ( new FileInputStream ( file2 ) ) ; Polynomial polynomial = Polynomial . createIrreducible ( 53 ) ; Fingerprint < Polynomial > rabin1 = new RabinFingerprintLong ( polynomial ) ; Fingerprint < Polynomial > rabin2 = new RabinFingerprintLong ( polynomial ) ; while ( ( ( size1 = bis1 . read ( buf1 ) ) != - 1 ) && ( ( size2 = bis2 . read ( buf2 ) ) != - 1 ) ) { rabin1 . pushBytes ( buf1 ) ; rabin2 . pushBytes ( buf2 ) ; String s1 = new String ( buf1 ) ; String s2 = new String ( buf2 ) ; if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) != 0 ) { System . out . println ( "file 1 and file 2 are different!" ) ; break ; } } if ( rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) == 0 ) System . out . println ( "file 1 and file 2 are the same!" ) ; long end = System . currentTimeMillis ( ) ; System . out . println ( "Time: " + ( end - start ) + "ms." ) ; assertEquals ( 0 , rabin1 . getFingerprint ( ) . compareTo ( rabin2 . getFingerprint ( ) ) ) ; }
tr	5	public void dbReadItem ( Connection aconn , String agroup , String atest ) { try { testgroupid = agroup ; testid = atest ; String qstr = "Select TestTitle TestDesc TestNotes BugReqID CaseSource " + "LastName FirstName AgeYrs AgeMos AgeWks AgeDays BirthDate AgeEntryMethod GenderCd CreateBy CreationDate ModDate BaseDate TestResult ResultNotes" + " From TestCaseTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; if ( rset . next ( ) ) { testtitle = rset . getString ( 1 ) ; testdesc = rset . getString ( 2 ) ; testnote = rset . getString ( 3 ) ; testreqid = rset . getString ( 4 ) == null ? "" : rset . getString ( 4 ) ; casesource = rset . getString ( 5 ) == null ? "" : rset . getString ( 5 ) ; lastname = rset . getString ( 6 ) ; firstname = rset . getString ( 7 ) ; ageyears = rset . getInt ( 8 ) ; agemonths = rset . getInt ( 9 ) ; ageweeks = rset . getInt ( 10 ) ; agedays = rset . getInt ( 11 ) ; birthdate = rset . getDate ( 12 ) ; agemethod = rset . getString ( 13 ) == null ? "" : rset . getString ( 13 ) ; gendercd = rset . getString ( 14 ) ; createby = rset . getString ( 15 ) ; createdate = rset . getDate ( 16 ) ; moddate = rset . getDate ( 17 ) ; basedate = rset . getDate ( 18 ) ; testresult = rset . getString ( 19 ) ; resultnotes = rset . getString ( 20 ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbReadItem cannot read item. " , ex ) ; } }
tr	3	public static void main ( String [ ] args ) { final int [ ] subscripts = new int [ ] { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 } ; final int last = subscripts [ subscripts . length - 1 ] ; String s = null ; long p = 1 ; int ls = 0 ; int j = 0 ; int l = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { s = String . valueOf ( i ) ; ls = s . length ( ) ; l += ls ; if ( l >= subscripts [ j ] ) { final int n = ls - ( l - subscripts [ j ] ) - 1 ; final int d = Integer . parseInt ( s . substring ( n , n + 1 ) ) ; p *= ( long ) d ; j ++ ; } if ( l > last ) { break ; } } System . out . println ( "# p = " + p ) ; }
tr	5	public int generateDurability ( int blockY ) { int durability = baseDurability_ ; if ( variance_ > 0 ) { durability += Citadel . getRandom ( ) . nextInt ( ) % ( variance_ * 2 + 1 ) ; durability -= variance_ ; } if ( yAdjustment_ < 0.00001 || yAdjustment_ > 0.00001 ) { durability += ( int ) ( ( float ) blockY * yAdjustment_ ) ; } if ( durability < minDurability_ ) { return minDurability_ ; } if ( durability > maxDurability_ ) { return maxDurability_ ; } return durability ; }
tr	3	static private final int jjMoveStringLiteralDfa13_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 11 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 12 , active0 ) ; return 13 ; } switch ( curChar ) { case 67 : return jjMoveStringLiteralDfa14_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 12 , active0 ) ; }
tr	8	public static void propagateZeros ( int [ ] [ ] arr ) { int width = arr . length ; int height = width == 0 ? 0 : arr [ 0 ] . length ; int [ ] rowsToZero = new int [ width ] ; int [ ] colsToZero = new int [ height ] ; for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( arr [ ii ] [ jj ] == 0 ) { rowsToZero [ ii ] = 1 ; colsToZero [ jj ] = 1 ; } } } for ( int ii = 0 ; ii < width ; ii ++ ) { for ( int jj = 0 ; jj < height ; jj ++ ) { if ( rowsToZero [ ii ] == 1 || colsToZero [ jj ] == 1 ) { arr [ ii ] [ jj ] = 0 ; } } } }
tr	8	public SolutionType [ ] decodeSolution ( String str ) throws DecodeException { SolutionType [ ] res ; int i = 0 ; int beginning = i ; while ( str . charAt ( i ) != > ) { i ++ ; } String type = str . substring ( beginning , i ) ; i ++ ; beginning = i ; if ( str . charAt ( i ) == < ) { i ++ ; while ( i < str . length ( ) ) { i ++ ; } String [ ] tab = str . substring ( beginning + 1 , i ) . split ( ":" ) ; res = ( SolutionType [ ] ) new Object [ tab . length ] ; for ( int x = 0 ; x < tab . length ; x ++ ) { switch ( type ) { case "int" : res [ x ] = ( SolutionType ) Integer . valueOf ( tab [ x ] ) ; break ; case "dbl" : res [ x ] = ( SolutionType ) double . valueOf ( tab [ x ] ) ; break ; case "str" : res [ x ] = ( SolutionType ) tab [ x ] ; break ; case "chr" : res [ x ] = ( SolutionType ) ( ( Character ) tab [ x ] . charAt ( 0 ) ) ; break ; default : throw new DecodeException ( "non recognized type" ) ; } } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	2	@ Override public String filterReplacedString ( FilterBypass fb , int offset , int length , String str , AttributeSet attrs ) { if ( str == null ) return "" ; int remaining = limit - fb . getDocument ( ) . getLength ( ) + length ; if ( remaining > str . length ( ) ) { return str ; } else { return str . substring ( 0 , remaining ) ; } }
tr	5	public Identifier AddUser ( User info ) { try { if ( info . getContact ( ) == null || info . getContact ( ) . getEmail ( ) == null || info . getFirstName ( ) == null || info . getLastName ( ) == null ) { return null ; } return Users . getInstance ( ) . create ( info ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { System . err . println ( "Failed to Add user. " + e . getMessage ( ) ) ; return null ; } }
tr	5	private static Collection < Layer > parseLayerArgument ( Model model , String layersarg ) { Collection < Layer > lays ; if ( layersarg . equalsIgnoreCase ( "all" ) ) { lays = model . getLayer ( ) ; } else { String [ ] layersarg1 = layersarg . split ( " " ) ; lays = new ArrayList < Layer > ( ) ; for ( Layer lay1 : model . getLayer ( ) ) { for ( String lan : layersarg1 ) { if ( lan . equals ( String . valueOf ( lay1 . getNumber ( ) ) ) ) { lays . add ( lay1 ) ; } } } } if ( lays . isEmpty ( ) ) { System . err . println ( "No matching layers found." ) ; System . exit ( 1 ) ; } return lays ; }
tr	8	private boolean swap ( SemanticFrame frame , int N , int M , int [ ] match , int [ ] invMatch , int p , int b , TIntArrayList args ) { int a = match [ p ] ; int q = invMatch [ b ] ; if ( p >= N && q >= N ) { return false ; } else if ( a >= M && b >= M ) { return false ; } if ( p < N ) frame . arglbids [ args . get ( p ) ] = b < M ? b : - 1 ; if ( q < N ) frame . arglbids [ args . get ( q ) ] = a < M ? a : - 1 ; match [ p ] = b ; invMatch [ b ] = p ; match [ q ] = a ; invMatch [ a ] = q ; return true ; }
tr	8	@ Override protected void process ( ) { StringTokenizer t = new StringTokenizer ( fileL . getListString ( true ) , "\n" ) ; int files = 0 , total = 0 ; for ( ; t . hasMoreTokens ( ) ; files ++ ) { String s = t . nextToken ( ) ; String title = Print . titleString ( "--" , s ) ; if ( showAllFiles ) { Print . ln ( title ) ; title = null ; } int i = 0 ; try ( BufferedReader in = new BufferedReader ( new FileReader ( s ) ) ) { for ( int line = 1 ; ( s = in . readLine ( ) ) != null ; line ++ ) if ( fnameFilter . accept ( s ) ) { if ( title != null ) { Print . ln ( title ) ; title = null ; } Print . f ( "%3d: %s\n" , line , s ) ; i ++ ; } } catch ( IOException ioe ) { Sys . warning ( ioe . toString ( ) ) ; } if ( i > 0 || showAllFiles ) { Print . ln ( "   " + i + " occurrence(s)" ) ; } total += i ; } Print . ln ( Print . separator ( "==========================" ) ) ; Print . ln ( "Totally " + total + " occurrence(s) in " + files + " file(s).\n" ) ; }
tr	4	public void run ( ) { useful = true ; UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . pushScreen ( popup ) ; } } ) ; int iterations = 0 ; while ( useful ) { try { Thread . sleep ( timeout ) ; } catch ( Exception e ) { } if ( ++ iterations > maximum ) iterations = 1 ; gaugeField . setValue ( iterations ) ; } if ( popup . isDisplayed ( ) ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { UiApplication . getUiApplication ( ) . popScreen ( popup ) ; } } ) ; } }
tr	2	public void setAttributes ( Point leftest , Point rightest ) { if ( leftest != null ) { leftAngle = Tools . round ( src . getDirection ( leftest ) , 10000 ) ; leftDist = src . getDistance ( leftest ) ; } if ( rightest != null ) { rightAngle = Tools . round ( src . getDirection ( rightest ) , 10000 ) ; rightDist = src . getDistance ( rightest ) ; } }
tr	0	public int getSize ( ) { return size ; }
tr	8	public void start ( ) { if ( applet != null ) { applet . start ( ) ; return ; } if ( gameUpdaterStarted ) return ; Thread t = new Thread ( ) { public void run ( ) { gameUpdater . run ( ) ; try { if ( ! gameUpdater . fatalError ) replace ( gameUpdater . createApplet ( ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } } ; t . setDaemon ( true ) ; t . start ( ) ; t = new Thread ( ) { public void run ( ) { while ( applet == null ) { repaint ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } } ; t . setDaemon ( true ) ; t . start ( ) ; gameUpdaterStarted = true ; }
tr	9X	public int moveToMe ( MyStore < T > other ) { if ( other . size == 0 ) return 0 ; if ( this . size == 0 ) { this . moveAll ( other . size , other . head , this . tail , other ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return this . size ; } int initialMySize = this . size ; int initialOtherSize = other . size ; Container < T > thisOld = this . head ; Container < T > otherOld = other . head ; Container < T > thisCurrent = this . head . next ; Container < T > otherCurrent = other . head . next ; int otherRemaining = other . size ; int moved = 0 ; boolean done = false ; while ( true ) { int result = this . compare ( thisCurrent . el , otherCurrent . el ) ; if ( result == 0 ) { if ( otherCurrent . next != null ) { otherOld = otherCurrent ; otherCurrent = otherCurrent . next ; otherRemaining -- ; } else { done = true ; break ; } if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } else if ( result > 0 ) { otherOld . next = otherCurrent . next ; other . size -- ; thisOld . next = otherCurrent ; otherCurrent . next = thisCurrent ; this . size ++ ; moved ++ ; thisOld = otherCurrent ; if ( other . tail == otherCurrent ) { other . tail = otherOld ; } if ( otherOld . next != null ) { otherCurrent = otherOld . next ; otherRemaining -- ; } else { done = true ; break ; } } else { if ( thisCurrent . next != null ) { thisOld = thisCurrent ; thisCurrent = thisCurrent . next ; } else { break ; } } } if ( ! done ) { this . moveAll ( otherRemaining , otherOld , thisCurrent , other ) ; moved += otherRemaining ; } assert ( this . size == initialMySize + moved ) ; assert ( other . size == initialOtherSize - moved ) ; assert ( other . size != 0 || other . head . next == null ) ; assert ( this . size != 0 || this . head . next == null ) ; assert ( this . tail . next == null ) ; assert ( other . tail . next == null ) ; return moved ; }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	3	public void update ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
tr	1	private Meter getSelectedMeter ( ) { Account temp = getSelectedAccount ( ) ; if ( temp != null ) { Meter m = temp . getMeter ( getSelectedMeterID ( ) ) ; return m ; } else return null ; }
tr	9X	public void setCurrentVar ( int idx ) { assert ( idx >= - 1 && idx < PaneData . var_measures . size ( ) ) ; if ( this . idx == idx ) return ; setVisible ( false ) ; this . removeAll ( ) ; this . idx = idx ; if ( idx == - 1 ) { log . severe ( "Filter Pane - Variable unselected." ) ; setVisible ( true ) ; applyFilter ( ) ; return ; } strMeasure = ( String ) PaneData . var_measures . get ( idx ) ; strType = ( String ) PaneData . var_types . get ( idx ) ; log . severe ( "Filter Pane - [" + PaneData . var_names . get ( idx ) + "] is selected." ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { assert ( PaneData . values_min . get ( idx ) instanceof Integer ) ; assert ( PaneData . values_max . get ( idx ) instanceof Integer ) ; int min = ( ( Integer ) PaneData . values_min . get ( idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( idx ) ) . intValue ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; checkboxList = new JCheckBox [ max - min + 1 ] ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( idx ) ; checkboxList [ i ] = new JCheckBox ( label . get ( min + i ) ) ; checkboxList [ i ] . setSelected ( true ) ; checkboxList [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { JCheckBox c = ( JCheckBox ) e . getSource ( ) ; PaneFilterSelect pfs = ( PaneFilterSelect ) ( c . getParent ( ) ) ; pfs . applyFilter ( ) ; String s = "" ; for ( int i = 0 ; i < pfs . checkboxList . length ; i ++ ) { s = s + "[" + pfs . checkboxList [ i ] . getText ( ) + "] " + pfs . checkboxList [ i ] . isSelected ( ) ; if ( i < pfs . checkboxList . length - 1 ) s = s + "  " ; } log . severe ( "Filter Pane: Filter setting [" + PaneData . var_names . get ( pfs . idx ) + "] chagned to " + s ) ; } } ) ; add ( checkboxList [ i ] ) ; repaint ( ) ; } } else if ( strMeasure . equals ( "Q" ) ) { Object min , max ; if ( strType . equals ( "I" ) ) { min = ( Integer ) PaneData . values_min . get ( idx ) ; max = ( Integer ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( Integer ) min ) . doubleValue ( ) , ( ( Integer ) max ) . doubleValue ( ) ) ; } else if ( strType . equals ( "D" ) ) { min = ( double ) PaneData . values_min . get ( idx ) ; max = ( double ) PaneData . values_max . get ( idx ) ; doubleSlider = new DoubleSlider ( DoubleSlider . HORIZONTAL , ( ( double ) min ) . doubleValue ( ) , ( ( double ) max ) . doubleValue ( ) ) ; } else { assert false ; min = new Integer ( 0 ) ; max = new Integer ( 0 ) ; } setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; lblList = new JLabel [ 2 ] ; lblList [ 0 ] = new JLabel ( min . toString ( ) ) ; lblList [ 0 ] . setHorizontalAlignment ( JLabel . LEFT ) ; lblList [ 1 ] = new JLabel ( max . toString ( ) ) ; lblList [ 1 ] . setHorizontalAlignment ( JLabel . RIGHT ) ; doubleSlider . addAdjustmentListener ( new DoubleSliderAdjustmentListener ( ) { public void adjustmentValueChanged ( DoubleSlider slider ) { PaneFilterSelect pfs = ( PaneFilterSelect ) ( slider . getParent ( ) ) ; pfs . applyFilter ( ) ; double selMin = slider . getSelectedMinimum ( ) ; double selMax = slider . getSelectedMaximum ( ) ; log . severe ( "Filter Pane - The filter for [" + PaneData . var_names . get ( pfs . idx ) + "]is changed to [" + selMin + "  " + selMax + "]" ) ; } } ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( lblList [ 0 ] , constraints ) ; constraints . weightx = 0.8 ; constraints . weighty = 1 ; constraints . gridx = 1 ; constraints . gridy = 0 ; add ( doubleSlider , constraints ) ; constraints . weightx = 0.1 ; constraints . weighty = 1 ; constraints . gridx = 2 ; constraints . gridy = 0 ; add ( lblList [ 1 ] , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	7	public static void main ( String [ ] args ) { Connection conn = null ; Statement stmt = null ; try { class . forName ( "com.mysql.jdbc.Driver" ) ; conn = DriverManager . getConnection ( DB_URL , USER , PASS ) ; stmt = conn . createStatement ( ) ; String sql ; sql = "SELECT * FROM Transport" ; ResultSet rs = stmt . executeQuery ( sql ) ; while ( rs . next ( ) ) { int id = rs . getInt ( "ID" ) ; System . out . print ( "ID: " + id ) ; } rs . close ( ) ; stmt . close ( ) ; conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { if ( stmt != null ) stmt . close ( ) ; } catch ( SQLException se2 ) { } try { if ( conn != null ) conn . close ( ) ; } catch ( SQLException se ) { se . printStackTrace ( ) ; } } }
tr	0	public static BasicRelation getEquivalenceRelation ( ) { BasicRelation rel = new BasicRelation ( "=" ) ; return rel ; }
tr	2	public Map < String , Map < String , Object >> loadAsMap ( String key ) throws IOException { Map < String , Map < String , Object >> map = new HashMap < String , Map < String , Object >> ( ) ; LineIterator iterator = new LineIterator ( new FileReader ( file ) ) ; while ( iterator . hasNext ( ) ) { Map < String , Object > json = JsonOutput . MAPPER . readValue ( iterator . nextLine ( ) , Map . class ) ; if ( json . containsKey ( key ) ) { map . put ( json . get ( key ) . toString ( ) , json ) ; } } return map ; }
tr	2	public void printInfo ( ) { System . out . println ( "Arithmos Xeirourgiwn :" + NumberOrSyrgeries ) ; for ( int i = 0 ; i <= tepRooms . size ( ) ; i ++ ) System . out . println ( "Dwmatio :" + tepRooms . get ( i ) ) ; for ( int i = 0 ; i <= tepSurgeries . size ( ) ; i ++ ) System . out . println ( "Xeirourgio :" + tepSurgeries . get ( i ) ) ; }
tr	2	public Hierarchy getHierarchy ( String id ) { for ( Hierarchy h : hierarchys ) { if ( h . getId ( ) . equalsIgnoreCase ( id ) ) { return h ; } } return null ; }
tr	6	public Map < String , String > readAdjNounSent ( ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "unsupervisedClauseMarkup.readAdjNounSent" ) ; if ( this . myDataHolder == null ) { return null ; } Map < String , String > myAdjNounSent = new HashMap < String , String > ( ) ; Iterator < SentenceStructure > iter = this . myDataHolder . getSentenceHolder ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { SentenceStructure sentenceObject = iter . next ( ) ; String modifier = sentenceObject . getModifier ( ) ; String tag = sentenceObject . getTag ( ) ; myLogger . trace ( "tag: " + tag ) ; if ( ( modifier != null ) && ( tag != null ) ) { if ( ( ! ( modifier . equals ( "" ) ) ) && ( tag . matches ( "^\\[.*$" ) ) ) { modifier = modifier . replaceAll ( "\\[.*?\\]" , "" ) . trim ( ) ; myAdjNounSent . put ( tag , modifier ) ; } } } return myAdjNounSent ; }
tr	6	public int longestConsecutive ( int [ ] num ) { int max = 0 ; if ( num == null ) return max ; Set < Integer > set = new HashSet < > ( ) ; for ( int i : num ) { set . add ( i ) ; } for ( int i : num ) { if ( set . contains ( i ) ) { set . remove ( i ) ; int start = i - 1 ; while ( set . contains ( start ) ) { set . remove ( start ) ; start -- ; } int end = i + 1 ; while ( set . contains ( end ) ) { set . remove ( end ) ; end ++ ; } max = Math . max ( max , end - start - 1 ) ; } } return max ; }
tr	1	public int step ( int state , char c ) { if ( classmap == null ) return transitions [ state * points . length + getCharClass ( c ) ] ; else return transitions [ state * points . length + classmap [ c - Character . MIN_VALUE ] ] ; }
tr	3	@ Test public void test ( ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( "testData/stemmerTest.txt" ) ) ; OutputStream out = new FileOutputStream ( "testData/stemmerTestResult.txt" ) ; SnowballStemmerWrapper stemmer = new SnowballStemmerWrapper ( reader , out ) ; while ( stemmer . isAlive ( ) ) { } assertTrue ( checkFiles ( ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; fail ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	5	public boolean isWallhugPosition ( int x , int y ) { if ( getFreeCount ( x , y ) != 2 ) return false ; else if ( isEmpty ( moveLeft ( x ) , y ) && isEmpty ( moveRight ( x ) , y ) ) return false ; else if ( isEmpty ( x , moveUp ( y ) ) && isEmpty ( x , moveDown ( y ) ) ) return false ; else return true ; }
tr	4	@ Override public < T extends AggregateRoot < ? >> T loadOneBy ( final class < T > aggregateRoot , final Specification < T > specification ) { @ SuppressWarnings ( "unchecked" ) final DomainRepositoryDriver < T , ? > driver = ( DomainRepositoryDriver < T , ? > ) drivers . get ( aggregateRoot ) ; if ( driver == null ) { throw new RuntimeException ( "Can't find any driver for the given aggregate: " + aggregateRoot ) ; } return driver . loadOneBySpecification ( specification ) ; }
tr	5	public static Integer createOfficeObject ( Integer OFFICE_OBJECT_TYPE_ID ) { Integer id = getUniqueId ( ) ; PreparedStatement ps = null ; try { con = ConnectionManager . getConnection ( ) ; if ( con == null ) { return null ; } String insertTableSQL = "INSERT INTO office_object(id  name  office_object_type_id  office_object_status_id)" + " VALUES (? ? ? ?)" ; ps = con . prepareStatement ( insertTableSQL ) ; ps . setInt ( 1 , id ) ; ps . setString ( 2 , "" ) ; ps . setInt ( 3 , OFFICE_OBJECT_TYPE_ID ) ; ps . setInt ( 4 , OfficeObject . ALL_IS_OK ) ; ps . executeUpdate ( ) ; } catch ( MySQLIntegrityConstraintViolationException e ) { e . printStackTrace ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; logger . error ( "SQL query execution errors. Error: " + e . getSQLState ( ) + " | " + e . getErrorCode ( ) ) ; } finally { try { if ( ps != null ) ps . close ( ) ; } catch ( Exception e ) { logger . warn ( "Connection was closed with errors." ) ; } } return id ; }
tr	6	public int partitionIt ( int left , int right , long pivot ) { int leftptr = left - 1 ; int rightptr = right + 1 ; while ( true ) { while ( leftptr < right && theArray [ ++ leftptr ] < pivot ) { } while ( rightptr > left && theArray [ -- rightptr ] > pivot ) { } if ( leftptr >= rightptr ) { break ; } else { swap ( leftptr , rightptr ) ; } } return leftptr ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Cohort other = ( Cohort ) obj ; if ( yearOfAdmission == null ) { if ( other . yearOfAdmission != null ) return false ; } else if ( ! yearOfAdmission . equals ( other . yearOfAdmission ) ) return false ; return true ; }
tr	6	@ Override @ Transactional public List getFilterValuesforReview ( String merchantName , String userName , String reviewStatus ) throws Exception { List filterValuesList = new ArrayList ( ) ; try { if ( merchantName != null ) { Query getMerchant = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oMerchant from MerchantReview merchantReview" ) ; filterValuesList = getMerchant . list ( ) ; System . out . println ( "merchant size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Merchant merchant = ( Merchant ) iterator . next ( ) ; System . out . println ( "merchant-------->" + merchant ) ; } } else if ( userName != null ) { Query getCashBackuser = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oCashBackUser from MerchantReview merchantReview" ) ; filterValuesList = getCashBackuser . list ( ) ; System . out . println ( "user size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { CashBackUser cashBackUser = ( CashBackUser ) iterator . next ( ) ; System . out . println ( "user-------->" + cashBackUser ) ; } } else { Query getReview = sessionFactory . getCurrentSession ( ) . createQuery ( "select merchantReview.oStatus from MerchantReview merchantReview" ) ; filterValuesList = getReview . list ( ) ; System . out . println ( "review status size..." + filterValuesList . size ( ) ) ; Iterator iterator = filterValuesList . iterator ( ) ; while ( iterator . hasNext ( ) ) { MerchantReviewStatus MerchantreviewStatus = ( MerchantReviewStatus ) iterator . next ( ) ; System . out . println ( "reviewStatus-------->" + MerchantreviewStatus ) ; } } } catch ( Exception exception ) { throw exception ; } return filterValuesList ; }
tr	1	@ Test @ Ignore public void haveDinner ( ) throws Exception { int eatTimes = 3 ; int numPhilosophers = 5 ; CountDownLatch waitTillAllInitialized = new CountDownLatch ( numPhilosophers ) ; CountDownLatch waitTillAllDoneDining = new CountDownLatch ( numPhilosophers ) ; AtomicInteger availableForks = new AtomicInteger ( numPhilosophers ) ; List < DiningPhilosopher > philosophers = new ArrayList < > ( ) ; for ( int i = 1 ; i <= numPhilosophers ; i ++ ) { DiningPhilosopher philosopher = new DiningPhilosopher ( i , availableForks , eatTimes , waitTillAllDoneDining ) ; philosophers . add ( philosopher ) ; } ImmutableList < DiningPhilosopher > allPhilosophers = new ImmutableList < > ( philosophers ) ; philosophers . forEach ( ( DiningPhilosopher philosopher ) -> { philosopher . start ( allPhilosophers , Registry . getDefault ( ) ) ; } ) ; waitTillAllDoneDining . await ( ) ; System . out . println ( "all philosophers done each dining " + eatTimes + " times" ) ; }
tr	2	@ Override public int compareTo ( PathNode o ) { if ( cost < o . cost ) return - 1 ; if ( cost > o . cost ) return 1 ; return 0 ; }
tr	2	@ Override public boolean remove ( Object o ) { Node < E > position = head ; for ( int i = 0 ; i < size ; i ++ ) { position = position . getNextNode ( ) ; if ( position . getValue ( ) == o ) { this . remove ( i ) ; return true ; } } return false ; }
tr	0	public int intensity_stereo_bound ( ) { return h_intensity_stereo_bound ; }
tr	0	public boolean get ( int value ) { assertValue ( value ) ; return ( bitset & 1 << value ) > 0 ; }
tr	3	public void loadFile ( ) { JFileChooser chooser = new JFileChooser ( executableDir ) ; FileNameExtensionFilter filter = new FileNameExtensionFilter ( "Pippin Executable Files" , "pipe" ) ; chooser . setFileFilter ( filter ) ; int openOK = chooser . showOpenDialog ( null ) ; if ( openOK == JFileChooser . APPROVE_OPTION ) { currentlyExecutingFile = chooser . getSelectedFile ( ) ; } if ( currentlyExecutingFile . exists ( ) ) { executableDir = currentlyExecutingFile . getAbsolutePath ( ) ; executableDir = executableDir . replace ( \ , / ) ; int lastSlash = executableDir . lastIndexOf ( / ) ; executableDir = executableDir . substring ( 0 , lastSlash + 1 ) ; try { properties . setProperty ( "SourceDirectory" , sourceDir ) ; properties . setProperty ( "ExecutableDirectory" , executableDir ) ; properties . store ( new FileOutputStream ( "propertyfile.txt" ) , "File locations" ) ; } catch ( Exception e ) { System . out . println ( "Error writing properties file" ) ; } } finalLoad_ReloadStep ( ) ; setChanged ( ) ; notifyObservers ( ) ; }
tr	9X	private void generateRandomBreakables ( ) { for ( int i = 3 ; i < 12 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 1 ) ; } } for ( int i = 3 ; i <= 13 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 2 ) ; } } for ( int i = 3 ; i <= 9 ; i ++ ) { for ( int j = 1 ; j <= 13 ; j += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( j , i ) ; } } } for ( int i = 1 ; i <= 11 ; i += 2 ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 10 ) ; } } for ( int i = 1 ; i <= 11 ; i ++ ) { if ( this . randomNumber ( 0 , 1 ) == 1 ) { this . addBreakable ( i , 11 ) ; } } }
tr	8	public static void mouseClicked ( MouseEvent mouseEvent ) { Iterator < PComponent > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { PComponent comp = it . next ( ) ; if ( comp == null ) continue ; if ( shouldHandleMouse ) { if ( comp . shouldHandleMouse ( ) ) comp . mouseClicked ( mouseEvent ) ; } else { if ( comp instanceof PFrame ) { for ( PComponent component : ( ( PFrame ) comp ) . getComponents ( ) ) if ( component . forceMouse ( ) ) component . mouseClicked ( mouseEvent ) ; } else if ( comp . forceMouse ( ) ) comp . mouseClicked ( mouseEvent ) ; } } }
tr	1	@ Override public int getColumnAmount ( ) { if ( this . optionTextFields [ 1 ] . getText ( ) . equals ( "" ) ) return 0 ; return Integer . parseInt ( this . optionTextFields [ 1 ] . getText ( ) ) ; }
tr	3	public static boolean isText ( int c ) { if ( isEnd ( c ) || isBreak ( c ) || isSpecial ( c ) ) return false ; return true ; }
tr	7	private String getOrientationString ( Orientations o ) { String os = "unknown" ; if ( o == Orientations . horizontal ) os = "horizontal" ; if ( o == Orientations . left ) os = "90\u00B0 left" ; if ( o == Orientations . right ) os = "90\u00B0 right" ; if ( o == Orientations . upside ) os = "180\u00B0" ; if ( myTFTType == TFTTypes . tft_320_240 ) { os = os + " (320x240)" ; } if ( myTFTType == TFTTypes . tft_800_480 ) { os = os + " (800x480)" ; } if ( myTFTType == TFTTypes . tft_480_272 ) { os = os + " (480x272)" ; } return os ; }
tr	8	private double [ ] [ ] inverso ( int [ ] [ ] llave ) { double [ ] [ ] inverso = new double [ llave . length ] [ llave [ 0 ] . length ] ; boolean signo = false ; for ( int f = 0 ; f < llave . length ; f ++ ) { for ( int c = 0 ; c < llave [ f ] . length ; c ++ ) { int [ ] [ ] matriz_de_adentro = new int [ llave . length - 1 ] [ llave [ f ] . length - 1 ] ; int fda = 0 , cda = 0 ; for ( int f2 = 0 ; f2 < llave . length ; f2 ++ ) { for ( int c2 = 0 ; c2 < llave [ f2 ] . length ; c2 ++ ) { if ( f2 != f && c2 != c ) { matriz_de_adentro [ fda ] [ cda ] = llave [ f2 ] [ c2 ] ; cda ++ ; if ( cda == matriz_de_adentro [ fda ] . length ) { cda = 0 ; fda ++ ; } } } } int dda = calcular_determinante ( matriz_de_adentro ) ; if ( signo ) { dda *= - 1 ; } signo = ! signo ; inverso [ f ] [ c ] = ( ( double ) dda ) / ( ( double ) DET ) ; } } return inverso ; }
tr	0	@ Override public void execute ( ) { light . on ( ) ; }
tr	6	public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c <   || c == + || c == % || c == = || c == ; ) { sb . append ( % ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Menu . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new Menu ( ) . setVisible ( true ) ; } } ) ; }
tr	4	public double evaluteTheStrategy ( ) { double sellSum = 0 ; double buySum = 0 ; int count = 0 ; int NumberOfSell = this . getNumberOfSell ( ) ; for ( GeneratedSignal gs : genSigList ) { if ( gs . getType ( ) . equals ( "sell" ) ) { sellSum += gs . getPrice ( ) ; } else if ( gs . getType ( ) . equals ( "buy" ) && count < NumberOfSell ) { buySum += gs . getPrice ( ) ; count ++ ; } } return ( sellSum - buySum ) ; }
tr	9X	public Geometry patch ( int m , int n , double basisMatrix [ ] [ ] , double data [ ] ) { newRectangularMesh ( m + 2 , n + 2 ) ; faces = new int [ m * n ] [ 4 ] ; for ( int k = 1 ; k < n + 1 ; k ++ ) for ( int j = 1 ; j < m + 1 ; j ++ ) { int f = ( k - 1 ) * m + j - 1 ; int v = k * ( m + 3 ) + j ; faces [ f ] [ 0 ] = v ; faces [ f ] [ 1 ] = v + 1 ; faces [ f ] [ 2 ] = v + m + 3 + 1 ; faces [ f ] [ 3 ] = v + m + 3 ; } double G [ ] [ ] [ ] = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) G [ k ] [ i ] [ j ] = data [ 12 * i + 3 * j + k ] ; Coefs = new double [ 3 ] [ 4 ] [ 4 ] ; for ( int k = 0 ; k < 3 ; k ++ ) constructBicubicCoefficients ( G [ k ] , basisMatrix , Coefs [ k ] ) ; int N = 0 ; for ( int j = - 1 ; j <= n + 1 ; j ++ ) { double v = ( double ) j / n ; for ( int i = - 1 ; i <= m + 1 ; i ++ ) { double u = ( double ) i / m ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = evalBicubic ( Coefs [ k ] , u , v ) ; N ++ ; } } computedMeshNormals = false ; return this ; }
tr	1	public void update ( M m , Connection conn ) { int result = update ( m , allFields ( ) , conn , "WHERE " + Cols . getSingle ( idFields ) . sqlName + "=?" , getId ( m ) ) ; if ( result != 1 ) { throw new RuntimeException ( "Failed to update record into " + tableName + " table" ) ; } }
tr	2	public ArrayList < Tile > getAdjacentTiles ( Tile tile ) { ArrayList < Tile > adjacentTiles = new ArrayList < Tile > ( ) ; for ( Direction direction : Direction . values ( ) ) { Tile nextTile = getTile ( tile . getGridX ( ) + direction . getXOffset ( ) , tile . getGridY ( ) + direction . getYOffset ( ) ) ; if ( nextTile != null ) { adjacentTiles . add ( nextTile ) ; } } return adjacentTiles ; }
tr	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; int v_4 ; int v_5 ; B_Y_found = false ; v_1 = cursor ; lab0 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "'" ) ) ) { break lab0 ; } ket = cursor ; slice_del ( ) ; } while ( false ) ; cursor = v_1 ; v_2 = cursor ; lab1 : do { bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab1 ; } ket = cursor ; slice_from ( "Y" ) ; B_Y_found = true ; } while ( false ) ; cursor = v_2 ; v_3 = cursor ; lab2 : do { replab3 : while ( true ) { v_4 = cursor ; lab4 : do { golab5 : while ( true ) { v_5 = cursor ; lab6 : do { if ( ! ( in_grouping ( g_v , 97 , 121 ) ) ) { break lab6 ; } bra = cursor ; if ( ! ( eq_s ( 1 , "y" ) ) ) { break lab6 ; } ket = cursor ; cursor = v_5 ; break golab5 ; } while ( false ) ; cursor = v_5 ; if ( cursor >= limit ) { break lab4 ; } cursor ++ ; } slice_from ( "Y" ) ; B_Y_found = true ; continue replab3 ; } while ( false ) ; cursor = v_4 ; break replab3 ; } } while ( false ) ; cursor = v_3 ; return true ; }
tr	6	boolean line ( ) throws IOException { int lev = integer ( ) - 1 ; if ( lev == - 1 ) return false ; int c = read ( ) ; if ( c == 1 ) { int len ; bb . reset ( ) ; while ( ( len = integer ( ) ) > 0 ) { bb . extend ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { bb . put ( ( byte ) read ( ) ) ; } } event . level ( lev ) ; event . event ( bb . clone ( ) ) ; return true ; } else if ( c > 1 ) { bb . reset ( ) ; bb . extend ( 64 ) ; bb . put ( ( byte ) c ) ; while ( ( c = read ( ) ) != 0 ) bb . put ( ( byte ) c ) ; event . level ( lev ) ; event . event ( new String ( bb . getBuffer ( ) , 0 , bb . length ( ) , "UTF-8" ) ) ; return true ; } else { event . level ( lev ) ; event . event ( "" ) ; } return true ; }
tr	9X	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == buttonAddDye ) { if ( ! ( textFDyeName . getText ( ) . isEmpty ( ) || textFDyePrice . getText ( ) . isEmpty ( ) ) ) { DyeParent newDye ; if ( radioDye . isSelected ( ) ) { newDye = new Dye ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioMetal . isSelected ( ) ) { newDye = new Metal ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else if ( radioLakk . isSelected ( ) ) { newDye = new Lakk ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; } else newDye = new Fluo ( textFDyeName . getText ( ) , double . parseDouble ( textFDyePrice . getText ( ) ) , null , 0 ) ; mainGui . getComboDyeType ( ) . addItem ( newDye ) ; table . addNotify ( ) ; textFDyeName . setText ( "" ) ; textFDyePrice . setText ( "" ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } else { if ( textFDyeName . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyeName , Color . RED , 200 ) ; } if ( textFDyePrice . getText ( ) . isEmpty ( ) ) { flashMyField ( textFDyePrice , Color . RED , 200 ) ; } } } else if ( e . getSource ( ) == buttonDelDye ) { int index = table . getSelectedRow ( ) ; if ( index >= 0 && index < table . getRowCount ( ) && PPC . calcObj . getAllDyeTypes ( ) . size ( ) > 1 ) { PPC . calcObj . removeDye ( index ) ; table . addNotify ( ) ; mainGui . getComboDyeType ( ) . setSelectedIndex ( 0 ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } } else if ( e . getSource ( ) == buttonSortDyes ) { PPC . calcObj . sortDyes ( ) ; model . fireTableDataChanged ( ) ; PPCDB . refreshDyeParents ( PPC . calcObj . getAllDyeTypes ( ) ) ; } }
tr	7	public void update ( ) { ArrayList < ArrayList < Entity >> entityarrays = new ArrayList < ArrayList < Entity >> ( entities . values ( ) ) ; for ( int x = 0 ; x < entityarrays . size ( ) ; x ++ ) { ArrayList < Entity > activeArray = entityarrays . get ( x ) ; for ( int y = 0 ; y < activeArray . size ( ) ; y ++ ) { Entity ent = activeArray . get ( y ) ; ArrayList < EffectPackage > effects = ent . getEffectPackages ( ) ; for ( int c = 0 ; c < effects . size ( ) ; c ++ ) { EffectPackage pack = effects . get ( c ) ; if ( pack . getEffect ( ) == Effect . MOVE_UP ) { levelchange = true ; changeto = level - 1 ; } else if ( pack . getEffect ( ) == Effect . MOVE_DOWN ) { levelchange = true ; changeto = level + 1 ; } } ent . update ( ) ; } } actors = new ArrayList < Actor > ( actorHashMap . values ( ) ) ; for ( int c = 0 ; c < actors . size ( ) ; c ++ ) { Actor a = actors . get ( c ) ; a . update ( ) ; Point pos = a . getPos ( ) ; if ( a . delete ( ) ) { actorHashMap . remove ( genKey ( pos . getX ( ) , pos . getY ( ) ) ) ; } } }
tr	5	protected com . akamon . slots . model . BetClass ParseBetClass ( BetClass xmlBetClass ) throws SlotModelException { int baseBet = xmlBetClass . basebet ; String betMultList = xmlBetClass . betMultList ; if ( betMultList . equals ( "*" ) || betMultList . toUpperCase ( ) . equals ( "ALL" ) ) return new com . akamon . slots . model . BetClass ( baseBet ) ; else { HashSet < Integer > betMults = new HashSet < Integer > ( ) ; String [ ] splitBetMultList = betMultList . split ( " " ) ; for ( int i = 0 ; i < splitBetMultList . length ; i ++ ) { try { int betMult = Integer . parseInt ( splitBetMultList [ i ] ) ; if ( betMults . contains ( betMult ) ) throw new com . akamon . slots . model . SlotModelException ( "Bet class has duplicate bet multipliers: " + betMultList ) ; betMults . add ( betMult ) ; } catch ( Exception e ) { throw new com . akamon . slots . model . SlotModelException ( "Invalid bet class value: " + splitBetMultList [ i ] ) ; } } return new com . akamon . slots . model . BetClass ( baseBet , betMults ) ; } }
tr	8	@ Override public void run ( ) { isRunning = true ; while ( isRunning ) { if ( mediaPlayer != null ) { if ( ! warningPassed && passedTime > TIME_GREEN ) { warningPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "dong03.wav" ) ; } if ( ! finishPassed && passedTime > TIME_YELLOW ) { finishPassed = true ; mediaPlayer . playMedia ( MainController . SOUND_PATH + "end.wav" ) ; } } try { SwingUtilities . invokeAndWait ( new Runnable ( ) { @ Override public void run ( ) { repaint ( ) ; } } ) ; } catch ( InterruptedException e ) { } catch ( InvocationTargetException e ) { } Thread . yield ( ) ; } }
tr	6	private static void processCase ( int caseNum ) { System . out . println ( "Field #" + caseNum + ":" ) ; mines = new int [ rows ] [ cols ] ; for ( int i = 0 ; i < rows ; i ++ ) { char [ ] line = in . nextLine ( ) . toCharArray ( ) ; for ( int j = 0 ; j < cols ; j ++ ) { if ( line [ j ] == * ) { mines [ i ] [ j ] = MINE ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < cols ; j ++ ) { if ( mines [ i ] [ j ] != MINE ) { System . out . print ( calc ( i , j ) ) ; } else { System . out . print ( * ) ; } } System . out . println ( ) ; } }
tr	0	public final int getSolutionMemoryMegabytes ( ) { return this . solutionMemoryMegabytes ; }
tr	1	public static SoundManager create ( class < ? > clazz ) throws IllegalArgumentException { return create ( clazz , new String ( ) ) ; }
tr	4	private static Expr resolveNoneParamExpr ( SyntaxTreeNode node ) { LexToken token = node . getToken ( ) ; String text = token . getText ( ) ; switch ( ( NagisaLexTokenType ) token . getType ( ) ) { case LITERAL_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerLiteral , text ) ; case IDENTIFIER_INTEGER : return new Expr ( ExprType . Integer , ExprOperator . IntegerVariableRef , text ) ; case LITERAL_STRING : return new Expr ( ExprType . String , ExprOperator . StringLiteral , text ) ; case IDENTIFIER_STRING : return new Expr ( ExprType . String , ExprOperator . StringVariableRef , text ) ; default : throw new UnsupportedOperationException ( token . toString ( ) ) ; } }
tr	5	private void constructGUIControls ( ) { Poseur singleton = Poseur . getPoseur ( ) ; PoseurStateManager poseurStateManager = singleton . getStateManager ( ) ; canvasSplitPane = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT ) ; appWindow = new AnimatedSpriteViewer ( ) ; PoseCanvasState zoomableCanvasState = poseurStateManager . getZoomableCanvasState ( ) ; zoomableCanvas = new PoseCanvas ( zoomableCanvasState ) ; zoomableCanvasState . setPoseCanvas ( zoomableCanvas ) ; zoomableCanvas . setBackground ( ZOOMABLE_CANVAS_COLOR ) ; northPanel = new JPanel ( ) ; northOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfNorthPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; southOfRightCanvas = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; vertical = new JScrollPane ( southOfRightCanvas ) ; MediaTracker tracker = new MediaTracker ( this ) ; int idCounter = 0 ; fileToolbar = new JToolBar ( ) ; newButton = ( JButton ) initButton ( NEW_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , NEW_TOOLTIP ) ; openButton = ( JButton ) initButton ( OPEN_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , OPEN_TOOLTIP ) ; saveButton = ( JButton ) initButton ( SAVE_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_TOOLTIP ) ; saveAsButton = ( JButton ) initButton ( SAVE_AS_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , SAVE_AS_TOOLTIP ) ; exportButton = ( JButton ) initButton ( EXPORT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXPORT_TOOLTIP ) ; exitButton = ( JButton ) initButton ( EXIT_IMAGE_FILE , fileToolbar , tracker , idCounter ++ , JButton . class , null , EXIT_TOOLTIP ) ; editToolbar = new JToolBar ( ) ; selectionButton = ( JButton ) initButton ( SELECTION_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , SELECT_TOOLTIP ) ; cutButton = ( JButton ) initButton ( CUT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , CUT_TOOLTIP ) ; copyButton = ( JButton ) initButton ( COPY_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , COPY_TOOLTIP ) ; pasteButton = ( JButton ) initButton ( PASTE_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , PASTE_TOOLTIP ) ; moveToBackButton = ( JButton ) initButton ( MOVE_TO_BACK_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_BACK_TOOLTIP ) ; moveToFrontButton = ( JButton ) initButton ( MOVE_TO_FRONT_IMAGE_FILE , editToolbar , tracker , idCounter ++ , JButton . class , null , MOVE_TO_FRONT_TOOLTIP ) ; shapeToolbar = new JToolBar ( ) ; shapeButtonGroup = new ButtonGroup ( ) ; lineToggleButton = ( JToggleButton ) initButton ( LINE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , LINE_TOOLTIP ) ; rectToggleButton = ( JToggleButton ) initButton ( RECT_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , RECT_TOOLTIP ) ; ellipseToggleButton = ( JToggleButton ) initButton ( ELLIPSE_SELECTION_IMAGE_FILE , shapeToolbar , tracker , idCounter ++ , JToggleButton . class , shapeButtonGroup , ELLIPSE_TOOLTIP ) ; DefaultComboBoxModel lineThicknessModel = new DefaultComboBoxModel ( ) ; for ( int i = 0 ; i < NUM_STROKES_TO_CHOOSE_FROM ; i ++ ) { String imageFileName = STROKE_SELECTION_FILE_PREFIX + ( i + 1 ) + PNG_FILE_EXTENSION ; Image img = batchLoadImage ( imageFileName , tracker , idCounter ++ ) ; ImageIcon ii = new ImageIcon ( img ) ; lineThicknessModel . addElement ( ii ) ; } lineStrokeSelectionComboBox = new JComboBox ( lineThicknessModel ) ; zoomToolbar = new JToolBar ( ) ; zoomOutButton = ( JButton ) initButton ( ZOOM_OUT_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_OUT_TOOLTIP ) ; zoomInButton = ( JButton ) initButton ( ZOOM_IN_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , ZOOM_IN_TOOLTIP ) ; zoomLabel = new JLabel ( ) ; zoomLabel . setFont ( ZOOM_LABEL_FONT ) ; updateZoomLabel ( ) ; dimensionsButton = ( JButton ) initButton ( POSE_DIMENSIONS_IMAGE_FILE , zoomToolbar , tracker , idCounter ++ , JButton . class , null , CHANGE_POSE_DIMENSIONS_TOOLTIP ) ; colorSelectionToolbar = new JToolBar ( ) ; colorButtonGroup = new ButtonGroup ( ) ; outlineColorSelectionButton = ( ColorToggleButton ) initButton ( OUTLINE_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , OUTLINE_TOOLTIP ) ; outlineColorSelectionButton . setBackground ( Color . BLACK ) ; fillColorSelectionButton = ( ColorToggleButton ) initButton ( FILL_COLOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , ColorToggleButton . class , colorButtonGroup , FILL_TOOLTIP ) ; fillColorSelectionButton . setBackground ( Color . WHITE ) ; outlineColorSelectionButton . setSelected ( true ) ; ColorPalletLoader cpl = new ColorPalletLoader ( ) ; ColorPalletState cps = new ColorPalletState ( ) ; cpl . initColorPallet ( COLOR_PALLET_SETTINGS_XML , cps ) ; colorPallet = new ColorPallet ( cps ) ; cps . setView ( colorPallet ) ; customColorSelectorButton = ( JButton ) initButton ( CUSTOM_COLOR_SELECTOR_IMAGE_FILE , colorSelectionToolbar , tracker , idCounter ++ , JButton . class , null , CUSTOM_COLOR_TOOLTIP ) ; alphaLabel = new JLabel ( ALPHA_LABEL_TEXT ) ; alphaLabel . setFont ( ALPHA_LABEL_FONT ) ; alphaLabel . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider = new JSlider ( JSlider . HORIZONTAL , TRANSPARENT , OPAQUE , OPAQUE ) ; transparencySlider . setBackground ( ALPHA_BACKGROUND_COLOR ) ; transparencySlider . setMajorTickSpacing ( ALPHA_MAJOR_TICK_SPACING ) ; transparencySlider . setMinorTickSpacing ( ALPHA_MINOR_TICK_SPACING ) ; transparencySlider . setPaintLabels ( true ) ; transparencySlider . setPaintTicks ( true ) ; transparencySlider . setPaintTrack ( true ) ; transparencySlider . setToolTipText ( ALPHA_TOOLTIP ) ; transparencySlider . setSnapToTicks ( false ) ; labelPoses = appWindow . getLabelPoses ( ) ; try { imagePose = ImageIO . read ( new File ( EDITPOSE_IMAGE_FILE ) ) ; System . out . println ( "Image has read" ) ; picLabelPose = new JLabel ( new ImageIcon ( imagePose ) ) ; } catch ( IOException ex ) { System . out . println ( "Did not read Image" ) ; } jtbEdit = new JToolBar ( ) ; idCounter = 0 ; btnNewPose = ( JButton ) initButton ( NEWPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , NEWPOSE_TOOLTIP ) ; btnSavePose = ( JButton ) initButton ( SAVEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , SAVEPOSE_TOOLTIP ) ; btnOpenPose = ( JButton ) initButton ( OPENPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , OPENPOSE_TOOLTIP ) ; btnDeletePose = ( JButton ) initButton ( DELETEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DELETEPOSE_TOOLTIP ) ; btnDuplicatePose = ( JButton ) initButton ( DUPLICATEPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DUPLICATEPOSE_TOOLTIP ) ; btnShiftLeftPose = ( JButton ) initButton ( SHIFTLEFT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , LEFTPOSE_TOOLTIP ) ; btnShifRighttPose = ( JButton ) initButton ( SHIFTRIGHT_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , RIGHTPOSE_TOOLTIP ) ; btnSetDurationPose = ( JButton ) initButton ( DURATIONPOSE_IMAGE_FILE , jtbEdit , tracker , idCounter ++ , JButton . class , null , DURATIONPOSE_TOOLTIP ) ; northOfZoomableCanvasPanel = new JPanel ( ) ; northOfZoomableCanvasPanel . setLayout ( new BorderLayout ( ) ) ; try { if ( ! appWindow . getCombo ( ) . getSelectedItem ( ) . toString ( ) . equals ( "Select Animation State" ) ) { this . setDisablePoseButton ( true ) ; } else { setDisablePoseButton ( false ) ; } } catch ( NullPointerException e ) { setDisablePoseButton ( false ) ; } try { tracker . waitForAll ( ) ; } catch ( InterruptedException ie ) { Logger . getLogger ( PoseurGUI . class . getName ( ) ) . log ( Level . SEVERE , null , ie ) ; } }
tr	2	private DefaultConstructorFactory getDefaultConstructorFactory ( ) { lock . lock ( ) ; try { DefaultConstructorFactory factory = null ; try { factory = new SunDefaultConstructorFactory ( ) ; } catch ( Exception e ) { } if ( factory == null ) factory = new NoDefaultConstructorFactory ( ) ; return factory ; } finally { lock . unlock ( ) ; } }
tr	9X	public void randommovement ( ) { if ( anim > 39 ) { if ( ! walking ) { number = random . nextInt ( 3 ) ; if ( number == 1 ) { randir = random . nextInt ( 4 ) ; int randis = random . nextInt ( 25 ) ; if ( randir == 0 ) yp += - randis ; if ( randir == 1 ) yp += randis ; if ( randir == 2 ) xp += - randis ; if ( randir == 3 ) xp += randis ; } } } if ( yp != 0 ) { if ( yp > 0 ) { ya ++ ; yp -- ; } if ( yp < 0 ) { ya -- ; yp ++ ; } } if ( xp != 0 ) { if ( xp > 0 ) { xa ++ ; xp -- ; } if ( xp < 0 ) { xa -- ; xp ++ ; } } }
tr	5	public boolean move ( Direction direction , StringBuffer output ) throws EndGameException { boolean hasMoved = false ; if ( myPosition . isCrossable ( direction ) ) { if ( myPosition . hasCharacter ( direction ) ) { Character defender = myPosition . getCharacter ( direction ) ; if ( attack ( defender ) ) { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You attacked and killed " + defender + ". You moved " + direction ) ; hasMoved = true ; } else { if ( isDead ( ) ) throw new EndGameException ( "Player has died. GAME OVER!" ) ; output . append ( "You attacked: \n" + defender . toString ( ) + "\n" + this . toString ( ) ) ; } } else { this . myPosition = myPosition . moveCharacter ( direction ) ; output . append ( "You moved " + direction + "." ) ; hasMoved = true ; } } else { output . append ( checkIfLockedExit ( direction ) ) ; } if ( hasMoved ) { notifyPositionChanged ( direction . getOppositeDirection ( ) ) ; } return hasMoved ; }
tr	6	public void start ( ) throws IllegalStateException { if ( instructions == null || endgamewindow == null || gameboard == null || lobby == null || loginsingup == null || newgame == null ) throw new IllegalStateException ( ) ; done = false ; attempConnection ( ) ; setState ( ModelStates . loginsingup ) ; newgame . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; endgamewindow . setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; Thread myThread = new Thread ( this ) ; myThread . start ( ) ; }
tr	1	public static TileObjectDisplayData getWeaponDisplayData ( Weapon w ) { TileObjectDisplayData data = getItemDisplayData ( w ) ; data . type = "Weapon" ; if ( w == null ) { data . addDatum ( "Attack" , "1" , true ) ; } else { data . addDatum ( "Attack" , Integer . toString ( w . getAttackValue ( ) ) , true ) ; } return data ; }
tr	7	public synchronized void tick ( ) { handleEvents ( ) ; updateWorkers ( ) ; for ( Sponsor sponsor : new ArrayList < Sponsor > ( sponsors ) ) { if ( sponsor . getMSLeft ( ) <= 0 ) sponsors . remove ( sponsor ) ; } Random r = new Random ( ) ; if ( sponsors . size ( ) < MAX_SPONSORS && r . nextInt ( ( int ) ( 1500 / Math . log ( getRenown ( ) + 2 ) ) ) == 0 ) { addSponsor ( ) ; } if ( getRenown ( ) <= 0 ) { showWindow ( null , new GameOverWindow ( ) ) ; } if ( r . nextInt ( DIFFICULTY ) == 0 ) { setRenown ( getRenown ( ) - 1 ) ; } if ( firstTick ) showWindow ( null , new HelpWindow ( ) ) ; firstTick = false ; }
tr	2	public void setMV ( String s ) throws ADataException { if ( s == null ) { mv = null ; return ; } if ( ! ( s . equals ( MENTAL ) | s . equals ( VITAL ) | s . equals ( SUPEREGO ) | s . equals ( SUPERID ) ) ) throw new ADataException ( ) ; this . mv = s ; }
tr	5	public static void merge ( int [ ] a , int [ ] aux , int lo , int mid , int hi ) { assert isSorted ( a , lo , mid ) ; assert isSorted ( a , mid + 1 , hi ) ; for ( int k = lo ; k <= hi ; k ++ ) aux [ k ] = a [ k ] ; int i = lo , j = mid + 1 ; for ( int k = lo ; k <= hi ; k ++ ) { if ( i > mid ) { a [ k ] = aux [ j ++ ] ; } else if ( j > hi ) { a [ k ] = aux [ i ++ ] ; } else if ( less ( aux [ j ] , aux [ i ] ) ) { a [ k ] = aux [ j ++ ] ; } else { a [ k ] = aux [ i ++ ] ; } } assert isSorted ( a , lo , hi ) ; }
tr	4	public void onSessionStatusChanged ( O2GSessionStatusCode status ) { System . out . println ( "Status: " + status . toString ( ) ) ; switch ( status ) { case TRADING_SESSION_REQUESTED : if ( mSessionID . isEmpty ( ) ) { System . out . println ( "Argument for trading session ID is missing" ) ; } else { mSession . setTradingSession ( mSessionID , mPin ) ; } break ; case CONNECTED : mConnected = true ; mDisconnected = false ; mSemaphore . release ( ) ; break ; case DISCONNECTED : mConnected = false ; mDisconnected = true ; mSemaphore . release ( ) ; break ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( RelVendasPorVendedor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new RelVendasPorVendedor ( ) . setVisible ( true ) ; } } ) ; }
tr	6	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . role != null ) { sb . append ( prefix ) . append ( "role=" ) . append ( this . role . getValue ( ) ) ; sb . append ( "&" ) ; } if ( this . name != null ) { String newPrefix = prefix + "name." ; sb . append ( this . name . toNVPString ( newPrefix ) ) ; } if ( this . fullLegalName != null ) { sb . append ( prefix ) . append ( "fullLegalName=" ) . append ( NVPUtil . encodeUrl ( this . fullLegalName ) ) ; sb . append ( "&" ) ; } if ( this . address != null ) { String newPrefix = prefix + "address." ; sb . append ( this . address . toNVPString ( newPrefix ) ) ; } if ( this . dateOfBirth != null ) { sb . append ( prefix ) . append ( "dateOfBirth=" ) . append ( NVPUtil . encodeUrl ( this . dateOfBirth ) ) ; sb . append ( "&" ) ; } if ( this . occupation != null ) { sb . append ( prefix ) . append ( "occupation=" ) . append ( NVPUtil . encodeUrl ( this . occupation ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
tr	5	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends Resource > T getOrLoadResource ( class < ? extends Resource > clazz , String resourceId , String filePath ) throws MapletResourceLoadException { if ( resources . containsKey ( resourceId ) ) { return ( T ) resources . get ( resourceId ) ; } else { ResourceType resourceType = clazz . getAnnotation ( ResourceType . class ) ; String [ ] fileExtensions = resourceType . extensions ( ) ; File resourceFile = null ; for ( String extension : fileExtensions ) { File file = new File ( MapletAPI . ROOT_DIRECTORY + filePath , resourceId + "." + extension ) ; if ( file . exists ( ) ) { resourceFile = file ; break ; } } if ( resourceFile != null ) { return loadResourceFromClass ( clazz , resourceId , resourceFile ) ; } else { throw new MapletResourceLoadException ( "Could not load resource file with ID '%s' in directory '%s'." , resourceId , filePath ) ; } } }
tr	1	public int getInt ( String propertyName , int defaultValue ) { CcsProperty property = getProperty ( propertyName ) ; int result = property == null ? defaultValue : Integer . parseInt ( property . getValue ( ) ) ; return result ; }
tr	6	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "OAuth 2.0 Token:" ) ; sb . append ( "\n  type: " ) ; sb . append ( type . toString ( ) ) ; if ( accessToken != null ) { sb . append ( "\n  access token: " ) ; sb . append ( accessToken ) ; } if ( refreshToken != null ) { sb . append ( "\n  refresh token: " ) ; sb . append ( refreshToken ) ; } if ( keyId != null ) { sb . append ( "\n  kid: " ) ; sb . append ( keyId ) ; } if ( macKey != null ) { sb . append ( "\n  mac key: " ) ; sb . append ( macKey ) ; } if ( macAlgorithm != null ) { sb . append ( "\n  mac algorithm: " ) ; sb . append ( macAlgorithm ) ; } if ( expiresIn != - 1 ) { sb . append ( "\n  expires in: " ) ; sb . append ( expiresIn ) ; } return sb . toString ( ) ; }
tr	4	public ListNode reverseKGroup1 ( ListNode head , int k ) { ListNode curr = head ; int count = 0 ; while ( curr != null && count != k ) { curr = curr . next ; count ++ ; } if ( count == k ) { curr = reverseKGroup ( curr , k ) ; while ( count -- > 0 ) { ListNode tmp = head . next ; head . next = curr ; curr = head ; head = tmp ; } head = curr ; } return head ; }
tr	7	@ Override public String execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { String data ; try { ArrayList < FilterBean > alFilter = new ArrayList < > ( ) ; if ( request . getParameter ( "filter" ) != null ) { if ( request . getParameter ( "filteroperator" ) != null ) { if ( request . getParameter ( "filtervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "filter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "filteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "filtervalue" ) ) ; oFilterBean . setFilterOrigin ( "user" ) ; alFilter . add ( oFilterBean ) ; } } } if ( request . getParameter ( "systemfilter" ) != null ) { if ( request . getParameter ( "systemfilteroperator" ) != null ) { if ( request . getParameter ( "systemfiltervalue" ) != null ) { FilterBean oFilterBean = new FilterBean ( ) ; oFilterBean . setFilter ( request . getParameter ( "systemfilter" ) ) ; oFilterBean . setFilterOperator ( request . getParameter ( "systemfilteroperator" ) ) ; oFilterBean . setFilterValue ( request . getParameter ( "systemfiltervalue" ) ) ; oFilterBean . setFilterOrigin ( "system" ) ; alFilter . add ( oFilterBean ) ; } } } RecompensaDao oRecompensaDAO = new RecompensaDao ( Conexion . getConection ( ) ) ; int pages = oRecompensaDAO . getCount ( alFilter ) ; data = "{\"data\":\"" + Integer . toString ( pages ) + "\"}" ; return data ; } catch ( Exception e ) { throw new ServletException ( "RecompensaGetregistersJson: View Error: " + e . getMessage ( ) ) ; } }
tr	7	public List < CodeList > parse ( XMLEventReader eventReader , StartElement startElement , ZipFile zipFile ) throws XMLStreamException , IOException , ExternalRefrenceNotFoundException { this . zipFile = zipFile ; List < CodeList > codeLists = new ArrayList < CodeList > ( ) ; boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextEvent ( ) ; switch ( event . getEventType ( ) ) { case XMLEvent . START_ELEMENT : StartElement se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeList" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . STRUCTURE_NAMESPACE ) ) { CodeList cl = processCodeList ( se , eventReader ) ; codeLists . add ( cl ) ; } break ; case XMLEvent . END_ELEMENT : EndElement endElement = event . asEndElement ( ) ; if ( endElement . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "CodeLists" ) && endElement . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( Constants . DEFAULT_NAMESPACE ) ) { endTagReached = true ; } break ; } } return codeLists ; }
tr	5	public void Editar ( Produto produto ) throws Exception { if ( produto == null ) { throw new Exception ( "Selecione um produto" ) ; } if ( produto . getIdProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o id do produto." ) ; } if ( produto . getNomeProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir o nome do produto." ) ; } if ( produto . getTipoProduto ( ) . isEmpty ( ) ) { throw new Exception ( "Favor inserir tipo do produto." ) ; } if ( produto . getValorProduto ( ) . equals ( "" ) ) { throw new Exception ( "Favor inserir o valor unit\u00E1rio do produto." ) ; } ProdutoController . obterInstancia ( ) . Editar ( produto ) ; }
tr	8	public List < HackResult > grok ( Reader reader ) throws IOException { long t0 = System . currentTimeMillis ( ) ; _HackContainer o = new _HackContainer ( ) ; Type t = new TypeToken < _HackContainer > ( ) { } . getType ( ) ; o = GSON . fromJson ( reader , t ) ; if ( o == null ) throw new IOException ( "GSON returned null!" ) ; L . info ( "Claimed size=" + o . total_rows ) ; if ( o . total_rows == 0 ) throw new IOException ( "GSON did not find objects!" ) ; List < HackResult > res = new ArrayList < HackResult > ( o . total_rows ) ; int total = 0 ; int count = 0 ; int canGetUltraCount = 0 ; for ( _HackRow r : o . rows ) { ++ count ; HackResult h = r . doc ; h . sourceLine = count ; if ( h . resos == null || h . hacker == null ) { L . warn ( "Skipping item " + count + " no resonators attached. id=" + h . _id ) ; continue ; } if ( L . isTraceEnabled ( ) ) L . trace ( String . format ( "  %5d %s\n" , count , h ) ) ; if ( h . hasCanGetUltra ( ) ) canGetUltraCount ++ ; total += h . getItemCount ( ) ; res . add ( h ) ; } long t1 = System . currentTimeMillis ( ) ; L . info ( "*** " + res . size ( ) + " hacks for " + total + " items  canGetUltraCount=" + canGetUltraCount + "  lengthCheck=" + ( res . size ( ) != o . total_rows ? "WARNING" : "OK" ) + " dt=" + ( t1 - t0 ) + " ms" ) ; return res ; }
tr	8	public void setRecursiveNotDirty ( ) { super . setRecursiveNotDirty ( ) ; this . isAltitudeModeDirty = false ; if ( this . location != null && this . location . isDirty ( ) ) { this . location . setRecursiveNotDirty ( ) ; } if ( this . orientation != null && this . orientation . isDirty ( ) ) { this . orientation . setRecursiveNotDirty ( ) ; } if ( this . scale != null && this . scale . isDirty ( ) ) { this . scale . setRecursiveNotDirty ( ) ; } if ( this . link != null && this . link . isDirty ( ) ) { this . link . setRecursiveNotDirty ( ) ; } }
tr	9X	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . contains ( "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	9X	public static void main ( String [ ] args ) { Utility . configure ( ) ; jobTrackerComm = new Communication ( Utility . JOBTRACKER . ipAddress , Utility . JOBTRACKER . port ) ; System . out . println ( "Registering on job tracker..." ) ; Message msg = new Message ( Utility . TASKTRACKERREG ) ; jobTrackerComm . sendMessage ( msg ) ; msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . REGACK ) { taskTrackerID = msg . getTaskTrackerID ( ) ; System . out . println ( "Successfully registered." ) ; } while ( isRunning ) { msg = jobTrackerComm . readMessage ( ) ; if ( msg . getMsgType ( ) == Utility . NEWJOB ) { JobContext jobContext = msg . getJobContext ( ) ; String jobID = jobContext . getJobID ( ) . getID ( ) ; System . out . println ( "Receiced new job from job[" + jobID + "] tracker" ) ; if ( ! jobContexts . containsKey ( jobID ) ) { jobContexts . put ( jobID , jobContext ) ; } msg = new Message ( Utility . NEWJOBACK ) ; jobTrackerComm . sendMessage ( msg ) ; } else if ( msg . getMsgType ( ) == Utility . RUNMAPPER ) { System . out . println ( "Received RUNMAPPER command from job tracker." ) ; List < MapBasicContext > mapBasicContexts = msg . getMapContexts ( ) ; if ( mapBasicContexts . size ( ) != 0 ) { String jobID = mapBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numMappers = mapBasicContexts . size ( ) ; launchMappers ( jobContext , mapBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . RUNREDUCER ) { System . out . println ( "Received RUNREDUCER command from job tracker." ) ; List < ReduceBasicContext > reduceBasicContexts = msg . getReduceContexts ( ) ; if ( reduceBasicContexts . size ( ) != 0 ) { String jobID = reduceBasicContexts . get ( 0 ) . getJobID ( ) . getID ( ) ; JobContext jobContext = jobContexts . get ( jobID ) ; numReducers = reduceBasicContexts . size ( ) ; launchReducers ( jobContext , reduceBasicContexts ) ; } } else if ( msg . getMsgType ( ) == Utility . CLOSE ) { isRunning = false ; } } jobTrackerComm . close ( ) ; }
tr	0	public void setProduto ( Produto produto ) { this . produto = produto ; }
tr	2	public void update ( float deltaTimeElapsedMs ) { speedX = bg1 . getSpeedX ( ) * 5 ; tileX += Util . factorByElapsedTimeMs ( speedX , deltaTimeElapsedMs ) ; tileBoundary . setBounds ( tileX , tileY , 40 , 40 ) ; if ( tileBoundary . intersects ( Player . perimeter ) && type != 0 ) { checkHorizontalCollision ( ) ; checkVerticalCollision ( ) ; } }
tr	6	public AudioDevice createAudioDevice ( ) throws JavaLayerException { AudioDevice device = null ; AudioDeviceFactory [ ] factories = getFactoriesPriority ( ) ; if ( factories == null ) throw new JavaLayerException ( this + ": no factories registered" ) ; JavaLayerException lastEx = null ; for ( int i = 0 ; ( device == null ) && ( i < factories . length ) ; i ++ ) { try { device = factories [ i ] . createAudioDevice ( ) ; } catch ( JavaLayerException ex ) { lastEx = ex ; } } if ( device == null && lastEx != null ) { throw new JavaLayerException ( "Cannot create AudioDevice" , lastEx ) ; } return device ; }
tr	5	@ Test public void testPacketSending ( ) throws SocketException { MicroSecondsTimeStamp stamper = mock ( MicroSecondsTimeStamp . class ) ; when ( stamper . timeStamp ( ) ) . thenReturn ( 0 ) ; UtpAlgorithm algorithm = new UtpAlgorithm ( stamper , new InetSocketAddress ( 51235 ) ) ; UtpAlgConfiguration . SEND_IN_BURST = true ; UtpAlgConfiguration . MAX_BURST_SEND = 3 ; int packetLength = 1000 ; algorithm . setMaxWindow ( packetLength * 10 ) ; UtpTimestampedPacketDTO pkt5 = createPacket ( 5 , packetLength ) ; UtpTimestampedPacketDTO pkt6 = createPacket ( 6 , packetLength ) ; UtpTimestampedPacketDTO pkt7 = createPacket ( 7 , packetLength ) ; UtpTimestampedPacketDTO pkt8 = createPacket ( 8 , packetLength ) ; UtpTimestampedPacketDTO pkt9 = createPacket ( 9 , packetLength ) ; algorithm . markPacketOnfly ( pkt5 . utpPacket ( ) , pkt5 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt6 . utpPacket ( ) , pkt6 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt7 . utpPacket ( ) , pkt7 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt8 . utpPacket ( ) , pkt8 . dataGram ( ) ) ; algorithm . markPacketOnfly ( pkt9 . utpPacket ( ) , pkt9 . dataGram ( ) ) ; assertEquals ( 5 * ( UtpPacketUtils . DEF_HEADER_LENGTH + packetLength ) , algorithm . getCurrentWindow ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; algorithm . setMaxWindow ( packetLength * 4 ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; } algorithm . setMaxWindow ( 10 * packetLength ) ; for ( int i = 0 ; i < UtpAlgConfiguration . MAX_BURST_SEND ; i ++ ) { assertEquals ( true , algorithm . canSendNextPacket ( ) ) ; } assertEquals ( false , algorithm . canSendNextPacket ( ) ) ; }
tr	5	public void wc ( MainClass mc , Encounter e ) { int x = mc . getXPos ( ) ; int y = mc . getYPos ( ) ; int k = e . getKeyPress ( ) ; if ( x >= 300 && x <= 450 ) { if ( y >= 40 && y <= 140 ) { e . win = false ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } } else if ( k == 10 ) { e . win = false ; e . setKeyPress ( 0 ) ; MainClass . getPlayer ( ) . addXP ( e . m . calculateXP ( ) ) ; MainClass . getPlayer ( ) . addGold ( e . m . getGold ( ) ) ; MainClass . getPlayer ( ) . setCurrentHP ( e . p . getCurrentHP ( ) ) ; mc . getMapHandler ( ) . getTheMap ( ) . getTile ( e . m . getCurTileX ( ) , e . m . getCurTileY ( ) ) . clearChar1 ( ) ; mc . getMapHandler ( ) . checkXP = true ; mc . setScreen ( "Map" ) ; } }
tr	4	public String getColumnName ( int c ) { switch ( c ) { case COL_RANK : return "#" ; case COL_NAME : return "Name" ; case COL_PRESENT : return "Present" ; case COL_BIDS : return "Bids" ; default : return "" ; } }
tr	0	private void effacer ( java . awt . event . ActionEvent evt ) { nomEtu . setText ( "" ) ; }
tr	9X	private void parseDocument ( int docNumber ) { Element docEle = docs . get ( docNumber ) . getDocumentElement ( ) ; NodeList nodelist = docEle . getElementsByTagName ( "room" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; String fileName = el . getTextContent ( ) ; parseXmlFile ( new File ( fileName ) ) ; } } for ( int i = 1 ; i < docs . size ( ) ; i ++ ) { Element roomdocEle = docs . get ( i ) . getDocumentElement ( ) ; NodeList roomnodelist = roomdocEle . getElementsByTagName ( "room" ) ; if ( roomnodelist != null && roomnodelist . getLength ( ) > 0 ) { for ( int j = 0 ; j < roomnodelist . getLength ( ) ; j ++ ) { Element roomElement = ( Element ) roomnodelist . item ( j ) ; getRoom ( roomElement ) ; } } } nodelist = docEle . getElementsByTagName ( "connect" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( i ) ; getConnection ( el ) ; } } nodelist = docEle . getElementsByTagName ( "player" ) ; if ( nodelist != null && nodelist . getLength ( ) > 0 ) { for ( int i = 0 ; i < nodelist . getLength ( ) ; i ++ ) { Element el = ( Element ) nodelist . item ( 0 ) ; mc = getPlayer ( el ) ; } } }
tr	9X	public String nextToken ( ) throws JSONException { char c ; char q ; StringBuffer sb = new StringBuffer ( ) ; do { c = next ( ) ; } while ( Character . isWhitespace ( c ) ) ; if ( c == " || c == ' ) { q = c ; for ( ; ; ) { c = next ( ) ; if ( c <   ) { throw syntaxError ( "Unterminated string." ) ; } if ( c == q ) { return sb . toString ( ) ; } sb . append ( c ) ; } } for ( ; ; ) { if ( c == 0 || Character . isWhitespace ( c ) ) { return sb . toString ( ) ; } sb . append ( c ) ; c = next ( ) ; } }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( EditStajFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new EditStajFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( obj instanceof GetAccountPolicyRequest == false ) return false ; GetAccountPolicyRequest other = ( GetAccountPolicyRequest ) obj ; if ( other . getAccountName ( ) == null ^ this . getAccountName ( ) == null ) return false ; if ( other . getAccountName ( ) != null && other . getAccountName ( ) . equals ( this . getAccountName ( ) ) == false ) return false ; if ( other . getPolicyName ( ) == null ^ this . getPolicyName ( ) == null ) return false ; if ( other . getPolicyName ( ) != null && other . getPolicyName ( ) . equals ( this . getPolicyName ( ) ) == false ) return false ; return true ; }
tr	8	@ Override protected void fillSamples ( List < Vector2 > samples , int numSamples ) { int n = ( int ) Math . sqrt ( ( float ) numSamples ) ; if ( n * n != numSamples ) { throw new RaytraceException ( "Number of samples are %d but must be a perfect square like %d!" , numSamples , n * n ) ; } float subcellWidth = 1.0f / ( ( float ) numSamples ) ; for ( int j = 0 ; j < numSamples ; j ++ ) samples . add ( new Vector2 ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { samples . get ( i * n + j ) . setX ( ( i * n + j ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; samples . get ( i * n + j ) . setY ( ( j * n + i ) * subcellWidth + rndFloat ( 0.0f , subcellWidth ) ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getX ( ) ; samples . get ( i * n + j ) . setX ( samples . get ( i * n + k ) . getX ( ) ) ; samples . get ( i * n + k ) . setX ( t ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int k = rndInt ( j , n - 1 ) ; float t = samples . get ( i * n + j ) . getY ( ) ; samples . get ( i * n + j ) . setY ( samples . get ( i * n + k ) . getY ( ) ) ; samples . get ( i * n + k ) . setY ( t ) ; } }
tr	2	public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int current = first ; while ( current != last ) { sb . append ( arr [ current ] . toString ( ) + " " ) ; if ( ++ current >= arr . length ) { current = 0 ; } } return sb . toString ( ) ; }
tr	1	@ Override public Object visitBooleanLiteral ( BooleanLiteral bool , Integer arg ) { if ( bool . spelling . equals ( "true" ) ) { Machine . emit ( Op . LOADL , Machine . trueRep ) ; } else { Machine . emit ( Op . LOADL , Machine . falseRep ) ; } return null ; }
tr	7	public boolean isCallableReference ( class clazz ) { if ( this == globalBridge ) { return false ; } if ( ! referencesEnabled ) { return false ; } if ( callableReferenceSet . contains ( clazz ) ) { return true ; } class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { if ( callableReferenceSet . contains ( interfaces [ i ] ) ) { return true ; } } class superClass = clazz . getSuperclass ( ) ; while ( superClass != null ) { if ( callableReferenceSet . contains ( superClass ) ) { return true ; } superClass = superClass . getSuperclass ( ) ; } return globalBridge . isCallableReference ( clazz ) ; }
tr	7	public RegisteredEventMonitor ( Method monitorMethod , Listener listener ) { EventMonitor monitorAnnotation = monitorMethod . getAnnotation ( EventMonitor . class ) ; if ( monitorAnnotation == null ) { throw new IllegalArgumentException ( "Monitor method does not have an EventMonitor annotation." ) ; } class < ? > [ ] monitorMethodParameters = monitorMethod . getParameterTypes ( ) ; if ( monitorMethodParameters . length != 2 || ! Event . class . isAssignableFrom ( monitorMethodParameters [ 0 ] ) || ! Result . class . isAssignableFrom ( monitorMethodParameters [ 1 ] ) ) { throw new IllegalArgumentException ( "Monitor method signature is invalid. Cannot accept (Event  Result)." ) ; } eventType = ( class < ? extends Event > ) monitorMethodParameters [ 0 ] ; this . monitorMethod = monitorMethod ; if ( ! monitorMethod . isAccessible ( ) ) { monitorMethod . setAccessible ( true ) ; } this . listener = listener ; }
tr	4	private void setUsersState ( int state ) { final int columnId = 0 ; if ( tableUsers . getSelectedRow ( ) != - 1 ) { int userId = ( Integer ) tableUsers . getValueAt ( tableUsers . getSelectedRow ( ) , columnId ) ; Statement statement = null ; ResultSet result = null ; try { statement = usersDAO . getConnection ( ) . createStatement ( ResultSet . TYPE_SCROLL_SENSITIVE , ResultSet . CONCUR_UPDATABLE ) ; result = statement . executeQuery ( usersDAO . getAllQuery ( ) ) ; while ( result . next ( ) ) { if ( result . getInt ( "ID" ) == userId ) { break ; } } result . updateInt ( "USERSTATE" , state ) ; result . updateRow ( ) ; usersDAO = new UsersDAO ( ) ; usersDAO . initTableModel ( tableUsers , usersDAO . listAll ( ) ) ; } catch ( SQLException exc ) { JOptionPane . showMessageDialog ( this , "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u0434\u0430\u043D\u043D\u044B\u0445" ) ; } } else { JOptionPane . showMessageDialog ( this , "\u041D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0435!" ) ; return ; } }
tr	5	public String getLatestTransmissionAttempt ( ) { if ( transmissionAttempts == 0 ) { return "no attempt yet" ; } switch ( transmissionAttempts ) { case 1 : return "first attempt" ; case 2 : return "second attempt" ; case 3 : return "third attempt" ; case 4 : return "fourth attempt" ; default : return "attempt #" + transmissionAttempts ; } }
tr	4	void onMouseHover ( int entered ) { switch ( entered ) { case GL_TRUE : for ( MouseHoverEvent e : _mouseHoverIn ) { e . run ( ) ; } break ; case GL_FALSE : for ( MouseHoverEvent e : _mouseHoverOut ) { e . run ( ) ; } break ; } }
tr	2	private void tarkistaKirjautuminen ( ) { kayttajatunnus = kayttajatunnusField . getText ( ) ; salasana = ripoffPassword ( salasanaField . getPassword ( ) ) ; Kayttajatunnus kayttaja = Database . tarkastaKirjautuminen ( kayttajatunnus , salasana ) ; if ( kayttaja == null ) { fail ( ) ; } else { if ( kayttaja . getSalasana ( ) . equals ( salasana ) ) { kirjaudu ( kayttaja ) ; } else { fail ( ) ; } } }
tr	9X	public static Method getMostSpecificMethod ( Method method , class < ? > targetClass ) { if ( method != null && isOverridable ( method , targetClass ) && targetClass != null && ! targetClass . equals ( method . getDeclaringClass ( ) ) ) { try { if ( Modifier . isPublic ( method . getModifiers ( ) ) ) { try { return targetClass . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ; } catch ( NoSuchMethodException ex ) { return method ; } } else { Method specificMethod = ReflectionUtils . findMethod ( targetClass , method . getName ( ) , method . getParameterTypes ( ) ) ; return ( specificMethod != null ? specificMethod : method ) ; } } catch ( SecurityException ex ) { } } return method ; }
tr	3	public int getPort ( ) { String num = getString ( "Port" ) ; if ( num == null || num . equals ( "" ) ) { return DEFAULT_PORT ; } try { return Integer . parseInt ( num , 10 ) ; } catch ( NumberFormatException ex ) { logger . warning ( "Bad value for listening port (" + num + ")" ) ; throw new IllegalStateException ( "Bad value for listening port (" + num + ")" , ex ) ; } }
tr	4	public ChemEquation ( Element [ ] elems , boolean full ) { first = new ArrayList < > ( ) ; second = new ArrayList < > ( ) ; this . full = full ; if ( full ) { boolean onReactants = false ; for ( Element elem : elems ) { if ( elem == null ) { onReactants = true ; } if ( onReactants ) { second . add ( elem ) ; } else { first . add ( elem ) ; } } } else { first . addAll ( Arrays . asList ( elems ) ) ; } }
tr	9X	private void execute ( ) { boolean running = true ; WatchKey key ; String dir = readProperties ( ) ; InboundWatcher watch = new InboundWatcher ( dir ) ; System . out . println ( "Starting the directory monitoring" ) ; System . out . println ( "Directory being monitored is: " + dir ) ; while ( running ) { try { key = watch . watcher . take ( ) ; } catch ( InterruptedException ie ) { return ; } for ( WatchEvent < ? > event : key . pollEvents ( ) ) { WatchEvent . Kind < ? > kind = event . kind ( ) ; if ( kind == StandardWatchEventKinds . ENTRY_CREATE ) { WatchEvent < Path > watchEventPath = ( WatchEvent < Path > ) event ; Path entry = watchEventPath . context ( ) ; if ( Pattern . matches ( "[so]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { SalesOrder . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( "[sr]{0 1}.+[\\.xml]" , entry . toString ( ) ) ) { StandardResponse . unmarshal ( dir , entry . toString ( ) ) ; } else if ( Pattern . matches ( ".+[\\.trg]" , entry . toString ( ) ) ) { File f = entry . toFile ( ) ; ShipAdvice . marshal ( f ) ; } } } key . reset ( ) ; if ( ! key . isValid ( ) ) { running = false ; } } }
tr	5	@ Override public String toString ( ) { String a = "" ; String b ; if ( ! playerScoreMinerals . keySet ( ) . equals ( playerShipLocations . keySet ( ) ) ) { for ( String s : playerScoreMinerals . keySet ( ) ) { System . out . println ( s ) ; } System . out . println ( "different from" ) ; for ( String s : playerShipLocations . keySet ( ) ) { System . out . println ( s ) ; } a = "\nthere seems to be an issue with the game state\n" ; } for ( String k : playerShipLocations . keySet ( ) ) { b = "" ; for ( BoardLocation bl : playerShipLocations . get ( k ) ) { b = b . concat ( " " + bl . row + " " + bl . col ) ; } a = a . concat ( k + ":" + b + "\n" ) ; a = a . concat ( k + " score:" + playerScoreMinerals . get ( k ) [ 0 ] + "\n" ) ; a = a . concat ( k + " minerals:" + playerScoreMinerals . get ( k ) [ 1 ] + "\n" ) ; } return a . concat ( separator ) ; }
tr	1	private void endExpression ( ) { String s = textHandler . end ( ) ; if ( s . length ( ) > 0 ) { container . add ( new Expression ( s , pass2 ) ) ; } }
tr	2	public void closeUpvalues ( int index ) { int loopIndex = upvalues . size ( ) ; while ( -- loopIndex >= 0 ) { UpValue upvalue = upvalues . elementAt ( loopIndex ) ; if ( upvalue . getIndex ( ) < index ) return ; upvalue . close ( ) ; upvalues . removeElementAt ( loopIndex ) ; } }
tr	8	public boolean isSameTree ( TreeNode p , TreeNode q ) { if ( p == null && q == null ) { return true ; } if ( p == null && q != null ) { return false ; } if ( p != null && q == null ) { return false ; } return ( p . val == q . val && isSameTree ( p . left , q . left ) && isSameTree ( p . right , q . right ) ) ; }
tr	3	@ Override public String toString ( ) { String result = null ; for ( SNode < E > nodeIt = this . frontNode ; nodeIt != null ; nodeIt = nodeIt . nextNode ) { if ( result == null ) { result = "[" + nodeIt . getElement ( ) . toString ( ) + "]" ; } else { result += " " + nodeIt . getElement ( ) . toString ( ) ; } } return result == null ? "empty" : result ; }
tr	7	private Object difference ( Object subtree1 , Object subtree2 , Object lo , Object hi ) { if ( subtree1 == null || subtree1 == subtree2 ) return null ; else if ( subtree2 == null ) return split ( subtree1 , lo , hi ) ; else if ( ! ( subtree1 instanceof Node ) ) { if ( ! ( subtree2 instanceof Node ) ) return difference ( ( Object [ ] ) subtree1 , ( Object [ ] ) subtree2 , lo , hi ) ; else { Node n2 = ( Node ) subtree2 ; Object elt2 = n2 . element ; Object elt1 = findEquiv ( subtree1 , elt2 ) ; Object new_left = difference ( trim ( subtree1 , lo , elt2 ) , trim ( n2 . left , lo , elt2 ) , lo , elt2 ) ; Object new_right = difference ( trim ( subtree1 , elt2 , hi ) , trim ( n2 . right , elt2 , hi ) , elt2 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } } else { Node n1 = ( Node ) subtree1 ; Object elt1 = n1 . element ; Object elt2 = findEquiv ( subtree2 , elt1 ) ; Object new_left = difference ( n1 . left , trim ( subtree2 , lo , elt1 ) , lo , elt1 ) ; Object new_right = difference ( n1 . right , trim ( subtree2 , elt1 , hi ) , elt1 , hi ) ; Object diff = equivDiff ( elt1 , elt2 ) ; if ( diff == NO_ELEMENT ) return join ( new_left , new_right ) ; else return concat ( diff , new_left , new_right ) ; } }
tr	7	public String toFirstUpperCase ( String title ) { if ( title . length ( ) == 0 ) return "" ; String upperCase = title . substring ( 0 , 1 ) . toUpperCase ( ) ; boolean isTheFirst = false ; if ( title . length ( ) > 1 ) for ( int i = 1 ; i < title . length ( ) ; i ++ ) { if ( title . charAt ( i ) ==   ) { upperCase += title . substring ( i , i + 1 ) ; if ( i + 1 < title . length ( ) && ! title . substring ( i + 1 , i + 2 ) . equals ( " " ) ) isTheFirst = true ; } else { if ( isTheFirst ) { upperCase += title . substring ( i , i + 1 ) . toUpperCase ( ) ; isTheFirst = false ; } else { upperCase += title . substring ( i , i + 1 ) ; } } } System . out . println ( upperCase ) ; return upperCase ; }
tr	2	public void draw ( ) { while ( ! ( glapi . isCloseRequest ( ) || Keyboard . isKeyDown ( Keyboard . KEY_Q ) ) ) { glapi . defaultMovements ( ) ; glapi . glLoopBegin ( ) ; glapi . glLoopEnd ( ) ; } glapi . destroyDisplay ( ) ; }
tr	9X	@ Override public Party getEnemyParty ( int level ) { Party party = new Party ( ) ; Random gen = new Random ( ) ; if ( level == 1 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Goblin ( ) ) ; else party . add ( new Rat ( ) ) ; } else if ( level == 2 ) { if ( gen . nextInt ( 2 ) == 0 ) party . add ( new Orc ( ) ) ; else party . add ( new Zombie ( ) ) ; } else if ( level == 3 ) { party . add ( new Spider ( ) ) ; } else if ( level == 5 ) { party . add ( new Ogre ( ) ) ; } else if ( level == 7 ) { party . add ( new Gargoyle ( ) ) ; } else if ( level == 15 ) { party . add ( new Dragon ( ) ) ; } else { do { int enemy = gen . nextInt ( level ) + 1 ; party . addAll ( getEnemyParty ( enemy ) ) ; level = level - enemy ; } while ( level != 0 ) ; } return party ; }
tr	9X	@ SuppressWarnings ( "unchecked" ) public static boolean isNotEmpty ( Object obj ) { if ( obj == null ) { return false ; } else if ( obj instanceof Collection ) { if ( ( ( Collection ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof List ) { if ( ( ( List ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Map ) { if ( ( ( Map ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Set ) { if ( ( ( Set ) obj ) . size ( ) <= 0 ) return false ; } else if ( obj instanceof Vector ) { if ( ( ( Vector ) obj ) . size ( ) <= 0 ) return false ; } else { if ( obj . toString ( ) . trim ( ) . length ( ) <= 0 || "null" . equals ( obj . toString ( ) . trim ( ) ) ) return false ; } return true ; }
tr	8	protected long skipBytes ( long bytes ) throws BasicPlayerException { long totalSkipped = 0 ; if ( m_dataSource instanceof File ) { int previousStatus = m_status ; m_status = SEEKING ; long skipped = 0 ; try { synchronized ( m_audioInputStream ) { notifyEvent ( BasicPlayerEvent . SEEKING , getEncodedStreamPosition ( ) , - 1 , null ) ; initAudioInputStream ( ) ; if ( m_audioInputStream != null ) { while ( totalSkipped < ( bytes - SKIP_INACCURACY_SIZE ) ) { skipped = m_audioInputStream . skip ( bytes - totalSkipped ) ; if ( skipped == 0 ) break ; totalSkipped = totalSkipped + skipped ; if ( totalSkipped == - 1 ) throw new BasicPlayerException ( BasicPlayerException . SKIPNOTSUPPORTED ) ; } } } notifyEvent ( BasicPlayerEvent . SEEKED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_status = OPENED ; if ( previousStatus == PLAYING ) startPlayback ( ) ; else if ( previousStatus == PAUSED ) { startPlayback ( ) ; pausePlayback ( ) ; } } catch ( IOException e ) { throw new BasicPlayerException ( e ) ; } } return totalSkipped ; }
tr	6	public void start ( String args [ ] ) { try { this . host = args [ 0 ] ; this . tcpPort = Integer . parseInt ( args [ 1 ] ) ; this . analyticServerRef = args [ 2 ] ; } catch ( NumberFormatException e ) { logger . error ( "Seconds argument has to be an integer" ) ; } catch ( ArrayIndexOutOfBoundsException e ) { logger . error ( "Too few arguments" ) ; } PropertyConfigurator . configure ( "src/log4j.properties" ) ; readProperties ( ) ; managementClient = new ManagementClient ( analyticServerRef ) ; managementClient . start ( ) ; managementClient . processInput ( "!subscribe .*" ) ; for ( int i = 0 ; i < clients ; i ++ ) { LoadTestClient client = new LoadTestClient ( host , tcpPort ) ; testClients . add ( client ) ; if ( auctionsPerMin > 0 ) client . createAuctions ( auctionsPerMin , auctionDuration ) ; if ( bidsPerMin > 0 ) client . bidAuctions ( bidsPerMin ) ; executorService . execute ( client ) ; } LoadTestClient updater = new LoadTestClient ( host , tcpPort ) ; testClients . add ( updater ) ; updater . updateList ( updateIntervalSec ) ; executorService . execute ( updater ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { input . readLine ( ) ; input . close ( ) ; } catch ( IOException ex ) { logger . error ( "IO Exception on System Standard Input" ) ; } shutdown ( ) ; }
tr	5	public void handle ( Connection connection , Request request ) { logger . debug ( "NickCommand handler : " + request ) ; if ( StringUtils . isEmpty ( request . getArgs ( ) ) ) { connection . serverSendCommandToMe ( "431 ERR_NONICKNAMEGIVEN :No nickname given" ) ; return ; } String newNickname = request . getArgs ( ) . trim ( ) ; String oldNickName = connection . getNickname ( ) ; if ( newNickname . startsWith ( ":" ) ) { newNickname = newNickname . substring ( 1 ) ; } if ( ! isNickCorrectlyFormat ( newNickname ) ) { connection . serverSendCommandToMe ( "432 ERR_ERRONEUSNICKNAME " + newNickname + " :Erroneus nickname" ) ; return ; } if ( connection . isNickExist ( newNickname ) ) { connection . serverSendCommandToMe ( "433 ERR_NICKNAMEINUSE " + newNickname + " :Nickname is already in use" ) ; return ; } if ( StringUtils . isNotEmpty ( oldNickName ) ) { connection . meSendCommandToAll ( "NICK " + newNickname ) ; } connection . setNickname ( newNickname ) ; }
tr	4	private Constant simplifySub ( AbstractBinaryOperator binaryOperator , AbstractMutableFormula left , AbstractMutableFormula right ) { if ( binaryOperator instanceof SubOperator && left instanceof Variable && right instanceof Variable && ( ( Variable ) left ) . getName ( ) . equals ( ( ( Variable ) right ) . getName ( ) ) ) { return new Constant ( 0 ) ; } return null ; }
tr	3	public static boolean onOneLine ( XY xy , XY xy2 ) { if ( xy2 . getX ( ) == xy . getX ( ) ) { return true ; } if ( xy2 . getY ( ) == xy . getY ( ) ) { return true ; } int dx = Math . abs ( xy2 . getX ( ) - xy . getX ( ) ) ; int dy = Math . abs ( xy2 . getY ( ) - xy . getY ( ) ) ; if ( dx == dy ) { return true ; } return false ; }
tr	0	@ XmlElementDecl ( namespace = "http://www.akamon.com/slots/gameconfigdata.xsd" , name = "GameConfigData" ) public JAXBElement < GameConfigData > createGameConfigData ( GameConfigData value ) { return new JAXBElement < GameConfigData > ( _GameConfigData_QNAME , GameConfigData . class , null , value ) ; }
tr	8	public int getResult ( ) { sqrs . add ( 1 ) ; sqrs . add ( 4 ) ; for ( int sum = 6 ; ; sum ++ ) { if ( sum % 300 == 0 ) { System . out . println ( sum + " debug " ) ; System . out . println ( sqrs . size ( ) + " siize " ) ; } for ( int i = sum - 3 ; i > sum / 2 ; i -- ) { for ( int j = i - 1 ; j > 2 ; j -- ) { int k = sum - i - j ; if ( k >= j || k <= 0 ) continue ; if ( i + j + k == sum ) { if ( checkSum ( i , j , k ) ) { System . out . println ( i + " " + j + " " + k + " sum " + sum ) ; return sum ; } } } } } }
tr	4	private void addSegmentsFor ( Obstacle source , Obstacle target ) { if ( source . intersects ( target ) ) addAllSegmentsBetween ( source , target ) ; else if ( target . bottom ( ) - 1 < source . y ) addSegmentsTargetAboveSource ( source , target ) ; else if ( source . bottom ( ) - 1 < target . y ) addSegmentsTargetAboveSource ( target , source ) ; else if ( target . right ( ) - 1 < source . x ) addSegmentsTargetBesideSource ( source , target ) ; else addSegmentsTargetBesideSource ( target , source ) ; }
tr	4	public void removeRange ( int start , int end ) { if ( end >= size ) { throw new IndexOutOfBoundsException ( "end can't be >= size: " + end + " >= " + size ) ; } if ( start > end ) { throw new IndexOutOfBoundsException ( "start can't be > end: " + start + " > " + end ) ; } int [ ] items = this . items ; int count = end - start + 1 ; if ( ordered ) { System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; } else { int lastIndex = this . size - 1 ; for ( int i = 0 ; i < count ; i ++ ) { items [ start + i ] = items [ lastIndex - i ] ; } } size -= count ; }
tr	0	public UserSessionVO getUserSessionVO ( ) { return userSessionVO ; }
tr	4	public static void main ( String [ ] args ) { System . out . println ( "Main menu" ) ; System . out . println ( "1. Add" ) ; System . out . println ( "2. Subtract" ) ; System . out . println ( "3. Multiply" ) ; System . out . println ( "4. Divide" ) ; System . out . print ( "Press 1  2  3 or 4 >>> " ) ; Scanner scan = new Scanner ( System . in ) ; int key = scan . nextInt ( ) ; System . out . print ( "enter first number >>> " ) ; float a = scan . nextFloat ( ) ; System . out . print ( "enter second number >>> " ) ; float b = scan . nextFloat ( ) ; switch ( key ) { case 1 : System . out . println ( "result of " + a + " + " + b + " = " + ( a + b ) ) ; break ; case 2 : System . out . println ( "result of " + a + " - " + b + " = " + ( a - b ) ) ; break ; case 3 : System . out . println ( "result of " + a + " * " + b + " = " + ( a * b ) ) ; break ; case 4 : Zero_Devide zeroDevide = new Zero_Devide ( ) ; zeroDevide . isDevideByZero ( a , b ) ; break ; default : System . out . println ( "Unknown Operator !!!" ) ; } System . out . println ( "Good bye !!!" ) ; }
tr	2	public void exit ( ) { for ( List < GameSystem > s : systems . values ( ) ) { for ( GameSystem system : s ) { system . exit ( ) ; } } systems . clear ( ) ; }
tr	1	@ Override public void setDataVector ( Vector newData , Vector columnNames ) { if ( newData == null ) { throw new IllegalArgumentException ( "setDataVector1() - Null parameter" ) ; } super . setDataVector ( dataVector , columnNames ) ; dataVector = newData ; attributiveModel = new DefaultCellAttribute ( dataVector . size ( ) , columnIdentifiers . size ( ) ) ; newRowsAdded ( new TableModelEvent ( this , 0 , getRowCount ( ) - 1 , TableModelEvent . ALL_COLUMNS , TableModelEvent . INSERT ) ) ; }
tr	9X	public String fwla_to_fsp ( String name ) { if ( name . indexOf ( . ) == - 1 ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String object = name . substring ( 0 , name . indexOf ( . ) ) ; String event = name . substring ( name . indexOf ( . ) + 1 ) ; String _res = "" ; if ( object == null || object . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; if ( event == null || event . isEmpty ( ) ) throw new java . lang . Error ( "The supplied string apears not to have the form <object>.<event>" ) ; String _object = null ; if ( elemsMap . containsKey ( object ) ) { _object = elemsMap . get ( object ) ; } else if ( netsMap . containsKey ( object ) ) { _object = netsMap . get ( object ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + object ) ; } assert ( _object != null ) ; LinkedList < String > _net_prefix = new LinkedList < String > ( ) ; boolean found = find_object ( _object , this . fsp_spec . root ( ) , _net_prefix ) ; assert ( found ) ; for ( String s : _net_prefix ) _res += s + "." ; if ( renamesMap . containsKey ( _object + "." + event ) ) { _res += renamesMap . get ( _object + "." + event ) ; } else { throw new java . lang . Error ( "No name mapping could be found for " + _object + "." + event ) ; } assert ( _res != null ) ; return _res ; }
tr	0	public void setWeight ( int weight ) { this . weight = weight ; }
tr	3	public static JsonObjectBuilder rewriteJson ( JsonObjectBuilder copyInto , JsonValue tree , String key ) { switch ( tree . getValueType ( ) ) { case OBJECT : JsonObject obj = ( JsonObject ) tree ; for ( String name : obj . keySet ( ) ) { copyInto = rewriteJson ( copyInto , obj . get ( name ) , name ) ; } break ; case STRING : JsonString st = ( JsonString ) tree ; copyInto . add ( key , st . getString ( ) ) ; break ; default : break ; } return copyInto ; }
tr	3	public static final void closeWindow ( ) { if ( clickListener != null ) { clickListener . removeHandler ( ) ; } if ( keyPressListener != null ) { keyPressListener . removeHandler ( ) ; } if ( blurListener != null ) { blurListener . removeHandler ( ) ; } Alerts . closeWindow ( ) ; }
tr	6	private static RubixPermutation parseMove ( char m ) { switch ( m ) { case F : return RubixPermutation . FRONT ; case B : return RubixPermutation . BACK ; case L : return RubixPermutation . LEFT ; case R : return RubixPermutation . RIGHT ; case U : return RubixPermutation . UP ; case D : return RubixPermutation . DOWN ; default : return RubixPermutation . IDENTITY ; } }
tr	8	@ Override public void visit ( CannyEvent cannyEvent ) { try { if ( model . getCurrentImagePath ( ) == null || model . getCurrentImagePath ( ) . isEmpty ( ) ) { throw new Exception ( "Brak pliku wej\u015Bciowego!" ) ; } String low_treshold_str = defaultViewChanger . showCannyParametersDialog ( true ) ; float low_treshold = 0.0f ; try { if ( low_treshold_str == null ) throw new NumberFormatException ( ) ; low_treshold = new float ( low_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 low_treshold: " + 0.5f ) ; low_treshold = 0.5f ; } String high_treshold_str = defaultViewChanger . showCannyParametersDialog ( false ) ; float high_treshold = 1.0f ; try { if ( high_treshold_str == null ) throw new NumberFormatException ( ) ; high_treshold = new float ( high_treshold_str ) ; } catch ( NumberFormatException e ) { System . out . println ( "Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; errorDialog . showErrorDialog ( "B\u0142\u0119dnie wpisania warto\u015B\u0107! Przyjmuje warto\u015B\u0107 domy\u015Bln\u0105 high_treshold: " + 1.0f ) ; high_treshold = 1.0f ; } Canny canny = new Canny ( low_treshold , high_treshold ) ; BufferedImage source ; System . out . println ( "Wczytuje plik \u017Ar\u00F3d\u0142owy..." ) ; source = ImageIO . read ( new File ( model . getCurrentImagePath ( ) ) ) ; System . out . println ( "Uruchamiam algorytm..." ) ; BufferedImage canny_image = canny . process ( source ) ; String output_name = "output/canny.png" ; saveImageToFile ( output_name , canny_image ) ; System . out . println ( "Wy\u015Bwietlam zdj\u0119cie..." ) ; defaultViewChanger . showModImage ( output_name ) ; } catch ( Exception e ) { if ( defaultViewChanger != null ) defaultViewChanger . showInformationDialog ( e . getMessage ( ) , "B\u0142\u0105d" , JOptionPane . ERROR_MESSAGE ) ; e . printStackTrace ( ) ; } }
tr	8	public SharingPanel ( int w , int h ) { super ( ) ; this . width = w ; this . height = h ; this . isSelected = false ; this . setBackground ( Constants . backColor ) ; this . setLayout ( null ) ; this . selectedInfo = "" ; bgImg = new JLabel ( new ImageIcon ( Constants . BackgroudPath . shareListBG . getPath ( ) ) ) ; bgImg . setBounds ( 0 , 0 , width , height ) ; shareTo = new ImageIcon [ 3 ] ; shareTo [ 0 ] = new ImageIcon ( Constants . IconPath . shareToIcon1 . getPath ( ) ) ; shareTo [ 1 ] = new ImageIcon ( Constants . IconPath . shareToIcon2 . getPath ( ) ) ; shareTo [ 2 ] = new ImageIcon ( Constants . IconPath . shareToIcon3 . getPath ( ) ) ; shareFrom = new ImageIcon [ 3 ] ; shareFrom [ 0 ] = new ImageIcon ( Constants . IconPath . shareFromIcon1 . getPath ( ) ) ; shareFrom [ 1 ] = new ImageIcon ( Constants . IconPath . shareFromIcon2 . getPath ( ) ) ; shareFrom [ 2 ] = new ImageIcon ( Constants . IconPath . shareFromIcon3 . getPath ( ) ) ; handler = new ActionHandler ( ) ; tableModel = new DefaultTableModel ( ) { @ Override public boolean isCellEditable ( int row , int column ) { return false ; } } ; tableModel . setColumnIdentifiers ( new String [ ] { "    User ID" , "    Directory" , "  Status" , "" , "" , "" } ) ; table = new JTable ( ) { public class getColumnClass ( int column ) { return getValueAt ( 0 , column ) . getClass ( ) ; } } ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . setRowHeight ( 30 ) ; table . setFont ( Constants . Font1 ) ; table . setModel ( tableModel ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 130 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 150 ) ; table . getColumnModel ( ) . getColumn ( 2 ) . setPreferredWidth ( 100 ) ; for ( int i = 3 ; i < 6 ; i ++ ) { table . getColumnModel ( ) . getColumn ( i ) . setPreferredWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMinWidth ( 0 ) ; table . getColumnModel ( ) . getColumn ( i ) . setMaxWidth ( 0 ) ; } table . getSelectionModel ( ) . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent event ) { if ( ! event . getValueIsAdjusting ( ) && ! editMode ) { isSelected = true ; selectedInfo = "" ; if ( table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareTo [ 0 ] ) || table . getValueAt ( table . getSelectedRow ( ) , 2 ) . equals ( shareFrom [ 0 ] ) ) { initialize ( ) ; if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Target" ) ) { selectedInfo = "Target" ; } else if ( table . getValueAt ( table . getSelectedRow ( ) , 3 ) . toString ( ) . equals ( "Requester" ) ) { selectedInfo = "Requester" ; } } changePanel ( ) ; } } } ) ; header = table . getTableHeader ( ) ; header . setFont ( Constants . Font2 ) ; header . setEnabled ( false ) ; renderer = new DefaultTableCellRenderer ( ) ; renderer . setHorizontalAlignment ( JLabel . CENTER ) ; renderer . setFont ( getFont ( ) . deriveFont ( 80f ) ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setCellRenderer ( renderer ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setCellRenderer ( renderer ) ; scroll = new JScrollPane ( table , ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS , ScrollPaneConstants . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; scroll . setBounds ( 200 , 200 , 400 , 250 ) ; btn = new JButton [ 4 ] ; btn [ 0 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . confirmBtn1 . getPath ( ) ) ) ; btn [ 0 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . confirmBtn2 . getPath ( ) ) ) ; btn [ 1 ] = new JButton ( new ImageIcon ( Constants . ButtonPath . cancelBtn1 . getPath ( ) ) ) ; btn [ 1 ] . setRolloverIcon ( new ImageIcon ( Constants . ButtonPath . cancelBtn2 . getPath ( ) ) ) ; for ( int i = 0 ; i < 2 ; i ++ ) { btn [ i ] . setBounds ( 420 + ( i * 100 ) , 160 , 80 , 30 ) ; btn [ i ] . addActionListener ( handler ) ; } this . add ( scroll ) ; this . add ( bgImg ) ; }
tr	3	public boolean method537 ( ) { if ( anIntArray658 == null ) return true ; boolean flag = true ; for ( int j = 0 ; j < anIntArray658 . length ; j ++ ) if ( ! Model . method463 ( anIntArray658 [ j ] ) ) flag = false ; return flag ; }
tr	9X	public static void main ( String [ ] args ) { char [ ] [ ] arr = new char [ ] [ ] { { i , l , o , v , e } , { d , i , n , t , e } , { n , e , w , e , p } , { a , i , v , r , i } , { m , a , x , e , c } } ; boolean [ ] [ ] flag = new boolean [ 5 ] [ 5 ] ; int count = 0 ; int i = 0 ; int j = 0 ; int direction = 0 ; System . out . print ( arr [ i ] [ j ] ) ; flag [ i ] [ j ] = true ; while ( count != ( 5 * 5 ) - 1 ) { switch ( direction ) { case 0 : { if ( j + 1 < 5 && ! flag [ i ] [ j + 1 ] ) { j ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 1 ; } break ; } case 1 : { if ( i + 1 < 5 && ! flag [ i + 1 ] [ j ] ) { i ++ ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 2 ; } break ; } case 2 : { if ( j - 1 > - 1 && ! flag [ i ] [ j - 1 ] ) { direction = 2 ; j -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 3 ; } break ; } case 3 : { if ( i - 1 > - 1 && ! flag [ i - 1 ] [ j ] ) { direction = 3 ; i -- ; count ++ ; flag [ i ] [ j ] = true ; System . out . print ( arr [ i ] [ j ] ) ; } else { direction = 0 ; } break ; } } } }
tr	7	public static String timeToString3 ( Date date ) { if ( date == null ) return "\u65E0" ; long milliSecond = System . currentTimeMillis ( ) - date . getTime ( ) ; int ss = 1000 ; int mi = ss * 60 ; int hh = mi * 60 ; long day = hh * 24 ; long month = day * 30 ; long year = month * 12 ; long years = ( milliSecond ) / year ; long months = ( long ) ( ( milliSecond - years * year ) / month ) ; long days = ( milliSecond - years * year - months * month ) / day ; long hour = ( long ) ( ( milliSecond - years * year - months * month - days * day ) / hh ) ; long minute = ( int ) ( ( milliSecond - years * year - months * month - days * day - hour * hh ) / mi ) ; long second = ( int ) ( ( milliSecond - years * year - months * month - days * day - hour * hh - minute * mi ) / ss ) ; String result = "" ; if ( years != 0 ) { result += years + "\u5E74\u524D" ; } else if ( months != 0 ) { result += months + "\u6708\u524D" ; } else if ( days != 0 ) { result += days + "\u5929\u524D" ; } else if ( hour != 0 ) { result += hour + "\u5C0F\u65F6\u524D" ; } else if ( minute != 0 ) { result += minute + "\u5206\u949F\u524D" ; } else if ( second != 0 ) { result += second + "\u79D2\u524D" ; } return result ; }
tr	0	public void setYear ( int year ) { this . year = year ; }
tr	9X	private static void saveSystemState ( String filename ) { String out = getParameterValueList ( ) + "\n" ; out += "Changed per state \n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( systemStateChangeds != null ) { for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += meth + "\t" ; } break ; } out += "\n" ; for ( String systemTestType : systemStateChangeds . keySet ( ) ) { for ( String meth : systemStateChangeds . get ( systemTestType ) . keySet ( ) ) { out += systemStateChangeds . get ( systemTestType ) . get ( meth ) + "\t" ; } out += "\n" ; } } out += "\n" ; out += "\n" ; out += "\t Mayority \t Confidence \t Weight \t Missfire \n" ; if ( lastSystemTestPoints != null ) for ( String s : lastSystemTestPoints . keySet ( ) ) { out += "\t" + s + "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Mayority" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Confidence" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Weight" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\t" ; out += ( String . format ( "%.3f" , ( lastSystemTestScore . get ( s ) . get ( "Missfire" ) / lastSystemTestPoints . get ( s ) ) ) ) ; out += "\n" ; } File f = new File ( filename ) ; try { if ( ! f . getParentFile ( ) . exists ( ) ) f . getParentFile ( ) . mkdirs ( ) ; if ( ! f . exists ( ) ) f . createNewFile ( ) ; FileWriter w = new FileWriter ( f ) ; w . write ( out ) ; w . flush ( ) ; w . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( ScienceTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	6	protected final Object computeRange ( ) { final List < double [ ] > raRange = new ArrayList < double [ ] > ( ) ; final double [ ] decRange = new double [ 2 ] ; if ( this . isPolesCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isNorthPoleCollision ( ) ) { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_DECLINATION ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isSouthPoleCollision ( ) ) { decRange [ MIN ] = SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_DECLINATION ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { decRange [ MIN ] = decUser - sizeArray [ 1 ] / 2.0 ; decRange [ MAX ] = decUser + sizeArray [ 1 ] / 2.0 ; if ( this . isBorderRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMaxRaCollision ( ) ) { raRange . add ( new double [ ] { raUser - sizeArray [ 0 ] / 2.0 , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else if ( this . isMinRaCollision ( ) ) { raRange . add ( new double [ ] { SimpleSpectralAccessProtocolLibrary . MIN_VALUE_FOR_RIGHT_ASCENSION , raUser + sizeArray [ 0 ] / 2.0 } ) ; raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } else { raRange . add ( new double [ ] { ( raUser - sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION , ( raUser + sizeArray [ 0 ] / 2.0 + SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION ) % SimpleSpectralAccessProtocolLibrary . MAX_VALUE_FOR_RIGHT_ASCENSION } ) ; } } return Arrays . asList ( raRange , decRange ) ; }
tr	6	private void readPolar ( ) throws IOException { long currTime ; while ( isRead ) { currTime = System . currentTimeMillis ( ) ; int msg = inputStream . read ( ) ; if ( msg == 254 ) { printMessage ( "\n" + System . currentTimeMillis ( ) + ": " ) ; polarMessageTmp = new PolarMessage ( System . currentTimeMillis ( ) ) ; } else if ( msg == - 1 ) { System . out . println ( "Roz\u0142\u0105czono" ) ; stopRead ( ) ; break ; } else if ( polarMessageTmp != null && polarMessageTmp . setNextValue ( msg ) ) { message = new PolarMessage ( System . currentTimeMillis ( ) ) ; message . setHr ( polarMessageTmp . getHr ( ) ) ; } if ( currTime - System . currentTimeMillis ( ) > 3000 ) { System . out . println ( "Zbyt d\u0142ugi czas oczekiwania" ) ; } printMessage ( " " + msg ) ; } }
tr	3	public Polygon getPolygon ( String s_nameCity ) { Polygon polygonToReturn = new Polygon ( ) ; for ( District district : model . getListDistrict ( ) ) { for ( City city : district . getListCity ( ) ) { if ( city . getS_name ( ) . equals ( s_nameCity ) ) { int i_x = district . getI_x ( ) * model . getI_nbHorizontalSquareInDistrict ( ) + city . getI_x ( ) + ( district . getI_y ( ) % 2 ) * model . getI_nbHorizontalSquareInDistrict ( ) / 2 ; int i_y = district . getI_y ( ) * model . getI_nbVerticalSquareInDistrict ( ) + city . getI_y ( ) ; Point point2D = new Point ( i_x , i_y ) ; polygonToReturn . setPoint2D ( point2D ) ; polygonToReturn . setPoint3D ( convert2DTo3D ( point2D ) ) ; return polygonToReturn ; } } } return polygonToReturn ; }
tr	8	private String subscribe ( String msg , iKPIC_subscribeHandler2 handler ) { deb_print ( "KpCore:subscribe method" ) ; int ret = 0 ; System . out . println ( "HERE!" ) ; if ( handler == null ) { this . KP_ERROR_ID = this . ERR_EVENT_HANDLER_NULL ; err_print ( "EVENT HANDLER IS NULL!!!" ) ; return null ; } deb_print ( "KpCore:SSAP:XML MESSAGE:\n" + msg ) ; deb_print ( "KpCore:SSAP:Open connection..." ) ; ret = openConnect ( ) ; if ( ret != this . ERR_Conected ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:connection error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Send message..." ) ; ret = send ( msg ) ; if ( ret != this . ERR_MsgSent ) { this . KP_ERROR_ID = ret ; err_print ( "ERROR:subscribeRDF:send error:" + this . getErrMess ( ) ) ; return null ; } deb_print ( "KpCore:SSAP:Message Sent..." ) ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; msg = "" ; int charRead = 0 ; try { while ( ( charRead = in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) { builder . append ( buffer , 0 , charRead ) ; msg = builder . toString ( ) ; if ( msg . contains ( "<SSAP_message>" ) && msg . contains ( "</SSAP_message>" ) ) { if ( this . xmlTools . isSubscriptionConfirmed ( msg ) ) { this . KP_ERROR_ID = this . ERR_Subscription_DONE ; System . out . println ( "1" ) ; kpSocket . setKeepAlive ( true ) ; Subscription s = new Subscription ( kpSocket , handler ) ; return msg ; } else { System . out . println ( "[90] UNKNOW MESSAGE:" + msg ) ; break ; } } } deb_print ( "KpCore:readByteXByteSIBmsg:READ LOOP TERMINATED" ) ; closeConnection ( ) ; } catch ( Exception e ) { err_print ( "KPICore:readByteXByteSIBmsg:Exception on EVENT HANDLER:RECEIVE:\n" + e ) ; this . KP_ERROR_ID = this . ERR_SOCKET_TIMEOUT ; } this . KP_ERROR_ID = this . ERR_Subscription_NOT_DONE ; deb_print ( "KpCore:SSAP:Message received:(" + msg + ")" ) ; return msg ; }
tr	9X	public static Method getAsMethodOfPublicBase ( class < ? > c , Method m ) { for ( class < ? > iface : c . getInterfaces ( ) ) { for ( Method im : iface . getMethods ( ) ) { if ( isMatch ( im , m ) ) { return im ; } } } class < ? > sc = c . getSuperclass ( ) ; if ( sc == null ) { return null ; } for ( Method scm : sc . getMethods ( ) ) { if ( isMatch ( scm , m ) ) { return scm ; } } return getAsMethodOfPublicBase ( sc , m ) ; }
tr	8	public Model getRotatedModel ( ) { Model model = aSpotAnim_1568 . getModel ( ) ; if ( model == null ) return null ; int j = aSpotAnim_1568 . aAnimation_407 . anIntArray353 [ anInt1569 ] ; Model model_1 = new Model ( true , Class36 . method532 ( j ) , false , model ) ; if ( ! aBoolean1567 ) { model_1 . method469 ( ) ; model_1 . method470 ( j ) ; model_1 . anIntArrayArray1658 = null ; model_1 . anIntArrayArray1657 = null ; } if ( aSpotAnim_1568 . anInt410 != 128 || aSpotAnim_1568 . anInt411 != 128 ) model_1 . method478 ( aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt410 , aSpotAnim_1568 . anInt411 ) ; if ( aSpotAnim_1568 . anInt412 != 0 ) { if ( aSpotAnim_1568 . anInt412 == 90 ) model_1 . method473 ( ) ; if ( aSpotAnim_1568 . anInt412 == 180 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; } if ( aSpotAnim_1568 . anInt412 == 270 ) { model_1 . method473 ( ) ; model_1 . method473 ( ) ; model_1 . method473 ( ) ; } } model_1 . method479 ( 64 + aSpotAnim_1568 . anInt413 , 850 + aSpotAnim_1568 . anInt414 , - 30 , - 50 , - 30 , true ) ; return model_1 ; }
tr	9X	private void readValues ( Buffer stream , int i ) { do { int opcode = stream . getUnsignedByte ( ) ; if ( opcode == 0 ) return ; if ( opcode == 1 ) stream . getUnsignedByte ( ) ; else if ( opcode == 2 ) stream . getUnsignedByte ( ) ; else if ( opcode == 3 ) anIntArray703 [ anInt702 ++ ] = i ; else if ( opcode == 4 ) { } else if ( opcode == 5 ) type = stream . getUnsignedLEShort ( ) ; else if ( opcode == 6 ) { } else if ( opcode == 7 ) stream . getInt ( ) ; else if ( opcode == 8 ) aBoolean713 = true ; else if ( opcode == 10 ) stream . getString ( ) ; else if ( opcode == 11 ) aBoolean713 = true ; else if ( opcode == 12 ) stream . getInt ( ) ; else if ( opcode == 13 ) { } else System . out . println ( "Error unrecognised config code: " + opcode ) ; } while ( true ) ; }
tr	1	public static ServiceFactory getInstance ( ) { if ( instance == null ) instance = new ServiceFactory ( ) ; return instance ; }
tr	4	public static byte [ ] decodeEncfs ( byte [ ] source ) { byte [ ] decodedInput = new byte [ source . length ] ; for ( int i = 0 ; i < source . length ; i ++ ) { int arrayIndex = source [ i ] ; if ( arrayIndex >= 0 ) { decodedInput [ i ] = _ENCFS_DECODABET [ source [ i ] ] ; } else { decodedInput [ i ] = - 9 ; } } int outputLen = ( source . length * 6 ) / 8 ; byte [ ] output = new byte [ outputLen ] ; int srcIdx = 0 ; int dstIdx = 0 ; int workBits = 0 ; long work = 0 ; while ( srcIdx < source . length ) { work |= decodedInput [ srcIdx ++ ] << workBits ; workBits += 6 ; while ( workBits >= 8 ) { output [ dstIdx ++ ] = ( byte ) ( work & ff ) ; work >>>= 8 ; workBits -= 8 ; } } return output ; }
tr	2	private String readStream ( Process proc , InputStream in ) { StringBuffer ret = new StringBuffer ( ) ; try { int n = in . read ( ) ; while ( n != - 1 ) { ret . append ( ( char ) n ) ; n = in . read ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( ThirdIdea . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return ret . toString ( ) ; }
tr	3	public void modifyCourse ( ClassInfo classInfo ) { ClassInfo cInfoData = getCourse ( classInfo . getClassNumber ( ) ) ; if ( cInfoData != null ) { if ( ! classInfo . getCourseName ( ) . equalsIgnoreCase ( cInfoData . getCourseName ( ) ) ) { Course crs = new Course ( ) ; crs . setCourseID ( classInfo . getCourseNumber ( ) ) ; crs . setCourseName ( classInfo . getCourseName ( ) ) ; saveDataModify ( crs ) ; } if ( ! classInfo . getCourseSection ( ) . equalsIgnoreCase ( cInfoData . getCourseSection ( ) ) ) { SchoolClass cls = new SchoolClass ( ) ; cls . setClassNumber ( classInfo . getClassNumber ( ) ) ; cls . setClassSection ( classInfo . getCourseSection ( ) ) ; saveDataModify ( cls ) ; } } }
tr	3	public void act ( List < Actor > newFoxes ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isAlive ( ) ) { giveBirth ( newFoxes ) ; Location newLocation = findFood ( ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( getLocation ( ) ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
tr	8	@ Test public void testPertenece2 ( ) { boolean expected = false ; boolean actual = arbolito . pertenece ( 8 ) && arbolito . pertenece ( 3 ) && arbolito . pertenece ( 6 ) && arbolito . pertenece ( 1 ) && arbolito . pertenece ( 16 ) && arbolito . pertenece ( 4 ) && arbolito . pertenece ( 7 ) && arbolito . pertenece ( 14 ) && arbolito . pertenece ( 13 ) ; assertEquals ( expected , actual ) ; }
tr	7	public char leerDato ( ) { char dato ; if ( isESTA_EN_RAM ( ) ) { if ( pos < data . length ( ) ) { dato = data . charAt ( pos ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } else { if ( "" . equals ( prox ) && lector . hasNext ( ) ) { prox = lector . next ( ) ; } else if ( "" . equals ( prox ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( pos >= prox . length ( ) ) { pos = 0 ; if ( lector . hasNext ( ) ) { prox = lector . next ( ) ; } else { throw new IndexOutOfBoundsException ( ) ; } } dato = prox . charAt ( pos ) ; } pos ++ ; return dato ; }
tr	9X	public PaymentDialog ( Member member , ClassType ct , String message , int flag ) { messageTextArea . setText ( message ) ; globalMember = member ; globalClassType = ct ; globalFlag = flag ; makePaymentButton = new JButton ( "Make Payment" ) ; makePaymentButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { Common . makePayment ( paymentTypeList . getSelectedValue ( ) , globalMember , ( Date ) utilDateModel . getValue ( ) , getPaymentAmount ( ) ) ; updatePaymentStatus ( globalMember , globalClassType ) ; dispose ( ) ; new PaymentDialog ( globalMember , globalClassType , "Payment made for " + globalMember . getName ( ) + "\n of " + getPaymentAmount ( ) + " for " + paymentTypeList . getSelectedValue ( ) . getPaymentTypeName ( ) + "\n up to date: " + ( ( Date ) utilDateModel . getValue ( ) ) . toString ( ) , globalFlag ) ; } } ) ; makePaymentButton . setEnabled ( false ) ; exitButton = new JButton ( "Exit" ) ; exitButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { dispose ( ) ; if ( globalFlag == 0 ) new MemberCheckInInterface ( globalClassType ) ; } } ) ; BufferedImage tkdIcon = CommonUI . getTkdIcon ( ) ; BufferedImage skyIcon = CommonUI . getSkyIcon ( ) ; BufferedImage kickIcon = CommonUI . getKickIcon ( ) ; Image img = null ; switch ( ct ) { case TAEKWONDO : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; break ; case SKYBOXING : img = new ImageIcon ( skyIcon ) . getImage ( ) ; break ; case KICKBOXING : img = new ImageIcon ( kickIcon ) . getImage ( ) ; break ; case OTHER : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; default : img = new ImageIcon ( tkdIcon ) . getImage ( ) ; } setIconImage ( img ) ; this . setTitle ( "Enter Payment for " + member . getName ( ) ) ; utilDateModel . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent arg0 ) { System . out . println ( "DateModel changed" ) ; setDateSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; panel . add ( paymentToPanel , BorderLayout . CENTER ) ; paymentTypeList . setListData ( Common . getPaymentTypes ( ct ) . toArray ( new PaymentType [ 1 ] ) ) ; paymentTypeList . addListSelectionListener ( new ListSelectionListener ( ) { @ Override public void valueChanged ( ListSelectionEvent arg0 ) { JList < PaymentType > tempList = ( JList < PaymentType > ) arg0 . getSource ( ) ; PaymentType pt = tempList . getSelectedValue ( ) ; paymentAmountTextField . setText ( String . format ( "%9.2f" , pt . getPaymentAmount ( ) ) ) ; setPaymentAmountFieldSelected ( ) ; if ( paymentAmountSelected && dateSelected ) { makePaymentButton . setEnabled ( true ) ; } } } ) ; listPanel . add ( paymentTypeList ) ; panel . add ( listPanel , BorderLayout . WEST ) ; paymentAmountPanel . add ( paymentAmountLabel ) ; paymentAmountPanel . add ( paymentAmountTextField ) ; buttonPanel . add ( paymentAmountPanel , BorderLayout . NORTH ) ; buttonPanel . add ( makePaymentButton , BorderLayout . WEST ) ; buttonPanel . add ( exitButton , BorderLayout . SOUTH ) ; panel . add ( buttonPanel , BorderLayout . SOUTH ) ; paymentStatusPanel . add ( paymentStatusTextArea , BorderLayout . NORTH ) ; paymentStatusPanel . add ( messageTextArea , BorderLayout . SOUTH ) ; updatePaymentStatus ( member , ct ) ; panel . add ( paymentStatusPanel , BorderLayout . EAST ) ; this . getContentPane ( ) . add ( panel ) ; this . setSize ( CommonUI . FULLSCREEN ) ; this . setVisible ( true ) ; }
tr	4	public void initFeatureAlphabets ( DependencyInstance inst ) { getFeatureVector ( inst ) ; int n = inst . length ; for ( SemanticFrame frame : inst . frames ) { int p = frame . predid ; createWordFeatureVector ( inst , p ) ; int [ ] args = frame . arglbids ; for ( int a = 0 ; a < n ; ++ a ) { boolean isValid = isValidPredAugPair ( inst , p , a ) ; if ( args [ a ] >= 0 && isValid ) { int r = args [ a ] ; createContextFeatureVector ( inst , p , a , r ) ; createPathFeatureVector ( inst , p , a , r ) ; createWordFeatureVector ( inst , a ) ; } } } }
tr	2	public int getCategorySize ( String name ) { Map < String , Actor > xactors = cloneActors ( ) ; int res = 0 ; for ( String key : xactors . keySet ( ) ) { Actor a = xactors . get ( key ) ; if ( a . getCategory ( ) . equals ( name ) ) { res ++ ; } } return res ; }
tr	9X	public List < Task > sort ( final int colIndex , final boolean sortDown ) { getTasks ( ) ; if ( colIndex >= 0 && colIndex <= 6 ) { Collections . sort ( tasks , new Comparator < Task > ( ) { @ Override public int compare ( Task arg0 , Task arg1 ) { int result = 0 ; if ( colIndex == 1 || colIndex == 2 || colIndex == 3 || colIndex == 5 || colIndex == 6 ) { StringComparer stringComparator = new StringComparer ( sortDown ) ; result = comparer ( stringComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 0 ) { IntegerComparer intComparator = new IntegerComparer ( sortDown ) ; result = comparer ( intComparator , arg0 , arg1 , colIndex ) ; } else if ( colIndex == 4 ) { DateComparer dateComparator = new DateComparer ( sortDown ) ; result = comparer ( dateComparator , arg0 , arg1 , colIndex ) ; } return result ; } } ) ; } else { throw new IllegalArgumentException ( "Invalid Column index." ) ; } return tasks ; }
tr	1	public int getMaxQuantity ( int quantity ) { if ( currentQuantity + quantity > maxQuantity ) { throw new StoreProblemException ( ) ; } return currentQuantity + quantity ; }
tr	5	public void paintTriangle ( Graphics g , int x , int y , int size ) { for ( int i = 0 ; i < size ; i ++ ) { switch ( facing ) { case UP : g . drawLine ( x - i , y - size / 2 + i , x + i , y - size / 2 + i ) ; break ; case DOWN : g . drawLine ( x - i , y + size / 2 - i , x + i , y + size / 2 - i ) ; break ; case LEFT : g . drawLine ( x - size / 2 + i , y - i , x - size / 2 + i , y + i ) ; break ; case RIGHT : g . drawLine ( x + size / 2 - i , y - i , x + size / 2 - i , y + i ) ; break ; } } }
tr	3	protected void fireTreeNodesRemoved ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) { e = new TreeModelEvent ( source , path , childIndices , children ) ; } ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesRemoved ( e ) ; } } }
tr	6	public static void main ( String [ ] args ) { int k = 0 ; try { k = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException e ) { System . out . println ( "Expected an argument with the number of elements to print." ) ; System . out . println ( "USAGE: Subset k - to print k values from the input." ) ; System . out . println ( "EXAMPLE: echo A B C D E F G H I | java Subset 3  => prints out 3 values from the input." ) ; } int n = 0 ; RandomizedQueue < String > rq = new RandomizedQueue < String > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String s = StdIn . readString ( ) ; n ++ ; if ( rq . size ( ) == k ) { final double rnd = StdRandom . uniform ( 1 , n + 1 ) ; if ( rnd <= k ) { rq . dequeue ( ) ; rq . enqueue ( s ) ; } } else { rq . enqueue ( s ) ; } } for ( int i = 0 ; i < k && ! rq . isEmpty ( ) ; i ++ ) { System . out . println ( rq . dequeue ( ) ) ; } }
tr	0	public String getFirstName ( ) { return firstName ; }
tr	7	private void updatePlayerList ( Buffer stream , int count ) { while ( stream . bitPosition + 10 < count * 8 ) { int pId = stream . readBits ( 11 ) ; if ( pId == 2047 ) break ; if ( players [ pId ] == null ) { players [ pId ] = new Player ( ) ; if ( playerAppearanceData [ pId ] != null ) players [ pId ] . updatePlayerAppearance ( playerAppearanceData [ pId ] ) ; } localPlayers [ localPlayerCount ++ ] = pId ; Player player = players [ pId ] ; player . lastUpdateTick = tick ; int observed = stream . readBits ( 1 ) ; if ( observed == 1 ) playersObserved [ playersObservedCount ++ ] = pId ; int teleported = stream . readBits ( 1 ) ; int x = stream . readBits ( 5 ) ; if ( x > 15 ) x -= 32 ; int y = stream . readBits ( 5 ) ; if ( y > 15 ) y -= 32 ; player . setPos ( localPlayer . waypointX [ 0 ] + y , localPlayer . waypointY [ 0 ] + x , teleported == 1 ) ; } stream . finishBitAccess ( ) ; }
tr	4	private int calcNumPattern ( int n , int r ) { if ( n == r ) return 1 ; else if ( n == 1 ) return 1 ; else if ( r == 1 ) return n ; if ( dp [ n ] [ r ] == 0 ) dp [ n ] [ r ] = ( calcNumPattern ( n - 1 , r - 1 ) + calcNumPattern ( n - 1 , r ) ) % NUM_MOD ; return dp [ n ] [ r ] ; }
tr	7	@ Override public boolean onResponse ( Message message ) { String msg = message . content . toLowerCase ( ) ; Pattern pattern = Pattern . compile ( "^@((qinbot)|(\u4EB2\u59B9\u5B50)) +help(.*)" ) ; Matcher matcher = pattern . matcher ( msg ) ; if ( matcher . find ( ) ) { if ( matcher . group ( 4 ) == null || matcher . group ( 4 ) . trim ( ) . equals ( "" ) ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "\\\\n\u8F93\u5165@QinBot help \u63D2\u4EF6\u540D\u79F0 \u83B7\u53D6\u5177\u4F53\u5E2E\u52A9\\\\n\u5F53\u524D\u63D2\u4EF6\u5982\u4E0B:\\\\n" ) ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { sb . append ( plugins . get ( i ) . name ) . append ( " ver:" ) . append ( plugins . get ( i ) . version ) . append ( "\\\\n" ) ; } message . reply ( sb . toString ( ) ) ; } else { String help = null ; for ( int i = 1 ; i < plugins . size ( ) ; i ++ ) { if ( plugins . get ( i ) . name . equals ( matcher . group ( 4 ) . trim ( ) ) ) { PluginBase pluginBase = plugins . get ( i ) ; help = String . format ( "\\\\n\u7B80\u4ECB:%s\\\\n\u5E2E\u52A9:%s\\\\n" , pluginBase . descrition , pluginBase . help ) ; break ; } } if ( help != null ) { message . reply ( help ) ; } else { message . reply ( "\u672A\u627E\u5230" + matcher . group ( 4 ) ) ; } } return true ; } return false ; }
tr	8	public ArrayList < Point > checkMove2 ( Stack < TTTBoard > boards , char player ) { ArrayList < Point > winningSpots = new ArrayList < Point > ( ) ; ArrayList < TTTBoard > tempArray = new ArrayList < TTTBoard > ( ) ; while ( ! boards . isEmpty ( ) ) { TTTBoard aBoard = boards . pop ( ) ; ArrayList < Point > spots = aBoard . getEmptySpots ( ) ; char turn = getChar ( spots . size ( ) ) ; ArrayList < TTTBoard > tempArray2 = new ArrayList < TTTBoard > ( ) ; for ( int i = 0 ; i < spots . size ( ) ; i ++ ) { TTTBoard board = new TTTBoard ( aBoard ) ; board . getBoard ( ) [ spots . get ( i ) . x ] [ spots . get ( i ) . y ] = turn ; if ( spots . size ( ) < 6 ) { if ( board . checkWin ( ) ) { if ( turn == player ) { winningSpots . add ( board . getStart ( ) ) ; break ; } else { break ; } } else { tempArray2 . add ( board ) ; } } else { tempArray . add ( board ) ; } } if ( tempArray2 . size ( ) == spots . size ( ) ) { tempArray . addAll ( tempArray2 ) ; } } if ( winningSpots . isEmpty ( ) && tempArray . get ( 0 ) . getEmptySpots ( ) . size ( ) != 0 ) { boards . addAll ( tempArray ) ; winningSpots = checkMove2 ( boards , player ) ; } return winningSpots ; }
tr	2	private static List < List < String >> clone ( List < List < String >> original ) { List < List < String >> clone = new ArrayList < List < String >> ( original . size ( ) ) ; for ( List < String > oStrings : original ) { List < String > cStrings = new ArrayList < String > ( oStrings . size ( ) ) ; for ( String oString : oStrings ) { cStrings . add ( oString ) ; } clone . add ( cStrings ) ; } return clone ; }
tr	7	@ Override public boolean combine ( AExecutionItem itemToAdd ) { if ( itemToAdd != null && itemToAdd . getClass ( ) == PreparedStatementExecutionItem . class ) { if ( this . query . toUpperCase ( ) . startsWith ( "INSERT" ) && ! this . query . toUpperCase ( ) . contains ( ";SELECT" ) ) { PreparedStatementExecutionItem otherItem = ( PreparedStatementExecutionItem ) itemToAdd ; if ( otherItem . query . toUpperCase ( ) . startsWith ( "INSERT" ) && ! otherItem . query . toUpperCase ( ) . contains ( ";SELECT" ) && otherItem . query . toLowerCase ( ) . equals ( query . toLowerCase ( ) ) ) { this . executionItems . add ( otherItem ) ; return true ; } } } return false ; }
tr	4	public static ChineseCharacter searchCharacter ( Integer [ ] intersection , int floatingPart , int straightStroke , int complexStroke ) { intersections = intersection ; floatingParts = floatingPart ; straightStrokes = straightStroke ; complexStrokes = complexStroke ; EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { PossibleChineseCharactersPanel . clearList ( ) ; Arrays . sort ( intersections ) ; for ( ChineseCharacter c : UniversalDataStorage . database ) { if ( c . getFloatingParts ( ) == floatingParts && Arrays . toString ( c . getIntersections ( ) . toArray ( ) ) . equals ( Arrays . toString ( intersections ) ) && ( c . getComplexStrokes ( ) + c . getStraightStrokes ( ) ) == ( complexStrokes + straightStrokes ) ) { String pinyin = c . getPinyin ( ) ; String character = c . getCharacter ( ) ; String meaning = c . getMeaning ( ) ; chinesecharacter = new ChineseCharacter ( pinyin , character , meaning , floatingParts , new ArrayList < Integer > ( Arrays . asList ( intersections ) ) , straightStrokes , complexStrokes ) ; System . out . println ( chinesecharacter ) ; PossibleChineseCharactersPanel . addToList ( chinesecharacter ) ; LogManager . logThing ( "Character found:" + chinesecharacter + " " + TimeManager . getCurrentTimeAndDate ( ) ) ; } } } } ) ; return chinesecharacter ; }
tr	5	public Model method578 ( int i , int j , int k , int l , int i1 , int j1 , int k1 ) { Model model = method581 ( i , k1 , j ) ; if ( model == null ) return null ; if ( aBoolean762 || aBoolean769 ) model = new Model ( aBoolean762 , aBoolean769 , model ) ; if ( aBoolean762 ) { int l1 = ( k + l + i1 + j1 ) / 4 ; for ( int i2 = 0 ; i2 < model . anInt1626 ; i2 ++ ) { int j2 = model . anIntArray1627 [ i2 ] ; int k2 = model . anIntArray1629 [ i2 ] ; int l2 = k + ( ( l - k ) * ( j2 + 64 ) ) / 128 ; int i3 = j1 + ( ( i1 - j1 ) * ( j2 + 64 ) ) / 128 ; int j3 = l2 + ( ( i3 - l2 ) * ( k2 + 64 ) ) / 128 ; model . anIntArray1628 [ i2 ] += j3 - l1 ; } model . method467 ( ) ; } return model ; }
tr	9X	public void Run ( String product ) { int i = bidTs . size ( ) - 1 ; if ( i < 400 ) { return ; } MarketData currBar = this . bidTs . get ( i ) ; MarketData prevBar = this . bidTs . get ( i - 1 ) ; if ( ! order . HasPosition ( product ) ) { state = 0 ; } double currBody = currBar . getClose ( ) - currBar . getOpen ( ) ; double prevBody = prevBar . getClose ( ) - prevBar . getOpen ( ) ; double point = CurrencyTable . getPoint ( product ) ; if ( state == 0 ) { boolean cond1 = prevBody > 0 && currBody < 0 ; boolean cond2 = currBar . getOpen ( ) >= prevBar . getClose ( ) ; boolean cond3 = currBar . getClose ( ) <= prevBar . getOpen ( ) ; boolean cond4 = currBody <= - 3 ; if ( cond1 && cond2 && cond3 && cond4 ) { String entryTime = bidTs . get ( i ) . getStart ( ) ; this . entryPrice = bidTs . get ( i ) . getClose ( ) ; order . MarketSell ( product , entryTime , entryPrice , 2 ) ; this . stopPrice = prevBar . getClose ( ) + 100 * point ; this . r = this . stopPrice - this . entryPrice ; this . takeProfit = this . entryPrice - r ; order . StopBuy ( product , entryTime , this . stopPrice , 2 ) ; state = 1 ; } } else if ( state == 1 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { order . MarketBuy ( product , currBar . getStart ( ) , this . takeProfit , 1 ) ; order . CancelAllPendingOrders ( product ) ; this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; state = 2 ; } } else if ( state == 2 ) { if ( this . askTs . get ( i ) . getClose ( ) < this . takeProfit ) { this . stopPrice = this . stopPrice - this . r ; this . takeProfit = this . takeProfit - this . r ; order . CancelAllPendingOrders ( product ) ; order . StopBuy ( product , currBar . getStart ( ) , this . stopPrice , 1 ) ; } } }
tr	0	public OlogClientBuilder withExecutor ( ExecutorService executor ) { this . executor = executor ; return this ; }
tr	7	public double rawinterp ( final int jl , final double x ) { final double TINY = 1.0e-99 ; int m , i , ns = 0 ; double y , w , t , hh , h , dd ; double [ ] c = new double [ mm ] ; double [ ] d = new double [ mm ] ; hh = abs ( x - xx [ jl + 0 ] ) ; for ( i = 0 ; i < mm ; i ++ ) { h = abs ( x - xx [ jl + i ] ) ; if ( h == 0.0 ) { dy = 0.0 ; return yy [ jl + i ] ; } else if ( h < hh ) { ns = i ; hh = h ; } c [ i ] = yy [ jl + i ] ; d [ i ] = yy [ jl + i ] + TINY ; } y = yy [ jl + ns -- ] ; for ( m = 1 ; m < mm ; m ++ ) { for ( i = 0 ; i < mm - m ; i ++ ) { w = c [ i + 1 ] - d [ i ] ; h = xx [ jl + i + m ] - x ; t = ( xx [ jl + i ] - x ) * d [ i ] / h ; dd = t - c [ i + 1 ] ; if ( dd == 0.0 ) throw new IllegalArgumentException ( "Error in routine ratint" ) ; dd = w / dd ; d [ i ] = c [ i + 1 ] * dd ; c [ i ] = t * dd ; } y += ( dy = ( 2 * ( ns + 1 ) < ( mm - m ) ? c [ ns + 1 ] : d [ ns -- ] ) ) ; } return y ; }
tr	8	private void waitForAndConnectClients ( ) { boolean afterFirstPlayer ; try { ServerSocket serverSocket = new ServerSocket ( PORT ) ; Socket clientSocket = new Socket ( ) ; acceptConnections ( serverSocket , clientSocket ) ; } catch ( SocketTimeoutException ste ) { System . out . println ( "SocketTimeoutException occured in Server" ) ; boolean exitLoop = false ; if ( Server . numOfClients >= 2 ) { this . startupPG . broadcastMessage ( "sBegin" ) ; while ( exitLoop == false ) { if ( this . startupPG . arePlayersReadyToPlay ( ) == true ) { cGame45 . beginRound ( ) ; exitLoop = true ; } else { try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ie ) { System . err . println ( "Server interupted while waiting on all remote players to set up their screens" ) ; } } } } else { System . out . println ( "Timeout exception occured and there was not enough players to begin playing" ) ; } } catch ( IOException ioe ) { System . out . println ( "IO Exception occured in Server" ) ; } catch ( SecurityException sc ) { System . out . println ( "SecurityExceptionException occured in Server" ) ; } catch ( IllegalBlockingModeException ibme ) { System . out . println ( "IllegalBlockingModeException occured in Server" ) ; } }
tr	2	@ Override public boolean equals ( Object that ) { if ( that == null ) return false ; if ( that instanceof abort_result ) return this . equals ( ( abort_result ) that ) ; return false ; }
tr	5	public void decay ( ) { entities . clear ( ) ; for ( int b = 0 ; b < parts . size ( ) ; b ++ ) { if ( parts . get ( b ) . isContainer ( ) ) { entities . addAll ( parts . get ( b ) . getEntities ( ) ) ; } } if ( entities . size ( ) > 0 ) { for ( int e = 0 ; e < entities . size ( ) ; e ++ ) { if ( entities . get ( e ) . getBodyPart ( ) != null ) { entities . get ( e ) . getBodyPart ( ) . decay ( ) ; } } } }
tr	1	public void setPopulation ( Population p ) { for ( int i = 0 ; i < operators . size ( ) ; ++ i ) { operators . get ( i ) . setPopulation ( p ) ; } }
tr	0	public void delete ( ) { Dispatch . call ( this , "Delete" ) ; }
tr	3	public double getDistanceAB ( ArrayList < Object > path ) { ArrayList < Object > nodes ; double distance = 0.0 ; for ( int i = 0 ; i < path . size ( ) - 1 ; i ++ ) { nodes = new ArrayList < Object > ( ) ; nodes . add ( path . get ( i ) ) ; nodes . add ( path . get ( i + 1 ) ) ; for ( Road road : roads ) { if ( road . getNodesAttached ( ) . containsAll ( nodes ) ) { distance += road . getDistance ( ) ; } } } distance = UtilCalc . round ( distance , 2 ) ; return distance ; }
tr	7	public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
tr	3	public Code getCodeByDescription ( String description ) { for ( Code code : codes ) { Map < String , String > localizedStrings = code . getDescription ( ) . getLocalizedStrings ( ) ; for ( String key : localizedStrings . keySet ( ) ) { if ( localizedStrings . get ( key ) . equalsIgnoreCase ( description ) ) { return code ; } } } return null ; }
tr	5	@ Test public void buildsGraph ( ) { Point p1 = vc . addPoint ( 0 , 0 ) ; Point p2 = vc . addPoint ( 1 , - 1 ) ; Point p3 = vc . addPoint ( 1 , 1 ) ; Point p4 = vc . addPoint ( 1.5 , 0.0 ) ; Point p5 = vc . addPoint ( 4 , - 1 ) ; Point p6 = vc . addPoint ( 4 , 1 ) ; p1 . setRight ( p2 ) ; p2 . setLeft ( p1 ) ; p3 . setRight ( p1 ) ; p1 . setLeft ( p3 ) ; p2 . setRight ( p3 ) ; p3 . setLeft ( p2 ) ; p4 . setRight ( p5 ) ; p5 . setLeft ( p4 ) ; p6 . setRight ( p4 ) ; p4 . setLeft ( p6 ) ; p5 . setRight ( p6 ) ; p6 . setLeft ( p5 ) ; vc . buildGraph ( ) ; Tree < Vertex > testadj1 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj2 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj3 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj4 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj5 = new Tree < > ( new VertexComparator ( ) ) ; Tree < Vertex > testadj6 = new Tree < > ( new VertexComparator ( ) ) ; testadj1 . add ( p2 ) ; testadj1 . add ( p3 ) ; testadj2 . add ( p1 ) ; testadj2 . add ( p5 ) ; testadj2 . add ( p4 ) ; testadj2 . add ( p3 ) ; testadj3 . add ( p1 ) ; testadj3 . add ( p6 ) ; testadj3 . add ( p4 ) ; testadj3 . add ( p2 ) ; testadj4 . add ( p2 ) ; testadj4 . add ( p3 ) ; testadj4 . add ( p5 ) ; testadj4 . add ( p6 ) ; testadj5 . add ( p2 ) ; testadj5 . add ( p4 ) ; testadj5 . add ( p6 ) ; testadj6 . add ( p5 ) ; testadj6 . add ( p4 ) ; testadj6 . add ( p3 ) ; assertTrue ( p1 . getAdjacents ( ) . equals ( testadj1 ) && p2 . getAdjacents ( ) . equals ( testadj2 ) && p3 . getAdjacents ( ) . equals ( testadj3 ) && p4 . getAdjacents ( ) . equals ( testadj4 ) && p5 . getAdjacents ( ) . equals ( testadj5 ) && p6 . getAdjacents ( ) . equals ( testadj6 ) ) ; }
tr	4	public FirstChoicePercent ( AlgorithmOutput output ) { int total = 0 ; int firsts = 0 ; for ( Timeslot t : output . keySet ( ) ) { for ( Student s : output . get ( t ) ) { total ++ ; if ( s . getFirstChoiceLabs ( ) . contains ( s . getAssignedLab ( ) ) ) { firsts ++ ; } } } this . fitness = ( double ) 100 * ( ( double ) firsts / ( double ) total ) ; if ( DEBUG ) { System . out . println ( fitness ) ; } output . addFitness ( "FirstChoicePercent" , fitness ) ; }
tr	4	private static int [ ] leeVector ( String mensaje , int longitud ) { int [ ] vector = new int [ longitud ] ; boolean valido = false ; while ( ! valido ) { System . out . print ( mensaje ) ; try { for ( int i = 0 ; i < longitud ; i ++ ) vector [ i ] = Coin . nextInt ( ) ; if ( Coin . hasNextLine ( ) ) Coin . nextLine ( ) ; valido = true ; } catch ( Exception ex ) { Coin . nextLine ( ) ; } } return vector ; }
tr	7	public static QuestionCalculation decode ( String encodedQuestionCalculation ) throws DecodeException { QuestionCalculation res ; if ( encodedQuestionCalculation . substring ( 0 , 19 ) . compareTo ( "#QuestionCalculaion" ) == 0 ) { res = new QuestionCalculation ( ) ; int i = 19 ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Integer > tmp_opd = decodeOperands ( encodedQuestionCalculation . substring ( 20 , i ) ) ; res . setOperands ( tmp_opd ) ; i ++ ; int beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } ArrayList < Character > tmp_opt = decodeOperators ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_opt . size ( ) == tmp_opt . size ( ) + 1 : "incorrect size of operators table" ; res . setOperators ( tmp_opt ) ; i ++ ; beginning = i ; if ( encodedQuestionCalculation . charAt ( i ) == < ) { while ( encodedQuestionCalculation . charAt ( i ) != > ) { i ++ ; } int tmp_lth = Integer . valueOf ( encodedQuestionCalculation . substring ( beginning + 1 , i ) ) ; assert tmp_lth < 0 : "negative length" ; res . setLength ( tmp_lth ) ; i ++ ; encodedQuestionCalculation = encodedQuestionCalculation . substring ( i ) ; Question . decode ( res , encodedQuestionCalculation ) ; } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } } else { res = null ; throw new DecodeException ( ) ; } return res ; }
tr	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Type other = ( Type ) obj ; if ( collectionType != other . collectionType ) return false ; if ( javaClass == null ) { if ( other . javaClass != null ) return false ; } else if ( ! javaClass . equals ( other . javaClass ) ) return false ; return true ; }
tr	1	private static void comparable ( ) { Set < DayOfTheWeek > dayOfTheWeeks = new TreeSet < > ( ) ; dayOfTheWeeks . add ( FRIDAY ) ; dayOfTheWeeks . add ( MONDAY ) ; dayOfTheWeeks . add ( SATURDAY ) ; for ( DayOfTheWeek dayOfTheWeek : dayOfTheWeeks ) { System . out . println ( dayOfTheWeek . display ( ) ) ; } }
tr	4	public char [ ] minCharCutMulti ( int numOfTracks ) { Debugger . debug ( "min cut set:***************\n" , 2 , debugLevel ) ; HashSet < ArrayList < Transition >> minCutSet = minCutMulti ( numOfTracks ) ; StringBuilder b = new StringBuilder ( ) ; for ( ArrayList < Transition > tracksArray : minCutSet ) { Transition tracks [ ] = new Transition [ numOfTracks ] ; for ( int i = 0 ; i < tracksArray . size ( ) ; i ++ ) { tracks [ tracksArray . get ( i ) . track - 1 ] = tracksArray . get ( i ) ; } for ( int i = 0 ; i < tracks . length ; i ++ ) { b . append ( "track" ) . append ( i + 1 ) ; b . append ( ": [" ) ; if ( tracks [ i ] . min != tracks [ i ] . max ) { Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "  " ) ; Transition . appendCharString ( tracks [ i ] . max , b ) ; } else Transition . appendCharString ( tracks [ i ] . min , b ) ; b . append ( "]" ) ; b . append ( "   " ) ; } b . append ( "\n" ) ; } Debugger . debug ( b . toString ( ) , 0 , debugLevel ) ; return null ; }
tr	1	public static void main ( String args [ ] ) { LinkedListBST b = new LinkedListBST ( ) ; ListNode a = new ListNode ( 1 ) ; ListNode a2 = a ; for ( int i = 0 ; i < 5 ; i ++ ) { a . next = new ListNode ( i + 2 ) ; a = a . next ; } TreeNode t = b . sortedListToBST ( a2 ) ; t . print ( t ) ; }
tr	7	private void insertDatabaseOperation ( Object object , Connection connection , DatabaseOperation databaseOperation ) { try { if ( ! object . getClass ( ) . isAnnotationPresent ( Table . class ) ) { throw new JStrykerException ( "Object(" + object + ") isn't Entity" ) ; } Table table = object . getClass ( ) . getAnnotation ( Table . class ) ; StringBuilder builder = new StringBuilder ( "<?xml version=\"1.0\"?>\n<dataset>\n<" ) ; builder . append ( table . name ( ) ) . append ( " " ) ; Field [ ] fields = object . getClass ( ) . getDeclaredFields ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; Object value = field . get ( object ) ; if ( value == null ) { continue ; } if ( field . isAnnotationPresent ( transient . class ) ) { continue ; } Column annotation = field . getAnnotation ( Column . class ) ; if ( annotation != null && ! "" . equals ( annotation . name ( ) ) ) { builder . append ( annotation . name ( ) ) ; } else { builder . append ( field . getName ( ) ) ; } builder . append ( "=\"" ) ; builder . append ( value ) ; builder . append ( "\" " ) ; } builder . append ( "/>\n</dataset>" ) ; String string = builder . toString ( ) ; execute ( null , connection , new ByteArrayInputStream ( string . getBytes ( ) ) , databaseOperation ) ; } catch ( IllegalAccessException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
tr	2	@ Test public void testTwoDimensionalArrays ( ) { final int rows = 3 ; final int cols = 4 ; int count = 0 ; int [ ] [ ] matrix = new int [ rows ] [ cols ] ; for ( int row = 0 ; row < rows ; row ++ ) { for ( int col = 0 ; col < cols ; col ++ ) { matrix [ row ] [ col ] = count ++ ; } } assertEquals ( 11 , matrix [ 2 ] [ 3 ] ) ; assertEquals ( 6 , matrix [ 1 ] [ 2 ] ) ; }
tr	0	public void setGame ( Game game ) { this . game = game ; }
tr	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
tr	5	public static BufferedImage getImage ( String fileName ) { BufferedImage i = null ; String path = "../images/" ; File f = null ; try { f = new File ( ResourceLoader . class . getResource ( path + fileName ) . getPath ( ) ) ; } catch ( NullPointerException e ) { Console . log ( "file + " + fileName + " is not there" , in . ERROR ) ; e . printStackTrace ( ) ; } if ( f != null && f . exists ( ) && ! f . isDirectory ( ) ) { try { i = ImageIO . read ( r . getClass ( ) . getClassLoader ( ) . getResource ( "images/" + fileName ) ) ; } catch ( Exception e ) { Console . log ( "image= " + fileName + " is not located here" , Console . in . ERROR ) ; e . printStackTrace ( ) ; } } return i ; }
tr	1	public boolean createAccount ( String login , String password ) { if ( logins . containsKey ( login + password ) ) { return false ; } else { logins . put ( login + password , null ) ; return true ; } }
tr	1	public String getClientToken ( ) { if ( clientToken . isEmpty ( ) ) { logger . debug ( "Token is empty.<br> A new one will be generated." ) ; clientToken = java . util . UUID . randomUUID ( ) . toString ( ) ; clientToken = clientToken . replaceAll ( "-" , "" ) ; logger . debug ( clientToken ) ; } return clientToken ; }
tr	6	@ Override public int loginUsuario ( String login , String password ) throws RemoteException { int result = - 1 ; ArrayList < UsuarioInt > usuarios = obtenerUsuarios ( ) ; for ( UsuarioInt usuario : usuarios ) { if ( login . compareTo ( usuario . getLogin ( ) ) == 0 && password . compareTo ( usuario . getPassword ( ) ) == 0 ) { if ( usuario . getAdmin ( ) ) { result = 2 ; } else { result = 1 ; } } else if ( login . compareTo ( usuario . getLogin ( ) ) == 0 || password . compareTo ( usuario . getPassword ( ) ) == 0 ) { result = 0 ; } } return result ; }
tr	0	public static void quadRectOutset ( Rect rect , double border , RGB fill , boolean inset ) { quadCoordOutset ( rect . getMin ( ) , rect . getMax ( ) , border , fill , inset ) ; }
tr	6	@ Override protected void fillComponentsInEditorPanel ( int rowSelected ) { nameTextField . setText ( getValueAt ( rowSelected , 1 ) . toString ( ) ) ; yearSpinner . setValue ( short . valueOf ( getValueAt ( rowSelected , 2 ) . toString ( ) ) ) ; strengthSpinner . setValue ( getValueAt ( rowSelected , 3 ) ) ; String speciality = getValueAt ( rowSelected , 4 ) . toString ( ) ; int index = 0 ; for ( int i = 0 ; i < specialities . length ; i ++ ) { if ( speciality . endsWith ( specialities [ i ] . getName ( ) ) ) { index = i ; } } specialityComboBox . setSelectedIndex ( index ) ; String department = getValueAt ( rowSelected , 5 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < departments . length ; i ++ ) { if ( department . endsWith ( departments [ i ] . getName ( ) ) ) { index = i ; } } departmentComboBox . setSelectedIndex ( index ) ; String form = getValueAt ( rowSelected , 3 ) . toString ( ) ; index = 0 ; for ( int i = 0 ; i < educationForms . length ; i ++ ) { if ( form . endsWith ( educationForms [ i ] . getType ( ) ) ) { index = i ; } } educationFormComboBox . setSelectedIndex ( index ) ; }
tr	5	public static void main ( String [ ] args ) { r1 = new Thread ( ) { public void run ( ) { while ( i < 100 ) { if ( i % 10 == 0 ) { if ( r2 . isAlive ( ) ) r2 . notify ( ) ; else r2 . run ( ) ; } i ++ ; } r1 . interrupt ( ) ; r2 . interrupt ( ) ; } } ; r2 = new Thread ( ) { public void run ( ) { System . out . println ( i ) ; try { if ( r2 . isAlive ( ) ) { r2 . wait ( ) ; r1 . notify ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ; r1 . run ( ) ; }
tr	4	private Mappable convertMappable ( Properties props , Map map , int i ) throws NoSuchMethodException , ClassNotFoundException , InstantiationException , IllegalAccessException , InvocationTargetException { String objPrefix = MAPOBJECT_PREFIX + SEP + i + SEP ; String className = props . getProperty ( objPrefix + ConfigurableProperties . class ) ; int x = getPropAsInt ( props , objPrefix + POS_X , 100 ) ; int y = getPropAsInt ( props , objPrefix + POS_Y , 100 ) ; String id = props . getProperty ( objPrefix + ID ) ; double angle = getPropAsDouble ( props , objPrefix + POS_ANGLE , 0.0 ) ; Constructor < ? > constructor = class . forName ( className ) . getConstructor ( MAPOBJ_PARAMS ) ; Mappable mappable = ( Mappable ) constructor . newInstance ( new Object [ ] { map , new Integer ( x ) , new Integer ( y ) } ) ; mappable . setAngle ( angle ) ; if ( id != null ) { mappable . setId ( id ) ; } List < ConfigurableProperties > list = mappable . getConfigurableProperties ( ) ; for ( ConfigurableProperties key : list ) { String val = props . getProperty ( objPrefix + key ) ; val = addHomeDir ( val ) ; if ( val != null ) { mappable . setConfiguredValue ( key , val ) ; } } return mappable ; }
tr	7	void updateGui ( String fieldname ) { Object fieldval = fieldvalues . get ( fieldname ) ; Object fieldcom = fieldcomponents . get ( fieldname ) ; String fieldtype = ( String ) fieldtypes . get ( fieldname ) ; if ( fieldcom instanceof JCheckBox ) { ( ( JCheckBox ) fieldcom ) . setSelected ( ( ( boolean ) fieldval ) . booleanValue ( ) ) ; } else if ( fieldcom instanceof JColorChooser ) { JColorChooser jcc = ( JColorChooser ) fieldcom ; jcc . setColor ( ( Color ) fieldval ) ; } else if ( fieldcom instanceof KeyField ) { ( ( KeyField ) fieldcom ) . setValue ( ( ( Integer ) fieldval ) . intValue ( ) ) ; } else if ( fieldcom instanceof JTextField ) { JTextField textfield = ( JTextField ) fieldcom ; if ( fieldtype . equals ( "int" ) || fieldtype . equals ( "double" ) ) { textfield . setText ( "" + fieldval ) ; } else if ( fieldtype . equals ( "String" ) ) { textfield . setText ( "" + fieldval ) ; } } }
tr	8	public static String getAFullMessage ( String [ ] finalWords , SocketChannel s ) throws IOException { ByteBuffer b = ByteBuffer . allocateDirect ( Global . BUFFER_LENGTH ) ; String retour = "" ; String m ; String token ; int i = 0 ; boolean continuer = true ; while ( continuer && i < Global . BUFFER_LENGTH ) { if ( s . read ( b ) == - 1 ) { Utilitaires . out ( "Fr\u00E9quence 2" , 2 , true ) ; continuer = false ; } if ( s . socket ( ) . isClosed ( ) ) { Utilitaires . out ( "Socket ferm\u00E9e !" ) ; throw new IOException ( ) ; } i ++ ; b . flip ( ) ; m = buffToString ( b ) ; retour += m ; b . clear ( ) ; Scanner sc = new Scanner ( m ) ; while ( sc . hasNext ( ) && continuer ) { token = sc . next ( ) ; for ( String w : finalWords ) { if ( token . equals ( w ) ) { continuer = false ; break ; } } } sc . close ( ) ; } return retour ; }
tr	4	private int getGameScore ( Game game ) { int result = 0 ; int tagworth = 1 ; int gameworth = 3 ; for ( Player p : activePlayers ) { if ( p . doesLikeGame ( game ) ) { result += gameworth ; } for ( Tag tag : game . getTags ( ) ) { if ( p . doesLikeTag ( tag ) ) { result += tagworth ; } } } return result ; }
tr	4	private void parseDisplayBPM ( String bpmValues , SimFile accumulator ) { final String [ ] bpmCodes = bpmValues . split ( " " ) ; double min = Integer . MAX_VALUE ; String minText = "" ; double max = Integer . MIN_VALUE ; String maxText = "" ; for ( String bpmCode : bpmCodes ) { String bpmText = bpmCode . substring ( bpmCode . indexOf ( = ) + 1 ) ; double bpm = double . parseDouble ( bpmText ) ; if ( bpm < min ) { min = bpm ; minText = bpmText ; } if ( bpm > max ) { max = bpm ; maxText = bpmText ; } } String displayBPM ; if ( max == min ) { displayBPM = minText ; } else { displayBPM = minText + " - " + maxText ; } accumulator . setDisplayBPM ( displayBPM ) ; }
tr	3	protected int readStringHeaderImpl ( ) throws IOException , UBJFormatException { byte type = checkType ( "STRING" , STRING_COMPACT , STRING ) ; int length = 0 ; switch ( type ) { case STRING_COMPACT : length = read ( ) ; break ; case STRING : length = readInt32Impl ( ) ; break ; } if ( length < 0 ) throw new UBJFormatException ( pos , "Encountered a negative (invalid) length of [" + length + "] specified for the STRING value at stream position " + pos + ". Length must be >= 0." ) ; return length ; }
tr	9X	@ Override public void positionChanged ( int newPosition ) { ScrolledNotesCanvas scrolledNotesCanvas = mainView . getScrolledNotesCanvas ( ) ; if ( playing && repeats . size ( ) == 2 ) { if ( newPosition < repeats . get ( 1 ) ) { scrolledNotesCanvas . scrollToPosition ( repeats . get ( 0 ) ) ; return ; } } Set < Note > notes = scrolledNotesCanvas . getNotesAtPosition ( newPosition ) ; Set < Pitch > pitches = new HashSet < Pitch > ( ) ; for ( Note note : notes ) { pitches . add ( note . getPitch ( ) ) ; } PianoCanvas pianoCanvas = mainView . getPianoCanvas ( ) ; pianoCanvas . setSelectedNotes ( notes ) ; final Set < Note > newNotes = new HashSet < Note > ( notes ) ; newNotes . removeAll ( oldNotes ) ; waitingNotes . setWaitingNotes ( newNotes ) ; waitingNotes . setAutoplayCallback ( new Runnable ( ) { public void run ( ) { try { for ( Note note : newNotes ) { if ( note . getTrack ( ) . isActive ( ) ) { if ( note . getTrack ( ) . isAutoplay ( ) ) { midiKeyboard . play ( note . getPitch ( ) , note . getVelocity ( ) , note . getDuration ( ) ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; if ( anyActiveNonAutoplay ( ) ) { if ( waitingNotes . waiting ( ) ) { midiKeyboard . setGuideLightsFromNotes ( waitingNotes . getWaitingNotes ( ) ) ; } else { Set < Note > nextNotes = scrolledNotesCanvas . getNotesAfterPosition ( newPosition ) ; midiKeyboard . setGuideLightsFromNotes ( Controller . filterWaitable ( nextNotes ) ) ; } } else { midiKeyboard . setGuideLightsFromNotes ( getActiveNotes ( notes ) ) ; } oldNotes = notes ; ScoreCanvas scoreCanvas = mainView . getScoreCanvas ( ) ; scoreCanvas . positionChanged ( scrolledNotesCanvas . getTicksFromBeginning ( newPosition ) ) ; }
tr	1	public static void notNull ( Object object , RuntimeException throwIfAssertFail ) { if ( object == null ) { throw throwIfAssertFail ; } }
tr	5	public < H , S > void dispatch ( Event < H , S > event , S source ) { event . setSource ( source ) ; try { for ( H handler : this . < H > getQueueForType ( registeredHandlers , event . getType ( ) ) ) { try { event . dispatch ( handler ) ; } catch ( Throwable t ) { LoggerFactory . getLogger ( handler . getClass ( ) ) . error ( "Unhandled exception while dispatching event" , t ) ; } } for ( Reference < Waiter < Event < H , S >>> ref : this . < Reference < Waiter < Event < H , S >>> > getQueueForType ( registeredWaiters , event . getType ( ) ) ) { Waiter < Event < H , S >> waiter = ref . get ( ) ; if ( waiter != null ) { waiter . offer ( event ) ; } } if ( ! ( event instanceof EventEvent ) ) { dispatch ( new EventEvent ( ) , event ) ; } } finally { event . setSource ( null ) ; } }
tr	7	private static void printHubDetails ( int indent , Device dev ) { try { Hub h = new Hub ( dev ) ; int ports = h . getNumPorts ( ) ; boolean indicator = h . isIndicator ( ) ; indentLine ( indent , ( h . isRootHub ( ) ? "Root " : "" ) + "Hub  " + ports + " ports" ) ; indentLine ( indent , "overcurrent protection: " + h . getOverCurrentMode ( ) ) ; indentLine ( indent , "power switching: " + h . getPowerSwitchingMode ( ) ) ; if ( indicator ) indentLine ( indent , "has port indicator LEDs" ) ; if ( h . isCompound ( ) ) indentLine ( indent , "part of a compound device" ) ; indent -= 4 ; indentLine ( indent , "" ) ; for ( int i = 1 ; i <= ports ; i ++ ) { Device child = dev . getChild ( i ) ; if ( child == null ) continue ; indentLine ( indent , "<!-- Port " + i + ( h . isRemovable ( i ) ? "" : " is built-in." ) + " -->" ) ; printDevice ( indent , child ) ; } } catch ( IOException e ) { e . printStackTrace ( System . out ) ; } }
tr	7	private void populate ( ) { Random rand = Randomizer . getRandom ( ) ; field . clear ( ) ; int Number_of_foxes = 0 ; int Number_of_rabbits = 0 ; int Number_of_korenwolfs = 0 ; for ( int row = 0 ; row < field . getDepth ( ) ; row ++ ) { for ( int col = 0 ; col < field . getWidth ( ) ; col ++ ) { if ( rand . nextDouble ( ) <= KORENWOLF_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Korenwolf korenwolf = new Korenwolf ( true , field , location ) ; actors . add ( korenwolf ) ; Number_of_korenwolfs ++ ; } else if ( rand . nextDouble ( ) <= FOX_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Fox fox = new Fox ( true , field , location ) ; actors . add ( fox ) ; Number_of_foxes ++ ; } else if ( rand . nextDouble ( ) <= RABBIT_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Rabbit rabbit = new Rabbit ( true , field , location ) ; actors . add ( rabbit ) ; Number_of_rabbits ++ ; } else if ( rand . nextDouble ( ) <= HUNTER_CREATION_PROBABILITY ) { Location location = new Location ( row , col ) ; Hunter hunter = new Hunter ( field , location ) ; actors . add ( hunter ) ; } else if ( rand . nextDouble ( ) <= 0.03 ) { Location location = new Location ( row , col ) ; Grass grass = new Grass ( field , location ) ; actors . add ( grass ) ; } } } Rabbit . PERFECT_NUMBER_OF_RABBITS = Number_of_rabbits ; Fox . PERFECT_NUMBER_OF_FOXES = Number_of_foxes ; Korenwolf . PERFECT_NUMBER_OF_KORENWOLFS = Number_of_korenwolfs ; }
tr	7	@ EventHandler public void onPlayerMove ( PlayerMoveEvent event ) { if ( event . isCancelled ( ) ) { return ; } Player player = event . getPlayer ( ) ; if ( preChecks ( player , event . getTo ( ) ) ) { JumpPort port = JumpPorts . getPort ( event . getTo ( ) ) ; if ( checkInstant ( event ) ) { return ; } if ( checkJump ( event ) ) { return ; } if ( checkFall ( event ) ) { return ; } if ( ! ignoredPlayers . contains ( player . getName ( ) ) ) { player . sendMessage ( Lang . get ( "port.triggered" ) . replaceAll ( "%N" , port . getName ( ) ) . replaceAll ( "%D" , port . getDescription ( ) ) ) ; if ( port . getPrice ( ) > 0 ) { player . sendMessage ( Lang . get ( "port.price" ) . replaceAll ( "%P" , "" + port . getPrice ( ) ) ) ; } player . sendMessage ( Lang . get ( "port.triggers" ) ) ; ignoredPlayers . add ( player . getName ( ) ) ; } } }
tr	5	private void initiateMalesAndFemales ( Habitat habitat ) { numberOfLonelyFemales = 0 ; males . clear ( ) ; lonelyFemales . clear ( ) ; for ( IndividualsGroupState group : habitat . getGroupsStates ( ) . values ( ) ) { if ( group . isMatureMale ( ) && group . strength > 0 ) males . add ( group ) ; else if ( group . isMatureFemale ( ) && group . getNotMultipliedst ( ) > 0 ) { lonelyFemales . add ( group ) ; numberOfLonelyFemales += group . getNotMultipliedst ( ) ; } } }
tr	1	@ Override public boolean equals ( Object obj ) { if ( obj instanceof GRGProteinNode ) { GRGProteinNode other = ( GRGProteinNode ) obj ; return this . node . equals ( other . node ) ; } else { return false ; } }
tr	0	public JSONArray put ( int index , double value ) throws JSONException { put ( index , new double ( value ) ) ; return this ; }
tr	8	@ Override protected void handleInboxItem ( InboxItem inboxItem ) { super . handleInboxItem ( inboxItem ) ; if ( inboxItem . getMessage ( ) instanceof TokenMessage ) { executeTurn ( ) ; } if ( inboxItem . getMessage ( ) instanceof LeaderElectionMessage ) { LeaderElectionMessage message = ( LeaderElectionMessage ) inboxItem . getMessage ( ) ; switch ( message . getLeaderElectionMessageType ( ) ) { case ASK_FOR_ROLL : { doRoll ( inboxItem . getSender ( ) ) ; break ; } case LEADER_ELECTED : { initRound ( ) ; ownPlayer . setActive ( true ) ; if ( message . getValue ( ) == ownEndpoint . getId ( ) ) { isDealer = true ; logger . info ( "New Dealer" ) ; sendToken ( getPreviousPlayer ( ) ) ; } else { logger . info ( "Player " + message . getValue ( ) + " is new dealer." ) ; } break ; } case ROLLED : { gatherRoll ( inboxItem . getSender ( ) , message ) ; break ; } } } if ( inboxItem . getMessage ( ) instanceof StatusMessage ) { handleStatusMessage ( ( StatusMessage ) inboxItem . getMessage ( ) ) ; } if ( inboxItem . getMessage ( ) instanceof DealerMessage ) { handleDealerMessage ( inboxItem . getSender ( ) , ( DealerMessage ) inboxItem . getMessage ( ) ) ; } }
tr	9X	private boolean r_attached_pronoun ( ) { int among_var ; ket = cursor ; if ( find_among_b ( a_1 , 13 ) == 0 ) { return false ; } bra = cursor ; among_var = find_among_b ( a_2 , 11 ) ; if ( among_var == 0 ) { return false ; } if ( ! r_RV ( ) ) { return false ; } switch ( among_var ) { case 0 : return false ; case 1 : bra = cursor ; slice_from ( "iendo" ) ; break ; case 2 : bra = cursor ; slice_from ( "ando" ) ; break ; case 3 : bra = cursor ; slice_from ( "ar" ) ; break ; case 4 : bra = cursor ; slice_from ( "er" ) ; break ; case 5 : bra = cursor ; slice_from ( "ir" ) ; break ; case 6 : slice_del ( ) ; break ; case 7 : if ( ! ( eq_s_b ( 1 , "u" ) ) ) { return false ; } slice_del ( ) ; break ; } return true ; }
tr	0	public InternManImpl ( UserStore userStore ) { this . users = new UserManagementImpl ( ) ; this . adverts = new AdvertManagementImpl ( ) ; }
tr	9X	public int getConfig ( int uid , int x , int y , int z ) { Ground tile = groundArray [ z ] [ x ] [ y ] ; if ( tile == null ) return - 1 ; if ( tile . wallObject != null && tile . wallObject . uid == uid ) return tile . wallObject . objConf & ff ; if ( tile . wallDecoration != null && tile . wallDecoration . uid == uid ) return tile . wallDecoration . objConf & ff ; if ( tile . groundDecoration != null && tile . groundDecoration . uid == uid ) return tile . groundDecoration . objConf & ff ; for ( int e = 0 ; e < tile . entityCount ; e ++ ) if ( tile . interactiveObjects [ e ] . uid == uid ) return tile . interactiveObjects [ e ] . objConf & ff ; return - 1 ; }
tr	0	@ Override public void deleteExam ( Exam exam ) { examDAO . delete ( exam ) ; }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	1	public MerchantDeal getMerchantDeal ( int merchantDealId ) { MerchantDeal merchantDeal = null ; try { session = mySessionFactory . getCurrentSession ( ) ; merchantDeal = ( MerchantDeal ) session . get ( MerchantDeal . class , merchantDealId ) ; } catch ( Exception e ) { } return merchantDeal ; }
tr	9X	public final void append ( PathIterator pi , boolean connect ) { double [ ] coords = new double [ 6 ] ; while ( ! pi . isDone ( ) ) { switch ( pi . currentSegment ( coords ) ) { case SEG_MOVETO : if ( ! connect || numTypes < 1 || numCoords < 1 ) { moveTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; } if ( pointTypes [ numTypes - 1 ] != SEG_CLOSE && doubleCoords [ numCoords - 2 ] == coords [ 0 ] && doubleCoords [ numCoords - 1 ] == coords [ 1 ] ) { break ; } lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_LINETO : lineTo ( coords [ 0 ] , coords [ 1 ] ) ; break ; case SEG_QUADTO : quadTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] ) ; break ; case SEG_CUBICTO : curveTo ( coords [ 0 ] , coords [ 1 ] , coords [ 2 ] , coords [ 3 ] , coords [ 4 ] , coords [ 5 ] ) ; break ; case SEG_CLOSE : closePath ( ) ; break ; } pi . next ( ) ; connect = false ; } }
tr	4	public boolean contain ( Ticket ticket ) { if ( ! parkIsNull ( ) && park . contain ( ticket ) ) { return true ; } for ( ParkBoy boy : this . parkBoyList ) { if ( boy . contain ( ticket ) ) { return true ; } } return false ; }
tr	0	public JButton getButtonClose ( ) { return btnClose ; }
tr	7	public static void main ( String [ ] args ) throws Exception { ApplicationContext context = new ClassPathXmlApplicationContext ( "spring-module.xml" ) ; UserService userservice = ( UserService ) context . getBean ( "userServiceBean" ) ; System . out . println ( "-------- --- USER --- ---------" ) ; User user = userservice . findUserByEmailPassword ( "martinpucheu@udec.cl" , "cresposexy" ) ; System . out . println ( "El usuario encontrado tiene como apellido: " + user . getlastName ( ) ) ; MovieService movieService = ( MovieService ) context . getBean ( "movieServiceBean" ) ; Movie m = new Movie ( "American Hustle" , 2013 , "Pel\u00EDcula de esta estafadores" , "David O. Russell" ) ; movieService . insert ( m ) ; System . out . println ( "-------- --- MOVIES --- ---------" ) ; Movie _movie = movieService . findMovieById ( 3 ) ; System . out . println ( "La pel\u00EDcula encontrada es: " + _movie . getName ( ) ) ; System . out . println ( " -.-.-.-" ) ; List < Movie > _movie2 = movieService . findMovieByTitle ( "Twilight" ) ; for ( int i = 0 ; i < _movie2 . size ( ) ; i ++ ) { System . out . println ( "Econtre la pel\u00EDcula que buscabas  es: " + _movie2 . get ( i ) . getName ( ) + " verdad?" ) ; } ActorService actorService = ( ActorService ) context . getBean ( "actorServiceBean" ) ; System . out . println ( "-------- --- ACTOR --- ---------" ) ; Actor _actor = actorService . findActorById ( 1 ) ; System . out . println ( "El actor encontrado es: " + _actor . getName ( ) + " " + _actor . getLName ( ) ) ; ActorService actsService = ( ActorService ) context . getBean ( "actsServiceBean" ) ; System . out . println ( "-------- --- ACTS --- ---------" ) ; List < Acts > _acts = actsService . findActsByMoiveId ( 1 ) ; for ( int i = 0 ; i < _acts . size ( ) ; i ++ ) System . out . println ( "En la pel\u00EDcula de id:1 actua el actor con id:[" + _acts . get ( i ) . getIda ( ) + "]" ) ; MovieService categoryService = ( MovieService ) context . getBean ( "categoryServiceBean" ) ; System . out . println ( "-------- --- CATEGORY --- ---------" ) ; Category _category = categoryService . findCategoryByGenre ( "Thriller" ) ; System . out . println ( "La categoria encontrada fue: " + _category . getGenre ( ) ) ; UserService doeslikeService = ( UserService ) context . getBean ( "doeslikeServiceBean" ) ; System . out . println ( "-------- --- DOESLIKE--- ---------" ) ; List < DoesLike > _doeslike = doeslikeService . findDoesLikeById ( 1 ) ; for ( int i = 0 ; i < _doeslike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 le gusta el genero: " + _doeslike . get ( i ) . getGenre ( ) ) ; UserService doesnotlikeService = ( UserService ) context . getBean ( "doesnotlikeServiceBean" ) ; System . out . println ( "-------- --- DOESNOTLIKE--- ---------" ) ; List < DoesNotLike > _doesnotlike = doesnotlikeService . findDoesNotLikeById ( 1 ) ; for ( int i = 0 ; i < _doesnotlike . size ( ) ; i ++ ) System . out . println ( "Al usuario 1 no le gusta el genero: " + _doesnotlike . get ( i ) . getGenre ( ) ) ; MovieService idiomService = ( MovieService ) context . getBean ( "idiomServiceBean" ) ; System . out . println ( "-------- --- IDIOM --- ---------" ) ; Idiom _idiom = idiomService . findIdiomByLanguage ( "Espanol" ) ; System . out . println ( "El idioma encontrado es: " + _idiom . getLanguage ( ) ) ; UserService idiompService = ( UserService ) context . getBean ( "idiompServiceBean" ) ; System . out . println ( "-------- --- IDIOMP --- ---------" ) ; List < Idiomp > _idiomp = idiompService . findByUserId ( 3 ) ; for ( int i = 0 ; i < _idiomp . size ( ) ; i ++ ) System . out . println ( "Al usuario 3 le gustan las peliculas en idioma: " + _idiomp . get ( i ) . getLanguage ( ) ) ; MovieService moviecategoryService = ( MovieService ) context . getBean ( "moviecategoryServiceBean" ) ; System . out . println ( "-------- --- MOVIECATEGORY --- ---------" ) ; List < MovieCategory > _moviecategory = moviecategoryService . findMoviesByGendre ( "Thriller" ) ; for ( int i = 0 ; i < _moviecategory . size ( ) ; i ++ ) System . out . println ( "Los ID de las pel\u00EDculas del genero Thriller son: " + _moviecategory . get ( i ) . getIdp ( ) ) ; MovieService ratingService = ( MovieService ) context . getBean ( "ratingServiceBean" ) ; System . out . println ( "-------- --- RATING --- ---------" ) ; Rating _rating = ratingService . findRatingById ( 1 , 1 ) ; System . out . println ( "La calificaci\u00F3n que le dio el usuario 2 a la pel\u00EDcula 3 es: [" + _rating . getMark ( ) + "]" ) ; MovieService speakService = ( MovieService ) context . getBean ( "speakServiceBean" ) ; Speak _speak2 = new Speak ( 2 , "Frances" ) ; System . out . println ( "-------- --- SPEAK --- ---------" ) ; Speak _speak = speakService . findSpeakByIdp ( 4 ) ; System . out . println ( "EL idioma de la pel\u00EDcula 4 es: " + _speak . getLengua ( ) ) ; UserService wishlistService = ( UserService ) context . getBean ( "wishlistServiceBean" ) ; WishList wishlist = new WishList ( 5 , 1 ) ; System . out . println ( "-------- --- WISHLIST --- ---------" ) ; List < WishList > _wishlist = wishlistService . findWishListById ( 1 ) ; for ( int i = 0 ; i < _wishlist . size ( ) ; i ++ ) System . out . println ( "La pel\u00EDcula con id:" + _wishlist . get ( i ) . getIdp ( ) + " est\u00E1 en la Wishlist del usuario 1 " ) ; }
tr	4	public static void fileSaveAsSCM ( File target ) { if ( MainMethods . openFile == null ) { updateStatusBar ( "Nothing to save ... please open a file first!" , 2 ) ; return ; } if ( ! MainMethods . openFile . isScmFile ( ) ) { updateStatusBar ( "You must open a SCM File to save as an SCM file" , 2 ) ; return ; } File outputFile = target ; if ( outputFile == null ) outputFile = MainMethods . getFileToSaveIn ( ) ; MapParser . write ( MainMethods . openFile . getChannelList ( ) , MainMethods . openFile . getFile ( ) ) ; int compressedFiles = ZipHandler . compress ( outputFile . getAbsolutePath ( ) , MainMethods . openFile . scmExtractedTo ( ) . getAbsolutePath ( ) ) ; if ( compressedFiles < 0 ) { MainMethods . updateStatusBar ( "Packaging SCM file failed!" , 2 ) ; return ; } updateStatusBar ( "Saved SCM file as \"" + outputFile . getAbsolutePath ( ) + "\"" , 2 ) ; }
tr	3	@ Override public void dispose ( ) { for ( ObjectMap < String , Object > entry : data . values ( ) ) { for ( Object resource : entry . values ( ) ) { if ( resource instanceof Disposable ) ( ( Disposable ) resource ) . dispose ( ) ; } } }
tr	2	public boolean isAlive ( ) { if ( ! isAlive ) { if ( location != null ) { field . clear ( location ) ; location = null ; field = null ; } } return isAlive ; }
tr	8	private String handleRequest ( String input ) throws IOException , IllegalArgumentException { System . out . println ( input ) ; String nameReg = "[a-zA-Z0-9\\.]+" ; String regex = "(boards)|(newBoard " + nameReg + ")|" + "(switch " + nameReg + " " + nameReg + " " + nameReg + ")|" + "(exit " + nameReg + ")|(users " + nameReg + ")|" + "(checkAndAddUser " + nameReg + " " + nameReg + ")|" + "(draw " + nameReg + "( " + nameReg + ")+)" ; if ( ! input . matches ( regex ) ) { System . out . println ( "Invalid input: " + input ) ; return null ; } String [ ] tokens = input . split ( " " ) ; if ( tokens [ 0 ] . equals ( "boards" ) ) { return boards ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "newBoard" ) ) { return newBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "switch" ) ) { return switchBoard ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "exit" ) ) { return exit ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "draw" ) ) { return draw ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "checkAndAddUser" ) ) { return checkAndAddUser ( tokens ) ; } else if ( tokens [ 0 ] . equals ( "users" ) ) { return users ( tokens ) ; } throw new UnsupportedOperationException ( ) ; }
tr	5	public void send ( final String name , final String node , final OtpErlangObject msg ) { try { final String currentNode = home . node ( ) ; if ( node . equals ( currentNode ) ) { send ( name , msg ) ; } else if ( node . indexOf ( @ , 0 ) < 0 && node . equals ( currentNode . substring ( 0 , currentNode . indexOf ( @ , 0 ) ) ) ) { send ( name , msg ) ; } else { final OtpCookedConnection conn = home . getConnection ( node ) ; if ( conn == null ) { return ; } conn . send ( self , name , msg ) ; } } catch ( final Exception e ) { } }
tr	0	@ Before public void setUp ( ) { DB . setDataSource ( new SQLite ( ) ) ; }
tr	3	protected Backpropagation calculateErrorAndUpdateHiddenNeurons ( ) { for ( int i = this . network . getLayersNum ( ) - 2 ; i > 0 ; i -- ) for ( INeuron neuron : this . network . getLayerAt ( i ) . getNeurons ( ) ) if ( neuron instanceof ErrorNeuron ) { ErrorNeuron errorNeuron = ( ErrorNeuron ) neuron ; this . updateNeuronWeights ( errorNeuron . setError ( this . calculateHiddenNeuronError ( errorNeuron ) ) ) ; } return this ; }
tr	2	public static boolean isPrime ( long n ) { log ( "Checking " + n ) ; boolean isPrime = n > 1 && rangeClosed ( 2 , ( long ) sqrt ( n ) ) . noneMatch ( divisor -> n % divisor == 0 ) ; if ( isPrime ) log ( "Prime found " + n ) ; return isPrime ; }
tr	2	public synchronized void produce ( ) { try { if ( product != 0 ) { wait ( ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } product = 1 ; System . out . println ( "Producer produce : " + product ) ; notifyAll ( ) ; }
tr	8	public void determineChunkStats ( ) { int emptyNeighborIndex = Integer . MIN_VALUE ; reset ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { boolean isRowEmpty = true ; for ( int j = 0 ; j < map [ i ] . length ; j ++ ) { if ( map [ i ] [ j ] != 0 ) { isRowEmpty = false ; } checkEnemy ( i , j ) ; checkCannons ( i , j ) ; checkTubes ( i , j ) ; checkHills ( i , j ) ; recordOtherStats ( i , j ) ; } if ( isRowEmpty && i - 1 != emptyNeighborIndex ) { emptyNeighborIndex = i ; numJumps ++ ; difficulty ++ ; if ( this . type != Type . JUMP && numJumps > getCurrentTypeCount ( ) ) { this . type = Type . JUMP ; } } else if ( isRowEmpty ) emptyNeighborIndex = i ; } }
tr	9X	public static String nullSafeToString ( Object obj ) { if ( obj == null ) { return NULL_STRING ; } if ( obj instanceof String ) { return ( String ) obj ; } if ( obj instanceof Object [ ] ) { return nullSafeToString ( ( Object [ ] ) obj ) ; } if ( obj instanceof boolean [ ] ) { return nullSafeToString ( ( boolean [ ] ) obj ) ; } if ( obj instanceof byte [ ] ) { return nullSafeToString ( ( byte [ ] ) obj ) ; } if ( obj instanceof char [ ] ) { return nullSafeToString ( ( char [ ] ) obj ) ; } if ( obj instanceof double [ ] ) { return nullSafeToString ( ( double [ ] ) obj ) ; } if ( obj instanceof float [ ] ) { return nullSafeToString ( ( float [ ] ) obj ) ; } if ( obj instanceof int [ ] ) { return nullSafeToString ( ( int [ ] ) obj ) ; } if ( obj instanceof long [ ] ) { return nullSafeToString ( ( long [ ] ) obj ) ; } if ( obj instanceof short [ ] ) { return nullSafeToString ( ( short [ ] ) obj ) ; } String str = obj . toString ( ) ; return ( str != null ? str : EMPTY_STRING ) ; }
tr	7	@ Override public void init ( ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( PokemonMoveset . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } try { java . awt . EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { initComponents ( ) ; } } ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	2	public double getArea ( ) { final Punto ptInt = this . getPuntoInterior ( ) ; double area = 0 ; for ( int i = 0 ; i < this . numVertices ; i ++ ) { final Punto ptSig = ( i == this . numVertices - 1 ) ? this . vertices [ 0 ] : this . vertices [ i + 1 ] ; area += Poligono . getAreaTriangulo ( this . vertices [ i ] , ptSig , ptInt ) ; } return Math . round ( area * 1000 ) / 1000.0 ; }
tr	0	@ Override public String getParams ( ) { StringBuilder parmas = new StringBuilder ( ) ; parmas . append ( pppUserName ) . append ( CTConstant . VALUE_ACCOUNT ) . append ( pppPassword ) ; return parmas . toString ( ) ; }
tr	3	@ Override protected byte [ ] encryptConcrete ( EncFSVolume volume , byte [ ] paddedDecFileName , byte [ ] fileIv ) throws EncFSCorruptDataException { try { return BlockCrypto . blockEncrypt ( volume , fileIv , paddedDecFileName ) ; } catch ( InvalidAlgorithmParameterException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( IllegalBlockSizeException e ) { throw new EncFSCorruptDataException ( e ) ; } catch ( BadPaddingException e ) { throw new EncFSCorruptDataException ( e ) ; } }
tr	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandEingang . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
tr	0	public Creditos ( ) { JOptionPane . showMessageDialog ( null , message , "About..." , JOptionPane . INFORMATION_MESSAGE ) ; }
tr	7	static boolean authenticate ( String username , String hashString , PassthroughConnection ptc ) { try { String encodedUsername = URLEncoder . encode ( username , "UTF-8" ) ; String encodedHashString = URLEncoder . encode ( hashString , "UTF-8" ) ; String authURLString = new String ( "http://www.minecraft.net/game/checkserver.jsp?user=" + encodedUsername + "&serverId=" + encodedHashString ) ; if ( ! Globals . isQuiet ( ) ) { ptc . printLogMessage ( "Authing with " + authURLString ) ; } URL minecraft = new URL ( authURLString ) ; URLConnection minecraftConnection = minecraft . openConnection ( ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( minecraftConnection . getInputStream ( ) ) ) ; String reply = in . readLine ( ) ; if ( Globals . isInfo ( ) ) { ptc . printLogMessage ( "Server Response: " + reply ) ; } in . close ( ) ; if ( reply != null && reply . equals ( "YES" ) ) { if ( ! Globals . isQuiet ( ) ) { ptc . printLogMessage ( "Auth successful" ) ; } return true ; } } catch ( MalformedURLException mue ) { ptc . printLogMessage ( "Auth URL error" ) ; } catch ( IOException ioe ) { ptc . printLogMessage ( "Problem connecting to auth server" ) ; } return false ; }
tr	7	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; int nTestCases = Integer . parseInt ( sc . nextLine ( ) ) ; sc . nextLine ( ) ; Line decryptedLine = new Line ( "the quick brown fox jumps over the lazy dog" ) ; for ( int t = 0 ; t < nTestCases ; ++ t ) { List < Line > lines = new LinkedList < Line > ( ) ; Map < Character , Character > dict = null ; while ( sc . hasNextLine ( ) ) { String input = sc . nextLine ( ) ; if ( input . isEmpty ( ) ) { break ; } Line line = new Line ( input ) ; lines . add ( line ) ; if ( dict == null ) { dict = line . getDict ( decryptedLine ) ; } } if ( dict == null ) { System . out . println ( "No solution." ) ; } else { for ( Line l : lines ) { System . out . println ( l . decrypt ( dict ) ) ; } } if ( t < nTestCases - 1 ) { System . out . println ( ) ; } } }
tr	7	private static void test2_4 ( ) throws FileNotFoundException { String test1 = "new game\n" + "examine room\n" + "quit\n" + "yes\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( test1 . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( testOutput . size ( ) - 6 , ">> The prison cell is a cold  dirty place." ) ; output . put ( testOutput . size ( ) - 5 , "The only light in the room filters through the bars in the cell door." ) ; output . put ( testOutput . size ( ) - 4 , "On the ground there is a: cell key." ) ; output . put ( testOutput . size ( ) - 3 , "The guard walks toward your cell." ) ; output . put ( testOutput . size ( ) - 2 , ">> Are you sure you want to quit? (y/n)" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test2_4 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test2_4 passed" ) ; } } else { System . out . println ( "test2_4 failed: error" ) ; } } }
tr	9X	public static String getTypeName ( class < ? extends Tag > clazz ) { if ( clazz . equals ( ByteArrayTag . class ) ) { return "TAG_Byte_Array" ; } else if ( clazz . equals ( ByteTag . class ) ) { return "TAG_Byte" ; } else if ( clazz . equals ( CompoundTag . class ) ) { return "TAG_Compound" ; } else if ( clazz . equals ( DoubleTag . class ) ) { return "TAG_Double" ; } else if ( clazz . equals ( EndTag . class ) ) { return "TAG_End" ; } else if ( clazz . equals ( FloatTag . class ) ) { return "TAG_Float" ; } else if ( clazz . equals ( IntArrayTag . class ) ) { return "TAG_Int_Array" ; } else if ( clazz . equals ( IntTag . class ) ) { return "TAG_Int" ; } else if ( clazz . equals ( ListTag . class ) ) { return "TAG_List" ; } else if ( clazz . equals ( LongTag . class ) ) { return "TAG_Long" ; } else if ( clazz . equals ( ShortTag . class ) ) { return "TAG_Short" ; } else if ( clazz . equals ( StringTag . class ) ) { return "TAG_String" ; } else if ( clazz . equals ( ListStringArrayTag . class ) ) { return "TAG_ListString_Array" ; } else if ( clazz . equals ( ListItemStackArrayTag . class ) ) { return "TAG_ListItemStack_Array" ; } else { throw new IllegalArgumentException ( "Invalid tag classs (" + clazz . getName ( ) + ")." ) ; } }
tr	4	public void update ( final long newCurrent , final String optStatus ) { if ( this . upperLimit == - 1 ) { throw new IllegalArgumentException ( "This progress printer has not been initialized" ) ; } this . ownPos = newCurrent ; long sumOfSubProgresses = 0 ; this . currentPos = 0 ; for ( final ProgressPrinter subProgress : this . subProgress . keySet ( ) ) { double percentFinishedSubProgress = subProgress . getPercent ( ) / 100.0 ; long totalNumberStepsSubProgress = this . subProgress . get ( subProgress ) ; this . currentPos += ( percentFinishedSubProgress * totalNumberStepsSubProgress ) ; sumOfSubProgresses += totalNumberStepsSubProgress ; } final long remainingPart = this . upperLimit - sumOfSubProgresses ; if ( remainingPart < 0 ) { throw new IllegalArgumentException ( "Invalid part-sums of sub progresses" ) ; } this . currentPos += this . ownPos ; final float newPercent = this . currentPos > 0 ? ( ( float ) ( this . currentPos ) / this . upperLimit * 100.0f ) : 0.0f ; this . optStatus = optStatus ; this . % = newPercent ; this . fireChangeListener ( ) ; }
tr	1	public Item ( String label , double quantity , double price , double vat , int count ) { this . label = label ; this . quantity = quantity ; this . price = price ; this . vat = vat ; for ( int i = 0 ; i < count ; ++ i ) { subItems . add ( new Item ( label + "." + i , random . nextDouble ( ) , random . nextDouble ( ) , random . nextDouble ( ) , 0 ) ) ; } }
tr	3	@ Override public Connection getConnection ( ) { try { if ( connection != null && ! connection . isClosed ( ) ) { return connection ; } else { connection = DriverManager . getConnection ( "jdbc:hsqldb:file:" + db + ";shutdown=true" , user , pass ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return connection ; }
tr	1	private void printMessage ( String messageOut ) { if ( debug ) { System . out . print ( messageOut ) ; } }
tr	1	public void actionPerformed ( ActionEvent e ) { String albumName = albumNameTF . getText ( ) ; try { makeAlbumPopUp . this . photosScreen . makeAlbum ( albumName ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } }
tr	5	static public void LU_ver ( double a [ ] [ ] ) { int n = a . length ; int i , j , k ; double suma ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j <= i - 1 ; j ++ ) { ver ( i , j , 0 ) ; System . out . print ( "(" ) ; ver ( i , j , 1 ) ; suma = 0 ; for ( k = 0 ; k <= j - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = ( a [ i ] [ j ] - suma ) / a [ j ] [ j ] ; ver ( j , j , 4 ) ; System . out . println ( ) ; } for ( j = i ; j < n ; j ++ ) { suma = 0 ; ver ( i , j , 0 ) ; ver ( i , j , 1 ) ; for ( k = 0 ; k <= i - 1 ; k ++ ) { ver ( i , k , 3 ) ; ver ( k , j , 2 ) ; suma += a [ i ] [ k ] * a [ k ] [ j ] ; } a [ i ] [ j ] = a [ i ] [ j ] - suma ; System . out . println ( ) ; } } }
tr	4	public int update ( int [ ] sig , double [ ] variances ) { int onset = Integer . MAX_VALUE ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . add ( sig [ i ] ) ; } if ( isFilled ( ) ) { System . out . print ( ( check ? "window filled\n" : "" ) ) ; check = false ; for ( int i = 0 ; i < sig . length ; i ++ ) { signals . get ( i ) . poll ( ) ; } onset = applyBonatoTest ( variances ) ; } return onset ; }
tr	9X	private static void horizLeftRight ( Board b , ArrayList < Tuple > movesToBlock , ArrayList < Tuple > movesToMake ) { int xIndex ; int yIndex ; Game game = b . getGame ( ) ; int player1Color = game . getPlayer1Color ( ) ; int player2Color = game . getPlayer2Color ( ) ; for ( int row = 0 ; row < 6 ; row ++ ) { for ( int col = 0 ; col < 4 ; col ++ ) { if ( player1Color == b . getGameGridCircle ( col , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player1Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToBlock , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 2 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) ) { xIndex = col + 3 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } if ( player2Color == b . getGameGridCircle ( col , row ) . getState ( ) && player2Color == b . getGameGridCircle ( col + 1 , row ) . getState ( ) && ( b . getGameGridCircle ( col + 2 , row ) . getState ( ) == 0 ) ) { if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == 0 ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 1 ) ; } if ( b . getGameGridCircle ( col + 3 , row ) . getState ( ) == player2Color ) { xIndex = col + 2 ; yIndex = row ; checkAndAdd ( b , movesToMake , xIndex , yIndex , 2 ) ; } } } } }
tr	3	public int [ ] getActions ( Game game , long timeDue ) { int [ ] directions = new int [ Game . NUM_GHOSTS ] ; for ( int i = 0 ; i < directions . length ; i ++ ) if ( game . ghostRequiresAction ( i ) ) { if ( Game . rnd . nextFloat ( ) < CONSISTENCY ) directions [ i ] = game . getNextGhostDir ( i , game . getCurPacManLoc ( ) , attract , Game . DM . PATH ) ; else { int [ ] possibleDirs = game . getPossibleGhostDirs ( i ) ; directions [ i ] = possibleDirs [ G . rnd . nextInt ( possibleDirs . length ) ] ; } } return directions ; }
tr	8	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
tr	9X	public static void main ( String [ ] args ) { boolean a , b ; System . out . println ( "a\tb\ta and b\ta or b\tnot a\tnot b \n" ) ; a = 3 > 5 ; b = 12 != 8 ; System . out . print ( "(3>5)\t(12!=8)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 5 >= 6 ; b = 3 != 3 ; System . out . print ( "(5>=6)\t(3!=3)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = - 7 == 8 ; System . out . print ( "(-7=8)\t(22)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + " NO SE PUEDE USAR EL 22\n" ) ; a = 21 != 12 ; b = true ; System . out . print ( "21!=12\t(true)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; a = 4 == 2 ; b = 7 >= - 9 ; System . out . print ( "(4==2)\t(7>=-9)\t" + ( a && b ) ) ; System . out . print ( "\t" ) ; System . out . print ( a || b ) ; System . out . print ( "\t" ) ; System . out . print ( ! a ) ; System . out . print ( "\t" ) ; System . out . println ( ! b + "\n" ) ; }
tr	0	private void finaliza ( ) { this . dispose ( ) ; }
tr	7	private Bed getBed ( CommandLine cmd ) { Bed bed = null ; if ( cmd . hasOption ( "hostel_id" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setHostelId ( new Identifier ( cmd . getOptionValue ( "hostel_id" ) ) ) ; } if ( cmd . hasOption ( "bed_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setNumber ( new Integer ( cmd . getOptionValue ( "bed_number" ) ) ) ; } if ( cmd . hasOption ( "room_number" ) ) { if ( bed == null ) bed = new Bed ( ) ; bed . setRoomNo ( new Integer ( cmd . getOptionValue ( "room_number" ) ) ) ; } if ( bed != null ) bed . setTariff ( null ) ; return bed ; }
tr	7	public static < E > void topKSort ( E [ ] array , Comparator < E > comparator , int k ) { if ( k >= array . length ) { k = array . length ; } if ( k < 0 ) { throw new UnsupportedOperationException ( "-k <number> number must be equal or greater than zero." ) ; } FourHeap < E > fh = new FourHeap < E > ( comparator ) ; int i = 0 ; while ( i < k ) { fh . insert ( array [ i ++ ] ) ; } if ( k != 0 ) { while ( i < array . length ) { if ( comparator . compare ( fh . findMin ( ) , array [ i ] ) < 0 ) { fh . deleteMin ( ) ; fh . insert ( array [ i ] ) ; } i ++ ; } } int v = k - 1 ; while ( ! fh . isEmpty ( ) ) { array [ v ] = fh . deleteMin ( ) ; v -- ; } }
tr	3	public static void main ( String args [ ] ) { int i , j , k ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 26 ; j ++ ) for ( k = 0 ; k < 2 ; k ++ ) System . out . print ( ( char ) ( A + j ) ) ; System . out . println ( ) ; }
tr	1	public static boolean invertM ( float [ ] mInv , int mInvOffset , float [ ] m , int mOffset ) { final float src0 = m [ mOffset + 0 ] ; final float src4 = m [ mOffset + 1 ] ; final float src8 = m [ mOffset + 2 ] ; final float src12 = m [ mOffset + 3 ] ; final float src1 = m [ mOffset + 4 ] ; final float src5 = m [ mOffset + 5 ] ; final float src9 = m [ mOffset + 6 ] ; final float src13 = m [ mOffset + 7 ] ; final float src2 = m [ mOffset + 8 ] ; final float src6 = m [ mOffset + 9 ] ; final float src10 = m [ mOffset + 10 ] ; final float src14 = m [ mOffset + 11 ] ; final float src3 = m [ mOffset + 12 ] ; final float src7 = m [ mOffset + 13 ] ; final float src11 = m [ mOffset + 14 ] ; final float src15 = m [ mOffset + 15 ] ; final float atmp0 = src10 * src15 ; final float atmp1 = src11 * src14 ; final float atmp2 = src9 * src15 ; final float atmp3 = src11 * src13 ; final float atmp4 = src9 * src14 ; final float atmp5 = src10 * src13 ; final float atmp6 = src8 * src15 ; final float atmp7 = src11 * src12 ; final float atmp8 = src8 * src14 ; final float atmp9 = src10 * src12 ; final float atmp10 = src8 * src13 ; final float atmp11 = src9 * src12 ; final float dst0 = ( atmp0 * src5 + atmp3 * src6 + atmp4 * src7 ) - ( atmp1 * src5 + atmp2 * src6 + atmp5 * src7 ) ; final float dst1 = ( atmp1 * src4 + atmp6 * src6 + atmp9 * src7 ) - ( atmp0 * src4 + atmp7 * src6 + atmp8 * src7 ) ; final float dst2 = ( atmp2 * src4 + atmp7 * src5 + atmp10 * src7 ) - ( atmp3 * src4 + atmp6 * src5 + atmp11 * src7 ) ; final float dst3 = ( atmp5 * src4 + atmp8 * src5 + atmp11 * src6 ) - ( atmp4 * src4 + atmp9 * src5 + atmp10 * src6 ) ; final float det = src0 * dst0 + src1 * dst1 + src2 * dst2 + src3 * dst3 ; if ( det == 0.0f ) { return false ; } final float dst4 = ( atmp1 * src1 + atmp2 * src2 + atmp5 * src3 ) - ( atmp0 * src1 + atmp3 * src2 + atmp4 * src3 ) ; final float dst5 = ( atmp0 * src0 + atmp7 * src2 + atmp8 * src3 ) - ( atmp1 * src0 + atmp6 * src2 + atmp9 * src3 ) ; final float dst6 = ( atmp3 * src0 + atmp6 * src1 + atmp11 * src3 ) - ( atmp2 * src0 + atmp7 * src1 + atmp10 * src3 ) ; final float dst7 = ( atmp4 * src0 + atmp9 * src1 + atmp10 * src2 ) - ( atmp5 * src0 + atmp8 * src1 + atmp11 * src2 ) ; final float btmp0 = src2 * src7 ; final float btmp1 = src3 * src6 ; final float btmp2 = src1 * src7 ; final float btmp3 = src3 * src5 ; final float btmp4 = src1 * src6 ; final float btmp5 = src2 * src5 ; final float btmp6 = src0 * src7 ; final float btmp7 = src3 * src4 ; final float btmp8 = src0 * src6 ; final float btmp9 = src2 * src4 ; final float btmp10 = src0 * src5 ; final float btmp11 = src1 * src4 ; final float dst8 = ( btmp0 * src13 + btmp3 * src14 + btmp4 * src15 ) - ( btmp1 * src13 + btmp2 * src14 + btmp5 * src15 ) ; final float dst9 = ( btmp1 * src12 + btmp6 * src14 + btmp9 * src15 ) - ( btmp0 * src12 + btmp7 * src14 + btmp8 * src15 ) ; final float dst10 = ( btmp2 * src12 + btmp7 * src13 + btmp10 * src15 ) - ( btmp3 * src12 + btmp6 * src13 + btmp11 * src15 ) ; final float dst11 = ( btmp5 * src12 + btmp8 * src13 + btmp11 * src14 ) - ( btmp4 * src12 + btmp9 * src13 + btmp10 * src14 ) ; final float dst12 = ( btmp2 * src10 + btmp5 * src11 + btmp1 * src9 ) - ( btmp4 * src11 + btmp0 * src9 + btmp3 * src10 ) ; final float dst13 = ( btmp8 * src11 + btmp0 * src8 + btmp7 * src10 ) - ( btmp6 * src10 + btmp9 * src11 + btmp1 * src8 ) ; final float dst14 = ( btmp6 * src9 + btmp11 * src11 + btmp3 * src8 ) - ( btmp10 * src11 + btmp2 * src8 + btmp7 * src9 ) ; final float dst15 = ( btmp10 * src10 + btmp4 * src8 + btmp9 * src9 ) - ( btmp8 * src9 + btmp11 * src10 + btmp5 * src8 ) ; final float invdet = 1.0f / det ; mInv [ mInvOffset ] = dst0 * invdet ; mInv [ 1 + mInvOffset ] = dst1 * invdet ; mInv [ 2 + mInvOffset ] = dst2 * invdet ; mInv [ 3 + mInvOffset ] = dst3 * invdet ; mInv [ 4 + mInvOffset ] = dst4 * invdet ; mInv [ 5 + mInvOffset ] = dst5 * invdet ; mInv [ 6 + mInvOffset ] = dst6 * invdet ; mInv [ 7 + mInvOffset ] = dst7 * invdet ; mInv [ 8 + mInvOffset ] = dst8 * invdet ; mInv [ 9 + mInvOffset ] = dst9 * invdet ; mInv [ 10 + mInvOffset ] = dst10 * invdet ; mInv [ 11 + mInvOffset ] = dst11 * invdet ; mInv [ 12 + mInvOffset ] = dst12 * invdet ; mInv [ 13 + mInvOffset ] = dst13 * invdet ; mInv [ 14 + mInvOffset ] = dst14 * invdet ; mInv [ 15 + mInvOffset ] = dst15 * invdet ; return true ; }
tr	0	public void setRing ( boolean ring ) { this . ring = ring ; }
tr	5	private long checkClientTimeouts ( int timeout ) { Set < Integer > disconnectedClientIds = new HashSet < Integer > ( ) ; long oldestClientCommunicationTime = - 1 ; synchronized ( CONNECTION_LOCK ) { if ( ! isRunning ) return - 1 ; long now = System . currentTimeMillis ( ) ; oldestClientCommunicationTime = now ; for ( Iterator < Integer > iter = clients . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { int clientId = iter . next ( ) ; ClientInfo client = clients . get ( clientId ) ; if ( client . getTimeOfLastCommunication ( ) + timeout <= now ) { iter . remove ( ) ; disconnectedClientIds . add ( clientId ) ; } else if ( client . getTimeOfLastCommunication ( ) < oldestClientCommunicationTime ) oldestClientCommunicationTime = client . getTimeOfLastCommunication ( ) ; } } for ( int clientId : disconnectedClientIds ) { logger . fine ( "Client " + clientId + " timed out" ) ; onClientDisconnected ( clientId , Server . CLIENT_TIMED_OUT ) ; } return oldestClientCommunicationTime ; }
tr	0	private void btnVoltarActionPerformed ( java . awt . event . ActionEvent evt ) { CSVAcesso acesso = new CSVAcesso ( "cadastro.csv" , "true" ) ; acesso . parse ( ) ; TelaMedico medico = new TelaMedico ( localNome , acesso . pegarPacientes ( ) , "Medico" ) ; this . setVisible ( false ) ; medico . setVisible ( true ) ; }
tr	8	public boolean IsInverse ( GameDirection Direction ) { if ( this == GameDirection . UP && Direction == GameDirection . DOWN ) return true ; if ( this == GameDirection . DOWN && Direction == GameDirection . UP ) return true ; if ( this == GameDirection . LEFT && Direction == GameDirection . RIGHT ) return true ; if ( this == GameDirection . RIGHT && Direction == GameDirection . LEFT ) return true ; return false ; }
tr	4	public static double [ ] [ ] produitMat ( double [ ] [ ] m1 , double [ ] [ ] m2 ) { int n1 = m1 . length ; int l1 = m1 [ 0 ] . length ; int n2 = m2 . length ; int l2 = m2 [ 0 ] . length ; double [ ] [ ] res = new double [ n1 ] [ l2 ] ; if ( ! ( l1 == n2 ) ) { System . out . println ( "Tailles non concordantes" ) ; } else { for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < l2 ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int l = 0 ; l < l1 ; l ++ ) { res [ i ] [ j ] += m1 [ i ] [ l ] * m2 [ l ] [ j ] ; } } } } return res ; }
tr	7	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ SIZE ] ; for ( int i = 2 ; i < SIZE ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < SIZE ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < SIZE ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; ArrayList < Radical > radicals = new ArrayList < Radical > ( ) ; for ( int i = 0 ; i <= SIZE ; i ++ ) radicals . add ( new Radical ( i , primeList ) ) ; radicals = sort ( radicals ) ; System . out . print ( radicals . get ( SIZE / 10 ) . num ) ; }
tr	8	public static Object subtract ( Object val0 , Object val1 ) { val0 = guess ( val0 ) ; val1 = guess ( val1 ) ; if ( val0 instanceof Color ) return ( ( Color ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Size ) return ( ( Size ) val0 ) . subtract ( val1 ) ; if ( val0 instanceof Number && val1 instanceof Number ) { if ( val0 instanceof double || val1 instanceof double ) return ( ( Number ) val0 ) . doubleValue ( ) - ( ( Number ) val1 ) . doubleValue ( ) ; return ( ( Number ) val0 ) . intValue ( ) - ( ( Number ) val1 ) . intValue ( ) ; } return val0 == null ? null : val1 == null ? val0 : Classes . toString ( val0 ) . replace ( Classes . toString ( val1 ) , "" ) ; }
tr	2	public void simulateOneStep ( ) { step ++ ; startSickness ( startKans ) ; List < Actor > newActors = new ArrayList < Actor > ( ) ; for ( Iterator < Actor > it = actors . iterator ( ) ; it . hasNext ( ) ; ) { Actor actor = it . next ( ) ; actor . act ( newActors ) ; if ( ! actor . isActive ( ) ) { it . remove ( ) ; } } actors . addAll ( newActors ) ; statusUpdate ( ) ; }
tr	5	@ Test public void testlimitNunberOfItems ( ) throws IOException { block = new StorageBlock ( testDir , 2 , StorageManager . DEFAULT_CAPACITY_PER_BLOCK , storageMode ) ; int limit = 1000 ; String testString = "Test String" ; byte [ ] testBytes = testString . getBytes ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; Pointer [ ] pointers = new Pointer [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) { Pointer pointer = block . store ( testBytes ) ; pointers [ i ] = pointer ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointer . getPosition ( ) ) ; assertTrue ( testBytes . length == pointer . getLength ( ) ) ; assertTrue ( testBytes . length * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . retrieve ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; } String smallTestString = "Test Str" ; byte [ ] smallTestBytes = smallTestString . getBytes ( ) ; for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , smallTestBytes ) ; assertTrue ( ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) == block . getDirty ( ) ) ; double expectedRatio = ( i + 1 ) * ( testBytes . length - smallTestBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( i * ( testBytes . length ) == pointers [ i ] . getPosition ( ) ) ; assertTrue ( smallTestBytes . length == pointers [ i ] . getLength ( ) ) ; assertTrue ( testBytes . length * limit - ( testBytes . length - smallTestBytes . length ) * ( i + 1 ) == block . getUsed ( ) ) ; } for ( int i = 0 ; i < limit ; i ++ ) { pointers [ i ] = block . update ( pointers [ i ] , testBytes ) ; assertTrue ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length == block . getDirty ( ) ) ; double expectedRatio = ( ( ( testBytes . length - smallTestBytes . length ) * ( limit - i - 1 ) ) + ( i + 1 ) * testBytes . length ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; assertTrue ( ( limit + i ) * testBytes . length == pointers [ i ] . getPosition ( ) ) ; assertTrue ( testBytes . length == pointers [ i ] . getLength ( ) ) ; } assertTrue ( testBytes . length * limit == block . getUsed ( ) ) ; for ( int i = 0 ; i < limit ; i ++ ) { byte [ ] resultBytes = block . remove ( pointers [ i ] ) ; assertEquals ( testString , new String ( resultBytes ) ) ; double expectedRatio = ( testBytes . length * limit + testBytes . length * ( i + 1 ) ) * 1.0 / StorageManager . DEFAULT_CAPACITY_PER_BLOCK ; assertTrue ( Math . abs ( expectedRatio - block . getDirtyRatio ( ) ) <= 1e-6 ) ; } assertTrue ( 0 == block . getUsed ( ) ) ; block . free ( ) ; assertTrue ( StorageManager . DEFAULT_CAPACITY_PER_BLOCK == block . getCapacity ( ) ) ; assertTrue ( 0 == block . getDirty ( ) ) ; assertTrue ( block . getDirtyRatio ( ) <= 1e-6 ) ; assertTrue ( 2 == block . getIndex ( ) ) ; }
tr	6	public Editor ( DefaultMutableTreeNode node , DefaultTreeModel model ) throws InvalidNodeRepresentationException { _node = node ; _model = model ; _children = new ArrayList < > ( ) ; if ( _node . getUserObject ( ) instanceof Song ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = ( Song ) node . getUserObject ( ) ; _playlist = null ; _artist = new JTextField ( _song . getArtist ( ) ) ; _title = new JTextField ( _song . getTitle ( ) ) ; _album = new JTextField ( _song . getAlbum ( ) ) ; _genre = new JTextField ( _song . getGenre ( ) ) ; _year = new JTextField ( _song . getYear ( ) ) ; _name = null ; JLabel artist = new JLabel ( "Artist:" ) ; JLabel title = new JLabel ( "Title:" ) ; JLabel album = new JLabel ( "Album:" ) ; JLabel genre = new JLabel ( "Genre:" ) ; JLabel year = new JLabel ( "Year:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( artist ) ; add ( _artist ) ; add ( title ) ; add ( _title ) ; add ( album ) ; add ( _album ) ; add ( genre ) ; add ( _genre ) ; add ( year ) ; add ( _year ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , artist , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _artist , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _artist , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _artist , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . WEST , title , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _title , 5 , SpringLayout . SOUTH , _artist ) ; layout . putConstraint ( SpringLayout . EAST , _title , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _title , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . WEST , album , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _album , 5 , SpringLayout . SOUTH , _title ) ; layout . putConstraint ( SpringLayout . EAST , _album , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _album , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . WEST , genre , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _genre , 5 , SpringLayout . SOUTH , _album ) ; layout . putConstraint ( SpringLayout . EAST , _genre , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _genre , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . WEST , year , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _year , 5 , SpringLayout . SOUTH , _genre ) ; layout . putConstraint ( SpringLayout . EAST , _year , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _year , 5 , SpringLayout . EAST , album ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _year ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _year ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else if ( _node . getUserObject ( ) instanceof Playlist ) { SpringLayout layout = new SpringLayout ( ) ; setLayout ( layout ) ; setBorder ( new LineBorder ( Color . BLACK , 3 ) ) ; setBackground ( Color . WHITE ) ; _song = null ; _playlist = ( Playlist ) node . getUserObject ( ) ; _artist = null ; _title = null ; _album = null ; _genre = null ; _year = null ; _name = new JTextField ( _playlist . getName ( ) ) ; JLabel name = new JLabel ( "Title:" ) ; try { _saveButton = new JButton ( new BeethovenIcon ( getClass ( ) . getResource ( "Icons/save.png" ) . toURI ( ) . toURL ( ) ) ) ; _saveButton . setBackground ( Color . WHITE ) ; _saveButton . setBorder ( null ) ; _saveButton . setToolTipText ( "Save" ) ; _saveButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { save ( ) ; } } ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } add ( name ) ; add ( _name ) ; add ( _saveButton ) ; layout . putConstraint ( SpringLayout . NORTH , name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . WEST , name , 5 , SpringLayout . WEST , this ) ; layout . putConstraint ( SpringLayout . NORTH , _name , 5 , SpringLayout . NORTH , this ) ; layout . putConstraint ( SpringLayout . EAST , _name , - 5 , SpringLayout . EAST , this ) ; layout . putConstraint ( SpringLayout . WEST , _name , 5 , SpringLayout . EAST , name ) ; layout . putConstraint ( SpringLayout . NORTH , _saveButton , 10 , SpringLayout . SOUTH , _name ) ; layout . putConstraint ( SpringLayout . WEST , _saveButton , 0 , SpringLayout . WEST , _name ) ; setPreferredSize ( new Dimension ( 512 , 720 / 3 ) ) ; } else { throw new InvalidNodeRepresentationException ( "Node must represent a Song or Playlist" ) ; } }
tr	4	private void setEventLimitFlags ( ) { Settings_Event . EVENT_LIMIT_REACHED_LOW = ( Settings_Event . RUNNING_EVENTS_LOW >= Settings_Event . MAX_RUNNING_EVENTS_LOW ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_MID = ( Settings_Event . RUNNING_EVENTS_MID >= Settings_Event . MAX_RUNNING_EVENTS_MID ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_HIGH = ( Settings_Event . RUNNING_EVENTS_HIGH >= Settings_Event . MAX_RUNNING_EVENTS_HIGH ) ? true : false ; Settings_Event . EVENT_LIMIT_REACHED_ALL = ( Settings_Event . RUNNING_EVENTS_ALL >= Settings_Event . MAX_RUNNING_EVENTS_ALL ) ? true : false ; }
tr	4	RendererContext ( final String name ) { if ( LOG_CREATE_CONTEXT ) { MarlinUtils . logInfo ( "new RendererContext = " + name ) ; } this . name = name ; nPCPathIterator = new NormalizingPathIterator . NearestPixelCenter ( float6 ) ; nPQPathIterator = new NormalizingPathIterator . NearestPixelQuarter ( float6 ) ; transformerPC2D = new TransformingPathConsumer2D ( ) ; cache = new MarlinCache ( this ) ; renderer = new Renderer ( this ) ; ptg = new MarlinTileGenerator ( renderer ) ; stroker = new Stroker ( this ) ; dasher = new Dasher ( this ) ; switch ( MarlinRenderingEngine . REF_TYPE ) { default : case MarlinRenderingEngine . REF_HARD : reference = this ; break ; case MarlinRenderingEngine . REF_SOFT : reference = new SoftReference < RendererContext > ( this ) ; break ; case MarlinRenderingEngine . REF_WEAK : reference = new WeakReference < RendererContext > ( this ) ; break ; } }
tr	6	public MainFrame ( ) { initComponents ( ) ; preferences = Preferences . userRoot ( ) . node ( this . getClass ( ) . getName ( ) ) ; final String pathToPDFLaTeXFile = preferences . get ( "pathToPDFLaTeXFile" , null ) ; final String pathToPDFExportFolder = preferences . get ( "pathToPDFExportFolder" , null ) ; if ( ( pathToPDFLaTeXFile == null ) || ( pathToPDFExportFolder == null ) ) Config . initPreferences ( preferences ) ; if ( ( pathToPDFLaTeXFile != null ) && ( ! pathToPDFLaTeXFile . equals ( Config . default ) ) ) Config . setPDFLaTeXFile ( new File ( pathToPDFLaTeXFile ) ) ; if ( ( pathToPDFExportFolder != null ) && ( ! pathToPDFExportFolder . equals ( Config . default ) ) ) Config . setPDFExportFolder ( new File ( pathToPDFExportFolder ) ) ; parameterLabelArray = new javax . swing . JLabel [ ] { parameter1Label , parameter2Label , parameter3Label , parameter4Label } ; parameterArray = new javax . swing . JTextField [ ] { parameter1 , parameter2 , parameter3 , parameter4 } ; problemPartComponentsArray = new JComponent [ ] { userAnswerField , checkButton , showSolutionLaTeXButton , showSolutionPlaintextButton , copyToClipboardButton , exportToPDFButton , resetButton } ; }
tr	2	public static void main ( String [ ] args ) { TreeSet < Integer > set2 = new TreeSet < Integer > ( ) ; set2 . add ( 4 ) ; set2 . add ( 100 ) ; set2 . add ( 45 ) ; set2 . add ( 19 ) ; set2 . add ( 33 ) ; ArrayList < TreeSet < Integer >> totalSubSets = findSubSets ( set2 , 0 ) ; if ( totalSubSets == null ) System . out . println ( "No possible subsets" ) ; else for ( TreeSet < Integer > ts : totalSubSets ) { System . out . println ( ts ) ; } }
tr	4	@ Override public void run ( ) { try { String hostname = NetBase . theNetBase ( ) . hostname ( ) ; if ( hostname != null ) { if ( hostname . isEmpty ( ) ) System . out . println ( "Host: root" ) ; else System . out . println ( "Host: '" + hostname + "'" ) ; } else System . out . println ( "Host: none" ) ; RPCService rpcService = ( RPCService ) NetBase . theNetBase ( ) . getService ( "rpc" ) ; if ( rpcService != null ) System . out . println ( "IP: " + IPFinder . localIP ( ) + "  Port: " + rpcService . localPort ( ) ) ; else System . out . println ( "No RPC service is running on this node." ) ; } catch ( Exception e ) { System . out . println ( "Caught exception: " + e . getMessage ( ) ) ; } }
tr	6	public void addPoint ( float p ) { if ( p < this . min || p > this . max ) return ; if ( p == this . max ) { this . bins [ count - 1 ] ++ ; return ; } float temp = ( p - this . min ) / ( this . max - this . min ) ; for ( int i = 0 ; i < this . count ; i ++ ) if ( temp >= this . h * i && temp < this . h * ( i + 1 ) ) { this . bins [ i ] ++ ; return ; } }
tr	5	@ Override public void render ( GameContainer gc , StateBasedGame sbg , Graphics grphcs ) throws SlickException { background . draw ( 0 , 0 ) ; txtName . render ( gc , grphcs ) ; for ( int i = 0 ; i < areas . length ; i ++ ) { areas [ i ] . render ( gc , grphcs ) ; } for ( StatAllocation stat : stats ) { ttf . drawString ( stat . getPosition ( ) . getX ( ) , stat . getPosition ( ) . getY ( ) , Integer . toString ( stat . getStat ( ) ) ) ; } if ( femaleChose == true ) { ttf . drawString ( 170 , 94 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : female ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } else { ttf . drawString ( 360 , 93 , "X" , Color . white ) ; int x = 94 ; grphcs . scale ( 2 , 2 ) ; for ( PlayerSprite ps : male ) { ps . getAnimation ( ) . draw ( x , 80 ) ; x = x + 36 ; } } grphcs . scale ( .5f , .5f ) ; }
tr	9X	public static String getResultXMLString ( SimulationFinalResult result ) { if ( result == null ) { return "" ; } StringBuilder xml = new StringBuilder ( ) ; xml . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>" ) . append ( LINE_END ) . append ( "<simulation>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<playercount>" ) . append ( result . getNrOfPlayers ( ) ) . append ( "</playercount>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<rounds>" ) . append ( result . getRounds ( ) ) . append ( "</rounds>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<type>" ) . append ( result . getPokerType ( ) . toString ( ) ) . append ( "</type>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<threads>" ) . append ( result . getNrOfThreads ( ) ) . append ( "</threads>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<duration unit=\"milliseconds\">" ) . append ( result . getDuration ( ) ) . append ( "</duration>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "</meta>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 1 ) ) . append ( "<players>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) ; PlayerProfile profile = result . getPlayer ( i - 1 ) ; xml . append ( "<handtype>" ) ; xml . append ( profile . getHandType ( ) . toString ( ) ) ; xml . append ( "</handtype>" ) ; xml . append ( LINE_END ) ; if ( profile . getHandType ( ) == HandType . EXACTCARDS ) { Card [ ] cards = profile . getCards ( ) ; for ( Card card : cards ) { xml . append ( getNestingCharacters ( 3 ) ) . append ( "<card>" ) . append ( card . toString ( ) ) . append ( "</card>" ) . append ( LINE_END ) ; } } else if ( profile . getHandType ( ) == HandType . RANGE ) { Range range = profile . getRange ( ) ; for ( int row = 0 ; row < 13 ; row ++ ) { for ( int col = 0 ; col < 13 ; col ++ ) { if ( range . getValue ( row , col ) ) { xml . append ( getNestingCharacters ( 3 ) ) ; xml . append ( "<cardtype>" ) ; xml . append ( Range . rangeNames [ row ] [ col ] ) ; xml . append ( "</cardtype>" ) ; xml . append ( LINE_END ) ; } } } } xml . append ( getNestingCharacters ( 2 ) ) ; xml . append ( "</player>" ) ; xml . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "</players>" ) ; xml . append ( LINE_END ) ; Card [ ] flop = result . getFlop ( ) ; Card turn = result . getTurn ( ) ; Card river = result . getRiver ( ) ; if ( flop != null || turn != null || river != null ) { xml . append ( getNestingCharacters ( 1 ) ) ; xml . append ( "<community>" ) ; xml . append ( LINE_END ) ; if ( flop != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"1\">" ) . append ( flop [ 0 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"2\">" ) . append ( flop [ 1 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "<flop id=\"3\">" ) . append ( flop [ 2 ] . toString ( ) ) . append ( "</flop>" ) . append ( LINE_END ) ; } if ( turn != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<turn>" ) . append ( turn . toString ( ) ) . append ( "</turn>" ) . append ( LINE_END ) ; } if ( river != null ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<river>" ) . append ( river . toString ( ) ) . append ( "</river>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</community>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "<result>" ) . append ( LINE_END ) ; for ( int i = 1 ; i <= result . getNrOfPlayers ( ) ; i ++ ) { xml . append ( getNestingCharacters ( 2 ) ) . append ( "<player id=\"" ) . append ( i ) . append ( "\">" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<wins>" ) . append ( result . getFormattedWinPercentage ( i - 1 ) ) . append ( "</wins>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<loses>" ) . append ( result . getFormattedLosePercentage ( i - 1 ) ) . append ( "</loses>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 3 ) ) . append ( "<ties>" ) . append ( result . getFormattedTiePercentage ( i - 1 ) ) . append ( "</ties>" ) . append ( LINE_END ) . append ( getNestingCharacters ( 2 ) ) . append ( "</player>" ) . append ( LINE_END ) ; } xml . append ( getNestingCharacters ( 1 ) ) . append ( "</result>" ) . append ( LINE_END ) . append ( "</simulation>" ) ; return xml . toString ( ) ; }
tr	5	public static void main ( String [ ] args ) { RedBlackTree < Integer > t = new RedBlackTree < > ( ) ; final int NUMS = 400000 ; final int GAP = 35461 ; System . out . println ( "Checking... (no more output means success)" ) ; for ( int i = GAP ; i != 0 ; i = ( i + GAP ) % NUMS ) t . insert ( i ) ; if ( t . findMin ( ) != 1 || t . findMax ( ) != NUMS - 1 ) System . out . println ( "FindMin or FindMax error!" ) ; for ( int i = 1 ; i < NUMS ; i ++ ) if ( ! t . contains ( i ) ) System . out . println ( "Find error1!" ) ; }
tr	3	public String [ ] getParametersTypeOf ( String view , String viewMethod ) { for ( int i = 0 ; i < relations . size ( ) ; i ++ ) { if ( relations . get ( i ) . getView ( ) . equals ( view ) && relations . get ( i ) . getViewMethod ( ) . equals ( viewMethod ) ) return relations . get ( i ) . getParametersTypeAsArray ( ) ; } return null ; }
tr	7	protected synchronized void update ( ) { Date now = new Date ( ) ; long delta = now . getTime ( ) - lastUpdate . getTime ( ) ; if ( isDead ( ) ) return ; Point oldPos = new Point ( x , y ) ; Point dir = new Point ( speed . getDirectionX ( ) , speed . getDirectionY ( ) ) ; boolean blocked = false ; if ( dir . x != 0 ) blocked |= ! updatePosX ( delta ) ; if ( dir . y != 0 ) blocked |= ! updatePosY ( delta ) ; if ( ( dir . x == 0 && dir . y == 0 ) || blocked || ! oldPos . equals ( this ) ) lastUpdate = now ; }
tr	9X	private Location createLocation ( IPLocation ipLoc ) { Location location = new Location ( ) ; String city = ipLoc . getArea ( ) ; String country = ipLoc . getCountry ( ) ; if ( ( city == null ) || ( city . indexOf ( "CZ88.NET" ) > - 1 ) ) { city = "" ; } location . setCountry ( country ) ; location . setProvince ( city ) ; location . setCity ( city ) ; location . setAddress ( country + city ) ; if ( ! MyStringUtil . isBlank ( location . getAddress ( ) ) ) { int provinclen = Provinces . length ; for ( int l = 0 ; l < provinclen ; l ++ ) { String province = Provinces [ l ] ; if ( location . getAddress ( ) . indexOf ( province ) != - 1 ) { location . setCountry ( "\u4E2D\u56FD" ) ; location . setProvince ( province ) ; System . out . println ( province ) ; String [ ] citys = ProvinceCityMap . get ( province ) ; if ( citys != null ) { int citylen = citys . length ; for ( int k = 0 ; k < citylen ; k ++ ) { city = citys [ k ] ; if ( location . getAddress ( ) . indexOf ( city ) != - 1 ) { location . setCity ( city ) ; break ; } } } else { location . setProvince ( "\u5176\u4ED6" ) ; location . setCity ( "\u5176\u4ED6" ) ; } break ; } } int isplen = ISPs . length ; for ( int l = 0 ; l < isplen ; l ++ ) { String isp = ISPs [ l ] ; if ( location . getAddress ( ) . indexOf ( isp ) != - 1 ) { location . setISP ( isp ) ; break ; } } } if ( MyStringUtil . isBlank ( location . getCountry ( ) ) ) { location . setCountry ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getProvince ( ) ) ) { location . setProvince ( "\u5176\u4ED6" ) ; } if ( MyStringUtil . isBlank ( location . getCity ( ) ) ) { location . setCity ( "\u5176\u4ED6" ) ; } return location ; }
tr	4	public void paint ( Graphics g ) { if ( key == null ) return ; Graphics2D g2d = ( Graphics2D ) g ; int rectWidth = getWidth ( ) / table . getSpecs ( ) . getCollectionRows ( ) ; int rectHeight = getHeight ( ) / table . getSpecs ( ) . getCollectionCols ( ) ; for ( int a = 0 ; a < table . getSpecs ( ) . getCollectionCols ( ) ; a ++ ) { for ( int b = 0 ; b < table . getSpecs ( ) . getCollectionRows ( ) ; b ++ ) { if ( key . print ( 100 , 50 ) . charAt ( b * table . getSpecs ( ) . getCollectionRows ( ) + a ) == 1 ) { g2d . setColor ( Color . BLACK ) ; } else { g2d . setColor ( Color . WHITE ) ; } g2d . fillRect ( b * rectWidth , a * rectHeight , ( b + 1 ) * rectWidth , ( a + 1 ) * rectHeight ) ; } } updateUI ( ) ; }
tr	3	public List < Pattern > findPatternsEqualTo ( int matchPattern , int matchCount , int [ ] [ ] board ) { List < Pattern > resultPatterns = new ArrayList < Pattern > ( ) ; for ( int i = 0 ; i < board . length ; i ++ ) { for ( int j = 0 ; j < board [ i ] . length ; j ++ ) { List < Pattern > result = checkPiecePatterns ( i , j , matchPattern , matchCount , board ) ; if ( result . size ( ) > 0 ) { resultPatterns . addAll ( result ) ; } } } return resultPatterns ; }
tr	8	private void updateClaim ( boolean choice1 ) { switch ( claim . getStatus ( ) ) { case UnRanked : claim . rank ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ; JOptionPane . showMessageDialog ( form , "The claim has been ranked " + ( choice1 ? Claim . Rank . Complex : Claim . Rank . Simple ) ) ; break ; case Ranked : claim . setStatus ( choice1 ? Claim . Status . Confirmed : Claim . Status . Declined ) ; if ( choice1 ) { String billingInfo = AutomaticCustomerEmulator . sendForm ( ) ; storage . addPayment ( claim . getCustomerId ( ) , claim . getId ( ) , claim . getDamageCost ( ) , billingInfo ) ; } else AutomaticCustomerEmulator . sendMail ( "Your claim was denied" ) ; JOptionPane . showMessageDialog ( form , "The claim has been " + ( choice1 ? "confirmed" : "declined" ) ) ; break ; default : return ; } storage . updateClaim ( claim ) ; if ( listener != null ) { listener . actionPerformed ( new ActionEvent ( this , 0 , null ) ) ; } }
tr	2	@ NotNull @ Override public FileContent fileContentBefore ( ) { if ( filePathBefore . equals ( noFilePath ) ) return FileContent . none ; LogFileContentResult logFileContentResult = vcsRoot . get ( ) . logFileContent ( filePathBefore , revisionBefore ) ; return logFileContentResult . isSuccessful ( ) ? new FileContent ( logFileContentResult . text ( ) ) : FileContent . failedToLoad ; }
tr	3	@ Override public void writeAVLData ( OutputStream out ) { PrintStream ps = new PrintStream ( out ) ; ps . print ( "BODY\n" ) ; ps . printf ( locale , "%1$s\n" , this . getName ( ) ) ; ps . printf ( locale , "#Nbody  Bspace\n" + formatInteger ( 1 ) + formatFloat ( 1 , 2 ) , this . getNbody ( ) , this . getBspace ( ) ) ; ps . print ( "\n" ) ; ps . print ( "YDUPLICATE\n" ) ; ps . printf ( locale , formatFloat ( 1 ) + "\n" , this . getYdupl ( ) ) ; if ( this . getdX ( ) != 0 || this . getdY ( ) != 0 || this . getdZ ( ) != 0 ) { ps . print ( "TRANSLATE\n" ) ; ps . printf ( locale , "#dX  dY  dZ\n" + formatFloat ( 3 ) + "\n" , this . getdX ( ) , this . getdY ( ) , this . getdZ ( ) ) ; } ps . print ( "BFILE\n" ) ; ps . print ( this . getBFILE ( ) + "\n" ) ; }
tr	5	@ Override public void enter ( BlockNode block , Deque < BlockNode > stack ) { ChangeNode previous = null ; Iterator < Node > nodes = block . - . iterator ( ) ; while ( nodes . hasNext ( ) ) { Node n = nodes . next ( ) ; if ( n instanceof ChangeNode ) { ChangeNode cn = ( ChangeNode ) n ; if ( cn . absolute ) { previous = null ; continue ; } if ( previous != null && cn . type == previous . type ) { previous . change += cn . change ; nodes . remove ( ) ; } else { previous = cn ; } } else { previous = null ; } } }
tr	0	public java . awt . Frame getFrame ( ) { return parent ; }
tr	7	public String toString ( ) { String str = "" ; if ( frameData != null ) { for ( int s = 0 ; s < getNumSignals ( ) ; s ++ ) { String st = "" ; for ( int f = 0 ; f < frameData . length ; f ++ ) if ( frameData [ f ] [ s ] >= 0 ) st += ( st . length ( ) == 0 ? "" : " " ) + f + "=" + frameData [ f ] [ s ] ; str += "(" + st + ")" ; } for ( int f = 0 ; f < pauseData . length ; f ++ ) if ( pauseData [ f ] ) str += " " + f ; } return str ; }
tr	2	public BacklogBean loadId ( BacklogBean oBacklog ) throws ServletException { try { if ( request . getParameter ( "id" ) != null ) { oBacklog . setId ( Integer . parseInt ( request . getParameter ( "id" ) ) ) ; } else { oBacklog . setId ( 0 ) ; } } catch ( NumberFormatException e ) { throw new ServletException ( "Controller: Error: loadId: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oBacklog ; }
tr	3	public Command getCmdFromIdent ( String ident , CommandSender sender ) { if ( this . identifiers . get ( ident . toLowerCase ( ) ) == null ) { for ( Command cmd : this . commands . values ( ) ) { if ( cmd . isIdentifier ( sender , ident ) ) { return cmd ; } } } return ( Command ) this . identifiers . get ( ident . toLowerCase ( ) ) ; }
tr	5	private int [ ] setDistancePriority ( int xdiff , int ydiff ) { int priority [ ] = { - 1 , - 1 , - 1 , - 1 } ; if ( ( Math . abs ( xdiff ) > ( Math . abs ( ydiff ) ) ) ) { if ( ( xdiff ) > 0 ) { priority [ 0 ] = 180 ; priority [ 3 ] = 0 ; } else { priority [ 0 ] = 0 ; priority [ 3 ] = 180 ; } if ( ( ydiff ) > 0 ) { priority [ 1 ] = 90 ; priority [ 2 ] = 270 ; } else { priority [ 1 ] = 270 ; priority [ 2 ] = 90 ; } } else { if ( ( ydiff ) > 0 ) { priority [ 0 ] = 90 ; priority [ 3 ] = 270 ; } else { priority [ 0 ] = 270 ; priority [ 3 ] = 90 ; } if ( ( xdiff ) > 0 ) { priority [ 1 ] = 180 ; priority [ 2 ] = 0 ; } else { priority [ 1 ] = 0 ; priority [ 2 ] = 180 ; } } return priority ; }
tr	3	@ EventHandler ( priority = EventPriority . LOWEST ) public void lever ( PlayerInteractEvent event ) { Action action = event . getAction ( ) ; if ( action == Action . LEFT_CLICK_BLOCK || action == Action . RIGHT_CLICK_BLOCK ) { if ( event . getClickedBlock ( ) . getType ( ) == Material . LEVER ) { prevent ( event , event . getPlayer ( ) , "lever interact" ) ; } } }
tr	5	public double readDouble ( String prompt , double low , double high ) { String msg = null ; while ( true ) { String line = readLine ( prompt ) ; try { double d = double . valueOf ( line ) . doubleValue ( ) ; if ( d >= low && d <= high ) return d ; msg = "Value is outside the range [" + low + ":" + high + "]" ; } catch ( NumberFormatException ex ) { msg = "Illegal numeric format" ; } showErrorMessage ( msg ) ; if ( prompt == null ) prompt = "Retry: " ; } }
tr	3	private static String calcularPorc ( double x1 , double x2 , ArrayList < Segmento > Lista , DecimalFormat f ) { double por = 1.0 ; for ( Segmento seg : Lista ) { if ( x1 >= seg . x1 && x2 <= seg . x2 ) por *= seg . r ; } return f . format ( por ) ; }
tr	1	public String toString ( ) { String out = "" ; for ( int k = 1 ; k <= size ; k ++ ) out += heap [ k ] + " " ; return out ; }
tr	2	@ Override public void process ( Asset asset ) { String url = asset . getProperty ( "url" ) ; HttpGet get = new HttpGet ( url ) ; ResponseHandler < String > responseHandler = new BasicResponseHandler ( ) ; try { String body = client . execute ( get , responseHandler ) ; asset . setValue ( body ) ; next ( asset ) ; } catch ( ClientProtocolException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } catch ( IOException e ) { throw new PipelineException ( asset , AssetState . FAILED , getLocation ( ) , e . getMessage ( ) ) ; } }
tr	9X	public JSONObject ( JSONTokener x ) throws JSONException { this ( ) ; char c ; String key ; if ( x . nextClean ( ) != { ) { throw x . syntaxError ( "A JSONObject text must begin with '{'" ) ; } for ( ; ; ) { c = x . nextClean ( ) ; switch ( c ) { case 0 : throw x . syntaxError ( "A JSONObject text must end with '}'" ) ; case } : return ; default : x . back ( ) ; key = x . nextValue ( ) . toString ( ) ; } c = x . nextClean ( ) ; if ( c == = ) { if ( x . next ( ) != > ) { x . back ( ) ; } } else if ( c != : ) { throw x . syntaxError ( "Expected a ':' after a key" ) ; } put ( key , x . nextValue ( ) ) ; switch ( x . nextClean ( ) ) { case ; : case   : if ( x . nextClean ( ) == } ) { return ; } x . back ( ) ; break ; case } : return ; default : throw x . syntaxError ( "Expected a ' ' or '}'" ) ; } } }
tr	1	public void saveLang ( ) { try { lang . save ( langFile ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	3	private void initCustomTag ( RandomAccessFile file ) throws IOException { int bufferLength = ( int ) ( getLength ( ) - ( endOffset + 1 ) ) ; if ( hasId3v1Tag ( ) ) bufferLength -= ID3v1Tag . TAG_LENGTH ; if ( bufferLength <= 0 ) { customTag = null ; } else { customTag = new byte [ bufferLength ] ; file . seek ( endOffset + 1 ) ; int bytesRead = file . read ( customTag , 0 , bufferLength ) ; if ( bytesRead < bufferLength ) throw new IOException ( "Not enough bytes read" ) ; } }
tr	6	public Object [ ] resume ( Coroutine thread , Object ... args ) { if ( thread . isDead ( ) ) throw new IllegalStateException ( "Cannot resume a dead coroutine!" ) ; int top = coroutine . getTop ( ) ; coroutine . pushJavaFrame ( null , top , top , 0 ) ; thread . thread = this ; thread . parent = this . coroutine ; CallFrame nextFrame = thread . getCurrentFrame ( ) ; int argCount = args . length ; if ( nextFrame . argCount == - 1 ) nextFrame . setTop ( argCount ) ; for ( int index = 0 ; index < argCount ; index ++ ) nextFrame . push ( args [ index ] ) ; if ( nextFrame . argCount == - 1 ) { nextFrame . argCount = argCount ; nextFrame . init ( ) ; } if ( nextFrame . restoreTop ) nextFrame . setTop ( nextFrame . closure . proto . maxStacksize ) ; this . coroutine = thread ; luaMainloop ( ) ; CallFrame frame = coroutine . getCurrentFrame ( ) ; int retCount = frame . getTop ( ) ; Object [ ] returns = new Object [ retCount ] ; for ( int index = 0 ; index < retCount ; index ++ ) returns [ index ] = frame . get ( index ) ; coroutine . setTop ( top ) ; coroutine . popCallFrame ( ) ; return returns ; }
tr	5	private int findShortestPath ( ) throws IllegalStateException { int min = Integer . MAX_VALUE ; for ( int i = 1 ; i <= graph . V ( ) ; i ++ ) { for ( int j = 1 ; j <= graph . V ( ) ; j ++ ) { if ( i == j && d [ i ] [ j ] [ graph . V ( ) ] < 0 ) { throw new IllegalStateException ( "Negative cycle!" ) ; } if ( d [ i ] [ j ] [ graph . V ( ) ] < min ) { min = d [ i ] [ j ] [ graph . V ( ) ] ; } } } return min ; }
tr	9X	private int get_next_page ( Page page , long boundary ) { if ( boundary > 0 ) boundary += offset ; while ( true ) { int more ; if ( boundary > 0 && offset >= boundary ) return OV_FALSE ; more = oy . pageseek ( page ) ; if ( more < 0 ) { offset -= more ; } else { if ( more == 0 ) { if ( boundary == 0 ) return OV_FALSE ; int ret = get_data ( ) ; if ( ret == 0 ) return OV_EOF ; if ( ret < 0 ) return OV_EREAD ; } else { int ret = ( int ) offset ; offset += more ; return ret ; } } } }
tr	4	private Nodo buscarNodo ( String padre ) { Nodo tmp1 = this . raiz ; Nodo tmp2 = tmp1 ; StringTokenizer path = new StringTokenizer ( padre , "/" ) ; String s ; while ( path . hasMoreTokens ( ) ) { s = path . nextToken ( ) ; while ( tmp1 != null ) { if ( s . equals ( tmp1 . dato ) ) break ; else { tmp2 = tmp1 = tmp1 . primerHijo ; } } if ( tmp1 == null ) return tmp1 ; else { tmp2 = tmp1 ; tmp1 = tmp1 . siguienteHermano ; } } return tmp2 ; }
tr	1	private String [ ] camposOrdem ( ) { String camposPesquisa [ ] = new String [ estruturaTabela . size ( ) ] ; for ( int i = 0 ; i < estruturaTabela . size ( ) ; i ++ ) { camposPesquisa [ i ] = estruturaTabela . get ( i ) . getCampo ( ) ; } jCBOrdemPesq . setModel ( new javax . swing . DefaultComboBoxModel ( camposPesquisa ) ) ; return camposPesquisa ; }
tr	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof EnquantoListener ) ( ( EnquantoListener ) listener ) . enterEscreva ( this ) ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( WindowAdd . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { WindowAdd dialog = new WindowAdd ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	1	public static String camelCaseName ( String name ) { return isEmpty ( name ) ? "" : Character . toLowerCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; }
tr	6	public void openFile ( String fileName ) { if ( m_bMpegPlaying ) { m_bKeepRunning = false ; } if ( m_inputStream != null ) { try { m_inputStream . close ( ) ; } catch ( IOException e ) { showDialog ( WARNING , e . getMessage ( ) ) ; } } if ( fileName != null ) { try { try { URL url = new URL ( fileName ) ; m_inputStream = new java . io . BufferedInputStream ( url . openStream ( ) ) ; } catch ( MalformedURLException e ) { m_inputStream = new java . io . BufferedInputStream ( new FileInputStream ( fileName ) ) ; } } catch ( IOException e ) { showDialog ( ERROR , e . getMessage ( ) ) ; } } else showDialog ( ERROR , "null FileName" ) ; }
tr	5	private static String extractFollowingParaContaining ( String document , String containing , int begin ) { Matcher paragraph = Pattern . compile ( "<p[\\s\\S]*?</p>" ) . matcher ( document ) ; int start = begin ; int first = 0 ; int last = start ; while ( paragraph . find ( start ) ) { start = paragraph . end ( ) ; if ( paragraph . group ( ) . matches ( "<p[^>]*>[\\s\u00A0]*</p>" ) ) { continue ; } if ( ! paragraph . group ( ) . matches ( containing ) ) { break ; } if ( first == 0 ) { first = paragraph . start ( ) ; } last = paragraph . end ( ) ; } return first != 0 ? document . substring ( first , last ) : null ; }
tr	7	private void openAddMeterPanel ( ) { boolean failure = false ; String options [ ] = { "Create" , "Cancel" } ; int result = JOptionPane . showOptionDialog ( null , addMeterPanel , "Add Meter to Account " + getSelectedAccountID ( ) , JOptionPane . DEFAULT_OPTION , JOptionPane . PLAIN_MESSAGE , null , options , options [ 0 ] ) ; if ( result == 0 ) { Meter m = getMeterFromAddMeterPanel ( ) ; Account temp = getSelectedAccount ( ) ; if ( m != null ) { if ( temp instanceof ResidentialAccount ) { ResidentialAccount resAcc = ( ResidentialAccount ) temp ; if ( resAcc . getMeter ( ) != null ) { boolean overWrite = confirmResidentialAccountConflict ( ) ; if ( ! overWrite ) return ; } } else if ( temp . hasMeter ( m . getMeterID ( ) ) ) { failure = true ; } } else { failure = true ; } if ( ! failure ) { temp . addMeter ( m ) ; System . out . println ( m . getMeterID ( ) ) ; showMetersInMeterTable ( temp ) ; } else { failToCreateMeterDialog ( ) ; } } }
tr	8	public void run ( ) throws ParsingException { parseStack . push ( new TerminalEntry ( EOF ) ) ; parseStack . addToParseStack ( ruleTable . find ( startSymbol , startToken ) ) ; A = parseStack . peek ( ) ; getNextToken ( ) ; while ( ( A != null ) && ! A . isEof ( ) ) { A = parseStack . peek ( ) ; if ( A . isTerminal ( ) ) { if ( A . matches ( i ) ) { parseStack . pop ( ) ; if ( parseStack . notEmpty ( ) ) { A = parseStack . peek ( ) ; getNextToken ( ) ; } } else { throw new ParsingException ( "Terminal mismatch. Expected: " + A + " Found: " + i + "" ) ; } } else if ( A . isSemanticEntry ( ) ) { final SemanticNode node = nodeFactory . getNewNode ( A ) ; node . runOnSemanticStack ( semanticStack ) ; parseStack . pop ( ) ; } else { if ( isRuleContained ( A , i ) ) { parseStack . pop ( ) ; parseStack . addToParseStack ( ruleTable . find ( A , i ) ) ; A = parseStack . peek ( ) ; } else { throw new ParsingException ( "Non-terminal mismatch. No entry in the table for: " + A + "   " + i ) ; } } } if ( ! stream . isEmpty ( ) ) { throw new ParsingException ( "Parser found the end of file marker but the token stream was not empty." ) ; } }
tr	6	public static double asinh ( double a ) { boolean negative = false ; if ( a < 0 ) { negative = true ; a = - a ; } double absAsinh ; if ( a > 0.167 ) { absAsinh = FastMath . log ( FastMath . sqrt ( a * a + 1 ) + a ) ; } else { final double a2 = a * a ; if ( a > 0.097 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 - a2 * ( 1.0 / 11.0 - a2 * ( 1.0 / 13.0 - a2 * ( 1.0 / 15.0 - a2 * ( 1.0 / 17.0 ) * 15.0 / 16.0 ) * 13.0 / 14.0 ) * 11.0 / 12.0 ) * 9.0 / 10.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else if ( a > 0.036 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 - a2 * ( 1.0 / 11.0 - a2 * ( 1.0 / 13.0 ) * 11.0 / 12.0 ) * 9.0 / 10.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else if ( a > 0.0036 ) { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 - a2 * ( 1 / 7.0 - a2 * ( 1 / 9.0 ) * 7.0 / 8.0 ) * 5.0 / 6.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } else { absAsinh = a * ( 1 - a2 * ( 1 / 3.0 - a2 * ( 1 / 5.0 ) * 3.0 / 4.0 ) / 2.0 ) ; } } return negative ? - absAsinh : absAsinh ; }
tr	6	public Settings ( JPanel content ) { JPanel theContent = new JPanel ( new GridLayout ( 12 , 1 , 0 , 5 ) ) ; auxButton . setFocusPainted ( false ) ; radButton . setFocusPainted ( false ) ; cdButton . setFocusPainted ( false ) ; climateLabel = new JLabel ( "Climate" ) ; climateLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; climateControl . setMinorTickSpacing ( 1 ) ; Hashtable labelTable = new Hashtable ( ) ; labelTable . put ( new Integer ( 0 ) , new JLabel ( "Cold" ) ) ; labelTable . put ( new Integer ( CLIMATE_MAX ) , new JLabel ( "Hot" ) ) ; climateControl . setLabelTable ( labelTable ) ; climateControl . setPaintLabels ( true ) ; ventLabel = new JLabel ( "Ventilation Fan" ) ; ventLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; ventButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { ventButton . setText ( "On" ) ; ventButton . setBackground ( Color . decode ( "#92CD00" ) ) ; } else { ventButton . setText ( "Off" ) ; ventButton . setBackground ( Color . decode ( "#FF3333" ) ) ; } } } ) ; soundLabel = new JLabel ( "Sound" ) ; soundLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; radioLabel = new JLabel ( "Volume" ) ; radioLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; frequency . setText ( "107.10" ) ; musicCards . add ( radioCard , "Radio controller" ) ; musicCards . add ( cdCard , "CD controller" ) ; musicCards . add ( auxCard , "AUX controller" ) ; Hashtable volLabelTable = new Hashtable ( ) ; volLabelTable . put ( new Integer ( 0 ) , new JLabel ( "0" ) ) ; volLabelTable . put ( new Integer ( 10 ) , new JLabel ( "1" ) ) ; volLabelTable . put ( new Integer ( 20 ) , new JLabel ( "2" ) ) ; volLabelTable . put ( new Integer ( 30 ) , new JLabel ( "3" ) ) ; volLabelTable . put ( new Integer ( 40 ) , new JLabel ( "4" ) ) ; volLabelTable . put ( new Integer ( 50 ) , new JLabel ( "5" ) ) ; volLabelTable . put ( new Integer ( 60 ) , new JLabel ( "6" ) ) ; volLabelTable . put ( new Integer ( 70 ) , new JLabel ( "7" ) ) ; volLabelTable . put ( new Integer ( 80 ) , new JLabel ( "8" ) ) ; volLabelTable . put ( new Integer ( 90 ) , new JLabel ( "9" ) ) ; volLabelTable . put ( new Integer ( 100 ) , new JLabel ( "10" ) ) ; volLabelTable . put ( new Integer ( 110 ) , new JLabel ( "11" ) ) ; radVolControl . setLabelTable ( volLabelTable ) ; radVolControl . setPaintLabels ( true ) ; freqButton . setText ( "AM" ) ; freqButton . setFocusPainted ( false ) ; freqButton . setBackground ( Color . decode ( "#393939" ) ) ; freqButton . setForeground ( Color . decode ( "#FFFFFF" ) ) ; freqButton . addActionListener ( new ActionListener ( ) { boolean active = false ; public void actionPerformed ( ActionEvent e ) { active = active == true ? false : true ; if ( active == true ) { freqButton . setText ( "FM" ) ; } else { freqButton . setText ( "AM" ) ; } } } ) ; radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; freqLabel = new JLabel ( "Frequency:" ) ; freqLabel . setFont ( new Font ( "Sans Serif" , Font . BOLD , 16 ) ) ; JPanel musicButtons = new JPanel ( new GridLayout ( 1 , 3 ) ) ; radButton . setText ( "RADIO" ) ; radButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { radButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "Radio controller" ) ; } } ) ; musicButtons . add ( radButton ) ; auxButton . setText ( "AUX" ) ; auxButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { auxButton . setBackground ( Color . decode ( "#92CD00" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; cdButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "AUX controller" ) ; } } ) ; musicButtons . add ( auxButton ) ; cdButton . setText ( "CD" ) ; cdButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdButton . setBackground ( Color . decode ( "#92CD00" ) ) ; auxButton . setBackground ( Color . decode ( "#FF3333" ) ) ; radButton . setBackground ( Color . decode ( "#FF3333" ) ) ; CardLayout cl = ( CardLayout ) ( musicCards . getLayout ( ) ) ; cl . show ( musicCards , "CD controller" ) ; } } ) ; musicButtons . add ( cdButton ) ; radioCard . add ( freqLabel ) ; radioCard . add ( frequency ) ; radioCard . add ( freqButton ) ; auxCard . add ( new JLabel ( "AUX Connected..." ) ) ; JPanel cdButtons = new JPanel ( new GridLayout ( 1 , 6 ) ) ; JButton playBtn = new JButton ( "Play" ) ; playBtn . setFocusPainted ( false ) ; playBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( playBtn ) ; JButton pauseBtn = new JButton ( "Pause" ) ; pauseBtn . setFocusPainted ( false ) ; pauseBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Paused" ) ; } } ) ; cdButtons . add ( pauseBtn ) ; JButton stopBtn = new JButton ( "Stop" ) ; stopBtn . setFocusPainted ( false ) ; stopBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { cdStatusLabel . setText ( currentSongStr + " Stopped" ) ; } } ) ; cdButtons . add ( stopBtn ) ; JButton prevBtn = new JButton ( "PREV" ) ; prevBtn . setFocusPainted ( false ) ; prevBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( prevBtn ) ; JButton nextBtn = new JButton ( "next" ) ; nextBtn . setFocusPainted ( false ) ; nextBtn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( currentSongStr . equals ( "Funky Town" ) ) { currentSongStr = "Bohemian Rhapsody" ; } else { currentSongStr = "Funky Town" ; } cdStatusLabel . setText ( "Playing " + currentSongStr + "..." ) ; } } ) ; cdButtons . add ( nextBtn ) ; JButton eject = new JButton ( "Eject" ) ; eject . setFocusPainted ( false ) ; cdButtons . add ( eject ) ; cdCard . add ( cdButtons ) ; cdCard . add ( cdStatusLabel ) ; settings . setFont ( new Font ( "Sans Serif" , Font . BOLD , 30 ) ) ; theContent . add ( settings ) ; theContent . add ( climateLabel ) ; theContent . add ( climateControl ) ; theContent . add ( ventLabel ) ; theContent . add ( ventButton ) ; theContent . add ( soundLabel ) ; theContent . add ( radioLabel ) ; theContent . add ( radVolControl ) ; theContent . add ( musicButtons ) ; theContent . add ( musicCards ) ; add ( theContent ) ; }
tr	0	public String getXlinkRole ( ) { return xlinkRole ; }
tr	0	public BaseLight ( Vector3f color , float intensity ) { this . color = color ; this . intensity = intensity ; }
tr	4	private String nextToInternal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . charAt ( pos ) ; if ( c == '' || c == '' || excluded . indexOf ( c ) != - 1 ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
tr	7	@ Override protected void handleMethodAttribute ( final String name , final byte [ ] data , final int offset , final long length , final ConstantPool constantPool ) { if ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeVisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Signature . equals ( name ) ) { parseSignature ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Deprecated . equals ( name ) ) { parseDeprecated ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_Synthetic . equals ( name ) ) { parseSynthetic ( data , offset , length ) ; } else if ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations . equals ( name ) ) { parseAnnotations ( ClassFileFormat . ATTR_RuntimeInvisibleAnnotations , data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Exceptions . equals ( name ) ) { parseExceptions ( data , offset , constantPool ) ; } else if ( ClassFileFormat . ATTR_Code . equals ( name ) ) { parseCode ( data , offset , constantPool ) ; } else { System . err . println ( "Unhandled method attribute: " + name ) ; } }
tr	1	public void setRowCount ( int count ) { this . tableModel . setRowCount ( count ) ; rowColors . clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { rowColors . add ( getTableForeground ( ) ) ; } }
tr	8	public String getLastLine ( ) { try ( RandomAccessFile file = new RandomAccessFile ( f , "r" ) ) { long index , length ; length = file . length ( ) ; index = length - 1 ; int ch = 0 ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } if ( index == 0 ) { return null ; } file . seek ( index -- ) ; ch = ( file . read ( ) ) ; while ( ch != 30 && index > 0 ) { file . seek ( index -- ) ; ch = ( file . read ( ) ) ; } file . seek ( index ++ ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( in . readUTF ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readLong ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( df . format ( new Date ( in . readLong ( ) ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( TimeConvert . millisToDays ( in . readLong ( ) ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; String code = in . readUTF ( ) ; sb . append ( code ) ; if ( code == "S" ) { sb . append ( in . readUTF ( ) ) ; } sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readBoolean ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; sb . append ( in . readDouble ( ) ) ; sb . append ( "\t" ) ; in . readChar ( ) ; return sb . toString ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
tr	7	public static boolean searchAndAdd ( TrieNode root , TrieNode prev , char [ ] str , int index ) { if ( root == null ) { return false ; } if ( root . childLinks == null ) { insertNode ( root , str , 0 ) ; return false ; } if ( index < str . length ) { for ( TrieNode child : root . childLinks ) { if ( child . alphabet == str [ index ] ) { return searchAndAdd ( child , root , str , ++ index ) ; } } } if ( index == str . length && prev . endOfWord ) { return true ; } else { insertNode ( prev , str , index ) ; return false ; } }
tr	5	public void next ( boolean respectRandom ) { if ( ! randomOrder || ! respectRandom ) { index ++ ; if ( index >= record . getRecordCount ( ) ) { index = 0 ; } } else if ( respectRandom ) { index = rand . nextInt ( record . getRecordCount ( ) ) ; } currentRecord = record . getRecordNumber ( index , false ) ; if ( currentRecord . getExtra1 ( ) . indexOf ( "rem=s" ) >= 0 ) { next ( ) ; } }
tr	2	public void aiUp ( ) { if ( Realm . player . x == x && Realm . player . y == ( y - 1 ) ) { attack ( ) ; } else { walkUp ( ) ; } }
tr	6	public boolean HasClearPath ( ChessTile Start , ChessTile End ) { int ForwardDistance ; int SideDistance ; if ( Start == null || End == null ) { return false ; } ForwardDistance = Math . abs ( End . GetPosition ( ) [ 1 ] - Start . GetPosition ( ) [ 1 ] ) ; SideDistance = Math . abs ( End . GetPosition ( ) [ 0 ] - Start . GetPosition ( ) [ 0 ] ) ; for ( int i = 1 ; i < Math . max ( ForwardDistance , SideDistance ) - 1 ; i ++ ) { int ForwardMin = Math . min ( ForwardDistance , i ) ; int SideMin = Math . min ( SideDistance , i ) ; if ( Start . GetPosition ( ) [ 0 ] > End . GetPosition ( ) [ 0 ] ) { SideMin = - SideMin ; } if ( Start . GetPosition ( ) [ 1 ] > End . GetPosition ( ) [ 1 ] ) { ForwardMin = - ForwardMin ; } if ( Board [ Start . GetPosition ( ) [ 0 ] + SideMin ] [ Start . GetPosition ( ) [ 1 ] + ForwardMin ] . GetHeldPiece ( ) != null ) { return false ; } } return true ; }
tr	6	public static void flatten ( TreeNode root ) { if ( root == null ) { return ; } Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ( ) ; TreeNode newNode = new TreeNode ( root . val ) ; TreeNode head = newNode ; TreeNode empty = new TreeNode ( 0 ) ; currentLevel . add ( root ) ; while ( ! currentLevel . isEmpty ( ) ) { Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ( ) ; while ( ! currentLevel . isEmpty ( ) ) { TreeNode node = currentLevel . poll ( ) ; if ( newNode . right != null ) { newNode = newNode . right ; } newNode . left = null ; newNode . right = node ; if ( node . left != null ) nextLevel . add ( node . left ) ; if ( node . right != null ) nextLevel . add ( node . right ) ; } currentLevel = nextLevel ; } root = head . right ; }
tr	5	public String checkDataEntry ( ) { if ( efastAnalysisPanel1 . parameterScreen . directoryChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) . equals ( "" ) || efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( efastAnalysisPanel1 . parameterScreen . parametersModel . contains ( "None Entered" ) ) { return "No parameters have been selected" ; } else { try { Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastCurves . getText ( ) ) ; Integer . parseInt ( efastAnalysisPanel1 . parameterScreen . efastSampleNumber . getText ( ) ) ; return null ; } catch ( NumberFormatException e ) { return "Number of curves and parameter samples must be integers" ; } } }
tr	5	static void updatestatus ( int m ) { switch ( m ) { case 1 : status . setText ( "Drag to create an entity" ) ; break ; case 2 : status . setText ( "Drag to create an bubble" ) ; break ; case 3 : status . setText ( "Drag to create an data store" ) ; break ; case 4 : status . setText ( "Drag to create an data flow arrow" ) ; break ; case 6 : status . setText ( "Drag to create an control flow arrow" ) ; break ; default : status . setText ( "" ) ; } }
tr	3	private void compact ( ) { int from = 0 ; int to = 0 ; while ( from < this . capacity ) { Object key = this . list [ from ] ; long usage = age ( this . ticks [ from ] ) ; if ( usage > 0 ) { this . ticks [ to ] = usage ; this . list [ to ] = key ; this . map . put ( key , to ) ; to += 1 ; } else { this . map . remove ( key ) ; } from += 1 ; } if ( to < this . capacity ) { this . length = to ; } else { this . map . clear ( ) ; this . length = 0 ; } this . power = 0 ; }
tr	4	@ Override public final Element get ( int index ) { final int size = elements . size ( ) ; if ( index >= 0 ) { if ( index < size ) { return elements . get ( index ) ; } else { return null ; } } else { final int calculated = size + index ; if ( calculated >= 0 && calculated < size ) { return elements . get ( calculated ) ; } else { return null ; } } }
tr	5	@ Override public boolean equals ( Object other ) { if ( this == other ) return true ; if ( other instanceof EulerAngles ) { EulerAngles otherAngle = ( EulerAngles ) other ; if ( FloatingPointUtils . floatEqual ( otherAngle . psi , this . psi ) && FloatingPointUtils . floatEqual ( otherAngle . theta , this . theta ) && FloatingPointUtils . floatEqual ( otherAngle . phi , this . phi ) ) { return true ; } } return false ; }
tr	4	protected EncodedString decodeEncodedCharacterStringOnThirdbit ( ) throws IOException , FastInfosetException { switch ( current_octet & FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_MASK_DISCRIMINANT ) { case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF8_DISCRIMINANT : encodedStringBuffer . setUTF8 ( decodeUTF8inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_UTF16_DISCRIMINANT : encodedStringBuffer . setUTF16 ( decodeUTF16inInternalEncodingBufferAsString ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALGORITHM_DISCRIMINANT : int index = decodeOctetInteger ( 5 ) ; Algorithm algo = vocabulary . algorithms . get ( index ) ; encodedStringBuffer . setAlgorithm ( index , algo , decodeNonEmptyOctetStringOnFifthBit ( ) ) ; return encodedStringBuffer ; case FastInfosetConstants . ENCODED_CHARACTER_STRING_3RD_BIT_ALPHABET_DISCRIMINANT : int index2 = decodeOctetInteger ( 5 ) ; Algorithm algo2 = vocabulary . alphabets . get ( index2 ) ; encodedStringBuffer . setAlphabet ( index2 , algo2 , algo2 . fromByteArray ( decodeNonEmptyOctetStringOnFifthBit ( ) ) ) ; return encodedStringBuffer ; } throw new FastInfosetException ( ) ; }
tr	6	protected Shape createTriangle ( float fx , float fy , float tx , float ty , boolean rot ) { int size = 15 ; float dx = tx - fx ; float dy = ty - fy ; float D = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float z = ( dx <= 0 ) ? fx - D : fx + D ; float mid = ( dx <= 0 ) ? fx - D / 2 : fx + D / 2 ; float dec = ( dx <= 0 ) ? size : - size ; GeneralPath gp = new GeneralPath ( ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; gp . moveTo ( z , fy ) ; gp . lineTo ( z + dec , fy + size / 2 ) ; gp . lineTo ( z + dec , fy - size / 2 ) ; if ( rot ) { gp . moveTo ( mid + dec , fy - size / 2 ) ; gp . curveTo ( mid , fy - size , mid , fy + size , mid + dec , fy + size / 2 ) ; } double alpha = ( dx > 0 ) ? Math . asin ( dy / D ) : - Math . asin ( dy / D ) ; return alpha != 0 ? gp . createTransformedShape ( AffineTransform . getRotateInstance ( alpha , fx , fy ) ) : gp ; }
tr	4	@ Test public void testTokenPayment ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; HttpsConnector connector = new HttpsConnector ( 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" ) ; LegatoTokenRequest legatoTokenRequest = new LegatoTokenRequest ( ) ; legatoTokenRequest . number = "5100000010001004" ; legatoTokenRequest . expiryMonth = 12 ; legatoTokenRequest . expiryYear = 18 ; legatoTokenRequest . cvd = "123" ; String url = "https://www.beanstream.com/scripts/tokenization/tokens" ; String output = "" ; try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } Gson gson = new Gson ( ) ; LegatoTokenResponse tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "token: " + output ) ; TokenPaymentRequest tokenReq = new TokenPaymentRequest ( ) ; tokenReq . setAmount ( 100.00 ) ; tokenReq . setOrderNumber ( getRandomOrderId ( "token" ) ) ; tokenReq . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( tokenReq ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } try { output = connector . ProcessTransaction ( HttpMethod . post , url , legatoTokenRequest ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( SampleTransactions . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } tokenResponse = gson . fromJson ( output , LegatoTokenResponse . class ) ; System . out . println ( "Token pre-auth: " + tokenResponse . getToken ( ) ) ; TokenPaymentRequest req = new TokenPaymentRequest ( ) ; req . setAmount ( 80.00 ) ; req . setOrderNumber ( getRandomOrderId ( "token" ) ) ; req . getToken ( ) . setName ( "John Doe" ) . setCode ( tokenResponse . getToken ( ) ) ; try { PaymentResponse response = beanstream . payments ( ) . preAuth ( req ) ; System . out . println ( "Token Payment Approved? " + response . isApproved ( ) ) ; response = beanstream . payments ( ) . preAuthCompletion ( response . id , 55.30 ) ; assert . assertTrue ( response . isApproved ( ) ) ; assert . assertEquals ( "PAC" , response . type ) ; } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	6	public static String replaceAll ( String origin , String oldPart , String replacement ) { if ( origin == null || replacement == null ) { return origin ; } if ( oldPart == null || oldPart . length ( ) == 0 ) { return origin ; } int index = origin . indexOf ( oldPart ) ; if ( index < 0 ) { return origin ; } StringBuffer sb = new StringBuffer ( origin ) ; do { sb . replace ( index , index + oldPart . length ( ) , replacement ) ; origin = sb . toString ( ) ; index = origin . indexOf ( oldPart ) ; } while ( index != - 1 ) ; return origin ; }
tr	5	@ Override public void doInBackground ( ) { int Slashes = this . Address . indexOf ( / ) ; int Dots = this . Address . indexOf ( . ) ; if ( ( Dots >= 1 ) && ( Slashes > 0 ) && ( Slashes < this . Address . length ( ) - 1 ) ) { try { URLConnection Connection = new URL ( "http://" + this . Address ) . openConnection ( ) ; int TotalSize = Connection . getContentLength ( ) ; BufferedInputStream Input = new BufferedInputStream ( Connection . getInputStream ( ) ) ; FileOutputStream Output = new FileOutputStream ( this . OutputFile ) ; int Read ; double TotalRead = 0 ; while ( ( Read = Input . read ( ) ) != - 1 ) { Output . write ( Read ) ; ++ TotalRead ; this . setProgress ( ( int ) ( 100.0 / TotalSize * TotalRead ) ) ; } Input . close ( ) ; Output . close ( ) ; String Version = this . Address . substring ( this . Address . indexOf ( _ ) + 1 , this . Address . lastIndexOf ( ".jar" ) ) . replace ( _ , . ) . trim ( ) ; this . SetCurrentVersion ( Version ) ; } catch ( Exception e ) { new SPopup ( new SPopupData ( e ) ) ; } this . UpdateFrame . CloseFrame ( ) ; } else { this . ErrorPopup = new SPopup ( new SPopupData ( new SException ( "Invalid Address" ) ) ) ; this . ErrorPopup . InjectActionListener ( this ) ; } return null ; }
tr	3	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( declaration == null ) ? 0 : declaration . hashCode ( ) ) ; result = prime * result + ( ( ident == null ) ? 0 : ident . hashCode ( ) ) ; result = prime * result + ( ( statementSequence == null ) ? 0 : statementSequence . hashCode ( ) ) ; return result ; }
tr	1	public void awaitTermination ( ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { String message = "awaitTermination() method was interrupted!" ; throw new UnsupportedOperationException ( message , e ) ; } }
tr	7	public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return false ; if ( o . equals ( boolean . false ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( boolean . true ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "] is not a Boolean." ) ; }
tr	1	public User getByID ( Line line ) { try { return getByID ( line . getString ( "userid" ) ) ; } catch ( Exception ex ) { } return getByID ( line . toString ( ) ) ; }
tr	9X	public boolean connect ( SharingPeer peer ) { boolean retry = false ; boolean sentObfuscatedHandshake = false ; do { Socket socket = new Socket ( ) ; InetSocketAddress address = new InetSocketAddress ( peer . getIp ( ) , peer . getPort ( ) ) ; logger . info ( "Connecting to " + peer + "..." ) ; try { socket . connect ( address , 3 * 1000 ) ; } catch ( IOException ioe ) { logger . warn ( "Could not connect to " + peer + ": " + ioe . getMessage ( ) ) ; return false ; } try { byte [ ] remotePeerId = ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ; if ( this . forceObfuscation ) sentObfuscatedHandshake = this . sendObfuscatedHandshake ( socket , remotePeerId , this . forceObfuscation ) ; else sentObfuscatedHandshake = this . sendHandshake ( socket , remotePeerId , peer . supportsObfuscation ( ) ) ; Handshake hs = this . validateHandshake ( socket , ( peer . hasPeerId ( ) ? peer . getPeerId ( ) . array ( ) : null ) ) ; this . fireNewPeerConnection ( socket , hs . getPeerId ( ) ) ; return true ; } catch ( ParseException pe ) { logger . info ( "Invalid handshake from " + this . socketRepr ( socket ) + ": " + pe . getMessage ( ) ) ; if ( sentObfuscatedHandshake && peer . supportsObfuscation ( ) ) { peer . supportsObfuscation ( false ) ; retry = true ; } try { socket . close ( ) ; } catch ( IOException e ) { } } catch ( IOException ioe ) { logger . info ( "An error occured while reading an incoming " + "handshake: " + ioe . getMessage ( ) ) ; try { if ( ! socket . isClosed ( ) ) socket . close ( ) ; } catch ( IOException e ) { } } } while ( retry ) ; return false ; }
tr	8	public final float getPixelUnitFactor ( boolean isHor ) { switch ( PlatformDefaults . getLogicalPixelBase ( ) ) { case PlatformDefaults . BASE_FONT_SIZE : Font font = c . getFont ( ) ; FontMetrics fm = c . getFontMetrics ( font != null ? font : SUBST_FONT ) ; Point . float p = FM_MAP . get ( fm ) ; if ( p == null ) { Rectangle2D r = fm . getStringBounds ( "X" , c . getGraphics ( ) ) ; p = new Point . float ( ( ( float ) r . getWidth ( ) ) / 6f , ( ( float ) r . getHeight ( ) ) / 13.27734375f ) ; FM_MAP . put ( fm , p ) ; } return isHor ? p . x : p . y ; case PlatformDefaults . BASE_SCALE_FACTOR : float s = isHor ? PlatformDefaults . getHorizontalScaleFactor ( ) : PlatformDefaults . getVerticalScaleFactor ( ) ; if ( s != null ) return s ; return ( isHor ? getHorizontalScreenDPI ( ) : getVerticalScreenDPI ( ) ) / ( float ) PlatformDefaults . getDefaultDPI ( ) ; default : return 1f ; } }
tr	0	Partido ( Manager [ ] managers ) { this . managers = managers ; }
tr	9X	public static boolean edgeTest ( double [ ] [ ] a , double [ ] [ ] b ) { double tmpPoint [ ] ; if ( a [ 0 ] [ X ] > a [ 1 ] [ X ] ) { tmpPoint = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = tmpPoint ; } if ( b [ 0 ] [ X ] > b [ 1 ] [ X ] ) { tmpPoint = b [ 0 ] ; b [ 0 ] = b [ 1 ] ; b [ 1 ] = tmpPoint ; } if ( a [ 0 ] [ Y ] == a [ 1 ] [ Y ] && b [ 0 ] [ Y ] == b [ 1 ] [ Y ] ) { if ( ( a [ 0 ] [ Y ] == b [ 0 ] [ Y ] ) && ( between ( b , a [ 0 ] [ X ] , X ) || between ( b , a [ 1 ] [ X ] , X ) ) ) { return true ; } return false ; } if ( a [ 0 ] [ X ] == a [ 1 ] [ X ] ) { if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) { if ( ( a [ 0 ] [ X ] == b [ 0 ] [ X ] ) && ( between ( b , a [ 0 ] [ Y ] , Y ) || between ( b , a [ 1 ] [ Y ] , Y ) ) ) { return true ; } return false ; } return wallTest ( b , a ) ; } else if ( b [ 0 ] [ X ] == b [ 1 ] [ X ] ) return wallTest ( a , b ) ; return segmentTest ( a , b ) ; }
tr	2	public static void onAllROute ( Individual individual ) { ProblemInstance problemInstance = individual . problemInstance ; for ( int period = 0 ; period < problemInstance . periodCount ; period ++ ) { for ( int vehicle = 0 ; vehicle < problemInstance . vehicleCount ; vehicle ++ ) { mutateRouteBy2_Opt ( individual , period , vehicle ) ; } } }
tr	9X	public String executeRequest ( ) throws IOException { setSigningMethod ( auth ) ; String signingString = getSigningString ( customer_id ) ; String signature ; String url_output = "" ; StringBuffer full_url = new StringBuffer ( base ) . append ( resource ) ; if ( params . size ( ) > 0 ) { full_url . append ( "?" ) ; int i = 0 ; for ( String key : params . keySet ( ) ) { if ( ++ i != 0 ) { full_url . append ( "&" ) ; } full_url . append ( URLEncoder . encode ( key , "UTF-8" ) ) . append ( "=" ) . append ( URLEncoder . encode ( params . get ( key ) , "UTF-8" ) ) ; } } url = new URL ( full_url . toString ( ) ) ; try { signature = encode ( signingString , secret_key ) ; } catch ( SignatureException e ) { System . err . println ( "Error signing request " + e . getMessage ( ) ) ; return null ; } String auth_header = "TSA " + customer_id + ":" + signature ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setConnectTimeout ( connectTimeout ) ; connection . setReadTimeout ( readTimeout ) ; connection . setRequestProperty ( "Authorization" , auth_header ) ; setTLSProtocol ( ) ; if ( post ) { connection . setRequestProperty ( "Content-Length" , Integer . toString ( body . length ( ) ) ) ; } for ( String key : ts_headers . keySet ( ) ) { connection . setRequestProperty ( key , ts_headers . get ( key ) ) ; } for ( String key : headers . keySet ( ) ) { connection . setRequestProperty ( key , headers . get ( key ) ) ; } if ( post ) { connection . setDoOutput ( true ) ; DataOutputStream wr = new DataOutputStream ( connection . getOutputStream ( ) ) ; wr . writeBytes ( body ) ; wr . flush ( ) ; wr . close ( ) ; } int response = connection . getResponseCode ( ) ; BufferedReader in ; try { InputStream isr = ( response == 200 ) ? connection . getInputStream ( ) : connection . getErrorStream ( ) ; in = new BufferedReader ( new InputStreamReader ( isr ) ) ; String urlReturn ; while ( ( urlReturn = in . readLine ( ) ) != null ) { url_output += urlReturn ; } in . close ( ) ; } catch ( IOException e ) { System . err . println ( "IOException while reading from input stream " + e . getMessage ( ) ) ; throw new RuntimeException ( e ) ; } return url_output ; }
tr	0	public short [ ] [ ] action_table ( ) { return _action_table ; }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
tr	8	protected FileRequestResponseMessage handleResponse ( InputStream in ) throws UnsupportedEncodingException { FileRequestResponseMessage try_again = new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . TRY_AGAIN_LATER , 0 ) ; int probe_len = FileRequestResponseMessage . TYPE_FIELD . length ( ) + 4 ; byte [ ] buffer = new byte [ probe_len ] ; try { in . read ( buffer , 0 , probe_len ) ; } catch ( IOException e ) { logger . log ( Level . SEVERE , "Could not read response stream: '" + e . getMessage ( ) + "' - assuming 'NEVER TRY AGAIN'" ) ; return try_again ; } String responseHeader = new String ( buffer , Message . ENCODING ) . trim ( ) ; switch ( responseHeader . toUpperCase ( ) ) { case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "OK" : String str_expectedTransferVolume = "" ; int next ; try { while ( ( next = in . read ( ) ) != Message . MESSAGE_SPERATOR ) if ( next == - 1 ) { Thread . sleep ( 500 ) ; } else { str_expectedTransferVolume += new String ( new byte [ ] { ( byte ) next } , Message . ENCODING ) ; } } catch ( IOException | InterruptedException e ) { logger . log ( Level . SEVERE , "Could not understand response header" ) ; transferState = TransferStatus . LostConnection ; closeSocket ( ) ; return null ; } try { long expectedTransferVolume = long . valueOf ( str_expectedTransferVolume ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . OK , expectedTransferVolume ) ; } catch ( NumberFormatException ex ) { logger . log ( Level . SEVERE , "Response contained invalid 'expected transfer volume' - assuming 'TRY AGAIN LATER'" ) ; return try_again ; } case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "TRY" : logger . log ( Level . INFO , "Received 'try again later from host'" ) ; return try_again ; case FileRequestResponseMessage . TYPE_FIELD + Message . FIELD_SEPERATOR + "NEV" : logger . log ( Level . INFO , "Received 'never try agiain from host'" ) ; return new FileRequestResponseMessage ( FileRequestResponseMessage . ResponseCode . NEVER_TRY_AGAIN , 0 ) ; default : logger . log ( Level . INFO , "Received garbage: '" + responseHeader + "'" ) ; return try_again ; } }
tr	2	private Activity getActivity ( String edgeType ) throws ProvBuildException { if ( _current == null || ! ( _current instanceof Activity ) ) { throw new ProvBuildException ( edgeType + " only applies to activities" ) ; } return ( Activity ) _current ; }
tr	9X	public void run ( ) { searchField . setText ( "" ) ; searchField . setText ( SelectionField . SEARCHTERM ) ; TreeMap < Integer , List < Champion >> priorities = new TreeMap < Integer , List < Champion >> ( ) ; for ( Champion c : Initialiser . getChampionList ( ) ) { int priority = c . calculatePriority ( ) ; List < Champion > priorityList = priorities . get ( priority ) ; if ( priorityList == null ) { priorityList = new LinkedList < Champion > ( ) ; priorities . put ( priority , priorityList ) ; } priorityList . add ( c ) ; } Entry < Integer , List < Champion >> e = priorities . pollLastEntry ( ) ; recommendedModel . clear ( ) ; goodModel . clear ( ) ; viableModel . clear ( ) ; allModel . clear ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) recommendedModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) goodModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; if ( e != null ) { for ( Champion c : e . getValue ( ) ) viableModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; while ( e != null ) { for ( Champion c : e . getValue ( ) ) allModel . addElement ( c ) ; e = priorities . pollLastEntry ( ) ; } } } } reset ( ) ; scroller . revalidate ( ) ; }
tr	3	@ Test public void superThreadSafe ( ) { final SimpleMath math = new SimpleMath ( ) ; final Map < Integer , Integer > results = new ConcurrentHashMap < Integer , Integer > ( ) ; final CountDownLatch latch = new CountDownLatch ( 1000 ) ; final CountDownLatch allDone = new CountDownLatch ( 1000 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { final int copy = i ; new Thread ( ) { public void run ( ) { try { latch . countDown ( ) ; latch . await ( ) ; int result = math . doubleAndIncrement ( copy ) ; results . put ( copy , result ) ; allDone . countDown ( ) ; } catch ( Exception e ) { } } } . start ( ) ; } try { allDone . await ( ) ; } catch ( Exception e ) { } assertEquals ( new Integer ( 45 ) , results . get ( 22 ) ) ; }
tr	0	public boolean isInterested ( ) { return this . interested ; }
tr	8	public ByteBuffer getBuffer ( String filePath ) { ByteBuffer buffer = fileMaps . get ( filePath ) ; if ( buffer == null ) { File requestedFile = new File ( filePath ) ; if ( requestedFile != null && requestedFile . exists ( ) ) { FileInputStream fileInput = null ; FileChannel fileChannel = null ; try { fileInput = new FileInputStream ( requestedFile ) ; fileChannel = fileInput . getChannel ( ) ; if ( fileChannel . size ( ) < ( 1024 * 1024 * 10 ) ) { MappedByteBuffer fileBuffer = fileChannel . map ( MapMode . READ_ONLY , 0 , fileChannel . size ( ) ) ; fileBuffer . load ( ) ; this . fileMaps . put ( filePath , fileBuffer ) ; buffer = fileBuffer . asReadOnlyBuffer ( ) ; } else { buffer = null ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( fileInput != null ) { fileInput . close ( ) ; fileInput = null ; } if ( fileChannel != null ) { fileChannel . close ( ) ; fileChannel = null ; } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } } return buffer ; }
tr	1	public static void writeStringToFile ( String content , String filename , boolean append ) { FileWriter fw ; try { fw = new FileWriter ( filename , append ) ; fw . append ( content ) ; fw . flush ( ) ; fw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	5	private String generateRandomId ( ) { StringBuilder sb = new StringBuilder ( ) ; int retry = 0 ; do { while ( sb . length ( ) < idLength ) { char ch = ( char ) rnd . nextInt ( ) ; if ( Utils . isUriLetterOrDigit ( ch ) ) { sb . append ( ch ) ; } } if ( tokens . containsKey ( sb . toString ( ) ) ) { sb . delete ( 0 , idLength ) ; } retry ++ ; } while ( sb . length ( ) == 0 || retry > RETRY_COUNT ) ; return sb . toString ( ) ; }
tr	4	protected final void measure ( int width , int height ) { Debug . log ( "MEASURING %s" , this ) ; if ( width == LayoutParameters . MATCH_PARENT ) { width = getParentWidth ( ) ; } if ( height == LayoutParameters . MATCH_PARENT ) { height = getParentHeight ( ) ; } onMeasure ( width , height ) ; if ( measuredWidth == NOT_SET || measuredHeight == NOT_SET ) { throw new IllegalStateException ( "View subclass (" + this + ") does not properly set the measured width or height." ) ; } Debug . log ( "MEASURED DIMENSIONS FOR (%s): width=%s  height=%s" , this , measuredWidth , measuredHeight ) ; }
tr	5	public static Method findVisitMethod ( MatchProcessor visitor , Match node ) { Method visitMethod = null ; class < ? > visitorClass = visitor . getClass ( ) ; Map < String , Method > visitMethods = __visitMethodCache . get ( visitorClass ) ; if ( visitMethods == null ) __visitMethodCache . put ( visitorClass , visitMethods = new HashMap < String , Method > ( ) ) ; String methodName = node . getParser ( ) . getLabel ( ) ; methodName = "process" + methodName . substring ( 0 , 1 ) . toUpperCase ( ) + methodName . substring ( 1 ) ; visitMethod = visitMethods . get ( methodName ) ; if ( visitMethod == null ) { try { visitMethod = visitorClass . getMethod ( methodName , Match . class ) ; visitMethods . put ( methodName , visitMethod ) ; } catch ( Exception e ) { } } if ( visitMethod == null ) return __defaultVisitMethod ; return visitMethod ; }
tr	6	public void doService ( ) { Message message = parser . nextMessage ( ) ; while ( message != null ) { switch ( message . getType ( ) ) { case CONNECT : writer . println ( "ALREADY CONNECTED!" ) ; writer . flush ( ) ; break ; case DISCONNECT : server . broadcaster . remove ( connection ) ; break ; case TEXTMSG_CLIENT : broadcastMessage ( message ) ; break ; case IMAGE_CLIENT : server . setImage ( ImageUtils . decodeImage ( message . getMatcher ( ) . group ( 1 ) ) ) ; broadcastMessage ( message ) ; break ; default : AbstractTool tool = AbstractTool . getTool ( message . getType ( ) ) ; if ( tool != null ) { server . updateImage ( tool , message ) ; broadcastMessage ( message ) ; } break ; } message = parser . nextMessage ( ) ; } }
tr	3	public User Authenticate ( String username , String password ) { DBConnection connection = DBConnection . sharedInstance ( ) ; ResultSet rs = connection . performQuery ( " SELECT * FROM users WHERE username = \"" + username + "\"" ) ; try { if ( rs . next ( ) ) { password = GenerateHash ( password ) ; if ( rs . getString ( "password" ) . equals ( password ) ) { UserFactory factory = UserFactory . sharedInstance ( ) ; User user = factory . getUserFromID ( rs . getInt ( "id" ) ) ; return user ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; return null ; } return null ; }
tr	2	public static void main ( String [ ] args ) { PricesInfo pricesInfo = new PricesInfo ( ) ; Reader [ ] readers = new Reader [ 5 ] ; Thread [ ] threadsReader = new Thread [ readers . length ] ; for ( int i = 0 ; i < readers . length ; i ++ ) { readers [ i ] = new Reader ( pricesInfo ) ; threadsReader [ i ] = new Thread ( readers [ i ] ) ; } Writer writer = new Writer ( pricesInfo ) ; Thread threadWriter = new Thread ( writer ) ; for ( Thread thread : threadsReader ) { thread . start ( ) ; } threadWriter . start ( ) ; }
tr	3	public void cleanAllHttpDatas ( ) { for ( HttpRequest request : requestFileDeleteMap . keySet ( ) ) { List < HttpData > fileToDelete = requestFileDeleteMap . get ( request ) ; if ( fileToDelete != null ) { for ( HttpData data : fileToDelete ) { data . delete ( ) ; } fileToDelete . clear ( ) ; } requestFileDeleteMap . remove ( request ) ; } }
tr	9X	final public void edgeRHS ( ) throws ParseException { ASTedgeRHS jjtn000 = new ASTedgeRHS ( JJTEDGERHS ) ; boolean jjtc000 = true ; jjtree . openNodeScope ( jjtn000 ) ; try { edgeop ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case ID : node_id ( ) ; break ; case SUBGRAPH : case { : subgraph ( ) ; break ; default : jj_la1 [ 11 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case EDGE_UNDIRECTED : case EDGE_DIRECTED : edgeRHS ( ) ; break ; default : jj_la1 [ 12 ] = jj_gen ; ; } } catch ( Throwable jjte000 ) { if ( jjtc000 ) { jjtree . clearNodeScope ( jjtn000 ) ; jjtc000 = false ; } else { jjtree . popNode ( ) ; } if ( jjte000 instanceof RuntimeException ) { { if ( true ) throw ( RuntimeException ) jjte000 ; } } if ( jjte000 instanceof ParseException ) { { if ( true ) throw ( ParseException ) jjte000 ; } } { if ( true ) throw ( Error ) jjte000 ; } } finally { if ( jjtc000 ) { jjtree . closeNodeScope ( jjtn000 , true ) ; } } }
tr	0	public SandTopSlab ( CustomSlabs plugin , Texture texture ) { super ( plugin , plugin . getConfig ( ) . getString ( "sand.name.top" , "Sand TopSlab" ) , 44 , 8 , new GenericCuboidBlockDesign ( plugin , texture , new int [ ] { 1 , 0 , 0 , 0 , 0 , 1 } , 0.0F , 0.5F , 0.0F , 1.0F , 1.0F , 1.0F ) ) ; this . setStepSound ( MaterialData . sand . getStepSound ( ) ) ; this . setHardness ( MaterialData . sand . getHardness ( ) ) ; this . setFriction ( MaterialData . sand . getFriction ( ) ) ; this . setLightLevel ( MaterialData . sand . getLightLevel ( ) ) ; this . setItemDrop ( new SpoutItemStack ( plugin . SandSlab ) ) ; }
tr	6	private boolean isPredictableResult ( ) { boolean commSet = true ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( this . communityCards [ i ] == null ) { commSet = false ; break ; } } if ( commSet ) { boolean correctPlayerTypes = false ; for ( PlayerProfile profile : this . profiles ) { if ( profile . getHandType ( ) != HandType . EXACTCARDS ) { correctPlayerTypes = true ; break ; } } if ( ! correctPlayerTypes ) { return true ; } } return false ; }
tr	1	public void onUnitDestroy ( Unit unit ) { if ( eventListener != null ) { eventListener . onUnitDestroy ( unit ) ; } }
tr	4	public Rectangle2D getDrawableArea ( Unit unit ) { double w = paperWidth . getValue ( unit ) ; double x = 0 ; if ( leftMargin != null ) { x = leftMargin . getValue ( unit ) ; w -= x ; } if ( rightMargin != null ) { w -= rightMargin . getValue ( unit ) ; } double h = paperHeight . getValue ( unit ) ; double y = 0 ; if ( topMargin != null ) { y = topMargin . getValue ( unit ) ; h -= y ; } if ( bottomMargin != null ) { h -= bottomMargin . getValue ( unit ) ; } return new Rectangle2D . double ( x , y , w , h ) ; }
tr	0	public JTextField getTextNombre ( ) { return TextNombre ; }
tr	4	public graph ( String C , String type , String interval , String r ) throws SQLException { super ( "Bar Chart" ) ; connnect = new sqlConnection ( ) ; sql = new selectQueries ( ) ; sqlInsert = new insertQueries ( ) ; Connection conn = connnect . connect ( ) ; int inte = Integer . parseInt ( interval ) ; ResultSet item = sql . getGraph1 ( conn , type , inte ) ; int i = 0 ; ResultSetMetaData md = item . getMetaData ( ) ; int count = md . getColumnCount ( ) ; String [ ] list = new String [ count ] ; int i1 = 0 ; while ( item . next ( ) ) { list [ i1 ] = item . getString ( "rcm_id" ) ; i1 ++ ; } BarChart chart = new BarChart ( ) ; Object [ ] col = new Object [ ] { Color . red , Color . green , Color . blue , Color . black , Color . pink , Color . yellow , Color . DARK_GRAY } ; for ( int p = 0 ; p < count ; p ++ ) { if ( p == col . length - 1 ) { break ; } try { chart . addBar ( ( Color ) col [ p ] , Integer . parseInt ( list [ p ] ) ) ; } catch ( Exception e ) { System . out . println ( "Exception occured here" ) ; } } getContentPane ( ) . setBackground ( Color . CYAN ) ; getContentPane ( ) . add ( chart ) ; setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; pack ( ) ; setVisible ( true ) ; }
tr	2	public void setValue ( int value ) { if ( value < this . minValue ) { this . value = minValue ; } else if ( value > maxValue ) { this . value = maxValue ; } else { this . value = value ; } this . slider . reactToChanges ( new CustomSliderEvent ( slider , this . value ) ) ; this . textField . reactToChanges ( new CustomTextFieldEvent ( textField , Integer . toString ( this . value ) ) ) ; }
tr	3	@ Override public Object getAsObject ( FacesContext facesContext , UIComponent uicomp , String value ) { try { FacesContext context = FacesContext . getCurrentInstance ( ) ; VendaBean venda = ( VendaBean ) context . getELContext ( ) . getELResolver ( ) . getValue ( context . getELContext ( ) , null , "venda" ) ; for ( Produto c : venda . getProdutos ( ) ) if ( c . getDescricao ( ) . equals ( value ) ) return c ; return null ; } catch ( Exception ex ) { return null ; } }
tr	5	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { try { ClientServiceImpl csi = new ClientServiceImpl ( conn ) ; Client client = new Client ( ) ; setNewClientProperty ( client ) ; if ( client . getFirstName ( ) . equals ( "" ) || client . getLastName ( ) . equals ( "" ) || client . getBirthDay ( ) == null || client . getPassportNumber ( ) . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0435\u0434\u043E\u0441\u0442\u0430\u044E\u0449\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0435!" ) ; } else { csi . insert ( client ) ; JOptionPane . showMessageDialog ( null , "\u041A\u043B\u0438\u0435\u043D\u0442 \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D!" ) ; close ( ) ; } } catch ( ExsistDoubleClient ex ) { JOptionPane . showMessageDialog ( null , "\u041A\u043B\u0438\u0435\u043D\u0442 \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442!" ) ; } }
tr	3	public void setEqualizer ( Equalizer = ) { if ( = == null ) = = Equalizer . PASS_THRU_EQ ; equalizer . setFrom ( = ) ; float [ ] factors = equalizer . getBandFactors ( ) ; if ( filter1 != null ) filter1 . setEQ ( factors ) ; if ( filter2 != null ) filter2 . setEQ ( factors ) ; }
tr	2	@ Override public boolean hasNext ( ) { while ( index < menu . size ( ) ) { if ( menu . get ( index ) . getCalories ( ) <= maxCalories ) { return true ; } else { index ++ ; } } return false ; }
tr	7	@ Override public boolean done ( ArrayList < Node > nw , int fab ) { int a = ( ( BeaconFAB ) nw . get ( 0 ) . getFAB ( fab ) ) . A ; Set < Integer > armies = new HashSet < Integer > ( ) ; int min = Integer . MAX_VALUE ; int d0 = 0 ; int d1 = 0 ; int d2 = 0 ; int d3 = 0 ; boolean res = true ; int sw = 0 ; for ( Node N : nw ) { armies . add ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A ) ; sw = ( ( BeaconFAB ) N . getFAB ( fab ) ) . D ; min = min < sw ? min : sw ; switch ( sw ) { case 0 : d0 ++ ; break ; case 1 : d1 ++ ; break ; case 2 : d2 ++ ; break ; case 3 : d3 ++ ; break ; default : break ; } if ( ( ( BeaconFAB ) N . getFAB ( fab ) ) . A != a ) { res = false ; } } return res ; }
tr	6	private void watchCandidate ( LeaderOffer previousOffer ) throws KeeperException , InterruptedException { LOG . info ( "{} not elected leader. Watching node {}" , leaderOffer , previousOffer ) ; Stat stat = zooKeeper . exists ( previousOffer . getOffer ( ) , new Watcher ( ) { public void process ( WatchedEvent event ) { if ( event . getType ( ) . equals ( Watcher . Event . EventType . NodeDeleted ) ) { if ( ! event . getPath ( ) . equals ( LeaderElectionService . this . leaderOffer . getOffer ( ) ) ) { LOG . debug ( "Node {} deleted. Need to run through the election process." , event . getPath ( ) ) ; try { determine ( ) ; } catch ( KeeperException e ) { failed ( e ) ; } catch ( InterruptedException e ) { failed ( e ) ; } } } } } ) ; if ( stat != null ) { LOG . info ( "Becoming follower with node {}  We're watching {}" , leaderOffer , previousOffer ) ; if ( leaderElectionAware != null ) { leaderElectionAware . onFollower ( leaderOffer ) ; } } else { LOG . debug ( "We were behind {} but it looks like died. Back to determination." , previousOffer ) ; determine ( ) ; } }
tr	3	public static ArrayList < Compte > getAllCompte ( ) { Statement stat ; ArrayList < Compte > comptes = new ArrayList < > ( ) ; try { stat = ConnexionDB . getConnection ( ) . createStatement ( ) ; stat . executeUpdate ( "use nemovelo" ) ; ResultSet res = stat . executeQuery ( "select * from compte" ) ; Compte compte ; int id_compte , fk_id_utilisateur ; double solde ; String typeCompte , dateCreation ; while ( res . next ( ) ) { id_compte = res . getInt ( "id_compte" ) ; typeCompte = res . getString ( "typeCompte" ) ; solde = res . getDouble ( "solde" ) ; dateCreation = res . getString ( "dateCreation" ) ; fk_id_utilisateur = res . getInt ( "fk_id_utilisateur" ) ; compte = new Compte ( id_compte , typeCompte , solde , dateCreation , fk_id_utilisateur ) ; comptes . add ( compte ) ; } } catch ( SQLException e ) { while ( e != null ) { System . out . println ( e . getErrorCode ( ) ) ; System . out . println ( e . getMessage ( ) ) ; System . out . println ( e . getSQLState ( ) ) ; e . printStackTrace ( ) ; e = e . getNextException ( ) ; } } return comptes ; }
tr	3	public static Matrix4 multiply ( Matrix4 m1 , Matrix4 m2 ) { Matrix4 C = new Matrix4 ( ) ; for ( int i = 0 ; i < 4 ; ++ i ) for ( int j = 0 ; j < 4 ; ++ j ) for ( int k = 0 ; k < 4 ; ++ k ) C . A [ i ] [ j ] += m1 . A [ i ] [ k ] * m2 . A [ k ] [ j ] ; return C ; }
tr	9X	private boolean checkBackDiagonal ( int j , int i , ConnectFourPiece [ ] [ ] m_Pieces ) { boolean gameWon = false ; int secondPieceDDiagonalColoumn = i - 1 ; int thirdPieceDDiagonalColoumn = i - 2 ; int fourthPieceDDiagonalColoumn = i - 3 ; int secondPieceDDiagonalRow = j + 1 ; int thirdPieceDDiagonalRow = j + 2 ; int fourthPieceDDiagonalRow = j + 3 ; if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( j < ROW_EIGHT && i > COLUMN_THREE && m_Pieces [ j ] [ i ] . getPieceColour ( ) == m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . getPieceColour ( ) ) { if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == RED_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( RED_STAR_PIECE ) ; } else if ( m_Pieces [ j ] [ i ] . getPieceColour ( ) == YELLOW_PIECE ) { m_Pieces [ j ] [ i ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ secondPieceDDiagonalRow ] [ secondPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ thirdPieceDDiagonalRow ] [ thirdPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; m_Pieces [ fourthPieceDDiagonalRow ] [ fourthPieceDDiagonalColoumn ] . setPieceColour ( YELLOW_STAR_PIECE ) ; } gameWon = true ; } } } return gameWon ; }
tr	2	private void removeNeuron ( int num ) { Neuron neuron = ( Neuron ) ( currentNetwork . getNode ( num ) ) ; currentNetwork . getNeurons ( ) . remove ( neuron ) ; for ( int i = 0 ; i < neuron . getInputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getInputs ( ) . get ( i ) ; connection . getGiveNeuron ( ) . getOutputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } for ( int i = 0 ; i < neuron . getOutputs ( ) . size ( ) ; i ++ ) { Connection connection = neuron . getOutputs ( ) . get ( i ) ; connection . getRecieveNeuron ( ) . getInputs ( ) . remove ( connection ) ; currentNetwork . getConnections ( ) . remove ( connection ) ; } System . out . println ( "Neuron :: " + num + " :: was removed" ) ; }
tr	0	private Vector < Arete > ajoute ( int p , Vector < Arete > v ) { DoubletVect < Arete > dVect = separe ( ens . elementAt ( p ) , v ) ; int [ ] tab = compte ( dVect . v1 , p ) ; Vector < Arete > vEnPlus = nouvellesAretes ( p , tab , p ) ; return concat ( dVect . v2 , vEnPlus ) ; }
tr	5	@ Override public void actionPerformed ( ActionEvent e ) { JMenuItem popup = ( JMenuItem ) e . getSource ( ) ; String name = popup . getName ( ) ; switch ( name ) { case "add track" : List < TrackBean > selectedTracks = view . getSelectedTracks ( ) ; model . addTracksToPlaylist ( selectedTracks ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "add album" : AlbumBean selectedAlbum = view . getSelectedAlbum ( ) ; model . addTracksToPlaylist ( selectedAlbum . getTracks ( ) ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "clear playlist" : model . stopSong ( false ) ; view . setDisplayedPlaylist ( model . getPlaylist ( ) ) ; break ; case "remove track" : removeTracks ( ) ; break ; case "get info" : view . displayInfoDialog ( view . getSelectedTracks ( ) . get ( 0 ) ) ; break ; } }
tr	3	@ Override public int resolve ( ) throws Exception { Room room = getMyRoom ( ) ; if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENDOWN ) ) { room . getTurtle ( ) . setPenStatus ( true ) ; return CommandConstants . COMMAND_RETURN_TRUE ; } else if ( getMyString ( ) . equals ( CommandConstants . COMMAND_NAME_PENUP ) ) { room . getTurtle ( ) . setPenStatus ( false ) ; return CommandConstants . COMMAND_RETURN_FALSE ; } else { if ( room . getTurtle ( ) . getPenStatus ( ) ) { return CommandConstants . COMMAND_RETURN_TRUE ; } else { return CommandConstants . COMMAND_RETURN_FALSE ; } } }
tr	0	public void setIndId ( Integer indId ) { this . indId = indId ; }
tr	4	public static void compute_first_sets ( ) throws internal_error { boolean change = true ; Enumeration n ; Enumeration p ; non_terminal nt ; production prod ; terminal_set prod_first ; while ( change ) { change = false ; for ( n = all ( ) ; n . hasMoreElements ( ) ; ) { nt = ( non_terminal ) n . nextElement ( ) ; for ( p = nt . productions ( ) ; p . hasMoreElements ( ) ; ) { prod = ( production ) p . nextElement ( ) ; prod_first = prod . check_first_set ( ) ; if ( ! prod_first . is_subset_of ( nt . _first_set ) ) { change = true ; nt . _first_set . add ( prod_first ) ; } } } } }
tr	8	public void updateLICImage ( ) { if ( m_field . termBasePoints ( ) . getNumVertices ( ) == 0 ) { PdVector . setConstant ( m_vec . getVectors ( ) , 1 ) ; m_lic . startLIC ( ) ; return ; } PdVector [ ] V_y_field = new PdVector [ m_domain . getNumVertices ( ) ] ; for ( int i = 0 ; i < m_domain . getNumVertices ( ) ; ++ i ) { PdVector pos = m_domain . getVertex ( i ) ; PdMatrix eV = Utils . solveEigen2x2 ( m_field . evaluate ( pos ) , null , true ) ; PdVector E ; if ( m_direction . getSelectedItem ( ) == Direction . Major ) { E = eV . getRow ( 0 ) ; } else { E = eV . getRow ( 1 ) ; } PdVector V_x = PdVector . copyNew ( E ) ; if ( V_x . getEntry ( 0 ) < 0 ) { V_x . multScalar ( - 1 ) ; } PdVector V_y = PdVector . copyNew ( E ) ; if ( V_y . getEntry ( 1 ) < 0 ) { V_y . multScalar ( - 1 ) ; } assert V_x . getEntry ( 0 ) >= 0 ; assert V_y . getEntry ( 1 ) >= 0 ; m_vec . setVector ( i , V_x ) ; V_y_field [ i ] = V_y ; assert m_vec . getVector ( i ) . getSize ( ) == 2 : m_vec . getVector ( i ) . getSize ( ) ; } BufferedImage lic1 = generateLICImage ( ) ; for ( int i = 0 ; i < V_y_field . length ; ++ i ) { m_vec . setVector ( i , V_y_field [ i ] ) ; } BufferedImage lic2 = generateLICImage ( ) ; double [ ] [ ] weights = computeBlendWeights ( ) ; int width = m_lic . getTextureSize ( ) . width ; int height = m_lic . getTextureSize ( ) . height ; BufferedImage result = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; for ( int i = 0 ; i < width ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { double col = ( lic1 . getRGB ( i , j ) & ff ) * weights [ i ] [ j ] + ( lic2 . getRGB ( i , j ) & ff ) * ( 1 - weights [ i ] [ j ] ) ; result . setRGB ( i , j , Color . HSBtoRGB ( 0f , 0f , ( float ) col / 256 ) ) ; } } m_domain . getTexture ( ) . setImage ( result ) ; m_disp . update ( m_domain ) ; }
tr	7	public void open ( int row , int col ) { validate ( row ) ; validate ( col ) ; int idx = index ( row , col ) ; if ( ! isOpenV ( idx ) ) { open [ idx ] = true ; if ( row == 1 ) { if ( toBottom [ idx ] ) { percolates = true ; } ufTop . union ( idx , theTOP ) ; } else { connectIfDestOpen ( idx , row - 1 , col ) ; } if ( col > 1 ) { connectIfDestOpen ( idx , row , col - 1 ) ; } if ( col < N ) { connectIfDestOpen ( idx , row , col + 1 ) ; } if ( row == N ) { if ( toTop [ idx ] ) { percolates = true ; } } else { connectIfDestOpen ( idx , row + 1 , col ) ; } } }
tr	9X	public int bitrate ( int i ) { if ( i >= links ) return ( - 1 ) ; if ( ! seekable && i != 0 ) return ( bitrate ( 0 ) ) ; if ( i < 0 ) { long bits = 0 ; for ( int j = 0 ; j < links ; j ++ ) { bits += ( offsets [ j + 1 ] - dataoffsets [ j ] ) * 8 ; } return ( ( int ) Math . rint ( bits / time_total ( - 1 ) ) ) ; } else { if ( seekable ) { return ( ( int ) Math . rint ( ( offsets [ i + 1 ] - dataoffsets [ i ] ) * 8 / time_total ( i ) ) ) ; } else { if ( vi [ i ] . bitrate_nominal > 0 ) { return vi [ i ] . bitrate_nominal ; } else { if ( vi [ i ] . bitrate_upper > 0 ) { if ( vi [ i ] . bitrate_lower > 0 ) { return ( vi [ i ] . bitrate_upper + vi [ i ] . bitrate_lower ) / 2 ; } else { return vi [ i ] . bitrate_upper ; } } return ( - 1 ) ; } } } }
tr	5	@ Override public void draw ( SpriteBatch batch ) { if ( object . isVisible ( ) ) { graphics . draw ( batch ) ; } if ( animate ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = explosionAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - 1f ) , ( animPos . y - 1f ) , 2 , 2 ) ; if ( explosionAnimation . isAnimationFinished ( stateTime ) ) { animate = false ; WorldObject . removelist . add ( object ) ; } } else if ( animateMiss ) { stateTime += Gdx . graphics . getDeltaTime ( ) ; currentFrame = splashAnimation . getKeyFrame ( stateTime , false ) ; batch . draw ( currentFrame , ( animPos . x - .5f ) , ( animPos . y - .5f ) , 1 , 1 ) ; if ( splashAnimation . isAnimationFinished ( stateTime ) ) { animateMiss = false ; WorldObject . removelist . add ( object ) ; } } }
tr	1	public static void input ( float delta ) { if ( nextScene != null ) { updateLoadScene ( ) ; } rootNode . input ( delta ) ; }
tr	5	@ Override public void doFilter ( ServletRequest servletRequest , ServletResponse servletResponse , FilterChain filterChain ) throws IOException , ServletException { HttpServletRequest request = ( HttpServletRequest ) servletRequest ; HttpServletResponse response = ( HttpServletResponse ) servletResponse ; User session = ( User ) request . getSession ( ) . getAttribute ( "user" ) ; String url = request . getRequestURI ( ) ; response . setHeader ( "Cache-Control" , "no-cache  no-store  must-revalidate" ) ; response . setHeader ( "Pragma" , "no-cache" ) ; response . setDateHeader ( "Expires" , 0 ) ; if ( session == null ) { if ( url . indexOf ( "/content/" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "/security/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } else { if ( url . indexOf ( "register.xhtml" ) >= 0 || url . indexOf ( "/login.xhtml" ) >= 0 ) { response . sendRedirect ( request . getContextPath ( ) + "../content/news.xhtml" ) ; } else if ( url . indexOf ( "logout.xhtml" ) >= 0 ) { request . getSession ( ) . removeAttribute ( "user" ) ; response . sendRedirect ( request . getContextPath ( ) + "/login.xhtml" ) ; } else { filterChain . doFilter ( request , response ) ; } } }
tr	4	private void init ( ) { int n = mapInfo . getMapSize ( ) ; visited = new boolean [ n ] [ n ] ; for ( int column = 0 ; column < n ; column ++ ) visited [ 0 ] [ column ] = visited [ n - 1 ] [ column ] = true ; for ( int row = 0 ; row < n ; row ++ ) visited [ row ] [ 0 ] = visited [ row ] [ n - 1 ] = true ; for ( int column = 0 ; column < n ; column ++ ) for ( int row = 0 ; row < n ; row ++ ) mapInfo . setCell ( row , column , new Cell ( true , true , true , true ) ) ; }
tr	6	@ Override public void run ( ) { if ( getLocation ( ) . distance ( bankerTile ) <= 10 ) { goHome ( ) ; } Time . sleep ( rand . nextInt ( 2000 ) ) ; if ( getLocation ( ) . equals ( new Tile ( 3262 , 3322 , 0 ) ) || getLocation ( ) . equals ( new Tile ( 3262 , 3323 , 0 ) ) ) { Walking . walk ( Field ) ; Time . sleep ( 5000 ) ; } SceneObject Gate = SceneEntities . getNearest ( new Filter < SceneObject > ( ) { public boolean accept ( SceneObject entity ) { return entity . getId ( ) == 45206 ; } } ) ; if ( getLocation ( ) . distance ( Gate ) <= 5 ) { Gate . interact ( "Open" ) ; Time . sleep ( 3000 ) ; } if ( getLocation ( ) . distance ( Gate ) <= 5 && ! Gate . isOnScreen ( ) ) { Camera . turnTo ( Gate ) ; Time . sleep ( 3000 ) ; } }
tr	1	public Editor ( ) { LOGGER . info ( "Starting Editor" ) ; try { db = MySQLConnector . getInstance ( ) ; } catch ( NotConfiguredException | DataStoreException | ConnectionException e ) { showErrorMessage ( "An error occurred while connecting to the database \n" + "please check your configuration file and the connection to the database." , "Database Error" ) ; System . exit ( - 2 ) ; } frame . setLayout ( new BorderLayout ( ) ) ; mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . Y_AXIS ) ) ; scrollPane = new JScrollPane ( mainPanel ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; frame . add ( informationPanel , BorderLayout . NORTH ) ; frame . add ( scrollPane , BorderLayout . CENTER ) ; setupMenu ( ) ; setupEnterActionForAllButtons ( ) ; setupListeners ( ) ; RecipeSectionPanel section = new RecipeSectionPanel ( 1 ) ; section . addChangeListener ( this ) ; sections . add ( section ) ; mainPanel . add ( section ) ; scrollPane . setPreferredSize ( new Dimension ( 767 , 600 ) ) ; frame . pack ( ) ; frame . setDefaultCloseOperation ( WindowConstants . DO_NOTHING_ON_CLOSE ) ; frame . setVisible ( true ) ; }
tr	2	private boolean isValidUserInput ( final String hostname , final String port ) { final String methodName = "isValidUserInput" ; ControllerLogger . entering ( CLASS_NAME , methodName , hostname , port ) ; try { if ( GUIUtils . isEmptyValue ( hostname ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_HOSTNAME_MESSAGE ) ; return false ; } if ( ! GUIUtils . isPortNumberValid ( port ) ) { GUIUtils . showWarningMessage ( connectToServerWindow , GUIMessages . INVALID_PORT_NUMBER_MESSAGE ) ; return false ; } return true ; } finally { ControllerLogger . exiting ( CLASS_NAME , methodName ) ; } }
tr	8	private void createGame ( ) { gameName = fieldGameName . getText ( ) ; playerNameHost = fieldPlayerName . getText ( ) ; Enumeration < NetworkInterface > nets = null ; try { nets = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( SocketException e1 ) { } Vector < String > l = new Vector < String > ( ) ; for ( NetworkInterface netint : Collections . list ( nets ) ) { Enumeration < InetAddress > inetAddresses = netint . getInetAddresses ( ) ; for ( InetAddress inetAddress : Collections . list ( inetAddresses ) ) { l . add ( netint . getDisplayName ( ) + " (" + inetAddress . toString ( ) . substring ( 1 ) + ")" ) ; } } Object selVal = JOptionPane . showInputDialog ( this , "Choose interface to bind" , "Input" , JOptionPane . INFORMATION_MESSAGE , null , l . toArray ( ) , l . elementAt ( 0 ) ) ; String ip = selVal . toString ( ) ; int beg = ip . lastIndexOf ( ( ) ; int end = ip . lastIndexOf ( ) ) ; String ipAddr = selVal . toString ( ) . substring ( beg + 1 , end ) ; try { addr = InetAddress . getByName ( ipAddr ) ; } catch ( UnknownHostException e1 ) { } if ( gameName == null || gameName . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each game needs a name" , "Game Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } if ( playerNameHost == null || playerNameHost . isEmpty ( ) ) { JOptionPane . showMessageDialog ( null , "each player needs a name" , "Player Name" , JOptionPane . ERROR_MESSAGE ) ; return ; } dispose ( ) ; s = new Server ( ipAddr ) ; adapter . connectToServer ( addr , playerNameHost ) ; hostFrame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; hostFrame . setTitle ( "Snake on Lan - Host Game" ) ; hostFrame . setVisible ( true ) ; hostFrame . setResizable ( false ) ; hostFrame . setLocationRelativeTo ( null ) ; StartSnakeGame . frame . dispose ( ) ; }
tr	4	public static final byte product ( byte u , byte v ) { if ( u == 0 || v == 0 ) return 0 ; if ( u == 1 ) return v ; if ( v == 1 ) return u ; else { byte product = getExp ( UNSIGN ( getLog ( u - 1 ) ) + UNSIGN ( getLog ( v - 1 ) ) ) ; return product ; } }
tr	1	public static List < Appointment > findByVenue ( long venueId ) throws SQLException { List < Appointment > aAppt = new ArrayList < Appointment > ( ) ; ResultSet resultSet = Data . _find ( Appointment . class . getSimpleName ( ) , "venueId" , String . valueOf ( venueId ) ) ; while ( resultSet . next ( ) ) { aAppt . add ( Appointment . createOneFromResultSet ( resultSet ) ) ; } return aAppt ; }
tr	9X	public void outDem ( String s , int color , boolean bold ) { String sortie = "" ; sortie += "\u001B[" ; if ( bold ) sortie += "1;" ; switch ( color ) { case 0 : sortie += "30" ; break ; case 1 : sortie += "31" ; break ; case 2 : sortie += "32" ; break ; case 3 : sortie += "33" ; break ; case 4 : sortie += "34" ; break ; case 5 : sortie += "35" ; break ; case 6 : sortie += "36" ; break ; case 7 : sortie += "37" ; break ; } sortie += "mServeur " + Global . TCP_PORT + " : " + s + "\u001B[0m\n" ; try { Thread . sleep ( ( int ) Math . abs ( Math . random ( ) * 20 ) ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . print ( sortie ) ; }
tr	7	public double pow ( double x , int n ) { if ( x == 0.0 && n > 0 ) return 0.0 ; if ( x == 0.0 && n <= 0 ) return 1.0 ; if ( n == 0 ) return 1.0 ; if ( n > 0 ) return x * pow ( x , n - 1 ) ; if ( n < 0 ) return 1 / x * pow ( x , n + 1 ) ; return 0.0 ; }
tr	3	public static void initConfig ( String path ) { FileInputStream fis = null ; try { fis = new FileInputStream ( path ) ; SYSTEM_CONFIG . load ( fis ) ; } catch ( Exception e ) { logger . error ( "System config file init fail !" , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } }
tr	1	public static boolean updateKurssi ( Kurssi kurssi ) { Connection con = connect ( ) ; try { PreparedStatement updateKurssi = con . prepareStatement ( "UPDATE kurssi SET nimi=? WHERE kurssiID=?" ) ; updateKurssi . setString ( 1 , kurssi . getNimi ( ) ) ; updateKurssi . setInt ( 2 , kurssi . getId ( ) ) ; updateKurssi . executeUpdate ( ) ; return true ; } catch ( SQLException ex ) { Logger . getLogger ( Database . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return false ; } finally { closeConnection ( con ) ; } }
tr	4	@ Override public void processDrawing ( ) { if ( rsAlreadyLoaded || loadingError || genericLoadingError ) { showErrorScreen ( ) ; return ; } drawCycle ++ ; if ( ! loggedIn ) drawLoginScreen ( false ) ; else drawGameScreen ( ) ; anInt1213 = 0 ; }
tr	5	@ Override public void run ( ) { while ( true ) { try { for ( BlockLocationPair p : deletionQueue ) { String nodeLocation = p . nodeLocation ; String blockName = p . blockName ; String [ ] ipPort ; try { ipPort = AddressToIPPort . addressToIPPort ( nodeLocation ) ; Message inputMessage = new Message ( "remove" ) ; inputMessage . fileName = blockName ; Communicator . sendMessage ( ipPort [ 0 ] , Integer . parseInt ( ipPort [ 1 ] ) , inputMessage ) ; } catch ( NumberFormatException | IOException e ) { e . printStackTrace ( ) ; throw new IOException ( "Could not delete distributed file block " + blockName + "\n " + e . getMessage ( ) ) ; } } } catch ( Exception e ) { Logger . log ( "Error encountered while deleting distributed file: " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } try { Thread . sleep ( 3000 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } }
tr	7	@ Override public short [ ] getShortData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; short [ ] out = new short [ ( int ) length ] ; short elem = ( short ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { short [ ] res = new short [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( short ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
tr	1	public char next ( char c ) throws JSONException { char n = next ( ) ; if ( n != c ) { throw syntaxError ( "Expected '" + c + "' and instead saw '" + n + "'" ) ; } return n ; }
tr	4	@ Override public Tipo validarSemantica ( ) throws Exception { Tipo izq , der ; izq = izquierdo . validarSemantica ( ) ; der = derecho . validarSemantica ( ) ; if ( izq instanceof TipoInt || der instanceof TipoFloat ) { if ( der instanceof TipoInt || der instanceof TipoFloat ) { return new TipoBooleano ( ) ; } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } } else { throw new Exception ( "Error Semantico no se puede comparar un Tipo Int o Float con un Tipo " + der . toString ( ) ) ; } }
tr	2	public int priseTerritoire ( Territoire t , int nbUnite ) { if ( this . nbUniteBonus >= nbUnite - 1 ) { this . nbUniteBonus -= nbUnite - 1 ; nbUnite = 1 ; } else { nbUnite -= this . nbUniteBonus ; this . nbUniteBonus = 0 ; } this . nbUniteEnMain -= nbUnite ; t . setNbUnite ( nbUnite ) ; t . setOccupant ( this ) ; this . territoiresOccupes . add ( t ) ; this . actionPriseTerritoire ( t ) ; if ( hasPower ( ) ) { this . pouvoir . actionPriseTerritoire ( t ) ; } return nbUnite ; }
tr	3	public static String StrFill ( String fillStr , String oldStr , int length , String place ) { StringBuffer sb = new StringBuffer ( ) ; if ( "right" . equals ( place ) ) { sb . append ( oldStr ) ; } for ( int i = 0 ; i < ( length - oldStr . length ( ) ) ; i ++ ) { sb . append ( fillStr ) ; } if ( "left" . equals ( place ) ) { sb . append ( oldStr ) ; } return sb . toString ( ) ; }
tr	3	public boolean equals ( Object obj ) { boolean returnMe = true ; if ( ! obj . getClass ( ) . equals ( this . getClass ( ) ) ) { returnMe = false ; } else { if ( docID != ( ( Pair ) obj ) . docID ) { returnMe = false ; } else { if ( score != ( ( Pair ) obj ) . score ) { returnMe = false ; } } } return returnMe ; }
tr	9X	private void parseSpriteSheets ( ) throws IOException , ExpectedTokenException , InvalidTokenException { String line ; line = reader . readLine ( ) ; if ( ! line . equals ( "SPRITESHEETS" ) ) { throw new ExpectedTokenException ( "SPRITESHEETS" , line ) ; } line = reader . readLine ( ) ; while ( line != null && ! line . equals ( "END SPRITESHEETS" ) ) { scanner = new Scanner ( line ) ; if ( ! scanner . hasNext ( ) ) { throw new ExpectedTokenException ( "<file>" , line ) ; } String file = scanner . next ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame width>" , line ) ; } int frameWidth = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<frame height>" , line ) ; } int frameHeight = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding x>" , line ) ; } int paddingX = scanner . nextInt ( ) ; if ( ! scanner . hasNextInt ( ) ) { throw new ExpectedTokenException ( "<padding y>" , line ) ; } int paddingY = scanner . nextInt ( ) ; SpriteSheet sheet = new SpriteSheet ( file , new Vec2i ( frameWidth , frameHeight ) , new Vec2i ( paddingX , paddingY ) ) ; sheets . put ( file , sheet ) ; line = reader . readLine ( ) ; } if ( line == null ) { throw new ExpectedTokenException ( "END SPRITESHEET" , line ) ; } }
tr	3	public static DummyKVStorable [ ] merge ( DummyKVStorable [ ] ... arrays ) { int size = 0 ; for ( DummyKVStorable [ ] A : arrays ) size += A . length ; DummyKVStorable [ ] all = new DummyKVStorable [ size ] ; int k = 0 ; for ( DummyKVStorable [ ] A : arrays ) { for ( DummyKVStorable d : A ) { all [ k ++ ] = d ; } } return all ; }
tr	0	@ Override public List < Apontamento > obterPorOrdemServico ( int ordemServicoId ) { return session . createQuery ( "from Apontamento where OrdemServicoId = :ordemServicoId" ) . setString ( "ordemServicoId" , String . valueOf ( ordemServicoId ) ) . list ( ) ; }
tr	9X	@ Override public boolean run ( ) { int i ; int j = - 1 ; int k ; int [ ] path ; int step ; int current = game . getCurPacManLoc ( ) ; if ( game . isJunction ( current ) ) { visitedJunctions . add ( current ) ; } int [ ] junction = game . getJunctionIndices ( ) ; int [ ] array ; ArrayList < Integer > list = new ArrayList < Integer > ( ) ; for ( i = 0 ; i < junction . length ; i ++ ) { list . add ( junction [ i ] ) ; } list . removeAll ( visitedJunctions ) ; boolean foundPath = false ; boolean foundGhost = false ; while ( ! foundPath && ! list . isEmpty ( ) ) { array = new int [ list . size ( ) ] ; for ( i = 0 ; i < array . length ; i ++ ) { array [ i ] = list . get ( i ) ; } j = game . getTarget ( current , array , true , Game . DM . PATH ) ; path = game . getPath ( current , j ) ; foundGhost = false ; for ( step = 0 ; step < path . length && ! foundGhost ; step ++ ) { for ( k = 0 ; k < Game . NUM_GHOSTS ; k ++ ) { int ghostDist = game . getGhostPathDistance ( k , path [ step ] ) ; int myDist = game . getPathDistance ( current , path [ step ] ) ; if ( ghostDist > 0 && ghostDist < MyPacMan . JUNC_DIST && ( ghostDist < myDist ) ) { foundGhost = true ; list . remove ( new Integer ( j ) ) ; break ; } } } foundPath = ! foundGhost ; } if ( foundPath ) { GameView . addPoints ( game , Color . LIGHT_GRAY , game . getPath ( current , j ) ) ; setTarget ( game . getNextPacManDir ( j , true , Game . DM . PATH ) ) ; return true ; } return false ; }
tr	4	private static int [ ] [ ] maxSumArea ( int m , int n , int [ ] [ ] forest ) { int [ ] [ ] res = new int [ m ] [ n ] ; int [ ] [ ] matrix = flip ( m , n , forest ) ; for ( int i = 0 ; i < res [ 0 ] . length ; i ++ ) { res [ 0 ] [ i ] = forest [ 0 ] [ i ] ; } for ( int i = 1 ; i < res . length ; i ++ ) { for ( int j = 0 ; j < res [ i ] . length ; j ++ ) { if ( forest [ i ] [ j ] == 0 ) res [ i ] [ j ] = 0 ; else res [ i ] [ j ] = res [ i - 1 ] [ j ] + forest [ i ] [ j ] ; } } return res ; }
tr	6	public Vector < Vector < Object >> getFolderContentsTable ( ) { Vector < Vector < Object >> tableData = new Vector < > ( ) ; List < FileInfo > files = getFolderContents ( ) ; logger . debug ( "Found " + files . size ( ) + " entries for " + path . toString ( ) ) ; for ( FileInfo file : files ) { Vector < Object > row = null ; if ( file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/folder.png" ) ) ; } else { row . add ( new ImageIcon ( "res/folder_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } for ( FileInfo file : files ) { Vector < Object > row = null ; if ( ! file . folder ) { row = new Vector < > ( ) ; if ( FileOp . convertPath ( path . resolve ( file . fileName ) ) . toFile ( ) . exists ( ) ) { row . add ( new ImageIcon ( "res/file.png" ) ) ; } else { row . add ( new ImageIcon ( "res/file_deleted.png" ) ) ; } row . add ( file . fileName ) ; row . add ( GuiUtility . humanReadableBytes ( file . fileSize , false ) ) ; row . add ( GuiUtility . formatDate ( file . createdDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastAccessedDate ) ) ; row . add ( GuiUtility . formatDate ( file . lastModifiedDate ) ) ; row . add ( Integer . toString ( file . numberOfRevisions ) ) ; row . add ( GuiUtility . humanReadableBytes ( file . revisionSizes , false ) ) ; tableData . add ( row ) ; } } return tableData ; }
tr	6	public static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
tr	7	private void computerNextTurn ( ) { if ( ! getGame ( ) . gameWon ( ) ) { new Thread ( new Runnable ( ) { public void run ( ) { try { Thread . sleep ( ANIMATION_TIME ) ; } catch ( Exception e ) { } if ( ! getGame ( ) . getPlayer ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS ) . getPlayerType ( ) . equals ( "Human" ) ) { int playerTurn = getGame ( ) . getPlayerTurn ( ) ; int x ; if ( ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_ONE && m_playerOneType == "Computer: Easy" ) || ( getGame ( ) . getPlayerTurn ( ) % TOTAL_PLAYERS == PLAYER_TWO && m_playerTwoType == "Computer: Easy" ) ) { ConnectFourEasyComputerPlayer player = ( ConnectFourEasyComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } else { ConnectFourHardComputerPlayer player = ( ConnectFourHardComputerPlayer ) getGame ( ) . getPlayer ( playerTurn % TOTAL_PLAYERS ) ; x = ( int ) player . makeAIMove ( getGame ( ) . getBoard ( ) ) . getX ( ) ; } performMove ( x ) ; getGame ( ) . incrementTurn ( ) ; } } } ) . start ( ) ; } }
tr	8	public void run ( ) { while ( ! mServerDisconnected ) { ArrayList < NetworkMessage > messages = GetMessages ( mUnsanitizedMessages ) ; for ( int i = 0 ; i < messages . size ( ) ; i ++ ) { NetworkMessage current = messages . get ( i ) ; current . Sanatize ( ) ; String message = current . GetMessage ( ) ; StringTokenizer st = new StringTokenizer ( message ) ; try { int id = Integer . parseInt ( st . nextToken ( ) ) ; ConnectedClient client = GetClient ( id ) ; if ( client != null ) { client . MessageRecieved ( ) ; } String command = st . nextToken ( ) ; if ( command . equalsIgnoreCase ( "ping" ) ) { client . PingRecieved ( ) ; } else if ( command . equalsIgnoreCase ( "connect" ) ) { if ( client == null ) { System . out . println ( "someone connected" ) ; ConnectedClient newClient = new ConnectedClient ( GetNextID ( ) , current . GetAddress ( ) , current . GetPort ( ) ) ; mClients . add ( newClient ) ; } } else { throw new Exception ( ) ; } } catch ( Exception e ) { AddMessage ( message , current . GetAddress ( ) , current . GetPort ( ) , mMessages ) ; } } try { Thread . sleep ( 10 ) ; } catch ( Exception e ) { } } }
tr	2	@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Vector < SerializableObject > deSerList = new Vector < SerializableObject > ( ) ; if ( "writeObj" . equals ( method . getName ( ) ) ) { Object obj = args [ 0 ] ; serializer . serialize ( pWriter , obj ) ; } else if ( "readObj" . equals ( method . getName ( ) ) ) { deSerList = deSerializer . deSerialize ( ) ; return deSerList ; } return null ; }
tr	9X	public static void writeToFile ( long [ ] sizes , int [ ] nthreads , double [ ] [ ] results , String file ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( System . getProperty ( "os.name" ) + " " + System . getProperty ( "os.arch" ) + " " + System . getProperty ( "os.version" ) ) ; writer . newLine ( ) ; writer . write ( System . getProperty ( "java.vendor" ) + " " + System . getProperty ( "java.version" ) ) ; writer . newLine ( ) ; writer . write ( "Available processors (cores): " + Runtime . getRuntime ( ) . availableProcessors ( ) ) ; writer . newLine ( ) ; writer . write ( "Total memory (bytes): " + Runtime . getRuntime ( ) . totalMemory ( ) ) ; writer . newLine ( ) ; writer . write ( "Number of threads: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { if ( th < nthreads . length - 1 ) { writer . write ( nthreads [ th ] + " " ) ; } else { writer . write ( nthreads [ nthreads . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Sizes: {" ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( sizes [ i ] + " " ) ; } else { writer . write ( sizes [ sizes . length - 1 ] + "}" ) ; } } writer . newLine ( ) ; writer . write ( "Timings: {" ) ; for ( int th = 0 ; th < nthreads . length ; th ++ ) { writer . write ( "{" ) ; if ( th < nthreads . length - 1 ) { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "} " ) ; } } writer . newLine ( ) ; } else { for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( i < sizes . length - 1 ) { writer . write ( results [ th ] [ i ] + " " ) ; } else { writer . write ( results [ th ] [ i ] + "}}" ) ; } } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
tr	3	private static boolean iguales ( Nodo nodo1 , Nodo nodo2 ) { if ( nodo1 == null && nodo2 == null ) return true ; if ( nodo1 . equals ( nodo2 ) ) return iguales ( nodo1 . getSiguiente ( ) , nodo2 . getSiguiente ( ) ) ; return false ; }
tr	1	public SimulatorView ( Simulator sim ) { super ( sim ) ; colors = new LinkedHashMap < class < ? > , Color > ( ) ; fieldView = new FieldView ( 100 , 100 ) ; }
tr	5	public static < T > boolean bfs ( BinaryTreeNode < T > root , T target ) { if ( root == null ) { return false ; } LinkedList < BinaryTreeNode > list = new LinkedList < BinaryTreeNode > ( ) ; list . add ( root ) ; BinaryTreeNode < Integer > current ; while ( list . size ( ) > 0 ) { current = list . remove ( ) ; if ( target . equals ( current . data ) ) { return true ; } if ( current . left != null ) { list . add ( current . left ) ; } if ( current . right != null ) { list . add ( current . right ) ; } } return false ; }
tr	8	private void checkForTermination ( int timezone ) { TerminationCounter counterT = terminationCounters . get ( timezone ) ; logger . info ( "Balance: " + counterT . getSentMessages ( ) + " / " + counterT . getReceivedMessages ( ) ) ; if ( counterT . isBalanced ( ) && counterT . isNotEmpty ( ) ) { TerminationCounter counterPrev = terminationCounters . get ( timezone - 1 ) ; TerminationCounter counterNext = terminationCounters . get ( timezone + 1 ) ; if ( counterPrev != null ) { if ( counterPrev . isBalanced ( ) && counterPrev . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } else { if ( counterNext != null && counterNext . isBalanced ( ) && counterNext . isNotEmpty ( ) ) { keepRunning = false ; logger . info ( "Termination reached! Messages sent: " + counterT . getSentMessages ( ) + " Messages received: " + counterT . getReceivedMessages ( ) ) ; } } } } }
tr	5	public MyPopulation ( int populationSize , int dataSize , IMyFitnessTestFunction < U > fitnessTester , IMyRandomDataFunction < U > rFunc ) throws Exception { if ( populationSize < 4 ) { throw new Exception ( "population size should be 4 or greater" ) ; } if ( dataSize < MyIndividual . MIN_DATA_SIZE ) { throw new Exception ( "data size should be 4 or greater" ) ; } if ( fitnessTester == null ) { throw new Exception ( "fitnessTester function Cannot be null" ) ; } population = new ArrayList < > ( ) ; try { for ( int i = 0 ; i < populationSize ; i ++ ) { population . add ( new MyIndividual ( dataSize , true , 0.99 , true , fitnessTester , rFunc ) ) ; } } catch ( Exception e ) { System . err . println ( "ex in individual's constructor:" + e . getMessage ( ) ) ; } }
tr	9X	public double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 >= y0 ) { if ( y0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 >= z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 *= t0 ; n0 = t0 * t0 * . ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 *= t1 ; n1 = t1 * t1 * . ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 *= t2 ; n2 = t2 * t2 * . ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 *= t3 ; n3 = t3 * t3 * . ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
tr	0	public String getFieldName ( ) { return _fieldName ; }
tr	3	@ Override public void printOptions ( ) { if ( getSuccessors ( ) == null || getSuccessors ( ) . size ( ) == 0 ) { return ; } Printer . print ( Settings_Output . OUT_OPTION_HEAD , "Please choose an option" ) ; Integer i = 0 ; for ( final IAction action : getSuccessors ( ) ) { Printer . print ( Settings_Output . OUT_OPTION , i , action . getName ( ) , action . getDescription ( ) ) ; i ++ ; } }
tr	0	@ XmlElementDecl ( namespace = "" , name = "xRequest" ) public JAXBElement < BigInteger > createXRequest ( BigInteger value ) { return new JAXBElement < BigInteger > ( _XRequest_QNAME , BigInteger . class , null , value ) ; }
tr	4	@ Override protected void imprimirTabuleiro ( TabuleiroXadrez tabuleiro ) { imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; for ( int linha = 8 ; linha >= 1 ; linha -- ) { imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimir ( linha + " " ) ; for ( int coluna = 1 ; coluna <= 8 ; coluna ++ ) { imprimir ( "|" ) ; Peca peca = tabuleiro . espiarPeca ( new Posicao ( coluna , linha ) ) ; imprimir ( PecaToString ( peca ) ) ; if ( peca == null ) imprimir ( "       " ) ; else if ( peca . getCorJogador ( ) == TipoCorJogador . BRANCO ) imprimir ( " branco" ) ; else imprimir ( " preto " ) ; } imprimirLinha ( "| " + linha ) ; } imprimirLinha ( "  -------------------------------------------------------------------------" ) ; imprimirLinha ( "      1        2        3        4        5        6        7        8     " ) ; }
tr	3	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { PrintWriter out = response . getWriter ( ) ; request . setCharacterEncoding ( "utf-8" ) ; boolean r = false ; boolean e = false ; response . setContentType ( "text/html;charset=UTF-8" ) ; search com = new search ( ) ; String id [ ] = request . getParameterValues ( "id" ) ; String docTellId [ ] = request . getParameterValues ( "docTellId" ) ; String docId [ ] = request . getParameterValues ( "docId" ) ; String docTellContent [ ] = request . getParameterValues ( "docTellContent" ) ; String excuteDate [ ] = request . getParameterValues ( "excuteDate" ) ; String excuteId [ ] = request . getParameterValues ( "excuteId" ) ; String docTellType [ ] = request . getParameterValues ( "docTellType" ) ; String stopDate [ ] = request . getParameterValues ( "stopDate" ) ; String patientId = request . getParameter ( "patientId" ) ; for ( int i = 0 ; i < docTellId . length ; i ++ ) { r = com . docTellFind ( id [ i ] ) ; if ( r ) { e = com . docTellUpdate ( id [ i ] , docTellContent [ i ] , excuteDate [ i ] , excuteId [ i ] , docTellType [ i ] , stopDate [ i ] ) ; } else { System . out . println ( docTellId [ i ] ) ; e = com . docTellInsert ( id [ i ] , docTellId [ i ] , docId [ i ] , docTellContent [ i ] , excuteDate [ i ] , excuteId [ i ] , docTellType [ i ] , stopDate [ i ] , patientId ) ; } } if ( e ) { response . sendRedirect ( request . getContextPath ( ) + "/wardManagement/patientList.jsp" ) ; } else { out . print ( "\u6CE8\u518C\u5931\u8D25" ) ; return ; } }
tr	6	public boolean shellCollideCheck ( Shell shell ) { if ( deadTime != 0 ) return false ; float xD = shell . x - x ; float yD = shell . y - y ; if ( xD > - 16 && xD < 16 ) { if ( yD > - height && yD < shell . height ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_KICK ] , this , 1 , 1 , 1 ) ; dead = true ; xa = 0 ; ya = 1 ; deadTime = 100 ; if ( world . recorder != null ) world . recorder . shellKillRecord ( this ) ; return true ; } } return false ; }
tr	6	public void addEdge ( int vi , int vj ) { Vertex vFrom = null ; Vertex vTo = null ; for ( Vertex v : vs ) { if ( v . vertex == vi ) { vFrom = v ; } if ( v . vertex == vj ) { vTo = v ; } } if ( vFrom == null ) { vFrom = new Vertex ( vi ) ; vs . add ( vFrom ) ; } if ( vi != vj ) { if ( vTo == null ) { vTo = new Vertex ( vj ) ; vs . add ( vTo ) ; } vFrom . adjacent . add ( vTo ) ; vTo . adjacent . add ( vFrom ) ; } else { vFrom . adjacent . add ( vFrom ) ; } }
tr	0	public long getTimeToWait ( ) { return this . timeToWait ; }
tr	3	@ Override public void doAction ( Player player , Grid grid ) throws InvalidActionException { if ( player . getRemainingTurns ( ) <= 0 ) throw new InvalidActionException ( "The player has no turns left!" ) ; Position currentPos = player . getPosition ( ) ; Position newPos = new Position ( currentPos . getxCoordinate ( ) + 1 , currentPos . getyCoordinate ( ) - 1 ) ; if ( ! canMoveToPosition ( player , grid , newPos ) || ! canMoveDiagonal ( grid , newPos ) ) throw new InvalidActionException ( "The player can't move to the desired position!" ) ; player . setPosition ( newPos ) ; player . getLightTrail ( ) . addPosition ( currentPos ) ; player . decrementTurn ( ) ; }
tr	2	@ Override public String toString ( ) { final StringBuilder bld = new StringBuilder ( this . getClass ( ) . getSimpleName ( ) ) . append ( ": " ) ; if ( ! PRIMITIVES . contains ( this . name ) ) { bld . append ( this . packageName != null ? this . packageName : "[default package]" ) . append ( "." ) ; } return bld . append ( this . name ) . toString ( ) ; }
tr	3	static float sqrt ( float n ) { float low = 0 , high = n ; float mid = ( low + high ) / 2 ; while ( Math . abs ( mid * mid - n ) > 0.00001 ) { if ( mid * mid < n ) low = mid ; else if ( mid * mid > n ) high = mid ; mid = ( low + high ) / 2 ; } return mid ; }
tr	4	private void jButtonCheckRoomsActionPerformed ( java . awt . event . ActionEvent evt ) { dflRooms . removeAllElements ( ) ; if ( "" . equals ( jXDatePickercheckRoomArrival . getEditor ( ) . getText ( ) ) || "" . equals ( jXDatePickercheckRoomDeparture . getEditor ( ) . getText ( ) ) ) { JOptionPane . showMessageDialog ( rootPane , "Make sure both arrival and departure date are entered and in the correct format" ) ; } else { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" ) ; jXDatePickercheckRoomArrival . setFormats ( dateFormat ) ; jXDatePickercheckRoomDeparture . setFormats ( dateFormat ) ; String arrival = dateFormat . format ( jXDatePickercheckRoomArrival . getDate ( ) ) . toString ( ) ; String departure = dateFormat . format ( jXDatePickercheckRoomDeparture . getDate ( ) ) . toString ( ) ; r = con . getRoomsList ( arrival , departure ) ; if ( r != null ) { for ( int i = 0 ; i < r . size ( ) ; i ++ ) { dflRooms . addElement ( r . get ( i ) . toString ( ) ) ; } } else { Statuslabel . setText ( "Could not get Rooms" ) ; } con . resetRooms ( ) ; } }
tr	9X	public static GregorianCalendar lireDate ( String date ) { boolean ok = false ; String [ ] champsDate ; int jour = 1 ; int mois = 0 ; int an = 0 ; GregorianCalendar dateSaisie = null ; champsDate = date . split ( "/" ) ; ok = true ; if ( champsDate . length >= 1 ) { try { mois = Integer . parseInt ( champsDate [ 0 ] ) ; if ( ( mois < 1 ) || ( mois > 12 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { mois = moisCourant ( ) ; } if ( champsDate . length == 2 ) { try { an = Integer . parseInt ( champsDate [ 1 ] ) ; if ( ( an < 1900 ) || ( an > 2100 ) ) { ok = false ; } } catch ( Exception e ) { ok = false ; } } else { an = anneeCourante ( ) ; } if ( ok ) { dateSaisie = new GregorianCalendar ( an , mois - 1 , jour ) ; return dateSaisie ; } else { return null ; } }
tr	1	public void print ( TreeNode root ) { if ( root == null ) { System . out . print ( " # " ) ; return ; } else { System . out . print ( " " + root . val + " " ) ; } print ( root . left ) ; print ( root . right ) ; }
tr	7	@ Deprecated static List < Object > graphToRDF ( Map < String , Object > graph , UniqueNamer namer ) { final List < Object > rval = new ArrayList < Object > ( ) ; for ( final String id : graph . keySet ( ) ) { final Map < String , Object > node = ( Map < String , Object > ) graph . get ( id ) ; final List < String > properties = new ArrayList < String > ( node . keySet ( ) ) ; Collections . sort ( properties ) ; for ( String property : properties ) { final Object items = node . get ( property ) ; if ( "@type" . equals ( property ) ) { property = RDF_TYPE ; } else if ( isKeyword ( property ) ) { continue ; } for ( final Object item : ( List < Object > ) items ) { final Map < String , Object > subject = new LinkedHashMap < String , Object > ( ) ; if ( id . indexOf ( "_:" ) == 0 ) { subject . put ( "type" , "blank node" ) ; subject . put ( "value" , namer . getName ( id ) ) ; } else { subject . put ( "type" , "IRI" ) ; subject . put ( "value" , id ) ; } final Map < String , Object > predicate = new LinkedHashMap < String , Object > ( ) ; predicate . put ( "type" , "IRI" ) ; predicate . put ( "value" , property ) ; if ( isList ( item ) ) { listToRDF ( ( List < Object > ) ( ( Map < String , Object > ) item ) . get ( "@list" ) , namer , subject , predicate , rval ) ; } else { final Object object = objectToRDF ( item , namer ) ; final Map < String , Object > tmp = new LinkedHashMap < String , Object > ( ) ; tmp . put ( "subject" , subject ) ; tmp . put ( "predicate" , predicate ) ; tmp . put ( "object" , object ) ; rval . add ( tmp ) ; } } } } return rval ; }
tr	5	@ SuppressWarnings ( "unchecked" ) public static void main ( String args [ ] ) { Repl < ? , ? > repl ; if ( args . length == 0 ) { repl = new Repl < > ( FractalEvaluator . class ) ; repl . loop ( ) ; } else { try { repl = new Repl ( class . forName ( args [ 0 ] ) ) ; ArrayList < String > fileList = new ArrayList < > ( ) ; for ( int i = 1 ; i < args . length ; i ++ ) { fileList . add ( args [ i ] ) ; } repl . visitFiles ( fileList ) ; repl . loop ( ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println ( cnfe . getMessage ( ) ) ; System . exit ( 1 ) ; } } }
tr	8	private static boolean busqueda ( int nt , String extra , String tipo , int pos ) { if ( pos < planes . size ( ) ) { Plan p = planes . get ( pos ) ; if ( p . getNumTel ( ) == nt ) return true ; if ( p instanceof PlanIPhone && tipo . equals ( "IPHONE" ) ) { if ( extra . equals ( ( ( PlanIPhone ) p ) . getEmail ( ) ) ) return true ; } if ( p instanceof PlanBlackBerry && tipo . equals ( "BLACKBERRY" ) ) { if ( extra . equals ( ( ( PlanBlackBerry ) p ) . getPin ( ) ) ) return true ; } return busqueda ( nt , extra , tipo , pos + 1 ) ; } return false ; }
tr	9X	private Object readLiteral ( ) throws JSONException { String literal = nextToInternal ( "{}[]/\\: =;# \t\f" ) ; if ( literal . length ( ) == 0 ) { throw syntaxError ( "Expected literal value" ) ; } else if ( "null" . equalsIgnoreCase ( literal ) ) { return JSONObject . null ; } else if ( "true" . equalsIgnoreCase ( literal ) ) { return boolean . true ; } else if ( "false" . equalsIgnoreCase ( literal ) ) { return boolean . false ; } if ( literal . indexOf ( . ) == - 1 ) { int base = 10 ; String number = literal ; if ( number . startsWith ( "0x" ) || number . startsWith ( "0X" ) ) { number = number . substring ( 2 ) ; base = 16 ; } else if ( number . startsWith ( "0" ) && number . length ( ) > 1 ) { number = number . substring ( 1 ) ; base = 8 ; } try { long longValue = long . parseLong ( number , base ) ; if ( longValue <= Integer . MAX_VALUE && longValue >= Integer . MIN_VALUE ) { return ( int ) longValue ; } else { return longValue ; } } catch ( NumberFormatException e ) { } } try { return double . valueOf ( literal ) ; } catch ( NumberFormatException ignored ) { } return new String ( literal ) ; }
tr	6	public boolean equals ( Grade g ) { if ( ! this . assignmentId . equals ( g . getAssignmentId ( ) ) ) { return false ; } else if ( ! this . comments . equals ( g . getComments ( ) ) ) { return false ; } else if ( this . courseId != g . getCourseId ( ) ) { return false ; } else if ( this . ptsEarn != g . getPointsEarned ( ) ) { return false ; } else if ( this . ptsPoss != g . getPointsPossible ( ) ) { return false ; } else if ( ! this . title . equals ( g . getTitle ( ) ) ) { return false ; } else { return true ; } }
tr	4	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
tr	1	public void removeAll ( ) { for ( int i = getRowCount ( ) - 1 ; i >= 0 ; i -- ) { removeRow ( i ) ; } }
tr	2	@ Override public void onMoveTick ( int x , int y , Game game ) { SinglePlayerGame spg = ( SinglePlayerGame ) game ; if ( filterByID ( spg . getSquareNeighbors ( x , y , 1 ) , juggernaut . id ) . isEmpty ( ) ) { Location loc = spg . getFirstSquareNeighborLocation ( x , y , 2 , zombie . id ) ; spg . moveEntity ( x , y , loc == null ? Location . wander ( x , y , 1 ) : Location . away ( x , y , loc , 2 ) ) ; } }
tr	9X	public static ArrayList < ArrayList < Integer >> fourSum ( int [ ] num , int target ) { ArrayList < ArrayList < Integer >> result = new ArrayList < ArrayList < Integer >> ( ) ; Arrays . sort ( num ) ; for ( int i = 0 ; i <= num . length - 4 ; i ++ ) { if ( i > 0 && num [ i ] == num [ i - 1 ] ) continue ; for ( int j = i + 1 ; j <= num . length - 3 ; j ++ ) { if ( j > i + 1 && num [ j ] == num [ j - 1 ] ) continue ; int l = j + 1 ; int r = num . length - 1 ; while ( l < r ) { int sum = num [ i ] + num [ j ] + num [ l ] + num [ r ] - target ; if ( sum > 0 ) { r -- ; } else if ( sum < 0 ) { l ++ ; } else { ArrayList < Integer > newList = new ArrayList < Integer > ( ) ; newList . add ( num [ i ] ) ; newList . add ( num [ j ] ) ; newList . add ( num [ l ] ) ; newList . add ( num [ r ] ) ; result . add ( newList ) ; l ++ ; r -- ; while ( l < r && num [ l ] == num [ l - 1 ] ) { l ++ ; } while ( l < r && num [ r ] == num [ r + 1 ] ) { r -- ; } } } } } return result ; }
tr	4	public Questionnaire getQuestionnaireById ( long id ) { PreparedStatement statement = null ; ResultSet rs = null ; Connection connection = null ; Questionnaire questionnaire = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Retrieving questionnaire " + id + "..." ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( SELECT_QUESTIONNAIRE ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( SELECT_QUESTIONNAIRE ) ; statement . setLong ( 1 , id ) ; rs = statement . executeQuery ( ) ; if ( rs . next ( ) ) { questionnaire = fillQuestionnaire ( rs ) ; } } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( rs , statement , connection ) ; } return questionnaire ; }
tr	6	private List < Student > parse ( final Document doc ) { final List < Student > students = new Vector < Student > ( ) ; if ( doc == null ) { return students ; } final Element root = doc . getDocumentElement ( ) ; final NodeList nodeStudents = root . getChildNodes ( ) ; if ( nodeStudents != null ) { if ( nodeStudents . getLength ( ) != 0 ) { for ( int i = 0 ; i < nodeStudents . getLength ( ) ; ++ i ) { final Node nodeStudent = nodeStudents . item ( i ) ; if ( nodeStudent != null ) { if ( nodeStudent . getNodeType ( ) == Node . ELEMENT_NODE ) { final Student student = parseStudent ( nodeStudent ) ; students . add ( student ) ; } } } } } return students ; }
tr	6	public void scores ( Player player ) { switch ( player . getScore ( ) ) { case LOVE : player . setScore ( FIFTEEN ) ; break ; case FIFTEEN : player . setScore ( THIRTY ) ; break ; case THIRTY : determineFortyOrDeuce ( player ) ; break ; case DEUCE : determineAdvantageOrDeuce ( player ) ; break ; case FORTY : case ADVANTAGE : player . setScore ( WIN ) ; } }
tr	3	public static String formatInt ( long number ) { String num = number + "" ; String out = "" ; String . = "." ; int cnt = 1 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { out = num . charAt ( i ) + out ; if ( cnt % 3 == 0 && i > 0 ) out = . + out ; cnt ++ ; } return out ; }
tr	1	private void drawCheckerboard ( Graphics2D g ) { Color backupColor = g . getColor ( ) ; Stroke backupStroke = g . getStroke ( ) ; g . setColor ( Color . RED ) ; g . setStroke ( new BasicStroke ( 1.0f ) ) ; g . drawRect ( 0 , 0 , _canvasBackground . getWidth ( ) - 1 , _canvasBackground . getHeight ( ) - 1 ) ; for ( int i = 0 ; i < _imageList . size ( ) ; i ++ ) { IPLNode node = _imageList . get ( i ) ; g . drawRect ( node . getX ( ) , node . getY ( ) , node . getScaleWidth ( ) , node . getScaleHeight ( ) ) ; } g . setColor ( backupColor ) ; g . setStroke ( backupStroke ) ; }
tr	4	public Klas getKlas ( long klas_id ) { Klas klas = null ; try { PreparedStatement klasStatement = manager . prepareStatement ( "SELECT * FROM klassen WHERE id = ?" ) ; klasStatement . setLong ( 1 , klas_id ) ; ResultSet klasResult = klasStatement . executeQuery ( ) ; if ( klasResult . next ( ) ) { klas = new Klas ( klasResult . getLong ( 1 ) , klasResult . getString ( 2 ) ) ; PreparedStatement leerlingenKlas = manager . prepareStatement ( "SELECT leerling_id FROM leerling_klas WHERE klas_id = ?" ) ; leerlingenKlas . setLong ( 1 , klas_id ) ; ResultSet leerlingIds = leerlingenKlas . executeQuery ( ) ; while ( leerlingIds . next ( ) ) { klas . addStudent ( getUser ( leerlingIds . getLong ( 1 ) ) ) ; } for ( Vak vak : getVakkenVanKlas ( klas_id ) ) { klas . addVak ( vak ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return klas ; }
tr	6	public void mouseClicked ( MouseEvent me ) { try { if ( me . getSource ( ) == jb_connexion ) { login = jtf_login . getText ( ) ; password = String . valueOf ( jpf_password . getPassword ( ) ) ; System . out . println ( "Email : " + login ) ; System . out . println ( "MotDePasse : " + password ) ; User u = null ; Connection co = bs . getConnection ( ) ; System . out . println ( "avant IF" ) ; if ( User . checkPresence ( bs , login , password ) ) { System . out . println ( "debut IF" ) ; u = User . findByLogs ( login , password , bs ) ; groupe = UserType . findById ( u . getId_ut ( ) , bs ) . getName_ut ( ) ; System . out . println ( "OK : " + groupe ) ; afficherMenuPrincipal ( ) ; setResizable ( true ) ; setExtendedState ( MAXIMIZED_BOTH ) ; } else { System . out . println ( "NON OK" ) ; } } if ( me . getSource ( ) == jb_mdp_oublie ) { if ( SwingUtilities . isLeftMouseButton ( me ) ) { } if ( SwingUtilities . isRightMouseButton ( me ) ) { } } } catch ( Exception e ) { System . out . println ( "Exception" ) ; e . printStackTrace ( ) ; } }
tr	0	public UserDaoImpl ( final java . sql . Connection userConn ) { this . userConn = userConn ; }
tr	4	@ Override public boolean hasNext ( ) { if ( end ) { return false ; } if ( next != null ) { return true ; } peeked = true ; while ( iterator . hasNext ( ) ) { final T n = iterator . next ( ) ; if ( predicate . evaluate ( n ) ) { next = n ; return true ; } } end = true ; return false ; }
tr	3	public void switchFullscreen ( ) { if ( fullscreen == false ) { throw new IllegalStateException ( "This window not supports fullscreen mode!" ) ; } if ( state == WindowState . WINDOW ) { Rectangle rc = this . getBounds ( ) ; boolean resizable = this . isResizable ( ) ; this . properties = new FrameProperties ( getX ( ) , getY ( ) , ( int ) rc . getWidth ( ) , ( int ) rc . getHeight ( ) , resizable ) ; } if ( device . getFullScreenWindow ( ) == null ) { FrameProperties properties = new FrameProperties ( 0 , 0 , getFullWidth ( ) , getFullHeight ( ) , false ) ; this . setExtendedState ( JFrame . MAXIMIZED_BOTH ) ; this . state = WindowState . FULLSCREEN ; properties . append ( this ) ; device . setFullScreenWindow ( this ) ; updateDisplay ( ) ; return ; } device . setFullScreenWindow ( null ) ; this . setExtendedState ( JFrame . NORMAL ) ; this . state = WindowState . WINDOW ; properties . append ( this ) ; updateDisplay ( ) ; }
tr	2	public JSONArray ( Collection collection ) { this . myArrayList = new ArrayList ( ) ; if ( collection != null ) { Iterator iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { this . myArrayList . add ( JSONObject . wrap ( iter . next ( ) ) ) ; } } }
tr	3	private void createNewKeyWithLoad ( BigInteger value , int load ) { if ( this . keyMode == KeyMode . COMPLEX_KEY ) { if ( ! this . allKeys . add ( new ComplexKey ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; } else if ( ! this . allKeys . add ( new Key ( value , load ) ) ) throw new RuntimeException ( "Key was in treeset!" ) ; }
tr	0	public void actionPerformed ( ActionEvent event ) { Main . newSet ( ) ; }
tr	8	@ Override public boolean equals ( Object cidades ) { if ( cidades == null ) { return false ; } if ( getClass ( ) != cidades . getClass ( ) ) { return false ; } final Cidades other = ( Cidades ) cidades ; if ( ( this . nome == null ) ? ( other . nome != null ) : ! this . nome . equals ( other . nome ) ) { return false ; } if ( ( this . uf == null ) ? ( other . uf != null ) : ! this . uf . equals ( other . uf ) ) { return false ; } if ( ( this . ddd == null ) ? ( other . ddd != null ) : ! this . ddd . equals ( other . ddd ) ) { return false ; } return true ; }
tr	1	@ Override public void windowClosing ( WindowEvent e ) { if ( JOptionPane . showConfirmDialog ( frame , "Are you sure to close this window?" , "Really Closing?" , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) == JOptionPane . YES_OPTION ) { btn . setEnabled ( true ) ; } }
tr	8	public Sprite ( StreamLoader streamLoader , String s , int i ) { Stream stream = new Stream ( streamLoader . getDataForName ( s + ".dat" ) ) ; Stream stream_1 = new Stream ( streamLoader . getDataForName ( "index.dat" ) ) ; stream_1 . currentOffset = stream . readUnsignedWord ( ) ; anInt1444 = stream_1 . readUnsignedWord ( ) ; anInt1445 = stream_1 . readUnsignedWord ( ) ; int j = stream_1 . readUnsignedByte ( ) ; int ai [ ] = new int [ j ] ; for ( int k = 0 ; k < j - 1 ; k ++ ) { ai [ k + 1 ] = stream_1 . read3Bytes ( ) ; if ( ai [ k + 1 ] == 0 ) ai [ k + 1 ] = 1 ; } for ( int l = 0 ; l < i ; l ++ ) { stream_1 . currentOffset += 2 ; stream . currentOffset += stream_1 . readUnsignedWord ( ) * stream_1 . readUnsignedWord ( ) ; stream_1 . currentOffset ++ ; } anInt1442 = stream_1 . readUnsignedByte ( ) ; anInt1443 = stream_1 . readUnsignedByte ( ) ; myWidth = stream_1 . readUnsignedWord ( ) ; myHeight = stream_1 . readUnsignedWord ( ) ; int i1 = stream_1 . readUnsignedByte ( ) ; int j1 = myWidth * myHeight ; myPixels = new int [ j1 ] ; if ( i1 == 0 ) { for ( int k1 = 0 ; k1 < j1 ; k1 ++ ) myPixels [ k1 ] = ai [ stream . readUnsignedByte ( ) ] ; setTransparency ( 255 , 0 , 255 ) ; return ; } if ( i1 == 1 ) { for ( int l1 = 0 ; l1 < myWidth ; l1 ++ ) { for ( int i2 = 0 ; i2 < myHeight ; i2 ++ ) myPixels [ l1 + i2 * myWidth ] = ai [ stream . readUnsignedByte ( ) ] ; } } setTransparency ( 255 , 0 , 255 ) ; }
tr	2	public void run ( ) { for ( String name : names ) { Apple apple = new Apple ( name ) ; dispatcher . dataReceived ( apple ) ; System . out . println ( "Built apple: " + apple ) ; try { Thread . sleep ( 900 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } dispatcher . dataReceived ( new Key ( all ( Apple . class ) ) ) ; }
tr	0	public boolean isSituacao ( ) { return situacao ; }
tr	6	private void initPanels ( ) { if ( attribs == null ) { attribs = new MyInternalFrame ( this , 1 ) ; jDesktopPane1 . add ( attribs , new Integer ( 10 ) ) ; } try { attribs . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } attribs . setVisible ( true ) ; if ( tools == null ) { tools = new MyInternalFrame ( this , 0 ) ; jDesktopPane1 . add ( tools , new Integer ( 10 ) ) ; } tools . setVisible ( true ) ; try { tools . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } if ( opers == null ) { opers = new MyInternalFrame ( this , 2 ) ; jDesktopPane1 . add ( opers , new Integer ( 10 ) ) ; } try { opers . setIcon ( true ) ; } catch ( java . beans . PropertyVetoException e ) { } opers . setVisible ( true ) ; }
tr	4	private int findPlaceholderEndIndex ( CharSequence buf , int startIndex ) { int index = startIndex + this . placeholderPrefix . length ( ) ; int withinNestedPlaceholder = 0 ; while ( index < buf . length ( ) ) { if ( StringUtils . substringMatch ( buf , index , this . placeholderSuffix ) ) { if ( withinNestedPlaceholder > 0 ) { withinNestedPlaceholder -- ; index = index + this . placeholderSuffix . length ( ) ; } else { return index ; } } else if ( StringUtils . substringMatch ( buf , index , this . simplePrefix ) ) { withinNestedPlaceholder ++ ; index = index + this . simplePrefix . length ( ) ; } else { index ++ ; } } return - 1 ; }
tr	0	public void setPrpMoaTipo ( String prpMoaTipo ) { this . prpMoaTipo = prpMoaTipo ; }
tr	1	int BitTreeDecode ( int [ ] paramArrayOfInt , int paramInt1 , int paramInt2 ) throws IOException { int i = 1 ; for ( int j = paramInt2 ; j > 0 ; j -- ) { i = i + i + BitDecode ( paramArrayOfInt , paramInt1 + i ) ; } return i - ( 1 << paramInt2 ) ; }
tr	8	@ Override public void transform ( double [ ] src , double [ ] dst ) { for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i ] ; temp2 [ 3 ] = 1 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i ] += matrix [ i ] [ j ] * temp2 [ j ] ; } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { copy [ i ] [ j ] = matrix [ i ] [ j ] ; } } Invert . invert ( copy , inverseMatrix ) ; transpose ( inverseMatrix , inverseMatrixTranspose ) ; for ( int i = 0 ; i < 3 ; i ++ ) temp2 [ i ] = src [ i + 3 ] ; temp2 [ 3 ] = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { dst [ i + 3 ] = 0 ; for ( int j = 0 ; j < 4 ; j ++ ) { dst [ i + 3 ] += inverseMatrixTranspose [ i ] [ j ] * temp2 [ j ] ; } } }
tr	6	public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
tr	3	private static boolean hasAccess ( IGraph g , IGraph access ) { for ( int i = 0 ; i < g . size ( ) ; i ++ ) { for ( int j = 0 ; j < access . size ( ) ; j ++ ) { String a = g . get ( i ) . getName ( ) ; String b = access . get ( j ) . getName ( ) ; if ( a . equals ( b ) ) return true ; } } return false ; }
tr	5	public Iterable < Position < E >> findRange ( E minValue , E maxValue ) { List < Position < E >> l = new ArrayList < > ( ) ; List < Position < E >> todas = ( List < Position < E >> ) this . positions ( ) ; for ( Position < E > pos : todas ) { E curValue = pos . element ( ) ; int compMin = findComparator . compare ( curValue , minValue ) ; int compMax = findComparator . compare ( curValue , maxValue ) ; boolean overMin = ( ( compMin == 0 ) || ( compMin == 1 ) ) ; boolean underMax = ( ( compMax == 0 ) || ( compMax == - 1 ) ) ; if ( overMin && underMax ) { l . add ( pos ) ; } } return l ; }
tr	1	@ Override public void run ( ) { try { instance . start ( ) ; } catch ( InterruptedException e ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + " interrupted" ) ; } }
tr	3	private Element findNext ( ) { if ( next == null ) { while ( i < length ) { Node node = elements . item ( i ++ ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { next = ( Element ) node ; break ; } } } return next ; }
tr	3	@ Override public int storeProject ( String name , String description ) { Connection conn = null ; StringBuffer query = new StringBuffer ( ) ; int newProjectId = 0 ; try { conn = getConnection ( ) ; query . append ( "INSERT INTO " ) . append ( super . getPrimaryTableName ( ) ) . append ( " (name  description)" ) . append ( " VALUES " ) . append ( "('" + name + "'  '" + description + "')" ) ; ResultSet rs = executeUpdateGetKeys ( conn , query . toString ( ) ) ; if ( rs . next ( ) ) { newProjectId = rs . getInt ( 1 ) ; } rs . getStatement ( ) . close ( ) ; rs . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( conn != null ) { close ( conn ) ; } } return newProjectId ; }
tr	5	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Schedule schedule = ( Schedule ) o ; if ( id != schedule . id ) return false ; if ( seqNumber != schedule . seqNumber ) return false ; return true ; }
tr	4	public void elsolve ( final double [ ] b , final double [ ] y ) { int i , j ; double sum ; if ( b . length != n || y . length != n ) throw new IllegalArgumentException ( "bad lengths" ) ; for ( i = 0 ; i < n ; i ++ ) { for ( sum = b [ i ] , j = 0 ; j < i ; j ++ ) sum -= el [ i ] [ j ] * y [ j ] ; y [ i ] = sum / el [ i ] [ i ] ; } }
tr	4	private void showInfo ( ) { try { FileReader file = new FileReader ( "data/info.txt" ) ; BufferedReader buff = new BufferedReader ( file ) ; boolean eof = false ; while ( ! eof ) { String line = buff . readLine ( ) ; if ( line != null ) { infoArea . append ( "\n" + line ) ; } else { eof = true ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	6	private List < Next > nextStates ( State < C > state ) { int m ; List < Transition > nexts = new ArrayList < > ( _transitions . get ( state ) ) ; List < Next > result = new ArrayList < > ( ) ; int offset = 0 ; while ( true ) { m = nextDeadLine ( nexts , offset ) ; if ( m != Integer . MAX_VALUE ) { result . add ( selectNextState ( m - offset , m , nexts ) ) ; offset = m ; } else { switch ( nexts . size ( ) ) { case 0 : throw new RuntimeException ( "Automata has no default transition for node: " + state ) ; case 1 : Transition target = nexts . get ( 0 ) ; Next timeout = new Next ( target . timeout ) ; timeout . add ( target . state , target . predicate ) ; result . add ( timeout ) ; break ; default : Next infinites = new Next ( INFINITY ) ; for ( Transition t : nexts ) { if ( t . timeout != INFINITY ) throw new RuntimeException ( "Cannot mix timeout alternative and infinite guards  neither having more than a single timeout alternative ('" + state + "': " + nexts + ")" ) ; infinites . add ( t . state , t . predicate ) ; } result . add ( infinites ) ; } break ; } } return result ; }
tr	8	public void changePanel ( JPanel panel ) { this . getContentPane ( ) . removeAll ( ) ; if ( panel != loginPanel ) { this . add ( actionBar ) ; if ( panel == connectionPanel ) { connectionPanel . initialize ( ) ; } else if ( panel == directoryListPanel ) { directoryListPanel . initialize ( ) ; } else if ( panel == fileListPanel ) { fileListPanel . initialize ( ) ; } } else { loginPanel . initialize ( ) ; actionBar . initialize ( ) ; } if ( ! actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getBackStack ( ) . push ( currentPanel ) ; } else if ( actionBar . isBackBtnPress ( ) && currentPanel != panel ) { actionBar . getForwardStack ( ) . push ( currentPanel ) ; } currentPanel = panel ; this . add ( panel ) ; this . repaint ( ) ; }
tr	5	private void calculateMissing ( ) { if ( totalBytes > - 1 ) { if ( usedBytes > - 1 && freeBytes == - 1 ) { freeBytes = totalBytes - usedBytes ; } else if ( usedBytes == - 1 && freeBytes > - 1 ) { usedBytes = totalBytes - freeBytes ; } } }
tr	8	private boolean r_perfective_gerund ( ) { int among_var ; int v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 9 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : lab0 : do { v_1 = limit - cursor ; lab1 : do { if ( ! ( eq_s_b ( 1 , "\u0430" ) ) ) { break lab1 ; } break lab0 ; } while ( false ) ; cursor = limit - v_1 ; if ( ! ( eq_s_b ( 1 , "\u044F" ) ) ) { return false ; } } while ( false ) ; slice_del ( ) ; break ; case 2 : slice_del ( ) ; break ; } return true ; }
tr	1	private char peekNextChar ( ) { if ( pos < ( input . length ( ) - 1 ) ) { return input . charAt ( pos + 1 ) ; } else { return 0 ; } }
tr	4	private Collection < Player > getPlayers ( File matchfile ) { String [ ] playernames = getValue ( matchfile , "players" ) . split ( " " ) ; for ( int i = 0 ; i < playernames . length ; i ++ ) { playernames [ i ] = playernames [ i ] . trim ( ) ; } LinkedList < Player > result = new LinkedList < Player > ( ) ; for ( String str : playernames ) { for ( Player p : model . getAllPlayers ( ) ) { if ( p . getName ( ) . equalsIgnoreCase ( str ) ) result . add ( p ) ; } } return result ; }
tr	6	@ SuppressWarnings ( "rawtypes" ) public static List < String > getClassNamesImplementingInterface ( class interf , String basePackage ) { List < String > classNames = new ArrayList < String > ( ) ; try { class [ ] result = getClasses ( basePackage ) ; for ( class c : result ) { if ( ! Modifier . isAbstract ( c . getModifiers ( ) ) ) { for ( class implementingInterface : c . getInterfaces ( ) ) { if ( implementingInterface . getName ( ) . equals ( interf . getName ( ) ) ) { classNames . add ( c . getCanonicalName ( ) ) ; } } } } } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return classNames ; }
tr	7	public void read ( org . apache . thrift7 . protocol . TProtocol iprot ) throws org . apache . thrift7 . TException { org . apache . thrift7 . protocol . TField field ; iprot . readStructBegin ( ) ; while ( true ) { field = iprot . readFieldBegin ( ) ; if ( field . type == org . apache . thrift7 . protocol . TType . STOP ) { break ; } switch ( field . id ) { case 1 : if ( field . type == org . apache . thrift7 . protocol . TType . STRING ) { this . queue_name = iprot . readString ( ) ; } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; case 2 : if ( field . type == org . apache . thrift7 . protocol . TType . SET ) { { org . apache . thrift7 . protocol . TSet _set12 = iprot . readSetBegin ( ) ; this . ids = new HashSet < long > ( 2 * _set12 . size ) ; for ( int _i13 = 0 ; _i13 < _set12 . size ; ++ _i13 ) { long _elem14 ; _elem14 = iprot . readI64 ( ) ; this . ids . add ( _elem14 ) ; } iprot . readSetEnd ( ) ; } } else { org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } break ; default : org . apache . thrift7 . protocol . TProtocolUtil . skip ( iprot , field . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; validate ( ) ; }
tr	2	private void updateTableColumn ( int column , int width ) { final TableColumn tableColumn = table . getColumnModel ( ) . getColumn ( column ) ; if ( ! tableColumn . getResizable ( ) ) return ; width += spacing ; if ( isOnlyAdjustLarger ) { width = Math . max ( width , tableColumn . getPreferredWidth ( ) ) ; } columnSizes . put ( tableColumn , new Integer ( tableColumn . getWidth ( ) ) ) ; table . getTableHeader ( ) . setResizingColumn ( tableColumn ) ; tableColumn . setWidth ( width ) ; }
tr	1	synchronized public String getString ( ) { try { wait ( ) ; } catch ( InterruptedException e ) { } return napis ; }
tr	6	public static void LoadReviewsFromSQL ( ) { DBUtil db1 = new DBUtil ( ) ; Logger . getInstance ( ) . getElapseTime ( true ) ; String sql = "select * from sentences" ; ResultSet rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { String filename = TextUtil . decode ( rs1 . getString ( "filename" ) ) ; int curSentIndex = rs1 . getInt ( "sent_index" ) ; if ( ! dataHash . containsKey ( filename ) ) { RestaurantEntry tmp = new RestaurantEntry ( ) ; tmp . StartSentIndex = curSentIndex ; dataHash . put ( filename , tmp ) ; } else { dataHash . get ( filename ) . EndSentIndex = curSentIndex ; } int revIndex = rs1 . getInt ( "revindex" ) ; double rating = rs1 . getDouble ( "revrating" ) ; if ( dataHash . get ( filename ) . ReviewMap . get ( revIndex ) == null ) { ReviewEntry tmp = new ReviewEntry ( ) ; tmp . setStartSentIndex ( curSentIndex ) ; tmp . setRating ( rating ) ; dataHash . get ( filename ) . ReviewMap . put ( revIndex , tmp ) ; } else { dataHash . get ( filename ) . ReviewMap . get ( revIndex ) . setEndSentIndex ( curSentIndex ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; sql = "select * from extractions" ; rs1 = db1 . executeQuerySQL ( sql ) ; try { while ( rs1 . next ( ) ) { int sentIndex = rs1 . getInt ( "sentindex" ) ; String attr = rs1 . getString ( "attr" ) ; stemmer . setCurrent ( attr ) ; stemmer . stem ( ) ; attr = stemmer . getCurrent ( ) ; String value = rs1 . getString ( "value" ) ; Extraction tmp = new Extraction ( value , attr , 0 ) ; tmp . setSentIndex ( sentIndex ) ; insertIntoHash ( tmp , sentIndex ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } Logger . getInstance ( ) . getElapseTime ( true ) ; db1 . rundown ( ) ; }
tr	6	private void persist ( PersistAction persistAction , String successMessage ) { if ( selected != null ) { setEmbeddableKeys ( ) ; try { if ( persistAction != PersistAction . DELETE ) { getFacade ( ) . edit ( selected ) ; } else { getFacade ( ) . remove ( selected ) ; } JsfUtil . addSuccessMessage ( successMessage ) ; } catch ( EJBException ex ) { String msg = "" ; Throwable cause = ex . getCause ( ) ; if ( cause != null ) { msg = cause . getLocalizedMessage ( ) ; } if ( msg . length ( ) > 0 ) { JsfUtil . addErrorMessage ( msg ) ; } else { JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } catch ( Exception ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JsfUtil . addErrorMessage ( ex , ResourceBundle . getBundle ( "/resoruces/Bundle" ) . getString ( "PersistenceErrorOccured" ) ) ; } } }
tr	6	static private final int jjMoveStringLiteralDfa9_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 7 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 8 , active0 ) ; return 9 ; } switch ( curChar ) { case 73 : return jjMoveStringLiteralDfa10_0 ( active0 , 20 ) ; case 105 : return jjMoveStringLiteralDfa10_0 ( active0 , 1000 ) ; case 108 : return jjMoveStringLiteralDfa10_0 ( active0 , 2000 ) ; case 114 : return jjMoveStringLiteralDfa10_0 ( active0 , 40 ) ; default : break ; } return jjStartNfa_0 ( 8 , active0 ) ; }
tr	4	@ Override public void run ( ) { try { while ( active ) { synchronized ( messages ) { if ( messages . isEmpty ( ) ) { messages . wait ( 200 ) ; } else { NetworkMessage nm = messages . remove ( 0 ) ; out . write ( nm . getData ( ) ) ; } } } } catch ( InterruptedException ex ) { System . err . println ( ex . getMessage ( ) ) ; } catch ( IOException ex ) { System . err . println ( ex . getMessage ( ) ) ; } }
tr	2	public static void changeSize ( final File file , final long newSize ) { try { RandomAccessFile randomAccessFile = new RandomAccessFile ( file , "rw" ) ; randomAccessFile . setLength ( newSize ) ; randomAccessFile . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( files . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	2	static List < VcsCommit > parseCommits ( String xml ) { try { CommitReadingHandler commitReadingHandler = new CommitReadingHandler ( ) ; SAXParserFactory parserFactory = SAXParserFactory . newInstance ( ) ; XMLReader xmlReader = parserFactory . newSAXParser ( ) . getXMLReader ( ) ; xmlReader . setContentHandler ( commitReadingHandler ) ; xmlReader . parse ( new InputSource ( new StringReader ( xml ) ) ) ; return commitReadingHandler . commits ; } catch ( SAXException e ) { throw new RuntimeException ( "Failed to parse xml: " + xml , e ) ; } catch ( ParserConfigurationException | IOException e ) { throw new RuntimeException ( e ) ; } }
tr	1	@ Override public String getMessage ( ) { String msg = super . getMessage ( ) ; for ( String name : badValues . keySet ( ) ) { msg += "\n\t" + name + " = " + badValues . get ( name ) ; } return msg ; }
tr	4	private void initializeTokens ( ) { tokens = new Token [ 21 ] [ 10 ] ; for ( int i = 0 ; i < tokens . length ; i ++ ) { for ( int j = 0 ; j < tokens [ i ] . length ; j ++ ) { tokens [ i ] [ j ] = new Token ( ) ; } } nextTokens1 = new TokenNext [ 2 ] [ 4 ] ; nextTokens2 = new TokenNext [ 2 ] [ 4 ] ; nextTokens3 = new TokenNext [ 2 ] [ 4 ] ; holdTokens = new TokenNext [ 2 ] [ 4 ] ; for ( int i = 0 ; i < nextTokens1 . length ; i ++ ) { for ( int j = 0 ; j < nextTokens1 [ i ] . length ; j ++ ) { nextTokens1 [ i ] [ j ] = new TokenNext ( ) ; nextTokens2 [ i ] [ j ] = new TokenNext ( ) ; nextTokens3 [ i ] [ j ] = new TokenNext ( ) ; holdTokens [ i ] [ j ] = new TokenNext ( ) ; } } currentTokens = new int [ 4 ] [ 2 ] ; directingTokens = new int [ 4 ] [ 2 ] ; nextTokens3Position = new int [ 4 ] [ 2 ] ; nextTokens2Position = new int [ 4 ] [ 2 ] ; nextTokens1Position = new int [ 4 ] [ 2 ] ; holdTokensPosition = new int [ 4 ] [ 2 ] ; }
tr	5	private static ArrayList < CoordenadasHomogeneas > criarMesh2 ( ArrayList < CoordenadasHomogeneas > listCoord , ArrayList < CoordenadasHomogeneas > listaSPCurvaParcial ) { for ( CoordenadasHomogeneas semiPonto : listaSPCurvaParcial ) { listCoord . add ( new CoordenadasNorm ( semiPonto . getXD ( ) , semiPonto . getYD ( ) , 1.0 ) ) ; } double [ ] [ ] m = new double [ 4 ] [ 3 ] ; Matrix matrizGeo = new Matrix ( m ) ; double [ ] f0 = new double [ 3 ] ; double [ ] deltaF0 = new double [ 3 ] ; double [ ] delta2F0 = new double [ 3 ] ; double [ ] delta3F0 = new double [ 3 ] ; FabricaMatriz ma = new FabricaMatriz ( ) ; Matrix gbs = ma . matrizGBS ( ) ; ArrayList < CoordenadasHomogeneas > ptsCurva = new ArrayList < CoordenadasHomogeneas > ( ) ; for ( int i = 0 ; i < listCoord . size ( ) - 3 ; i ++ ) { for ( int j = 0 ; j < matrizGeo . getRowDimension ( ) ; j ++ ) { matrizGeo . set ( j , 0 , listCoord . get ( j + i ) . getXD ( ) ) ; matrizGeo . set ( j , 1 , listCoord . get ( j + i ) . getYD ( ) ) ; matrizGeo . set ( j , 2 , listCoord . get ( j + i ) . getZD ( ) ) ; } Matrix coef = gbs . times ( matrizGeo ) ; double delta = ( 1.0 / DIVISOES ) ; for ( int k = 0 ; k < 3 ; k ++ ) { f0 [ k ] = coef . get ( 3 , k ) ; deltaF0 [ k ] = coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) + coef . get ( 2 , k ) * delta ; delta2F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) + 2 * coef . get ( 1 , k ) * ( Math . pow ( delta , 2 ) ) ; delta3F0 [ k ] = 6 * coef . get ( 0 , k ) * ( Math . pow ( delta , 3 ) ) ; } CoordenadasHomogeneas p = listCoord . get ( i ) ; ArrayList < CoordenadasHomogeneas > ptsSegCurva = forwardDiferencies ( p , f0 , deltaF0 , delta2F0 , delta3F0 ) ; for ( CoordenadasHomogeneas c : ptsSegCurva ) { ptsCurva . add ( c ) ; } } return ptsCurva ; }
tr	8	@ Override public int compare ( Card o1 , Card o2 ) { if ( o1 . isTrumpOrS ( trump ) && o2 . isTrumpOrS ( trump ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . isTrumpOrS ( trump ) ) { return 1 ; } else if ( o2 . isTrumpOrS ( trump ) ) { return - 1 ; } else { if ( o1 . suit . equals ( leadSuit ) && o2 . suit . equals ( leadSuit ) ) { return o1 . number . value - o2 . number . value ; } else if ( o1 . suit . equals ( leadSuit ) ) { return 1 ; } else if ( o2 . suit . equals ( leadSuit ) ) { return - 1 ; } else { return 0 ; } } }
tr	1	public String showDisplay ( Connection aconn ) { CCodeDesc series = new CCodeDesc ( aconn , "SeriesTbl" , "SeriesCd" , "SeriesNm" , "SeriesCd" ) ; CCodeDesc results = new CCodeDesc ( aconn , "EvalResultTbl" , "ResultCd" , "ResultNm" , "ResultCd" ) ; String retstr = " <table class=\"result\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"restitleleft\" >&nbsp;&nbsp;Evaluation Results</td> </tr> </table>" ; retstr = retstr + "<table class='factors' summary='next dose evaluation'>\n" ; retstr = retstr + "<col style='width:20%'><col style='width:15%'><col style='width:5%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:3%'><col style='width:8%'>" ; retstr = retstr + "<tr>\n" ; retstr = retstr + " <td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td class='subtitle' style='border-bottom-color: #0066FF;' colspan='5'>Accelerated Schedule</td><td class='subtitle' style='border-bottom-color: #00CC00;' colspan='5'>Recommended Schedule</td><td class='subtitle'  style='border-bottom-color: #FF6600;' colspan='5'>Overdue Schedule</td></tr><tr>" ; retstr = retstr + "<th class='factors' scope='col'>Series</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Status</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dose</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Acc Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Rec Date</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Yrs</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Mos</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Wks</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Dys</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Ovr Date</th></tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CEvalItem myitem = ( CEvalItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='result'>" + series . getDescByCode ( myitem . seriescd ) + "</td>\n" ; retstr = retstr + "<td class='result'>" + results . getDescByCode ( myitem . resultcd ) + "</td>\n" ; retstr = retstr + "<td class='factors'>" + Integer . toString ( myitem . doseord ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EAyrs" + idx + "' id='EAyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAmos" + idx + "' id='EAmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAwks" + idx + "' id='EAwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdys" + idx + "' id='EAdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EAdate" + idx + "' id='EAdate" + idx + "'>" + myitem . getAccelDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='ERyrs" + idx + "' id='ERyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERmos" + idx + "' id='ERmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERwks" + idx + "' id='ERwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdys" + idx + "' id='ERdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='ERdate" + idx + "' id='ERdate" + idx + "'>" + myitem . getRecomDateStr ( ) + "</td>\n" ; retstr = retstr + "<td class='factors' name='EOyrs" + idx + "' id='EOyrs" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOmos" + idx + "' id='EOmos" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOwks" + idx + "' id='EOwks" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdys" + idx + "' id='EOdys" + idx + "'></td>\n" ; retstr = retstr + "<td class='factors' name='EOdate" + idx + "' id='EOdate" + idx + "'>" + myitem . getOverdueDateStr ( ) + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table><br>\n" ; return ( retstr ) ; }
tr	3	public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( o instanceof ASPath ) return this . equals ( ( ASPath ) o ) ; return false ; }
tr	5	public void updateLocation ( int id , List < Object > list ) { if ( ! handler_location . initialize ( ) ) { System . out . println ( "LocationServer : failed to initialize location handler!" ) ; return ; } int result = 0 , min_rssi = 1000 ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { String mac = ( String ) list . get ( i ) ; LocationNode node = handler_location . getLocationNode ( mac ) ; if ( node != null ) { int rssi = ( int ) list . get ( i + 1 ) - node . rssi ; if ( rssi < min_rssi ) { min_rssi = rssi ; result = node . area ; } } } if ( result != 0 ) { handler_location . updateLocation ( id , result ) ; } handler_location . close ( ) ; }
tr	5	public void update ( final World w ) { for ( short x = 0 ; x < sideLength ; x ++ ) { for ( short y = 0 ; y < sideLength ; y ++ ) { short tileX = ( short ) ( x + ( coords . getX ( ) * sideLength ) ) ; short tileY = ( short ) ( y + ( coords . getY ( ) * sideLength ) ) ; final Tile t = getTile ( x , y ) ; if ( ( t == Tiles . air ) || ( t == null ) ) { new Packet03Tile ( t , tileX , tileY ) . writeDataToServer ( ) ; } if ( t . doesTick ( ) ) { t . update ( w , tileX , tileY ) ; } } } }
tr	4	private static HashMap < String , Integer > addToEndGroup ( HashMap < String , Integer > endGroups , String endGroup , int end ) { if ( endGroup != null ) { if ( endGroups == null ) endGroups = new HashMap < String , Integer > ( 2 ) ; Integer oldEnd = endGroups . get ( endGroup ) ; if ( oldEnd == null || end > oldEnd ) endGroups . put ( endGroup , end ) ; } return endGroups ; }
tr	2	static public void ReInit ( java . io . InputStream stream , String encoding ) { try { jj_input_stream . ReInit ( stream , encoding , 1 , 1 ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } token_source . ReInit ( jj_input_stream ) ; token = new Token ( ) ; jj_ntk = - 1 ; jj_gen = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) jj_la1 [ i ] = - 1 ; }
tr	8	public static void main ( String [ ] args ) { int numElementos = leeNumero ( "Introduzca el n\u00FAmero de elementos a procesar (m\u00E1ximo 100): " ) ; if ( numElementos < 0 ) { System . out . println ( "\u00A1Ha de ser positivo!" ) ; return ; } else if ( numElementos > 100 ) { System . out . println ( "\u00A1Ha de ser menor o igual a 100!" ) ; return ; } int [ ] elementos = new int [ numElementos ] ; for ( int i = 0 ; i < numElementos ; i ++ ) elementos [ i ] = leeNumero ( ( i + 1 ) + ": " ) ; System . out . println ( ) ; ArrayList < Integer > noRepetidos = new ArrayList < Integer > ( numElementos ) ; for ( int i = 0 ; i < numElementos ; i ++ ) { if ( ! noRepetidos . contains ( elementos [ i ] ) ) noRepetidos . add ( elementos [ i ] ) ; } if ( numElementos == 0 ) { System . out . println ( "\u00A1No hay elementos a ordenar!" ) ; } else { System . out . println ( "Vector original:" ) ; for ( int a : elementos ) System . out . print ( a + " " ) ; System . out . println ( ) ; System . out . println ( "Vector sin repetidos:" ) ; for ( int a : noRepetidos ) System . out . print ( a + " " ) ; System . out . println ( ) ; } }
tr	4	public void run ( ) { if ( Logger . getDebugValue ( ) == 3 ) { System . out . println ( "run() of " + Thread . currentThread ( ) . getName ( ) + " is called." ) ; } String word ; Set < MusicInfo > info_found ; while ( ( word = readFile . readWordFromSearchFile ( ) ) != null ) { info_found = store . find ( word ) ; if ( info_found != null ) { Iterator < MusicInfo > iter = info_found . iterator ( ) ; while ( iter . hasNext ( ) ) { results . add ( iter . next ( ) ) ; } } } }
tr	3	public void saveGame ( ) throws CannotSaveException { try { SaveFile saveFile = new SaveFile ( GameSaver . AUTO_SAVE_LOCATION ) ; FileOutputStream saveStream = new FileOutputStream ( saveFile . getFile ( ) ) ; ObjectOutputStream save = new ObjectOutputStream ( saveStream ) ; save . writeObject ( GameState . getInstance ( ) ) ; save . close ( ) ; } catch ( CannotCreateFileException e ) { throw new CannotSaveException ( "Cannot create file" ) ; } catch ( FileNotFoundException e ) { throw new CannotSaveException ( "File not found" ) ; } catch ( IOException e ) { throw new CannotSaveException ( "IO Exception" ) ; } }
tr	8	public Vector < Door > nearbyDoors ( Game game ) { Vector < Door > doors = new Vector < Door > ( ) ; for ( Tile tile : game . getMap ( ) . getTiles ( ) ) { if ( ! ( tile instanceof Door ) ) continue ; Door door = ( Door ) tile ; if ( door . getState ( ) == Door . OPEN ) continue ; Rectangle2D door_rect = door . getArea ( ) ; double left = door_rect . getX ( ) ; double right = left + door_rect . getWidth ( ) ; double top = door_rect . getY ( ) ; double bottom = top + door_rect . getHeight ( ) ; double x = fLocation . getX ( ) ; double y = fLocation . getY ( ) ; if ( x < left ) x = left ; if ( x > right ) x = right ; if ( y < top ) y = top ; if ( y > bottom ) y = bottom ; Point2D door_point = new Point2D . double ( x , y ) ; double distance = fLocation . distance ( door_point ) ; distance -= getSize ( ) ; if ( distance <= getReach ( ) ) doors . add ( door ) ; } return doors ; }
tr	2	protected void pausePlayback ( ) { if ( m_line != null ) { if ( m_status == PLAYING ) { m_line . stop ( ) ; m_status = PAUSED ; notifyEvent ( BasicPlayerEvent . PAUSED , getEncodedStreamPosition ( ) , - 1 , null ) ; m_line . drain ( ) ; } } }
tr	3	private void carregaPreuTipusHabitacions ( ) { String [ ] nomsHotels = { "Palace" , "Hilton" , "Metropolitan" , "Arts" , "Catalunya" , "Pensi\u00F3n Pepe" , "Bonjour" , "Oulala" } ; String [ ] nomsTipus = { "Individual" , "Doble" , "Matrimoni" } ; float [ ] preus = { 100 , 200 , 250 } ; for ( int i = 0 ; i < nomsHotels . length ; ++ i ) { for ( int j = 0 ; j < nomsTipus . length ; ++ j ) { PreuTipusHabitacio pth = new PreuTipusHabitacio ( ) ; pth . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pth . setPreu ( preus [ j ] ) ; if ( j == 0 ) { AbsoluteDiscountPreuStrategy adps = new AbsoluteDiscountPreuStrategy ( ) ; adps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; adps . setDescompte ( 30 ) ; pth . setStrategy ( adps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( adps ) ; } else { PercentDiscountPreuStrategy pdps = new PercentDiscountPreuStrategy ( ) ; pdps . setId ( new PreuTipusHabitacioId ( nomsHotels [ i ] , nomsTipus [ j ] ) ) ; pdps . setPerc ( 0.7F ) ; pth . setStrategy ( pdps ) ; session . saveOrUpdate ( pth ) ; session . saveOrUpdate ( pdps ) ; } } } }
tr	3	public void refreshTextList ( ) { ground . remove ( textpane ) ; textpane = null ; resultSets = connector . getAllResultSets ( userID ) ; Iterator < ? > result = resultSets . iterator ( ) ; dataname . clear ( ) ; if ( result != null ) { while ( result . hasNext ( ) ) { ResultSet temp_res = ( ResultSet ) result . next ( ) ; resultmapper . put ( temp_res . getDocument ( ) . getFileName ( ) , ( ResultSet ) temp_res ) ; dataname . addElement ( temp_res . getDocument ( ) . getFileName ( ) ) ; } textpane = new JScrollPane ( texte ) ; textpane . setLocation ( 280 , 50 ) ; textpane . setSize ( 180 , 300 ) ; textpane . setVisible ( true ) ; texte . setVisible ( true ) ; ground . add ( textpane ) ; textpane . repaint ( ) ; ground . repaint ( ) ; } }
tr	0	public AddOrigen ( java . awt . Frame parent , boolean modal ) { super ( parent , modal ) ; initComponents ( ) ; }
tr	1	public void divide ( int ncol , int nrow ) { canvasPads . setSize ( this . getSize ( ) . width , this . getSize ( ) . height , ncol , nrow ) ; int ncharts = canvasPads . getNPads ( ) ; series . clear ( ) ; for ( int loop = 0 ; loop < ncharts ; loop ++ ) { ScGroupSeries chart = new ScGroupSeries ( new ScRegion ( canvasPads . getX ( loop ) , canvasPads . getY ( loop ) , canvasPads . getWidth ( loop ) , canvasPads . getHeight ( loop ) ) ) ; series . add ( chart ) ; } }
tr	2	private void select ( String s ) { int index = Integer . parseInt ( s ) ; for ( RenderableObject o : ( ( MainFrame ) frame ) . getObjects ( ) ) { if ( o . getID ( ) == index ) { selectItem ( index ) ; } } clearIdentities ( ) ; }
tr	5	public static double inverseSensorModel_old ( Point p , Point measurement , RobotState sensorState , int z , Sensor s ) { double result ; int r = Utils . euclideanDistance ( new Point ( sensorState . x , sensorState . y ) , p ) ; if ( z == - 1 ) { result = Config . LOGODD_START ; } else if ( r > Math . min ( s . zMax , z ) + Config . GRID_CELL_SIZE ) { result = Config . LOGODD_START ; } else if ( z < s . zMax && p . equals ( measurement ) ) { result = Config . LOGODD_OCCUPIED_CORRECT ; } else if ( r < z ) { result = Config . LOGODD_OCCUPIED_WRONG ; } else { result = Config . LOGODD_START ; } return result ; }
tr	9X	public double calScore ( Query query , Document doc ) { Vector < String > qv = query . _tokens ; Vector < String > docTokens = ( ( DocumentFull ) doc ) . getConvertedTitleTokens ( ) ; docTokens . addAll ( ( ( DocumentFull ) doc ) . getConvertedBodyTokens ( ) ) ; double score = 0.0 ; if ( qv . size ( ) == 1 ) { for ( String queryToken : query . _tokens ) { for ( String docToken : docTokens ) { if ( queryToken . equals ( docToken ) ) score ++ ; } } } else { for ( int i = 0 ; i < qv . size ( ) - 1 ; i ++ ) { if ( docTokens . size ( ) == 1 ) { if ( qv . get ( i ) . equals ( docTokens . get ( 0 ) ) ) score ++ ; } else { for ( int j = 0 ; j < docTokens . size ( ) - 1 ; j ++ ) if ( qv . get ( i ) . equals ( docTokens . get ( j ) ) && qv . get ( i + 1 ) . equals ( docTokens . get ( j + 1 ) ) ) score ++ ; } } } return score ; }
tr	5	public boolean recordLogin ( InetAddress origin , String userName ) { boolean ret = false ; Watch time = new Watch ( ) ; String incQuery = "UPDATE History SET lastLoginIndex = lastLoginIndex + 1 MOD length WHERE userName = '" + userName + "';" ; String delQuery = "DELETE LogIn FROM LogIn JOIN History ON(LogIn.hid = History.hid) WHERE LogIn.index = ((History.lastLoginIndex + 1) MOD length) AND History.userName = '" + userName + "';" ; String query = "INSERT INTO LogIn(hid  ip  month  day  year  `index`  hours  minutes)" + " SELECT hid  INET_ATON('" + origin . getHostAddress ( ) + "')  " + time . getMonth ( ) + "  " + time . getDate ( ) + "  " + time . getYear ( ) + "  lastLoginIndex MOD length  " + time . getHours ( ) + "  " + time . getMinutes ( ) + " " + "FROM History " + "WHERE userName = '" + userName + "';" ; try { connect ( ) ; Statement stmt = connection . createStatement ( ) ; stmt . executeUpdate ( delQuery ) ; connection . setAutoCommit ( false ) ; stmt . executeUpdate ( incQuery ) ; stmt . executeUpdate ( query ) ; connection . commit ( ) ; ret = true ; } catch ( SQLException e ) { e . printStackTrace ( ) ; ret = false ; try { if ( connection != null ) connection . rollback ( ) ; } catch ( SQLException e1 ) { e1 . printStackTrace ( ) ; } } finally { if ( connection != null ) try { connection . setAutoCommit ( true ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } } return ret ; }
tr	8	public void importGraphInfo ( String result ) throws IOException { if ( this . getType ( ) == InfoEnum . ModelCategory . ATTACK_MODEL . name ( ) ) { List < String > elements = Arrays . asList ( result . split ( "\n" ) ) ; for ( String element : elements ) { if ( element . startsWith ( "element" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findElementById ( factors . get ( 1 ) ) == null ) { RequirementElement elem = parseAttackElementInfo ( factors ) ; this . getElements ( ) . add ( elem ) ; } } } for ( String element : elements ) { if ( element . startsWith ( "link" ) ) { List < String > factors = Arrays . asList ( element . split ( ";" ) ) ; if ( this . findLinkById ( factors . get ( 1 ) ) == null ) { RequirementLink link = parseAttackModelLinkInfo ( factors ) ; this . getLinks ( ) . add ( link ) ; } } } } for ( Element elem : this . getElements ( ) ) { reprocessRequirementElement ( ( RequirementElement ) elem ) ; } }
tr	0	@ Override public String getSchema ( ) throws SQLException { return null ; }
tr	2	public void addThird ( Timeslot t ) { if ( t instanceof Lab ) { addThirdLab ( t ) ; } else if ( t instanceof Tutorial ) { addThirdTut ( t ) ; } }
tr	8	public void connect1 ( TreeLinkNode root ) { if ( root == null ) return ; Queue < TreeLinkNode > curLev = new LinkedList < TreeLinkNode > ( ) ; curLev . add ( root ) ; while ( ! curLev . isEmpty ( ) ) { Queue < TreeLinkNode > nextLev = new LinkedList < TreeLinkNode > ( ) ; while ( ! curLev . isEmpty ( ) ) { TreeLinkNode cur = curLev . poll ( ) ; if ( cur . left != null ) nextLev . add ( cur . left ) ; if ( cur . right != null ) nextLev . add ( cur . right ) ; if ( ! curLev . isEmpty ( ) ) { TreeLinkNode curNext = curLev . peek ( ) ; if ( curNext . left != null ) nextLev . add ( cur . left ) ; if ( curNext . right != null ) nextLev . add ( cur . right ) ; cur . next = curNext ; } } curLev = nextLev ; } }
tr	4	public static void run ( class < ? extends Window > clazz , class < ? > [ ] args , Object [ ] param ) { try { executeInstance ( ( Window ) clazz . getConstructor ( args ) . newInstance ( param ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	8	public void draw ( ) { Iterator < Entity > i2 = getNearbyEntities ( p . getLocation ( ) , 15 ) . iterator ( ) ; ArrayList < Block > bs = getNearbyBlocks ( p . getLocation ( ) . modify ( 0 , 0 ) , 16 ) ; for ( Block b : bs ) { b . draw ( ) ; } while ( i2 . hasNext ( ) ) { Entity toDraw = i2 . next ( ) ; toDraw . draw ( ) ; } if ( path != null ) { for ( int c = 0 ; c < path . size ( ) ; c ++ ) { if ( c == 0 ) { Engine . render ( path . get ( c ) , Material . GOLD_ORE . getImage ( ) ) ; } else if ( c == path . size ( ) - 1 ) { Engine . render ( path . get ( c ) , Material . IRON_ORE . getImage ( ) ) ; } else { Engine . render ( path . get ( c ) , Material . OBSIDIAN . getImage ( ) ) ; } } } if ( renderLight ) { Engine . addQueueItem ( new RenderQueueItem ( lightLoc , lightMap ) ) ; } if ( drawMap ) { Engine . addQueueItem ( new RenderQueueItem ( new Rectangle ( 0 , 0 , Main . getPaneWidth ( ) , Main . getPaneHeight ( ) ) , Color . blue ) ) ; Engine . addQueueItem ( new RenderQueueItem ( 0 , 0 , map ) ) ; } }
tr	0	public int [ ] getWarps ( ) { return new int [ ] { 0 , 0 , 0 , 0 } ; }
tr	9X	private String internalReadChunkedString ( int length ) throws IOException { StringBuffer buf = internalReadString ( length ) ; boolean done = false ; while ( ! done ) { int code = readNextCode ( ) ; switch ( code ) { case Codes . STRING_PACKED_LENGTH_START + 0 : case Codes . STRING_PACKED_LENGTH_START + 1 : case Codes . STRING_PACKED_LENGTH_START + 2 : case Codes . STRING_PACKED_LENGTH_START + 3 : case Codes . STRING_PACKED_LENGTH_START + 4 : case Codes . STRING_PACKED_LENGTH_START + 5 : case Codes . STRING_PACKED_LENGTH_START + 6 : case Codes . STRING_PACKED_LENGTH_START + 7 : internalReadStringBuffer ( buf , code - Codes . STRING_PACKED_LENGTH_START ) . toString ( ) ; done = true ; break ; case Codes . STRING : internalReadStringBuffer ( buf , readCount ( ) ) ; done = true ; break ; case Codes . STRING_CHUNK : internalReadStringBuffer ( buf , readCount ( ) ) ; break ; default : throw expected ( "chunked string" , code ) ; } } return buf . toString ( ) ; }
tr	2	public void open ( URL location , String referer ) throws IOException { String host = location . getHost ( ) ; if ( referer == null ) referer = "http://" + host + "/" ; String path = location . getPath ( ) + "?" + location . getQuery ( ) ; int port = location . getPort ( ) ; if ( port == - 1 ) port = 80 ; socket . setSoTimeout ( 5000 ) ; socket . connect ( new InetSocketAddress ( host , port ) , 5000 ) ; PrintWriter pw = new PrintWriter ( socket . getOutputStream ( ) , true ) ; pw . println ( "GET " + path + " HTTP/1.1" ) ; pw . println ( "Host: " + host ) ; pw . println ( "Referer: " + referer ) ; pw . println ( "Accept: */*" ) ; pw . println ( "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)" ) ; pw . println ( "Connection: Keep-Alive" ) ; pw . println ( ) ; instream = socket . getInputStream ( ) ; getResponse ( ) ; }
tr	1	public static StroopTest createOneColourTest ( int wordSize ) { List < Word > words = new ArrayList < Word > ( wordSize ) ; for ( int i = 0 ; i < wordSize ; i ++ ) { words . add ( WordFactory . createRandomColourWord ( ) ) ; } return new StroopTest ( words , TestType . TEST_WORD ) ; }
tr	6	protected void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c == '' ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case '' : prevCharIsCR = true ; break ; case '' : prevCharIsLF = true ; break ; case 	 : column -- ; column += ( tabSize - ( column % tabSize ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; }
tr	7	private boolean placeRandomTeleportLocation ( int [ ] [ ] map , int [ ] randomlocation ) { if ( map == null ) throw new IllegalArgumentException ( "Invalid argument: map is null" ) ; if ( map [ 0 ] == null ) throw new IllegalArgumentException ( "Invalid argument: a row is null" ) ; if ( randomlocation . length != 2 ) throw new IllegalArgumentException ( "Invalid argument: the randomlocation array-holder is not of length 2" ) ; ArrayList < int [ ] > availableLocations = new ArrayList < > ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length ; j ++ ) { if ( map [ i ] [ j ] == 0 ) { availableLocations . add ( new int [ ] { i , j } ) ; } } } if ( availableLocations . size ( ) == 0 ) { java . lang . System . out . println ( "Warning: You have a teleporter in a map with no spaces" ) ; return false ; } Random random = new Random ( ) ; random . setSeed ( java . lang . System . currentTimeMillis ( ) ) ; int index = random . nextInt ( availableLocations . size ( ) ) ; int [ ] chosen = availableLocations . get ( index ) ; randomlocation [ 0 ] = chosen [ 0 ] ; randomlocation [ 1 ] = chosen [ 1 ] ; return true ; }
tr	8	private static Map < UnaryRule , List < String >> computeUnaryClosure ( Collection < UnaryRule > unaryRules ) { Map < UnaryRule , String > intermediateStates = new HashMap < UnaryRule , String > ( ) ; Counter < UnaryRule > pathCosts = new Counter < UnaryRule > ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByChild = new HashMap < String , List < UnaryRule >> ( ) ; Map < String , List < UnaryRule >> closedUnaryRulesByParent = new HashMap < String , List < UnaryRule >> ( ) ; Set < String > states = new HashSet < String > ( ) ; for ( UnaryRule unaryRule : unaryRules ) { relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , unaryRule , null , unaryRule . getScore ( ) ) ; states . add ( unaryRule . getParent ( ) ) ; states . add ( unaryRule . getChild ( ) ) ; } for ( String intermediateState : states ) { List < UnaryRule > incomingRules = closedUnaryRulesByChild . get ( intermediateState ) ; List < UnaryRule > outgoingRules = closedUnaryRulesByParent . get ( intermediateState ) ; if ( incomingRules == null || outgoingRules == null ) continue ; for ( UnaryRule incomingRule : incomingRules ) { for ( UnaryRule outgoingRule : outgoingRules ) { UnaryRule rule = new UnaryRule ( incomingRule . getParent ( ) , outgoingRule . getChild ( ) ) ; double newScore = pathCosts . getCount ( incomingRule ) * pathCosts . getCount ( outgoingRule ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , rule , intermediateState , newScore ) ; } } } for ( String state : states ) { UnaryRule selfLoopRule = new UnaryRule ( state , state ) ; relax ( pathCosts , intermediateStates , closedUnaryRulesByChild , closedUnaryRulesByParent , selfLoopRule , null , 1.0 ) ; } Map < UnaryRule , List < String >> closureMap = new HashMap < UnaryRule , List < String >> ( ) ; for ( UnaryRule unaryRule : pathCosts . keySet ( ) ) { unaryRule . setScore ( pathCosts . getCount ( unaryRule ) ) ; List < String > path = extractPath ( unaryRule , intermediateStates ) ; closureMap . put ( unaryRule , path ) ; } System . out . println ( "SIZE: " + closureMap . keySet ( ) . size ( ) ) ; return closureMap ; }
tr	9X	public static void phdStudentInsert ( JSONObject data ) { String firstName = ( String ) data . get ( "firstName" ) ; String surName = ( String ) data . get ( "surName" ) ; String lastName = ( String ) data . get ( "lastName" ) ; String personalId = ( String ) data . get ( "personalId" ) ; String phone = ( String ) data . get ( "phone" ) ; String email = ( String ) data . get ( "email" ) ; String type = ( String ) data . get ( "type" ) ; String form = ( String ) data . get ( "form" ) ; PhdStudentType studentType = null ; StudyForm studyForm = null ; if ( form . contains ( "self_training" ) ) studyForm = StudyForm . SELF_TRAINING ; else studyForm = StudyForm . REGULAR_TRAINING ; if ( type . contains ( "creative" ) ) studentType = PhdStudentType . CREATIVE ; else studentType = PhdStudentType . RESEARCH ; Student student = new Student ( firstName , surName , lastName , personalId , phone , email , studentType , studyForm ) ; SqlInsert . insertStudent ( student ) ; boolean assigned = boolean . parseBoolean ( ( String ) data . get ( "assigned" ) ) ; String assignedDate = ( String ) data . get ( "assignedDate" ) ; String supervisor = ( String ) data . get ( "supervisor" ) ; String thesis = ( String ) data . get ( "thesis" ) ; boolean individualPlan = boolean . parseBoolean ( ( String ) data . get ( "individualPlan" ) ) ; String approvalDate = ( String ) data . get ( "approvalDate" ) ; String monitoringDate = ( String ) data . get ( "monitoringDate" ) ; String evaluation_raw = ( String ) data . get ( "evaluation" ) ; Evaluation evaluation = null ; if ( evaluation_raw . equals ( "positive" ) ) evaluation = Evaluation . POSITIVE ; else if ( evaluation_raw . equals ( "negative" ) ) evaluation = Evaluation . NEGATIVE ; else evaluation = Evaluation . CRITICAL ; Monitoring monitoring = new Monitoring ( monitoringDate ) ; TrainingStatus trainingStatus = new TrainingStatus ( assigned , assignedDate , supervisor , thesis , individualPlan , approvalDate , monitoring , evaluation ) ; SqlInsert . insertTrainingStatus ( trainingStatus , student ) ; String facultyName = ( String ) data . get ( "facultyName" ) ; int specialtyCode = Integer . parseInt ( ( String ) data . get ( "specialtyCode" ) ) ; Faculty faculty = new Faculty ( facultyName , specialtyCode , trainingStatus , student ) ; SqlInsert . insertFaculty ( faculty , student , trainingStatus ) ; String specialtyExam = ( String ) data . get ( "specialtyExam" ) ; String publicProtection = ( String ) data . get ( "publicProtection" ) ; Curriculum studentCurriculum = new Curriculum ( specialtyExam , publicProtection ) ; SqlInsert . insertStudentCurriculum ( studentCurriculum , student ) ; JSONArray courses = ( JSONArray ) data . get ( "courses" ) ; for ( int i = 0 ; i < courses . size ( ) ; i ++ ) { JSONObject course = ( JSONObject ) courses . get ( i ) ; String courseName = ( String ) course . get ( "courseName" ) ; String courseEstimate = ( String ) course . get ( "courseEstimate" ) ; String courseType = ( String ) course . get ( "courseType" ) ; String courseProtocol = ( String ) course . get ( "courseProtocol" ) ; CourseProtocols protocol = new CourseProtocols ( courseProtocol ) ; CourseType ctype = null ; if ( courseType . equals ( "compulsory" ) ) ctype = CourseType . COMPULSORY ; else ctype = CourseType . ELECTIVE ; Course studentCourse = new Course ( courseEstimate , courseName , ctype , protocol ) ; SqlInsert . insertCourseProtocol ( protocol ) ; SqlInsert . insertCourses ( studentCourse , student , studentCurriculum ) ; } JSONArray eduActivities = ( JSONArray ) data . get ( "activities" ) ; for ( int i = 0 ; i < eduActivities . size ( ) ; i ++ ) { JSONObject eduActivity = ( JSONObject ) eduActivities . get ( i ) ; String activityName = ( String ) eduActivity . get ( "activityName" ) ; String activityType = ( String ) eduActivity . get ( "activityType" ) ; EduActivityType eduType = null ; if ( activityType . equals ( "lecture" ) ) eduType = EduActivityType . LECTURE ; else eduType = EduActivityType . SEMINAR ; EduActivities activity = new EduActivities ( activityName , eduType ) ; SqlInsert . insertEduActivities ( activity , student , studentCurriculum ) ; } JSONArray artisticEvents = ( JSONArray ) data . get ( "events" ) ; for ( int i = 0 ; i < artisticEvents . size ( ) ; i ++ ) { JSONObject artEvent = ( JSONObject ) artisticEvents . get ( i ) ; String eventName = ( String ) artEvent . get ( "eventName" ) ; String eventDate = ( String ) artEvent . get ( "eventDate" ) ; ArtisticEvents event = new ArtisticEvents ( eventDate , eventName ) ; SqlInsert . insertArtisticEvents ( event , student , studentCurriculum ) ; } JSONArray scientificProds = ( JSONArray ) data . get ( "productions" ) ; for ( int i = 0 ; i < scientificProds . size ( ) ; i ++ ) { JSONObject scProd = ( JSONObject ) scientificProds . get ( i ) ; String productionName = ( String ) scProd . get ( "productionName" ) ; String productionType = ( String ) scProd . get ( "productionType" ) ; ScientificProductions production = new ScientificProductions ( productionName , productionType ) ; SqlInsert . insertScProd ( production , student , studentCurriculum ) ; } }
tr	9X	public boolean isMatch ( String s , String p ) { if ( p . length ( ) == 0 ) { return s . length ( ) == 0 ; } if ( p . length ( ) == 1 ) { return ( s . length ( ) == 1 ) && ( p . charAt ( 0 ) == s . charAt ( 0 ) || p . charAt ( 0 ) == . ) ; } if ( p . charAt ( 1 ) != * ) { if ( s . length ( ) < 1 ) { return false ; } else { return ( s . charAt ( 0 ) == p . charAt ( 0 ) || p . charAt ( 0 ) == . ) && isMatch ( s . substring ( 1 ) , p . substring ( 1 ) ) ; } } while ( s . length ( ) > 0 && ( p . charAt ( 0 ) == s . charAt ( 0 ) || p . charAt ( 0 ) == . ) ) { if ( isMatch ( s , p . substring ( 2 ) ) ) { return true ; } s = s . substring ( 1 ) ; } return isMatch ( s , p . substring ( 2 ) ) ; }
tr	9X	protected void downloadJars ( String path ) throws Exception { File versionFile = new File ( path , "md5s" ) ; Properties md5s = new Properties ( ) ; if ( versionFile . exists ( ) ) { try { FileInputStream fis = new FileInputStream ( versionFile ) ; md5s . load ( fis ) ; fis . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } state = 4 ; int [ ] fileSizes = new int [ urlList . length ] ; boolean [ ] skip = new boolean [ urlList . length ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; urlconnection . setDefaultUseCaches ( false ) ; skip [ i ] = false ; if ( ( urlconnection instanceof HttpURLConnection ) ) { ( ( HttpURLConnection ) urlconnection ) . setRequestMethod ( "HEAD" ) ; int code = ( ( HttpURLConnection ) urlconnection ) . getResponseCode ( ) ; if ( code / 100 == 3 ) { skip [ i ] = true ; } } fileSizes [ i ] = urlconnection . getContentLength ( ) ; totalSizeDownload += fileSizes [ i ] ; } int initialPercentage = this . percentage = 10 ; byte [ ] buffer = new byte [ 65536 ] ; for ( int i = 0 ; i < urlList . length ; i ++ ) { if ( skip [ i ] != false ) { percentage = ( initialPercentage + fileSizes [ i ] * 45 / totalSizeDownload ) ; } boolean downloadFile = true ; while ( downloadFile ) { downloadFile = false ; URLConnection urlconnection = urlList [ i ] . openConnection ( ) ; String etag = "" ; if ( ( urlconnection instanceof HttpURLConnection ) ) { urlconnection . setRequestProperty ( "Cache-Control" , "no-cache" ) ; urlconnection . connect ( ) ; etag = urlconnection . getHeaderField ( "ETag" ) ; } String currentFile = getFileName ( urlList [ i ] ) ; InputStream inputstream = getJarInputStream ( currentFile , urlconnection ) ; FileOutputStream fos = new FileOutputStream ( path + currentFile ) ; long downloadStartTime = System . currentTimeMillis ( ) ; int downloadedAmount = 0 ; int fileSize = 0 ; String downloadSpeedMessage = "" ; MessageDigest m = MessageDigest . getInstance ( "MD5" ) ; int bufferSize ; while ( ( bufferSize = inputstream . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fos . write ( buffer , 0 , bufferSize ) ; m . update ( buffer , 0 , bufferSize ) ; currentSizeDownload += bufferSize ; fileSize += bufferSize ; percentage = ( initialPercentage + currentSizeDownload * 45 / totalSizeDownload ) ; subtaskMessage = ( "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430: " + currentFile + " " + currentSizeDownload * 100 / totalSizeDownload + "%" ) ; downloadedAmount += bufferSize ; long timeLapse = System . currentTimeMillis ( ) - downloadStartTime ; if ( timeLapse >= 1000 ) { float downloadSpeed = downloadedAmount / ( float ) timeLapse ; downloadSpeed = ( int ) ( downloadSpeed * 100.0F ) / 100.0F ; downloadSpeedMessage = " @ " + downloadSpeed + " KB/sec" ; downloadedAmount = 0 ; downloadStartTime += 1000 ; } subtaskMessage += downloadSpeedMessage ; } inputstream . close ( ) ; fos . close ( ) ; } } }
tr	2	public List < Player > getPlayersOnPlace ( ) { final List < Player > players = new ArrayList < Player > ( ) ; for ( final Player player : Monopoly . getInstance ( ) . getPlayers ( ) ) { if ( player . position == this . placeID ) { players . add ( player ) ; } } return players ; }
tr	4	public boolean autoCheckSibMessage ( String xml , String id [ ] , String ref [ ] ) { Hashtable hashtable = SibXMLMessageParser ( xml , id ) ; if ( hashtable == null ) return false ; if ( hashtable . size ( ) < id . length ) return false ; for ( int i = 0 ; i < hashtable . size ( ) ; i ++ ) if ( ! ref [ i ] . equals ( ( String ) hashtable . get ( id [ i ] ) ) ) return false ; return true ; }
tr	8	public static int searchInt ( int [ ] arr , int low , int high , int x ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( arr [ mid ] >= arr [ low ] && arr [ mid ] >= arr [ high ] ) { if ( x >= arr [ low ] && x < arr [ mid ] ) return searchInt ( arr , low , mid - 1 , x ) ; else return searchInt ( arr , mid , high , x ) ; } else { if ( x > arr [ mid ] && x <= arr [ high ] ) return searchInt ( arr , mid + 1 , high , x ) ; else return searchInt ( arr , low , mid , x ) ; } }
tr	0	public Logger getLogger ( ) { return this . logger ; }
tr	8	public static String [ ] splitbyLetter2 ( CharSequence text ) { list . clear ( ) ; int pos = 0 ; int len = text . length ( ) ; boolean first = true ; for ( int i = 0 ; i < len ; i ++ ) { char c = text . charAt ( i ) ; if ( c > 58 ) { if ( first ) { first = false ; buffer [ pos ++ ] = c ; continue ; } list . add ( new String ( buffer , 0 , pos ) ) ; pos = 0 ; buffer [ pos ++ ] = c ; } else if ( c == 32 || c == 10 || c == 47 || c == 13 || c == 9 ) { } else { buffer [ pos ++ ] = c ; } } list . add ( new String ( buffer , 0 , pos ) ) ; return list . toArray ( new String [ list . size ( ) ] ) ; }
tr	7	public void insertAndIndexDocument ( Document doc ) throws IOException , ClassNotFoundException { Node currentNode = null ; Node previousNode = null ; int sentenceNumber = 0 ; int wordNumber = 0 ; Transaction tx = graphDb . beginTx ( ) ; try { ArrayList < Sentence > sentences = doc . getSentences ( ) ; for ( Sentence sentence : sentences ) { wordNumber = 0 ; ArrayList < Word > words = sentence . getWords ( ) ; for ( Word word : words ) { currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; if ( currentNode == null ) { Neo4jNode newNode = new Neo4jNode ( word . getContent ( ) ) ; ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; newNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; insertAndIndexNode ( newNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } else { Neo4jNode existingNode = convertToNeo4jNode ( currentNode ) ; if ( existingNode . isInDocumentTable ( doc . getId ( ) ) ) { ArrayList < String > documentEntity = existingNode . getDocumentEntity ( doc . getId ( ) ) ; int tf = Integer . parseInt ( documentEntity . get ( 0 ) ) + 1 ; documentEntity . set ( 0 , String . valueOf ( tf ) ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } else { ArrayList < String > documentEntity = new ArrayList < String > ( ) ; documentEntity . add ( "1" ) ; documentEntity . add ( String . valueOf ( sentenceNumber ) + "_" + String . valueOf ( wordNumber ) ) ; existingNode . addToDocumentTable ( doc . getId ( ) , documentEntity ) ; } modifyAndIndexNode ( existingNode , currentNode ) ; currentNode = findNodeByProperty ( Neo4jNode . WORD_PROPERTY , word . getContent ( ) ) ; } if ( currentNode != null && previousNode != null && ! doesRelationsExist ( previousNode , currentNode , "document_" + doc . getId ( ) ) ) { createRelationship ( previousNode , currentNode , "document_" + doc . getId ( ) ) ; } previousNode = currentNode ; wordNumber ++ ; } sentenceNumber ++ ; } tx . success ( ) ; } finally { tx . finish ( ) ; } }
tr	2	@ Override public int hashCode ( ) { int result = key != null ? key . hashCode ( ) : 0 ; result = 31 * result + ( value != null ? value . hashCode ( ) : 0 ) ; return result ; }
tr	4	@ Override public int attachSoundEffect ( SoundEffect effect , int channel ) { if ( channel > chEffects . size ( ) ) throw new IndexOutOfBoundsException ( "Channel must be in range!" ) ; effect = effect . clone ( ) ; if ( channel < 0 ) { if ( effect . getChannelCount ( ) != channelCount ) throw new IllegalArgumentException ( "The effects channel count must be same as this mixers channel count!" ) ; mEffects . add ( effect ) ; return mEffects . size ( ) - 1 ; } else { if ( effect . getChannelCount ( ) != getInputChannelOutputChannelCount ( channel ) ) throw new IllegalArgumentException ( "The effects channel count must be the same as input channels channel count!" ) ; ArrayList < SoundEffect > e = chEffects . get ( channel ) ; e . add ( effect ) ; return e . size ( ) - 1 ; } }
tr	9X	private void initBlock ( ) { char magic1 , magic2 , magic3 , magic4 ; char magic5 , magic6 ; magic1 = bsGetUChar ( ) ; magic2 = bsGetUChar ( ) ; magic3 = bsGetUChar ( ) ; magic4 = bsGetUChar ( ) ; magic5 = bsGetUChar ( ) ; magic6 = bsGetUChar ( ) ; if ( magic1 == 17 && magic2 == 72 && magic3 == 45 && magic4 == 38 && magic5 == 50 && magic6 == 90 ) { complete ( ) ; return ; } if ( magic1 != 31 || magic2 != 41 || magic3 != 59 || magic4 != 26 || magic5 != 53 || magic6 != 59 ) { badBlockHeader ( ) ; streamEnd = true ; return ; } storedBlockCRC = bsGetInt32 ( ) ; if ( bsR ( 1 ) == 1 ) { blockRandomised = true ; } else { blockRandomised = false ; } getAndMoveToFrontDecode ( ) ; mCrc . initialiseCRC ( ) ; currentState = START_BLOCK_STATE ; }
tr	8	public void updateList ( ) { listModel . clear ( ) ; ArrayList < String > a = new ArrayList < > ( ) ; for ( Course co : aList ) { if ( co . getInstructor ( ) == null && co . getLab ( ) == null ) { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) != null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) + " (Lab)" ) ; } else if ( co . getInstructor ( ) != null && co . getLab ( ) == null ) { a . add ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + co . getInstructor ( ) . getName ( ) ) ; } else { listModel . addElement ( co . getClassCode ( ) + " " + co . getSection ( ) + " : " + "n/a" + " (Lab)" ) ; } } Collections . sort ( a ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { listModel . add ( i , a . get ( i ) ) ; } }
tr	4	private void updateItemsBorrowed ( ) { String attribute = null ; if ( studentJRadioButton . isSelected ( ) ) { attribute = studentJTextField . getText ( ) ; memberId = studentJTextField . getText ( ) ; } else if ( facultyJRadioButton . isSelected ( ) ) { attribute = facultyJTextField . getText ( ) ; memberId = facultyJTextField . getText ( ) ; } String query = "UPDATE members SET ItemsBorrowed=(ItemsBorrowed+1) WHERE MemberId='" + attribute + "' " ; String query2 = "UPDATE books SET IsBorrowed=1 WHERE ((Name='" + title . getTitleName ( ) + "') AND (ItemNo='" + title . getItemNo ( ) + "')) " ; try { pst = connection . prepareStatement ( query ) ; pst = connection . prepareStatement ( query2 ) ; pst . addBatch ( query ) ; pst . addBatch ( query2 ) ; pst . executeBatch ( ) ; JOptionPane . showMessageDialog ( null , "All tables are up-to-date.\nYou can now lend the Item to Member" , "Successful lending" , JOptionPane . INFORMATION_MESSAGE ) ; } catch ( SQLException e ) { JOptionPane . showMessageDialog ( null , e ) ; } finally { try { rs . close ( ) ; pst . close ( ) ; } catch ( Exception e ) { } } }
tr	3	public NotebookJTableModel ( NotebookDao dbSource , String query ) { if ( dbSource == null ) { throw new IllegalArgumentException ( "Notebook table model ben\u00F6tigt eine Datenbankquelle != null" ) ; } this . dbSource = dbSource ; if ( query == null || query . trim ( ) . isEmpty ( ) ) { throw new IllegalArgumentException ( "Notebook table model query String darf nicht null oder leer sein!" ) ; } this . query = query ; this . getDBContents ( ) ; }
tr	4	public void testLineSeriesChart ( ) { LineSeriesChart < Number , Number > chart = new LineSeriesChart < Number , Number > ( "Curves" , "X" , "Y" ) ; Collection < LineSeriesItem < Number , Number >> linhaSin = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaSin . add ( new LineSeriesItem < Number , Number > ( i , Math . sin ( i ) + 4 ) ) ; } chart . addValue ( linhaSin ) ; Collection < LineSeriesItem < Number , Number >> linhaCos = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaCos . add ( new LineSeriesItem < Number , Number > ( i , Math . cos ( i ) ) ) ; } chart . addValue ( linhaCos ) ; Collection < LineSeriesItem < Number , Number >> linhaExp = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 2 ; i += 0.01 ) { linhaExp . add ( new LineSeriesItem < Number , Number > ( i , Math . exp ( i ) + 1 ) ) ; } chart . addValue ( linhaExp ) ; Collection < LineSeriesItem < Number , Number >> linhaReta = new ArrayList < LineSeriesItem < Number , Number >> ( ) ; for ( double i = 0 ; i <= 6 ; i += 0.01 ) { linhaReta . add ( new LineSeriesItem < Number , Number > ( i , i ) ) ; } chart . addValue ( linhaReta ) ; Highlighter highlighter = criarHighlighter ( ) ; chart . getChartConfiguration ( ) . setHighlighter ( highlighter ) ; chart . addSerie ( criarSerie ( "Seno" , "#489104" ) ) ; chart . addSerie ( criarSerie ( "Coseno" , "#c91212" ) ) ; chart . addSerie ( criarSerie ( "Exponensial" , "#7D02B2" ) ) ; chart . addSerie ( criarSerie ( "Reta" , "#066FA7" ) ) ; Legend legend = new Legend ( true , Location . ne ) ; legend . setPlacement ( "outsideGrid" ) ; chart . setLegend ( legend ) ; Axis < String > axis = new AxisString ( ) ; axis . setLabelRenderer ( JqPlotResources . CanvasAxisLabelRenderer ) ; chart . setAxesDefaults ( axis ) ; Axes axes = chart . getAxes ( ) ; XAxis xaxis = axes . getXaxis ( ) ; TickOptions tickOptions = new TickOptions ( ) ; tickOptions . setAngle ( 270 ) ; tickOptions . setLabelPosition ( "end" ) ; xaxis . setTickOptions ( tickOptions ) ; xaxis . setTickRenderer ( JqPlotResources . CanvasAxisTickRenderer ) ; xaxis . setTickInterval ( 1 ) ; axes . getYaxis ( ) . setTickInterval ( 0.50 ) ; axes . getYaxis ( ) . setMax ( 8.50 ) ; axes . getYaxis ( ) . setMin ( - 1.50 ) ; TickOptions tickOptionsY = new TickOptions ( ) ; tickOptionsY . setFormatString ( "%.2f" ) ; axes . getYaxis ( ) . setTickOptions ( tickOptionsY ) ; Grid grid = new Grid ( ) ; grid . setBackground ( "#ffffff" ) ; grid . setGridLineColer ( "#a0a0a0" ) ; chart . getChartConfiguration ( ) . setGrid ( grid ) ; Cursor cursor = new Cursor ( ) ; cursor . setZoom ( true ) ; cursor . setClickReset ( true ) ; chart . getChartConfiguration ( ) . setCursor ( cursor ) ; String json = JqPlotUtils . createJquery ( chart , "div3" ) ; json = json . replaceAll ( "\\$" , "jQuery" ) ; System . out . println ( json ) ; }
tr	0	public StudentInfo getStdInfo ( ) { return stdInfo ; }
tr	2	@ Override protected boolean isConsumed ( KeyboardEvent e ) { boolean rc = false ; if ( e . getKey ( ) == Keyboard . KEY_UP || e . getKey ( ) == Keyboard . KEY_DOWN ) { rc = true ; } return rc ; }
tr	1	public void setCode ( CodeFragment code ) { if ( code == null ) code = new CodeFragment ( ) ; this . code = code ; }
tr	5	public boolean isIsAndOrSentenceHelper ( List < String > words , String sentencePtn , String ptn1 , String ptn2 ) { PropertyConfigurator . configure ( "conf/log4j.properties" ) ; Logger myLogger = Logger . getLogger ( "learn.isIsAndOrSentence" ) ; sentencePtn = sentencePtn . toLowerCase ( ) ; sentencePtn = sentencePtn . replaceAll ( "t" , "m" ) ; Pattern p1 = Pattern . compile ( ptn1 ) ; Matcher m1 = p1 . matcher ( sentencePtn ) ; Pattern p2 = Pattern . compile ( ptn2 ) ; Matcher m2 = p2 . matcher ( sentencePtn ) ; int end = - 1 ; boolean case1 = false ; boolean case2 = false ; if ( m1 . find ( ) ) { end = m1 . end ( ) ; case1 = true ; } if ( m2 . find ( ) ) { end = m2 . end ( ) ; case2 = true ; } if ( case1 || case2 ) { String matchedWords = StringUtils . join ( words . subList ( 0 , end ) , " " ) ; String regex = String . format ( "\\b(%s)\\b" , this . myLearnerUtility . getConstant ( ) . PREPOSITION ) ; if ( StringUtility . isMatchedNullSafe ( matchedWords , regex ) ) { myLogger . trace ( "Case 1" ) ; return false ; } myLogger . trace ( "Case 2" ) ; return true ; } myLogger . trace ( "Case 3" ) ; return false ; }
tr	6	public static float valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof float ) { return ( float ) o ; } else if ( o instanceof double ) { return ( float ) o ; } else if ( o instanceof byte ) { return ( float ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( float ) ( Integer ) o ; } else if ( o instanceof long ) { return ( float ) ( long ) o ; } else { return null ; } }
tr	7	public void run ( ) { parser = new CommandParser ( true ) ; parser . setCommandList ( new ApplicationCommandList ( ) ) ; System . out . println ( "WELCOME" ) ; System . out . println ( "READY for Input!" ) ; reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String input ; try { while ( ( input = reader . readLine ( ) ) != null ) { if ( input . equals ( "!end" ) ) { break ; } else { if ( input . length ( ) > 0 ) { String query = parser . parse ( input . trim ( ) ) ; if ( query . length ( ) > 1 ) { parser . parse ( query ) ; } } else System . out . println ( "" ) ; } } } catch ( IOException e ) { logger . error ( "reading input lines failed" ) ; } finally { System . out . println ( "BYE" ) ; if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { logger . error ( "could not close reader" ) ; } } } }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PhpposSuppliersEntity that = ( PhpposSuppliersEntity ) o ; if ( personId != that . personId ) return false ; if ( accountNumber != null ? ! accountNumber . equals ( that . accountNumber ) : that . accountNumber != null ) return false ; return true ; }
tr	5	public Calendar getMaxDueDate ( ) { Calendar result = Calendar . getInstance ( ) ; Calendar max = null ; Calendar toCheck ; if ( tasks != null && tasks . size ( ) > 0 ) { for ( Task t : tasks ) { toCheck = t . getDueDate ( ) ; if ( max == null || toCheck . compareTo ( max ) > 0 ) { max = toCheck ; } } result . set ( Calendar . YEAR , max . get ( Calendar . YEAR ) ) ; result . set ( Calendar . MONTH , max . get ( Calendar . MONTH ) ) ; result . set ( Calendar . DAY_OF_MONTH , max . get ( Calendar . DAY_OF_MONTH ) ) ; } return result ; }
tr	1	private void setColunas ( ArrayList < EstruturaTabela > estruturaTabela ) { colunas = new String [ estruturaTabela . size ( ) ] ; Iterator iterator = estruturaTabela . iterator ( ) ; int i = 0 ; while ( iterator . hasNext ( ) ) { EstruturaTabela est = ( EstruturaTabela ) iterator . next ( ) ; colunas [ i ] = est . getCampo ( ) ; i ++ ; } }
tr	7	public static void makeCompactGrid ( Container parent , int rows , int cols , int initialX , int initialY , int xPad , int yPad ) { SpringLayout layout ; try { layout = ( SpringLayout ) parent . getLayout ( ) ; } catch ( ClassCastException exc ) { System . err . println ( "The first argument to makeCompactGrid must use SpringLayout." ) ; return ; } Spring x = Spring . constant ( initialX ) ; for ( int c = 0 ; c < cols ; c ++ ) { Spring width = Spring . constant ( 0 ) ; for ( int r = 0 ; r < rows ; r ++ ) { width = Spring . max ( width , getConstraintsForCell ( r , c , parent , cols ) . getWidth ( ) ) ; } for ( int r = 0 ; r < rows ; r ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setX ( x ) ; constraints . setWidth ( width ) ; } x = Spring . sum ( x , Spring . sum ( width , Spring . constant ( xPad ) ) ) ; } Spring y = Spring . constant ( initialY ) ; for ( int r = 0 ; r < rows ; r ++ ) { Spring height = Spring . constant ( 0 ) ; for ( int c = 0 ; c < cols ; c ++ ) { height = Spring . max ( height , getConstraintsForCell ( r , c , parent , cols ) . getHeight ( ) ) ; } for ( int c = 0 ; c < cols ; c ++ ) { SpringLayout . Constraints constraints = getConstraintsForCell ( r , c , parent , cols ) ; constraints . setY ( y ) ; constraints . setHeight ( height ) ; } y = Spring . sum ( y , Spring . sum ( height , Spring . constant ( yPad ) ) ) ; } SpringLayout . Constraints pCons = layout . getConstraints ( parent ) ; pCons . setConstraint ( SpringLayout . SOUTH , y ) ; pCons . setConstraint ( SpringLayout . EAST , x ) ; }
tr	2	@ Override public void actionPerformed ( ActionEvent e ) { if ( e . getActionCommand ( ) . equals ( "Apply" ) ) { this . dispose ( ) ; System . out . println ( "aaaa" ) ; Tuple < String , Tuple < String , Integer >> player1Data = player1 . getPlayerData ( ) ; Tuple < String , Tuple < String , Integer >> player2Data = player2 . getPlayerData ( ) ; int deadFields = this . deadFields . getDeadFieldNumber ( ) ; System . out . println ( deadFields ) ; System . out . println ( "bbb" ) ; Player [ ] players = { new Player ( player1Data . getFirstElement ( ) , player1Data . getSecondElement ( ) . getFirstElement ( ) , "w" , player1Data . getSecondElement ( ) . getSecondElement ( ) ) , new Player ( player2Data . getFirstElement ( ) , player2Data . getSecondElement ( ) . getFirstElement ( ) , "b" , player2Data . getSecondElement ( ) . getSecondElement ( ) ) , } ; System . out . println ( "ccc" ) ; try { masterGui . newGame ( players , deadFields ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; } System . out . println ( "ddd" ) ; } }
tr	8	public void incCount ( E data ) { if ( overallRoot == null ) { overallRoot = new AVLNode ( data ) ; return ; } AVLNode currentNode = ( AVLNode ) overallRoot ; while ( true ) { int cmp = comparator . compare ( data , currentNode . data ) ; if ( cmp == 0 ) { currentNode . count ++ ; return ; } else if ( cmp < 0 ) { if ( currentNode . left == null ) { currentNode . left = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . left ; } else { if ( currentNode . right == null ) { currentNode . right = new AVLNode ( data , currentNode ) ; break ; } currentNode = ( AVLNode ) currentNode . right ; } } percHeightUp ( currentNode ) ; while ( currentNode != null ) { Side isImbalanced = checkImbalance ( currentNode ) ; if ( isImbalanced != Side . BALANCED ) { percHeightDown ( rotate ( currentNode , isImbalanced ) ) ; break ; } currentNode = currentNode . parent ; } }
tr	2	@ Override public void close ( final String guiName ) { if ( ! guiThreads . get ( guiName ) . isAlive ( ) ) { return ; } running = false ; try { guiThreads . get ( guiName ) . join ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
tr	3	public static void applyShading ( Mesh m , view3D view ) { m . ensureVertBuffers ( ) ; m . transformVertices ( m . getMatrix ( ) , null ) ; for ( int i = 0 ; i < m . elements . size ( ) ; i ++ ) { Renderable e = m . elem ( i ) ; if ( e . type != RENDERABLE_FACE ) continue ; Face f = ( Face ) e ; { int a = f . v0 * 3 , b = f . v1 * 3 , c = f . v2 * 3 ; sVect . x = m . viewVert [ a + 0 ] - m . viewVert [ c + 0 ] ; sVect . y = m . viewVert [ a + 1 ] - m . viewVert [ c + 1 ] ; sVect . z = m . viewVert [ a + 2 ] - m . viewVert [ c + 2 ] ; tVect . x = m . viewVert [ b + 0 ] - m . viewVert [ c + 0 ] ; tVect . y = m . viewVert [ b + 1 ] - m . viewVert [ c + 1 ] ; tVect . z = m . viewVert [ b + 2 ] - m . viewVert [ c + 2 ] ; FPoint3 . crossProduct ( sVect , tVect , cProd ) ; cProd . normalize ( ) ; double sine = - FPoint3 . dotProduct ( cProd , view . lightDir ( ) ) ; double currLevel = f . getShade ( ) * .75 ; if ( sine > 0 ) { currLevel = ( 1.0 + sine ) * currLevel ; } f . setShade ( ( int ) currLevel ) ; } } }
tr	6	public int [ ] getActions ( Game game , long timeDue ) { int pacmanLoc = game . getCurPacManLoc ( ) ; for ( int i = 0 ; i < dirs . length ; i ++ ) { if ( game . ghostRequiresAction ( i ) ) { if ( isCrowded ( game ) && ! closeToMsPacMan ( game , game . getCurGhostLoc ( i ) ) ) dirs [ i ] = getRetreatActions ( game , i ) ; else if ( game . getEdibleTime ( i ) > 0 || closeToPower ( game ) ) dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , false , Game . DM . PATH ) ; else dirs [ i ] = game . getNextGhostDir ( i , pacmanLoc , true , Game . DM . PATH ) ; } } return dirs ; }
tr	9X	public String fillStaffInfo ( String staffPos ) { DB . db . openConnection ( ) ; ResultSet rs = DB . db . staff ( ) ; StringBuffer info = new StringBuffer ( ) ; try { info . append ( "<table>" ) ; while ( rs . next ( ) ) { ResultSet res = DB . db . position ( rs . getInt ( "posid" ) ) ; while ( res . next ( ) ) { if ( res . getString ( "posdesc" ) . equalsIgnoreCase ( staffPos ) ) { if ( staffPos . equalsIgnoreCase ( "gp" ) ) { info . append ( "<tr><td>Dr. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ns" ) ) { info . append ( "<tr><td>R.N. <b>" ) ; } else if ( staffPos . equalsIgnoreCase ( "ma" ) ) { info . append ( "<tr><td>Med.As. <b>" ) ; } info . append ( rs . getString ( "lname" ) ) ; info . append ( "  " + rs . getString ( "fname" ) ) ; info . append ( "</b></td></tr>" ) ; info . append ( "<tr><td>Phone: <b>" ) ; info . append ( rs . getString ( "phone" ) + "</b></td></tr>" ) ; ResultSet ress = DB . db . qualification ( rs . getInt ( "qualid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Qualification: <b>" ) ; info . append ( ress . getString ( "qualdesc" ) + "</b></td></tr>" ) ; } ResultSet rss = DB . db . staffSchedule ( rs . getInt ( "id" ) ) ; while ( rss . next ( ) ) { ress = DB . db . hospital ( rss . getInt ( "hospid" ) ) ; while ( ress . next ( ) ) { info . append ( "<tr><td>Hospital: <b>" ) ; info . append ( ress . getString ( "name" ) + "</b></td></tr>" ) ; } } info . append ( "<tr></tr>" ) ; } } } info . append ( "</table>" ) ; DB . db . close ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( StartMedOfficer . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; DB . db . close ( ) ; } return info . toString ( ) ; }
tr	9X	public final void loadTerrainBlock ( byte blockData [ ] , int blockY , int blockX , int k , int l , CollisionMap collisionMap [ ] ) { for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) if ( blockX + tileX > 0 && blockX + tileX < 103 && blockY + tileY > 0 && blockY + tileY < 103 ) collisionMap [ plane ] . clippingData [ blockX + tileX ] [ blockY + tileY ] &= feffffff ; } } Buffer stream = new Buffer ( blockData ) ; for ( int plane = 0 ; plane < 4 ; plane ++ ) { for ( int tileX = 0 ; tileX < 64 ; tileX ++ ) { for ( int tileY = 0 ; tileY < 64 ; tileY ++ ) loadTerrainTile ( tileY + blockY , l , stream , tileX + blockX , plane , 0 , k ) ; } } }
tr	2	public static Kind find ( String lowerCase ) { for ( Kind k : Kind . values ( ) ) { if ( k . name . equalsIgnoreCase ( lowerCase ) ) { return k ; } } return null ; }
tr	6	public boolean getBoolean ( int index ) throws JSONException { Object object = this . get ( index ) ; if ( object . equals ( boolean . false ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( boolean . true ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "] is not a boolean." ) ; }
tr	0	public BigRational ( ) { this ( BigDecimal . ZERO ) ; }
tr	0	public JPasswordField getPassword ( ) { return password ; }
tr	1	public Labels getLabels ( ) { if ( labels == null ) { labels = new Labels ( ) ; } return labels ; }
tr	3	public double max ( ) { if ( count ( ) == 0 ) return 0 ; double max = data . get ( 0 ) ; for ( double value : data ) if ( value > max ) max = value ; return max ; }
tr	5	@ Override public int compare ( Course course1 , Course course2 ) { if ( sortOrder == SortOrder . ASCENDING ) { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return - 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return 1 ; } } else { if ( course1 . getStudents ( ) < course2 . getStudents ( ) ) { return 1 ; } else if ( course1 . getStudents ( ) == course2 . getStudents ( ) ) { return 0 ; } else { return - 1 ; } } }
tr	1	@ Test public void testGetArgument ( ) { initializeArguments ( ) ; InputDefinition definition = new InputDefinition ( ) ; definition . addArguments ( Arrays . asList ( ( InputArgument ) foo ) ) ; assertEquals ( "getArgument() returns a InputArgument by its name" , foo , definition . getArgument ( "foo" ) ) ; try { definition . getArgument ( "bar" ) ; fail ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" ) ; } catch ( Exception e ) { assertTrue ( "getArgument() throws an IllegalArgumentException if the InputArgument name does not exist" , e instanceof IllegalArgumentException ) ; assertEquals ( "The \"bar\" argument does not exist." , e . getMessage ( ) ) ; } }
tr	5	public static int diasMes ( String mesInt ) { int result ; String mes = mesInt . toLowerCase ( ) ; switch ( mes ) { case "febrero" : result = 28 ; break ; case "abril" : case "junio" : case "septiembre" : case "noviembre" : result = 30 ; break ; default : result = 31 ; break ; } return result ; }
tr	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; String [ ] p0 ; int p1 ; int p2 ; p0 = new String [ ] { "kenta" , "kentaro" , "ken" } ; p1 = 2 ; p2 = 3 ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "hideo" , "hideto" , "hideki" , "hide" } ; p1 = 2 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "aya" , "saku" , "emi" , "ayane" , "sakura" , "emika" , "sakurako" } ; p1 = 3 ; p2 = 24 ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "taro" , "jiro" , "hanako" } ; p1 = 2 ; p2 = 0 ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "alice" , "bob" , "charlie" } ; p1 = 1 ; p2 = 6 ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , true , p2 ) && all_right ; p0 = new String [ ] { "ryota" , "ryohei" , "ryotaro" , "ryo" , "ryoga" , "ryoma" , "ryoko" , "ryosuke" , "ciel" , "lun" , "ryuta" , "ryuji" , "ryuma" , "ryujiro" , "ryusuke" , "ryutaro" , "ryu" , "ryuhei" , "ryuichi" , "evima" } ; p1 = 3 ; p2 = 276818566 ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , true , p2 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	5	public static String toString ( float [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
tr	1	public static GTHome getHome ( ) { if ( home == null ) home = new GTHomeImpl ( ) ; return home ; }
tr	9X	public boolean isMatching ( StringBuffer word , int wordPos ) { boolean matching = true , inMulti = false , multiMatch = false ; char matchCh ; for ( int matchPos = 0 ; matchPos < match . length ; matchPos ++ ) { matchCh = match [ matchPos ] ; if ( matchCh == STARTMULTI || matchCh == ENDMULTI ) { inMulti = ! inMulti ; if ( ! inMulti ) matching = matching & multiMatch ; else multiMatch = false ; } else { if ( matchCh != word . charAt ( wordPos ) ) { if ( inMulti ) multiMatch = multiMatch | false ; else matching = false ; } else { if ( inMulti ) multiMatch = multiMatch | true ; else matching = true ; } if ( ! inMulti ) wordPos ++ ; if ( ! matching ) break ; } } if ( end && wordPos != word . length ( ) ) matching = false ; return matching ; }
tr	9X	private void doTransfer ( ) throws IOException { if ( ressourceInputStream == null ) { if ( sendHeaderInRsp ) { String header = new FileRequestResponseMessage ( ResponseCode . NEVER_TRY_AGAIN , 0 ) . Serialize ( ) ; logger . info ( "send header '" + header + "'" ) ; networkOutputStream . write ( header . getBytes ( ) ) ; } networkOutputStream . close ( ) ; return ; } else { if ( offset > numAvailableData ) { logger . log ( Level . INFO , "Requested offset is not valid: requested " + offset + "  length of file: " + numAvailableData ) ; if ( sendHeaderInRsp ) networkOutputStream . write ( new FileRequestResponseMessage ( ResponseCode . OK , 0 ) . Serialize ( ) . getBytes ( ) ) ; networkOutputStream . close ( ) ; transferState = TransferStatus . Finished ; return ; } if ( offset + expectedTransferVolume > numAvailableData ) { logger . log ( Level . INFO , "Requested length of " + expectedTransferVolume + " was too large  shortened  it to " + expectedTransferVolume ) ; expectedTransferVolume = numAvailableData - offset ; } transferState = TransferStatus . Transfering ; if ( sendHeaderInRsp ) networkOutputStream . write ( ( new FileRequestResponseMessage ( ResponseCode . OK , expectedTransferVolume ) . Serialize ( ) ) . getBytes ( Message . ENCODING ) ) ; if ( bufferSize == - 1 ) { bufferSize = FALLBACK_BUFFER_SIZE ; logger . log ( Level . INFO , "Using fallback buffersize " + bufferSize ) ; } logger . info ( "sending data" ) ; ressourceInputStream . skip ( offset ) ; int bytesRead = 0 ; int bytesToRead = bufferSize ; byte [ ] buffer = new byte [ bufferSize ] ; while ( bytesToRead > 0 && keepTransferAlive && totalTransferedVolume < expectedTransferVolume && ( bytesRead = ressourceInputStream . read ( buffer , 0 , bytesToRead ) ) != - 1 ) { networkOutputStream . write ( buffer , 0 , bytesRead ) ; totalTransferedVolume += bytesRead ; if ( totalTransferedVolume + bytesToRead > expectedTransferVolume ) { bytesToRead = ( int ) ( expectedTransferVolume - totalTransferedVolume ) ; } } networkOutputStream . flush ( ) ; networkOutputStream . close ( ) ; ressourceInputStream . close ( ) ; logger . info ( "finished sending data" ) ; if ( totalTransferedVolume == expectedTransferVolume ) transferState = TransferStatus . Finished ; else { if ( ! keepTransferAlive ) transferState = TransferStatus . Canceled ; else transferState = TransferStatus . LostConnection ; } } }
tr	8	public void filtrarContratosActivos ( ) { try { String filtro = panelAdminContratos . getTextoFiltro ( ) ; int tipoFiltro = panelAdminContratos . getTipoFiltro ( ) ; if ( ! filtro . trim ( ) . equals ( "" ) ) { if ( tipoFiltro == Contrato . FILTRO_ID_DUENIO || tipoFiltro == Contrato . FILTRO_ID_HABITANTE || tipoFiltro == Contrato . FILTRO_ID_RESPONSABLE ) { long id = long . parseLong ( filtro ) ; ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , id , "" ) ; panelAdminContratos . setListaContratos ( lista ) ; } else if ( tipoFiltro == Contrato . FILTRO_NOMBRE_DUENIO || tipoFiltro == Contrato . FILTRO_NOMBRE_HABITANTE || tipoFiltro == Contrato . FILTRO_NOMBRE_RESPONSABLE ) { ArrayList < Contrato > lista = Contrato . getListaContratosFiltro ( Contrato . CONTRATOS_ACTIVOS , tipoFiltro , - 1 , filtro ) ; panelAdminContratos . setListaContratos ( lista ) ; } } else { cargarContratosActivos ( ) ; } } catch ( NumberFormatException ex ) { JOptionPane . showMessageDialog ( panelAdminContratos , "Error num\u00E9rico al buscar por el n\u00FAmero de id" , "Error num\u00E9rico" , JOptionPane . ERROR_MESSAGE ) ; } }
tr	2	public void load ( Runnable runnable ) { while ( true ) { try { executor . execute ( runnable ) ; break ; } catch ( RejectedExecutionException e ) { Macro . sleep ( 500 ) ; } } }
tr	5	public static Map < String , String > resolveAttributes ( final Map < String , String > attributes ) { final Pattern p = Pattern . compile ( "\\[([-_a-zA-Z0-9]+)\\]" ) ; final StringBuffer sb = new StringBuffer ( ) ; boolean modified = true ; boolean modifiedLocal = false ; while ( modified ) { modified = false ; final Map < String , String > tmp = new HashMap < > ( attributes ) ; for ( final Entry < String , String > e : tmp . entrySet ( ) ) { final String s = e . getValue ( ) ; final Matcher m = p . matcher ( s ) ; modifiedLocal = false ; while ( m . find ( ) ) { final String s2 = attributes . get ( m . group ( 1 ) ) ; if ( s2 == null ) { m . appendReplacement ( sb , m . group ( ) ) ; } else { m . appendReplacement ( sb , Matcher . quoteReplacement ( s2 ) ) ; modified = true ; modifiedLocal = true ; } } m . appendTail ( sb ) ; if ( modifiedLocal ) { attributes . put ( e . getKey ( ) , sb . toString ( ) ) ; } sb . delete ( 0 , sb . length ( ) ) ; } } return attributes ; }
tr	5	public Type get ( int index ) { if ( index >= length ) return new BooleanValue ( false ) ; else if ( index < 0 && Math . abs ( index ) <= length ) return elements [ length + index ] ; else if ( index < 0 && Math . abs ( index ) > length ) return new BooleanValue ( false ) ; return elements [ index ] ; }
tr	1	public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( "Field " + fieldId + " doesn't exist!" ) ; return fields ; }
tr	8	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	1	@ Override public void update ( ) { AIHockeyist puckOwner = manager . getPuckOwner ( ) ; AIRectangle myZone = manager . getMyZone ( ) ; int currentTick = manager . getCurrentTick ( ) ; init ( ) ; for ( Map . Entry < long , AIRole > p : roles . entrySet ( ) ) { moves . put ( p . getKey ( ) , p . getValue ( ) . move ( ) ) ; } }
tr	1	private int insert ( final BeanMissatge bean ) { String SQL1 = "INSERT INTO sig_missatgeria (idEntrevista destinatari idMateria materia actitud notes feina comentaris dataContestat idMensajeProfesor) " + " VALUES(? ? ? ? ? ? ? ? ? ?)" ; Object [ ] objs = new Object [ ] { bean . idEntrevista , bean . destinatari_abrev , bean . idMateria , bean . materia , bean . actitud , bean . notes , bean . feina , bean . comentari , bean . dataContestat , bean . idMensajeProfesor } ; int nup = client . getMysql ( ) . preparedUpdateID ( SQL1 , objs ) ; if ( nup > 0 ) { bean . setId ( nup ) ; } return nup ; }
tr	3	public JSONWriter object ( ) throws JSONException { if ( this . mode == i ) { this . mode = o ; } if ( this . mode == o || this . mode == a ) { this . append ( "{" ) ; this . push ( new JSONObject ( ) ) ; this . , = false ; return this ; } throw new JSONException ( "Misplaced object." ) ; }
tr	0	public boolean RemoveContact ( long nIndexContact ) { return otapiJNI . AddressBook_RemoveContact ( swigCPtr , this , removeRefContact ( nIndexContact ) ) ; }
tr	0	public void setLoggingIn ( ) { removeAll ( ) ; JPanel panel = new JPanel ( new BorderLayout ( ) ) ; panel . add ( getUpdateNews ( ) , "Center" ) ; JPanel southPanel = new TexturedPanel ( ) ; southPanel . setLayout ( new BorderLayout ( ) ) ; southPanel . add ( new LogoPanel ( ) , "West" ) ; southPanel . add ( new TransparentPanel ( ) , "Center" ) ; JLabel label = new TransparentLabel ( "Logging in...                      " , 0 ) ; label . setFont ( new Font ( null , 1 , 16 ) ) ; southPanel . add ( center ( label ) , "East" ) ; southPanel . setPreferredSize ( new Dimension ( 100 , 100 ) ) ; panel . add ( southPanel , "South" ) ; add ( panel , "Center" ) ; validate ( ) ; }
tr	2	private int validateProtocol ( ) throws IOException { int resp = this . sendDummyRequest ( ) ; if ( ! this . sc . isSecureConnection ( ) ) { this . sc . setSecureConnection ( true ) ; try { resp = this . sendDummyRequest ( ) ; } catch ( SSLException e ) { this . sc . setSecureConnection ( false ) ; } } return resp ; }
tr	5	private static int mixLightness ( int colour , int lightness , int drawType ) { if ( ( drawType & 2 ) == 2 ) { if ( lightness < 0 ) lightness = 0 ; else if ( lightness > 127 ) lightness = 127 ; lightness = 127 - lightness ; return lightness ; } lightness = lightness * ( colour & 7f ) >> 7 ; if ( lightness < 2 ) lightness = 2 ; else if ( lightness > 126 ) lightness = 126 ; return ( colour & ff80 ) + lightness ; }
tr	3	public List < VariableAppearance > getAltAppearances ( ParsingContext context ) { List < VariableAppearance > result = new ArrayList < VariableAppearance > ( ) ; for ( String variableName : detectedVariableNames ) { for ( int i = 0 ; i < altPrefixRegexps . size ( ) ; i ++ ) { String completeRegexp = altPrefixRegexps . get ( i ) + variableName + altSuffixRegexps . get ( i ) ; Matcher matcher = Pattern . compile ( completeRegexp ) . matcher ( context . getContent ( ) ) ; while ( matcher . find ( ) ) { result . add ( new VariableAppearance ( matcher . group ( ) , variableName , globalContext , context , "" ) ) ; } } } return result ; }
tr	8	@ Override protected void handleAttribute ( XMLStreamReader parser , int i ) { if ( parser . getAttributeLocalName ( i ) == "Font" ) { fontType = Font . decode ( parser . getAttributeValue ( i ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "FontColor" ) { fontColor = setColorKeepAlpha ( fontColor , Color . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "FontAlpha" ) { fontColor = setAlphaKeepColor ( fontColor , Integer . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "Opac" ) { opac = true ; return ; } if ( parser . getAttributeLocalName ( i ) == "BackgroundColor" ) { backgroundColor = setColorKeepAlpha ( backgroundColor , Color . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "BackgroundAlpha" ) { backgroundColor = setAlphaKeepColor ( backgroundColor , Integer . decode ( parser . getAttributeValue ( i ) ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "TextX" ) { TextX = Integer . decode ( parser . getAttributeValue ( i ) ) ; return ; } if ( parser . getAttributeLocalName ( i ) == "TextY" ) { TextY = Integer . decode ( parser . getAttributeValue ( i ) ) ; return ; } super . handleAttribute ( parser , i ) ; }
tr	3	private String findTag ( String text , String startToken , String endToken , int fromIndex ) { int startIndex = text . indexOf ( startToken , fromIndex ) ; int endIndex = text . indexOf ( endToken , startIndex ) ; if ( startIndex >= 0 && endIndex > 0 && endIndex > startIndex ) return text . substring ( startIndex , endIndex + endToken . length ( ) ) ; return null ; }
tr	5	public boolean isDefined ( ) { return ( this . x1 != null && this . x2 != null && this . y1 != null && this . y2 != null && this . z1 != null && this . z2 != null ) ; }
tr	0	public TitleImp ( ) { this . line = new LineImp ( this ) ; }
tr	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; PairImpl < ? > other = ( PairImpl < ? > ) obj ; return Tuples . equals ( _first , other . _first ) && Tuples . equals ( _second , other . _second ) ; }
tr	5	public void setGoalRandom ( ) { if ( this . goals . isEmpty ( ) ) { this . goal = null ; return ; } if ( this . randomGoals . isEmpty ( ) ) { this . randomGoals . addAll ( this . goals ) ; Collections . shuffle ( this . randomGoals , RANDOM ) ; } this . goal = this . randomGoals . remove ( 0 ) ; if ( this . goal . robotNumber >= this . robots . length ) { this . setGoalRandom ( ) ; } if ( this . isSolution01 ( ) && ( this . randomGoals . size ( ) > 0 ) ) { final Goal goal01 = this . goal ; this . setGoalRandom ( ) ; this . randomGoals . add ( goal01 ) ; } }
tr	2	public DecisionNode getBranch ( Game game ) { int i ; for ( i = 0 ; i < Game . NUM_GHOSTS ; i ++ ) { if ( game . isEdible ( i ) == true ) return this . trueNode ; } return this . falseNode ; }
tr	6	public String pillcaseSearch ( String pillId ) { String status = "" ; String payer = "" ; String pillAmount = "" ; String number = "" ; String pillName = "" ; String pillNum = "" ; String str = "select distinct pl.payer p.pill_num rl.status pl.pill_amount p.number p.pill_name from pill p pill_list pl recepit_list rl where pl.id='" + pillId + "' and  p.pill_num=pl.pill_id and rl.receipt_id=pl.id and rl.pillOrEquip='1' order by p.pill_name;" ; System . out . println ( "pillcaseSearch________________" + str ) ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; sb . append ( "<tr> <td>\u836F\u54C1\u540D\u79F0</td> <td>\u6570\u91CF</td> <td>\u5E93\u5B58\u6570\u91CF</td> </tr> " ) ; while ( num . next ( ) ) { pillNum = num . getString ( "pill_num" ) ; status = num . getString ( "status" ) ; payer = num . getString ( "payer" ) ; pillAmount = num . getString ( "pill_amount" ) ; number = num . getString ( "number" ) ; pillName = num . getString ( "pill_name" ) ; sb . append ( " <tr><td><input type=\"text\" value=\"" + pillName + "\" readonly><input type=\"text\" value=\"" + pillNum + "\" style=\"display:none\" name=\"pillid\"></td>" ) ; sb . append ( "<td><input type=\"text\" value=\"" + pillAmount + "\" name=\"pillAmount\" readonly> </td><td><input type=\"text\" value=\"" + number + "\" name=\"pillNum\" readonly></td></tr>" ) ; sb . append ( "<input type=\"text\"  value=\"" + pillId + "\" name=\"id\" style=\"display:none\">" ) ; } if ( status . equals ( "1" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u672A\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } else if ( status . equals ( "2" ) ) { sb . append ( "<tr> <td>\u4EA4\u6B3E\u72B6\u6001</td> <td colspan=\"2\"><input type=\"text\" value=\"\u5DF2\u4EA4\u6B3E\" readonly></td> </tr>" ) ; } if ( payer == null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u672A\u4ED8\u836F</td> </tr>" ) ; } else if ( payer != null ) { sb . append ( "<tr> <td>\u4ED8\u836F\u72B6\u6001</td> <td colspan=\"2\" id=\"fyzt\">\u5DF2\u4ED8\u836F</td> </tr>" ) ; } pstmt . close ( ) ; dbConn . close ( conn ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return sb . toString ( ) ; }
tr	2	public static void debug ( Connection con ) throws Exception { System . out . println ( "\nDUMP OF TABLE GEOLOC:" ) ; Statement stmt = con . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT geohash  subject  predicate  lat_lon_object  lat  lon FROM geoloc" ) ; while ( rs . next ( ) ) System . out . println ( "geoloc row: " + rs . getString ( "geohash" ) + " " + rs . getString ( "subject" ) + " " + rs . getString ( "predicate" ) + " " + rs . getString ( "lat_lon_object" ) + " " + rs . getFloat ( "lat" ) + " " + rs . getFloat ( "lon" ) ) ; System . out . println ( ) ; System . out . println ( "\nDUMP OF TABLE FREE TEXT PREDICATES:" ) ; stmt = con . createStatement ( ) ; rs = stmt . executeQuery ( "SELECT predicate FROM free_text_predicates" ) ; while ( rs . next ( ) ) System . out . println ( "free_text_predicates row: " + rs . getString ( "predicate" ) ) ; System . out . println ( ) ; }
tr	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Station station = ( Station ) o ; if ( id != station . id ) return false ; if ( name != null ? ! name . equals ( station . name ) : station . name != null ) return false ; return true ; }
tr	3	protected char [ ] move_array ( char [ ] array , int offset , boolean left ) { int total = array . length ; char [ ] new_array = new char [ total ] ; for ( int i = 0 ; i < total ; i ++ ) { int new_pos ; if ( ! left ) { new_pos = ( i + offset ) % total ; } else { new_pos = ( i - offset ) % total ; if ( new_pos < 0 ) { new_pos += total ; } } new_array [ new_pos ] = array [ i ] ; } return new_array ; }
tr	6	public static Integer valueOf ( Object o ) { if ( o == null ) { return null ; } else if ( o instanceof byte ) { return ( int ) ( byte ) o ; } else if ( o instanceof Integer ) { return ( Integer ) o ; } else if ( o instanceof double ) { return ( int ) ( double ) ( double ) o ; } else if ( o instanceof float ) { return ( int ) ( float ) ( float ) o ; } else if ( o instanceof long ) { return ( int ) ( long ) ( long ) o ; } else { return null ; } }
tr	4	public static void setPanelInsets ( UnitValue top , UnitValue left , UnitValue bottom , UnitValue right ) { if ( top != null ) PANEL_INS [ 0 ] = top ; if ( left != null ) PANEL_INS [ 1 ] = left ; if ( bottom != null ) PANEL_INS [ 2 ] = bottom ; if ( right != null ) PANEL_INS [ 3 ] = right ; MOD_COUNT ++ ; }
tr	6	public static Player fromXml ( org . w3c . dom . Node playerRoot , MonteCarloPlayer player ) { NamedNodeMap attrs = playerRoot . getAttributes ( ) ; player . description = "" ; if ( attrs . getNamedItem ( "playout" ) != null ) { try { Field field = PlayoutStrategy . class . getField ( attrs . getNamedItem ( "playout" ) . getNodeValue ( ) ) ; player . playout = ( PlayoutStrategy ) field . get ( null ) ; player . description += String . format ( "playout=%s" , field . getName ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "finalMove" ) != null ) { try { Field field = FinalNodeSelectionStrategy . class . getField ( attrs . getNamedItem ( "finalMove" ) . getNodeValue ( ) ) ; player . finalNode = ( FinalNodeSelectionStrategy ) field . get ( null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } if ( attrs . getNamedItem ( "maxTurnTime" ) != null ) { try { player . MAX_TURN_TIME = long . parseLong ( attrs . getNamedItem ( "maxTurnTime" ) . getNodeValue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } player . description = String . format ( "playout=%s final=%s" , player . playout , player . finalNode ) ; return player ; }
tr	5	ListNode parseList ( SeekableStringReader sr ) { sr . read ( ) ; sr . skipWhitespace ( ) ; ListNode list = new ListNode ( ) ; if ( sr . peek ( ) == ] ) { sr . read ( ) ; return list ; } list . elements = parseExprList ( sr ) ; sr . skipWhitespace ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; if ( sr . peek ( ) ==   ) sr . read ( ) ; if ( ! sr . hasMore ( ) ) throw new ParseException ( "missing ']'" ) ; char closechar = sr . read ( ) ; if ( closechar != ] ) throw new ParseException ( "expected ']'" ) ; return list ; }
tr	0	@ Override public MessageType getMessageType ( ) { return MessageType . EXITCHATROOM ; }
tr	7	private void readValues ( Stream stream ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; if ( j == 1 ) { anInt648 = stream . readUnsignedWord ( ) ; anInt649 = stream . readUnsignedByte ( ) ; anInt650 = stream . readUnsignedByte ( ) ; } else if ( j == 10 ) stream . readString ( ) ; else if ( j == 2 ) aBoolean651 = true ; else if ( j == 3 ) stream . readDWord ( ) ; else if ( j == 4 ) stream . readDWord ( ) ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
tr	4	private AVLNode rotateLeftRight ( AVLNode parent ) { AVLNode parentNode = parent ; AVLNode current = ( AVLNode ) parentNode . left ; AVLNode moveToTop = ( AVLNode ) current . right ; AVLNode LRL = ( AVLNode ) moveToTop . left ; AVLNode LRR = ( AVLNode ) moveToTop . right ; if ( parent . parent == null ) { this . overallRoot = moveToTop ; ; moveToTop . parent = null ; } else if ( parent . parent . left == parent ) { parent . parent . left = moveToTop ; moveToTop . parent = parent . parent ; } else { parent . parent . right = moveToTop ; moveToTop . parent = parent . parent ; } current . right = LRL ; if ( LRL != null ) { LRL . parent = current ; } parent . left = LRR ; if ( LRR != null ) { LRR . parent = parent ; } moveToTop . left = current ; moveToTop . right = parent ; current . parent = moveToTop ; parent . parent = moveToTop ; return moveToTop ; }
tr	8	@ Override public void run ( ) { repaint ( ) ; }
tr	0	public int getSize ( ) { return this . slots . length ; }
tr	4	@ Override public void visit ( FSP_OrSplit g ) { dot_program . append ( "\tstruct_" + g . name ( ) + " [color=red  label=\"{" + g . name ( ) + "| OR_SPLIT }|{" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String s = g . all_names ( ) . get ( i ) ; dot_program . append ( "<" + s + "> " + s ) ; if ( i != g . all_names ( ) . size ( ) - 1 ) { dot_program . append ( "|" ) ; } } dot_program . append ( "}\"];\n" ) ; for ( int i = 0 ; i < g . all_names ( ) . size ( ) ; i ++ ) { String nm = g . all_names ( ) . get ( i ) ; FSPLink l = g . get_link ( nm ) ; if ( l != null ) { dot_program . append ( "\tstruct_" + g . name ( ) + ":" + nm + "->" + l . name ( ) + ";\n" ) ; } } }
tr	3	private int compareInputStreams ( InputStream encfsIs , InputStream decFsIs , String decodedFsFileName ) throws IOException { int bytesRead = 0 ; int bytesRead2 ; while ( bytesRead >= 0 ) { byte [ ] readBuf = new byte [ 128 ] ; byte [ ] readBuf2 = new byte [ 128 ] ; bytesRead = encfsIs . read ( readBuf ) ; bytesRead2 = decFsIs . read ( readBuf2 ) ; if ( bytesRead != bytesRead2 ) { logger . error ( "File bytes read missmatch {} ({}  {})" , new Object [ ] { decodedFsFileName , bytesRead , bytesRead2 } ) ; return - 1 ; } if ( ! Arrays . equals ( readBuf , readBuf2 ) ) { logger . error ( "File bytes missmatch {}" , decodedFsFileName ) ; return - 1 ; } } return 0 ; }
tr	6	public void run ( ) { Message m = Parser . extractRequest ( fromClient ) ; Node child = m . contents . getFirstChild ( ) ; if ( ! child . getLocalName ( ) . equals ( Parser . connectRequest ) ) { return ; } System . out . println ( "Receiving: " + m ) ; String xmlString = Message . responseHeader ( m . id ( ) ) + "<connectResponse id='" + id + "'/></response>" ; Message r = new Message ( xmlString ) ; if ( ! sendMessage ( r ) ) { System . err . println ( "Unable to respond to connect Request from remote Client." ) ; return ; } Server . register ( id , this ) ; while ( ( m = Parser . extractRequest ( fromClient ) ) != null ) { Message response = handler . process ( this , m ) ; if ( ! sendMessage ( response ) ) { break ; } } if ( handler instanceof IShutdownHandler ) { ( ( IShutdownHandler ) handler ) . logout ( Server . getState ( id ) ) ; } Server . unregister ( id ) ; try { fromClient . close ( ) ; toClient . close ( ) ; client . close ( ) ; } catch ( IOException e ) { System . err . println ( "Unable to close connection:" + e . getMessage ( ) ) ; } }
tr	9X	@ Override public void handleCommand ( CommandMessage m ) { String [ ] args = m . getArgs ( ) ; if ( args . length == 1 ) { String nick = m . getNick ( ) ; if ( pozdravy . containsKey ( nick ) ) { ph . sendMessage ( nick + ": " + pozdravy . get ( nick ) ) ; } } else if ( args . length < 3 ) { if ( pozdravy . containsKey ( args [ 1 ] ) ) { ph . sendMessage ( args [ 1 ] + ": " + pozdravy . get ( args [ 1 ] ) ) ; } } else if ( args [ 1 ] . equals ( "set" ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 3 ; i < args . length ; i ++ ) { sb . append ( args [ i ] ) ; sb . append (   ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; pozdravy . put ( args [ 2 ] , sb . toString ( ) ) ; try { ph . saveData ( pozdravy ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else if ( args [ 1 ] . equals ( "reset" ) ) { pozdravy . remove ( args [ 2 ] ) ; try { ph . saveData ( pozdravy ) ; ph . sendMessage ( "Pozdrav pro " + args [ 2 ] + " byl zru\u0161en" ) ; } catch ( IOException ex ) { logger . warn ( "Pozdravy couldn't be saved." , ex ) ; } } else { ph . sendMessage ( this . help ( ph . getPrefix ( ) ) ) ; } }
tr	3	public static void filledCircle ( double x , double y , double r ) { if ( r < 0 ) throw new IllegalArgumentException ( "circle radius must be nonnegative" ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( 2 * r ) ; double hs = factorY ( 2 * r ) ; if ( ws <= 1 && hs <= 1 ) pixel ( x , y ) ; else offscreen . fill ( new Ellipse2D . double ( xs - ws / 2 , ys - hs / 2 , ws , hs ) ) ; draw ( ) ; }
tr	4	public static String substring ( String origin , String begin , String end ) { if ( origin == null ) { return origin ; } int beginIndex = begin == null ? 0 : origin . indexOf ( begin ) + begin . length ( ) ; int endIndex = end == null ? origin . length ( ) : origin . indexOf ( end , beginIndex ) ; if ( endIndex == - 1 ) { return origin . substring ( beginIndex ) ; } return origin . substring ( beginIndex , endIndex ) ; }
tr	6	@ Override public void doTurn ( ) { getLocation ( ) . world . clearTileVisibility ( ) ; for ( int y = getLocation ( ) . y + getViewDistance ( ) ; y >= getLocation ( ) . y - getViewDistance ( ) ; y -- ) { int deltaX = getViewDistance ( ) - Math . abs ( y - getLocation ( ) . y ) ; for ( int x = getLocation ( ) . x + deltaX ; x >= getLocation ( ) . x - deltaX ; x -- ) { if ( AIController . checkVisibility ( getLocation ( ) , new WorldLocation ( null , x , y ) ) ) { getLocation ( ) . world . setTileVisible ( x , y , true ) ; } if ( new WorldLocation ( getLocation ( ) . world , x , y ) . getTile ( ) instanceof TileSecretDoor ) { int chance = 30 - getStats ( ) . getIntelligence ( ) ; if ( chance <= 0 || new Random ( ) . nextInt ( chance ) == 0 ) { logMessage ( "Something about one of the walls nearby seems off to you" ) ; } } } } }
tr	8	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d == direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) ? - double . MAX_VALUE : double . MAX_VALUE ; } else if ( d == 0 ) { return ( direction < 0 ) ? - double . MIN_VALUE : double . MIN_VALUE ; } final long bits = double . doubleToLongBits ( d ) ; final long sign = bits & 8000000000000000 ; if ( ( direction < d ) ^ ( sign == 0 ) ) { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) + 1 ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
tr	7	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<Location" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</Location>\n" ; } return kml ; }
tr	5	@ Override public void mousePressed ( MouseEvent me ) { int w = gridRenderer . getWidth ( ) / gridColumns ; int col = me . getX ( ) / w ; int h = gridRenderer . getHeight ( ) / gridRows ; int row = me . getY ( ) / h ; int value = grid [ col ] [ row ] ; if ( me . getButton ( ) == MouseEvent . BUTTON1 ) { if ( tilesRemaining > 0 ) { value ++ ; tilesRemaining -- ; } if ( tilesRemaining == 0 ) { saveAsButton . setEnabled ( true ) ; } } else if ( me . getButton ( ) == MouseEvent . BUTTON3 ) { if ( value > 0 ) { value -- ; tilesRemaining ++ ; saveAsButton . setEnabled ( false ) ; } } grid [ col ] [ row ] = value ; updateTilesRemainingLabel ( ) ; gridRenderer . repaint ( ) ; }
tr	7	@ Override public void rightMultiply ( Matrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	7	public CardCertificatesPane ( boolean ca , ActionListener listener ) { super ( ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; double w = c . weightx ; c . insets = new Insets ( 5 , 0 , 5 , 10 ) ; JButton button = null ; String label = null ; baseIndex = ca ? 0 : 3 ; clearButtons = new JButton [ 3 ] ; viewButtons = new JButton [ 3 ] ; certNames = new JTextField [ 3 ] ; if ( ! ca ) { verifyButtons = new JButton [ 3 ] ; verifyFlags = new JTextField [ 3 ] ; } totalCerts = ca ? 1 : 3 ; for ( int i = 0 ; i < totalCerts ; i ++ ) { c . gridx = 0 ; c . gridy = i ; c . weightx = w ; c . fill = GridBagConstraints . NONE ; c . anchor = GridBagConstraints . EAST ; if ( ca ) { label = "CA Cert" ; } else { label = ulabels [ i ] + " Cert" ; } add ( new JLabel ( label + ":" ) , c ) ; c . anchor = GridBagConstraints . WEST ; c . gridx ++ ; button = new JButton ( "Get from Card" ) ; button . setActionCommand ( "cardgetcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "Load..." ) ; button . setActionCommand ( "loadcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; certNames [ i ] = new JTextField ( 30 ) ; certNames [ i ] . setFont ( MainGUI . FONT ) ; certNames [ i ] . setEditable ( false ) ; components . add ( certNames [ i ] ) ; add ( certNames [ i ] , c ) ; c . gridx ++ ; button = new JButton ( "Clear" ) ; button . setActionCommand ( "clearcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; clearButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; button = new JButton ( "View" ) ; button . setActionCommand ( "viewcardcert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; components . add ( button ) ; viewButtons [ i ] = button ; add ( button , c ) ; if ( ! ca ) { c . gridx ++ ; button = new JButton ( "Verify" ) ; button . setActionCommand ( "verifycert" + ( baseIndex + i ) ) ; button . addActionListener ( listener ) ; verifyButtons [ i ] = button ; components . add ( button ) ; add ( button , c ) ; c . gridx ++ ; verifyFlags [ i ] = new JTextField ( 6 ) ; verifyFlags [ i ] . setFont ( MainGUI . FONT ) ; verifyFlags [ i ] . setEditable ( false ) ; components . add ( verifyFlags [ i ] ) ; add ( verifyFlags [ i ] , c ) ; } c . gridx ++ ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; add ( new JLabel ( ) , c ) ; } updateCertsStatus ( ) ; setBorder ( BorderFactory . createTitledBorder ( ( ca ? "CA" : "User" ) + " Certificates" ) ) ; }
tr	7	void prune ( File [ ] files ) { int size = 0 ; for ( File file : files ) { if ( file . isFile ( ) && ! file . getName ( ) . equals ( "FAT" ) ) { size += file . length ( ) ; } } int cnt = 0 ; int limit = Globals . getCacheLimit ( ) ; while ( size > limit && cnt < files . length ) { File current = files [ cnt ++ ] ; if ( current . isFile ( ) && ! current . getName ( ) . equals ( "FAT" ) ) { size -= current . length ( ) ; current . delete ( ) ; } } fileUse . set ( size ) ; updateGUIDisk ( ) ; }
tr	4	public void printBoard ( ) { int rowEnd = g . getBoard ( ) . numRows ; int colEnd = g . getBoard ( ) . numColumns ; System . out . println ( "{" ) ; for ( int j = 0 ; j < rowEnd ; j ++ ) { System . out . print ( "{ " ) ; for ( int i = 0 ; i < colEnd ; i ++ ) { System . out . printf ( "%1d " , g . getBoard ( ) . getGameGrid ( ) [ i ] [ j ] . getState ( ) ) ; if ( ! ( i == colEnd - 1 ) ) { System . out . print ( " " ) ; } } System . out . print ( " }" ) ; if ( ! ( j == rowEnd - 1 ) ) { System . out . println ( " " ) ; } else { System . out . println ( ) ; } } System . out . println ( "}" ) ; }
tr	6	public String next ( int n ) throws JSONException { if ( n == 0 ) { return "" ; } char [ ] buffer = new char [ n ] ; int pos = 0 ; if ( this . useLastChar ) { this . useLastChar = false ; buffer [ 0 ] = this . lastChar ; pos = 1 ; } try { int len ; while ( ( pos < n ) && ( ( len = reader . read ( buffer , pos , n - pos ) ) != - 1 ) ) { pos += len ; } } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . index += pos ; if ( pos < n ) { throw syntaxError ( "Substring bounds error" ) ; } this . lastChar = buffer [ n - 1 ] ; return new String ( buffer ) ; }
tr	6	public void advance ( ) { timeUntilNext -- ; if ( timeUntilNext <= 0 ) { stoppingAt ( ) ; if ( ! reverse && nextStation . getNext ( ) == null ) { reverse = true ; timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; return ; } if ( reverse && nextStation . getPrev ( ) == null ) { reverse = false ; timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; return ; } if ( reverse ) { timeUntilNext = nextStation . getPrevTime ( ) ; nextStation = nextStation . getPrev ( ) ; } else { timeUntilNext = nextStation . getNextTime ( ) ; nextStation = nextStation . getNext ( ) ; } } }
tr	4	@ Override public void write ( byte [ ] data , int offset , int length ) throws IOException { if ( data == null ) throw new IllegalArgumentException ( "data cannot be null" ) ; if ( offset < 0 || length < 0 || ( offset + length ) > data . length ) throw new IllegalArgumentException ( "offset [" + offset + "] and length [" + length + "] must be >= 0 and (offset + length)[" + ( offset + length ) + "] must be <= data.length [" + data . length + "]" ) ; ensureCapacity ( i + length ) ; System . arraycopy ( data , offset , bbuffer , i , length ) ; i += length ; }
tr	8	public DescribeServiceCertificatesResult unmarshall ( StaxUnmarshallerContext context ) throws Exception { DescribeServiceCertificatesResult describeServiceCertificatesResult = new DescribeServiceCertificatesResult ( ) ; int originalDepth = context . getCurrentDepth ( ) ; int targetDepth = originalDepth + 1 ; if ( context . isStartOfDocument ( ) ) targetDepth += 1 ; while ( true ) { XMLEvent xmlEvent = context . nextEvent ( ) ; if ( xmlEvent . isEndDocument ( ) ) return describeServiceCertificatesResult ; if ( xmlEvent . isAttribute ( ) || xmlEvent . isStartElement ( ) ) { if ( context . testExpression ( "serviceCertificates/item" , targetDepth ) ) { describeServiceCertificatesResult . getServiceCertificates ( ) . add ( ServiceCertificateStaxUnmarshaller . getInstance ( ) . unmarshall ( context ) ) ; continue ; } } else if ( xmlEvent . isEndElement ( ) ) { if ( context . getCurrentDepth ( ) < originalDepth ) { return describeServiceCertificatesResult ; } } } }
tr	9X	@ Override public void run ( ) { try { while ( Settling . this . running ) { Thread . sleep ( 1 ) ; } } catch ( InterruptedException e ) { } }
tr	4	protected String getJarName ( URL url ) { String fileName = url . getFile ( ) ; if ( fileName . contains ( "?" ) ) { fileName = fileName . substring ( 0 , fileName . indexOf ( "?" ) ) ; } if ( fileName . endsWith ( ".pack.lzma" ) ) fileName = fileName . replaceAll ( ".pack.lzma" , "" ) ; else if ( fileName . endsWith ( ".pack" ) ) fileName = fileName . replaceAll ( ".pack" , "" ) ; else if ( fileName . endsWith ( ".lzma" ) ) { fileName = fileName . replaceAll ( ".lzma" , "" ) ; } return fileName . substring ( fileName . lastIndexOf ( / ) + 1 ) ; }
tr	1	public static void main ( String [ ] args ) { try { AppGameContainer app = new AppGameContainer ( new Application ( ) ) ; app . setDisplayMode ( SCREEN_WIDTH , SCREEN_HEIGHT , false ) ; app . start ( ) ; } catch ( SlickException e ) { e . printStackTrace ( ) ; } }
tr	1	private BigInteger selfPowers ( int n ) { Preconditions . checkArgument ( n > 0 ) ; BigInteger acc = BigInteger . ZERO ; for ( int i = 1 ; i <= n ; i ++ ) { acc = acc . add ( BigInteger . valueOf ( i ) . pow ( i ) ) ; } return acc ; }
tr	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( UpadateApplicationJFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new UpadateApplicationJFrame ( ) . setVisible ( true ) ; } } ) ; }
tr	3	public NodeUnion ( Link [ ] links ) { if ( links == null || links . length < 2 || links . length > 4 ) { throw new IllegalArgumentException ( "Links size must be >=2 and <=4" ) ; } this . links = links ; }
tr	3	@ Override public void mouseReleased ( MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 ) { tableDoubleClick ( "Employee" ) ; } if ( _view . table_employee . isRowSelected ( _view . table_employee . getSelectedRow ( ) ) ) { if ( evt . getButton ( ) == MouseEvent . BUTTON3 ) { Integer integer = ( Integer ) _view . table_employee . getValueAt ( _view . table_employee . getSelectedRow ( ) , 0 ) ; int rowNumber = _view . table_employee . rowAtPoint ( evt . getPoint ( ) ) ; _view . table_employee . getSelectionModel ( ) . setSelectionInterval ( rowNumber , rowNumber ) ; showPopup ( evt , integer , "Employee" ) ; } } }
tr	6	LatexExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } mFamilyLabel = new JLabel ( "Name" ) ; mFamilyLabel . setHorizontalAlignment ( JLabel . RIGHT ) ; mFamilyField = new JTextField ( "" ) ; mNoticeLabel = new JLabel ( "Note that Latex maps \"\\textbf\"\nto BOLD_EXTENDED  not BOLD." ) ; add ( mFamilyLabel ) ; add ( mFamilyField ) ; add ( mNoticeLabel ) ; mFontStacker = new ComponentStacker ( ) ; mFontStacker . setStackDirection ( ComponentStacker . STACK_VERTICAL ) ; mFontStacker . setStretch ( true ) ; mFontStacker . setMargins ( 0 , 0 ) ; mFontStacker . setBorder ( BorderFactory . createTitledBorder ( "Fonts" ) ) ; mFontStacker . setBackground ( Color . WHITE ) ; add ( mFontStacker ) ; int i = 0 ; mFontPanels = new ArrayList < FontPanel > ( ) ; for ( FontHandle f : fonts ) { FontPanel p = new FontPanel ( f ) ; p . setSize ( 50 , 75 ) ; if ( i ++ % 2 == 0 ) { p . setBackground ( Palette . ODD_COLOR ) ; } else { p . setBackground ( Palette . EVEN_COLOR ) ; } mFontStacker . add ( p ) ; mFontPanels . add ( p ) ; } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mCancelButton = new JButton ( "Cancel" ) ; mOkButton = new JButton ( "OK" ) ; add ( mCancelButton ) ; add ( mOkButton ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; mOkButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doOkay ( ) ; } } ) ; setLayout ( new Layout ( ) ) ; setOpaque ( true ) ; mDialog = new JDialog ( ( Window ) parent , "Configure Tex Typeface" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 550 , 650 ) ; mDialog . setLocationRelativeTo ( null ) ; mDialog . setVisible ( true ) ; }
tr	4	public static boolean readUsers ( DecisionLineEvent readEvent , int playableEdges ) { if ( ! isConnected ( ) ) if ( ! connect ( ) ) { System . out . println ( "Error  database connection could not be created" ) ; System . exit ( 0 ) ; } try { PreparedStatement pstmt = getConnection ( ) . prepareStatement ( "SELECT userName  userPassword  position from user where eventId=(?) ORDER BY position ASC" ) ; pstmt . setString ( 1 , readEvent . getUniqueId ( ) ) ; ResultSet myRS = pstmt . executeQuery ( ) ; User newUser ; String name , password ; int position ; while ( myRS . next ( ) ) { name = new String ( myRS . getString ( "userName" ) ) ; password = new String ( myRS . getString ( "userPassword" ) ) ; position = myRS . getInt ( "position" ) ; newUser = new User ( name , password , position , playableEdges ) ; readEvent . getUsers ( ) . add ( newUser ) ; } return true ; } catch ( SQLException e ) { System . out . println ( "error executing SQL statement!" ) ; } return false ; }
tr	0	static Date getTimeWarp ( ) { return timeWarp ; }
tr	4	@ Test public void testNaissanceSoldats ( ) { SalleSoldat testSoldat = new SalleSoldat ( ) ; SalleNourrice sn = new SalleNourrice ( ) ; Evenements . getInstance ( ) . setEvenementActif ( Constantes . EVEN_DEPLACEMENT ) ; sn . ajouterFourmi ( 3 ) ; testSoldat . naissanceSoldats ( 2 , sn ) ; assertEquals ( 1 , testSoldat . getNbCourantFourmi ( ) ) ; assertEquals ( 1 , sn . getNbCourantFourmi ( ) ) ; try { testSoldat . naissanceSoldats ( 2 , sn ) ; fail ( "ExceptionNourrices non levee." ) ; } catch ( ExceptionNourrices en ) { } try { testSoldat . naissanceSoldats ( 0 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 1 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } try { testSoldat . naissanceSoldats ( 5 , sn ) ; fail ( "IllegalArgumentException non levee." ) ; } catch ( IllegalArgumentException iae ) { } }
tr	2	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; HTTPTokener x = new HTTPTokener ( string ) ; String token ; token = x . nextToken ( ) ; if ( token . toUpperCase ( ) . startsWith ( "HTTP" ) ) { jo . put ( "HTTP-Version" , token ) ; jo . put ( "Status-Code" , x . nextToken ( ) ) ; jo . put ( "Reason-Phrase" , x . nextTo (  ) ) ; x . next ( ) ; } else { jo . put ( "Method" , token ) ; jo . put ( "Request-URI" , x . nextToken ( ) ) ; jo . put ( "HTTP-Version" , x . nextToken ( ) ) ; } while ( x . more ( ) ) { String name = x . nextTo ( : ) ; x . next ( : ) ; jo . put ( name , x . nextTo (  ) ) ; x . next ( ) ; } return jo ; }
tr	1	@ Override public void windowClosing ( WindowEvent e ) { if ( ClientFrame . this . client . isConnected ( ) ) { ClientFrame . this . client . disconnect ( ) ; } }
tr	9X	public Card [ ] pickCards ( SelectCardOptions sco , Card [ ] allcards ) { GameQuery p = new GameQuery ( QueryType . GETCARD , QueryType . CARD ) . setObject ( sco ) ; p = query ( p ) ; if ( p == null ) return null ; if ( p . t != QueryType . CARD ) return null ; if ( p . o instanceof Card [ ] || p . o instanceof String [ ] ) { String [ ] selected ; if ( p . o instanceof Card [ ] ) { ArrayList < String > a = new ArrayList < String > ( ) ; for ( Card c : ( Card [ ] ) p . o ) a . add ( c . getName ( ) ) ; selected = a . toArray ( new String [ 0 ] ) ; } else selected = ( String [ ] ) p . o ; ArrayList < Card > ret = new ArrayList < Card > ( ) ; ArrayList < Card > all = new ArrayList < Card > ( Arrays . asList ( allcards ) ) ; for ( int i = 0 ; i < selected . length ; i ++ ) { for ( int j = 0 ; j < all . size ( ) ; j ++ ) { if ( all . get ( j ) . equals ( selected [ i ] ) ) { ret . add ( all . get ( j ) ) ; all . remove ( j ) ; break ; } } } return ret . toArray ( new Card [ 0 ] ) ; } return null ; }
tr	5	protected String getNestedUsage ( String [ ] args , int level , Method method , T player ) throws CommandException { StringBuilder command = new StringBuilder ( ) ; command . append ( "/" ) ; for ( int i = 0 ; i <= level ; ++ i ) { command . append ( args [ i ] + " " ) ; } Map < String , Method > map = commands . get ( method ) ; boolean found = false ; command . append ( "<" ) ; Set < String > allowedCommands = new HashSet < String > ( ) ; for ( Map . Entry < String , Method > entry : map . entrySet ( ) ) { Method childMethod = entry . getValue ( ) ; found = true ; if ( hasPermission ( childMethod , player ) ) { Command childCmd = childMethod . getAnnotation ( Command . class ) ; allowedCommands . add ( childCmd . aliases ( ) [ 0 ] ) ; } } if ( allowedCommands . size ( ) > 0 ) { command . append ( StringUtil . joinString ( allowedCommands , "|" , 0 ) ) ; } else { if ( ! found ) { command . append ( "?" ) ; } else { throw new CommandPermissionsException ( ) ; } } command . append ( ">" ) ; return command . toString ( ) ; }
tr	4	@ Override public void keyPressed ( KeyEvent e ) { int curKeys = e . getKeyCode ( ) ; if ( location == "Map" && movable == true ) { p . setKeyPress ( curKeys ) ; } if ( location == "Encounter" && movable == true ) { enc . setKeyPress ( curKeys ) ; clicked = true ; } }
tr	1	@ Override public Hotel get ( String nom ) throws Exception { Session session = null ; Hotel hotel = null ; try { session = HibernateUtil . getSessionFactory ( ) . getCurrentSession ( ) ; session . beginTransaction ( ) ; hotel = ( Hotel ) session . get ( Hotel . class , nom ) ; } catch ( RuntimeException e ) { session . getTransaction ( ) . rollback ( ) ; throw new Exception ( "hotelNoExisteix" ) ; } return hotel ; }
tr	7	public void __doGet ( HttpServletRequest req , HttpServletResponse resp ) throws IOException , ServletException { Context ctx = ( Context ) req . getSession ( ) . getAttribute ( Authtoken . TOKEN ) ; if ( ctx == null ) { ctx = new Context ( ) ; } String questionId = new String ( ) ; if ( req . getPathInfo ( ) != null ) { questionId = "/" + Question . RESOURCE_NAME + "/" + req . getPathInfo ( ) . replaceAll ( "/" , "" ) ; } if ( ! questionId . equals ( "" ) ) { Message request = new Message ( ctx ) ; request . put ( Question . ID , questionId ) ; Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; Message profileReq = new Message ( ctx ) ; Message profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , response . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; response . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; List < Map < String , String >> answers = new ArrayList < Map < String , String >> ( ) ; Message answerResp , voteResp ; for ( Map < String , String > ref : response . getReferences ( Question . ANSWERS ) ) { request = new Message ( ctx ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; answerResp = new Message ( ctx ) ; new AnswerService ( ) . doGet ( request , answerResp ) ; Map < String , String > answer = new HashMap < String , String > ( ) ; answer . put ( Answer . ID , answerResp . get ( Answer . ID ) ) ; answer . put ( Answer . CONTENT , answerResp . get ( Answer . CONTENT ) ) ; answer . put ( Answer . VOTES , answerResp . get ( Answer . VOTES ) ) ; answer . put ( Document . AUTHOR , answerResp . get ( Document . AUTHOR ) ) ; answer . put ( System . TIMESTAMP , answerResp . get ( System . TIMESTAMP ) ) ; profileReq = new Message ( ctx ) ; profileResp = new Message ( ctx ) ; profileReq . put ( Profile . ID , answerResp . get ( Document . AUTHOR ) ) ; new ProfileService ( ) . doGet ( profileReq , profileResp ) ; answer . put ( Profile . FULL_NAME , profileResp . get ( Profile . FULL_NAME ) ) ; if ( ctx != null ) { request = new Message ( ctx ) ; request . put ( Profile . ID , ctx . getLoggedInUserProfileId ( ) ) ; request . put ( Answer . ID , ref . get ( Answer . ID ) ) ; voteResp = new Message ( ctx ) ; new VoteService ( ) . doGet ( request , voteResp ) ; if ( voteResp . containsField ( Vote . ID ) ) { answer . put ( Vote . ID , voteResp . get ( Vote . ID ) ) ; answer . put ( Vote . VOTE , voteResp . get ( Vote . VOTE ) ) ; } } answers . add ( answer ) ; } req . setAttribute ( Answer . RESOURCE_NAME , answers ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , Question . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "View Question" ) ; eventRequest . put ( Event . OBJECT , questionId ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_VIEW , req , resp ) ; } else { Message request = new Message ( ctx ) ; if ( req . getParameter ( QuestionSearchIndex . QUERY_STRING ) != null ) { request . put ( QuestionSearchIndex . QUERY_STRING , req . getParameter ( QuestionSearchIndex . QUERY_STRING ) ) ; } else { request . put ( QuestionSearchIndex . QUERY_STRING , "" ) ; } Message response = new Message ( ctx ) ; new QuestionService ( ) . doGet ( request , response ) ; response . put ( QuestionSearchIndex . QUERY_STRING , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; req . setAttribute ( Question . RESOURCE_NAME , response ) ; Message eventRequest = new Message ( request . getContext ( ) ) ; eventRequest . put ( Event . DOCUMENT_TYPE , QuestionSearchIndex . RESOURCE_NAME ) ; eventRequest . put ( Event . TYPE , "GET" ) ; eventRequest . put ( Event . DESCRIPTION , "Search Question" ) ; eventRequest . put ( Event . OBJECT , request . get ( QuestionSearchIndex . QUERY_STRING ) ) ; eventRequest . put ( Event . USER , ctx . getLoggedInUserProfileId ( ) ) ; eventRequest . put ( Event . TIMESTAMP , request . get ( System . TIMESTAMP ) ) ; EventPublisherService pub = new EventPublisherService ( ) ; pub . doPost ( eventRequest , response ) ; super . forward ( QUESTION_SEARCH_VIEW , req , resp ) ; } }
tr	5	public static void print ( JTextComponent textComponent ) throws TextComponentUtilException { InputStream is = null ; try { PrintService [ ] printServices = PrintServiceLookup . lookupPrintServices ( DocFlavor . INPUT_STREAM . AUTOSENSE , null ) ; if ( printServices . length > 0 ) { PrintRequestAttributeSet printRequestAttributeSet = new HashPrintRequestAttributeSet ( ) ; printRequestAttributeSet . add ( new JobName ( "JAligner" , null ) ) ; PrintService service = ServiceUI . printDialog ( null , 50 , 50 , printServices , PrintServiceLookup . lookupDefaultPrintService ( ) , DocFlavor . INPUT_STREAM . AUTOSENSE , printRequestAttributeSet ) ; if ( service != null ) { DocPrintJob printJob = service . createPrintJob ( ) ; PrintJobMointor printJobMointor = new PrintJobMointor ( printJob ) ; is = new ByteArrayInputStream ( textComponent . getText ( ) . getBytes ( ) ) ; DocumentName documentName = new DocumentName ( "JAligner" , null ) ; HashDocAttributeSet docAttributeSet = new HashDocAttributeSet ( ) ; docAttributeSet . add ( documentName ) ; Doc doc = new SimpleDoc ( is , DocFlavor . INPUT_STREAM . AUTOSENSE , docAttributeSet ) ; printJob . print ( doc , printRequestAttributeSet ) ; printJobMointor . waitForPrintJob ( ) ; } } else { throw new TextComponentUtilException ( "No print service found!" ) ; } } catch ( Exception e ) { throw new TextComponentUtilException ( e . getMessage ( ) ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { logger . log ( Level . WARNING , "Failed closing input stream: " + e . getMessage ( ) , e ) ; } } } }
tr	1	private static void createList ( String tabName , final Vector < Chart > charts , TabFolder tabFolder , final StackLayout layout , final Composite composite ) { final List list = new List ( tabFolder , SWT . H_SCROLL | SWT . V_SCROLL ) ; TabItem basicTabItem = new TabItem ( tabFolder , SWT . NONE ) ; basicTabItem . setText ( tabName ) ; basicTabItem . setControl ( list ) ; for ( Chart chart : charts ) { list . add ( chart . getTitle ( ) . getText ( ) ) ; } list . addSelectionListener ( new SelectionAdapter ( ) { @ Override public void widgetSelected ( SelectionEvent event ) { Chart chart = charts . get ( list . getSelectionIndex ( ) ) ; chart . getAxisSet ( ) . adjustRange ( ) ; layout . topControl = chart ; composite . layout ( ) ; } } ) ; }
tr	0	public UnitOfWork with ( Object [ ] contextObjectArray ) { this . ctx = new business . Context ( contextObjectArray ) ; return this ; }
tr	8	public static Mineral find ( int remoteId ) { switch ( remoteId ) { case 34 : return Tritanium ; case 35 : return Pyerite ; case 36 : return Mexallon ; case 37 : return Isogen ; case 38 : return Nocxium ; case 39 : return Zydrine ; case 40 : return Megacyte ; case 11399 : return Morphite ; default : { throw new RuntimeException ( "Id does not represent mineral" ) ; } } }
tr	1	public static void main ( String [ ] args ) { int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) { processCase ( i + 1 ) ; } }
tr	7	protected void action ( Source source , Map < String , Object > map , int i ) throws Exception { log . debug ( String . format ( "Loop [%s] step %d." , getName ( ) , i ) ) ; map . put ( "position" , i ) ; if ( source != null ) { map . put ( "value" , source . pickOne ( "value" , "base" ) ) ; } if ( getBeforeAction ( ) == null || getBeforeAction ( ) . invoke ( getContext ( ) , this , i ) ) { for ( Insert insert : getInserts ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  insert %s" , getName ( ) , i , insert . getName ( ) ) ) ; insert . execute ( ) ; } for ( Loop loop : getLoops ( ) ) { log . debug ( String . format ( "Loop [%s] step %d  loop %s" , getName ( ) , i , loop . getName ( ) ) ) ; loop . execute ( ) ; } if ( getAction ( ) != null ) { getAction ( ) . invoke ( getContext ( ) , this , i ) ; } if ( getAfterAction ( ) != null ) { getAfterAction ( ) . invoke ( getContext ( ) , this , i ) ; } } }
tr	9X	private String rec ( String S , String A , String B , int a , int b ) { if ( a == A . length ( ) && b == B . length ( ) ) return "" ; if ( visited [ a ] [ b ] ) return memo [ a ] [ b ] ; String res = null ; int cur = S . length ( ) - ( A . length ( ) - a ) - ( B . length ( ) - b ) ; if ( a < A . length ( ) && matches ( S . charAt ( cur ) , A . charAt ( a ) ) ) { String best = rec ( S , A , B , a + 1 , b ) ; if ( best != null ) { if ( res == null || res . compareTo ( A . charAt ( a ) + best ) > 0 ) res = A . charAt ( a ) + best ; System . out . println ( res ) ; } } if ( b < B . length ( ) && matches ( S . charAt ( cur ) , B . charAt ( b ) ) ) { String best = rec ( S , A , B , a , b + 1 ) ; if ( best != null ) { if ( res == null || res . compareTo ( B . charAt ( b ) + best ) > 0 ) res = B . charAt ( b ) + best ; System . out . println ( res ) ; } } memo [ a ] [ b ] = res ; visited [ a ] [ b ] = true ; return res ; }
tr	2	private void exiting ( ) { if ( connectionHandler != null && connectionHandler . isConnected ( ) ) connectionHandler . disconnect ( ) ; }
tr	7	@ Test public void testNavigateShowDescending ( ) { for ( int i = MockFileSystem . NUM_SEASONS ; i > 0 ; i -- ) { for ( int j = MockFileSystem . NUM_EPISODES ; j > 0 ; j -- ) { int season = ( j == 1 ) ? i - 1 : i ; int expEp = ( j == 1 ) ? MockFileSystem . NUM_EPISODES : j - 1 ; EpisodeMatch toNavigate = new EpisodeMatch ( "Scrubs" , i , j ) ; EpisodeMatch expResult = new EpisodeMatch ( season , expEp ) ; EpisodeMatch result = episode . navigate ( toNavigate , EpisodeNavigator . Pointer . PREV ) ; if ( result == null && i == 1 && j == 1 ) { return ; } System . out . println ( "Navigating: " + toNavigate + " : to : " + expResult ) ; assertEquals ( expResult . getSeason ( ) , result . getSeason ( ) ) ; assertEquals ( expResult . getEpisodes ( ) , result . getEpisodes ( ) ) ; } } }
tr	1	public final ProgramaContext programa ( ) throws RecognitionException { ProgramaContext _localctx = new ProgramaContext ( _ctx , getState ( ) ) ; enterRule ( _localctx , 0 , RULE_programa ) ; try { enterOuterAlt ( _localctx , 1 ) ; { setState ( 10 ) ; seqComando ( ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	9X	public static void arraycopy ( final float [ ] src , final int srcPos , final FloatLargeArray dest , final long destPos , final long length ) { if ( srcPos < 0 || srcPos >= src . length ) { throw new ArrayIndexOutOfBoundsException ( "srcPos < 0 || srcPos >= src.length" ) ; } if ( destPos < 0 || destPos >= dest . length ( ) ) { throw new ArrayIndexOutOfBoundsException ( "destPos < 0 || destPos >= dest.length()" ) ; } if ( length < 0 ) { throw new IllegalArgumentException ( "length < 0" ) ; } if ( dest . isConstant ( ) ) { throw new IllegalArgumentException ( "Constant arrays cannot be modified." ) ; } int i = srcPos ; int nthreads = ( int ) Math . min ( length , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; if ( nthreads < 2 || length < 100000 ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } else { long k = length / nthreads ; Thread [ ] threads = new Thread [ nthreads ] ; for ( int j = 0 ; j < nthreads ; j ++ ) { final long firstIdx = j * k ; final long lastIdx = ( j == nthreads - 1 ) ? length : firstIdx + k ; threads [ j ] = new Thread ( new Runnable ( ) { @ Override public void run ( ) { for ( long k = firstIdx ; k < lastIdx ; k ++ ) { dest . setFloat ( destPos + k , src [ srcPos + ( int ) k ] ) ; } } } ) ; threads [ j ] . start ( ) ; } try { for ( int j = 0 ; j < nthreads ; j ++ ) { threads [ j ] . join ( ) ; threads [ j ] = null ; } } catch ( InterruptedException ex ) { for ( long j = destPos ; j < destPos + length ; j ++ ) { dest . setFloat ( j , src [ i ++ ] ) ; } } } }
tr	0	public void start ( ) { this . setPlayingOrder ( player1 , player2 ) ; this . board . clearTheBoard ( ) ; this . setStatus ( Game . NEW_GAME ) ; }
tr	0	@ Override public String getVarName ( ) { return this . name ; }
tr	7	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; int [ ] p0 ; int p1 ; p0 = new int [ ] { 5 , 1 , 2 } ; p1 = 4 ; all_right = KawigiEdit_RunTest ( 0 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 4 } ; p1 = 8 ; all_right = KawigiEdit_RunTest ( 1 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 1 , 2 , 7 } ; p1 = 6 ; all_right = KawigiEdit_RunTest ( 2 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 94512 , 2 , 87654 , 81316 , 6 , 5 , 6 , 37151 , 6 , 139 , 1 , 36 , 307 , 1 , 377 , 101 , 8 , 37 , 58 , 1 } ; p1 = 1092 ; all_right = KawigiEdit_RunTest ( 3 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 883 , 66392 , 3531 , 28257 , 1 , 14131 , 57 , 1 , 25 , 88474 , 4 , 1 , 110 , 6 , 1769 , 220 , 442 , 7064 , 7 , 13 } ; p1 = 56523 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; p0 = new int [ ] { 2 , 3 } ; p1 = 1 ; all_right = KawigiEdit_RunTest ( 4 , p0 , true , p1 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
tr	5	public void setCell ( int col , int row , boolean alive ) { if ( row >= 0 && row < 8 && col >= 0 && col < 8 ) { if ( alive ) { cells |= ( ( long ) 1 << ( 8 * row + col ) ) ; } else { cells &= ~ ( ( long ) 1 << ( 8 * row + col ) ) ; } } }
tr	2	private static int maxNode3 ( BSTNode root , int maxSoFar ) throws InvalidBSTException { if ( root == null ) return maxSoFar ; if ( maxNode3 ( root . getLeft ( ) , maxSoFar ) > ( ( Integer ) root . getData ( ) ) ) { throw new InvalidBSTException ( ) ; } maxSoFar = ( ( Integer ) root . getData ( ) ) . intValue ( ) ; return maxNode3 ( root . getRight ( ) , maxSoFar ) ; }
tr	8	private void emitLoadOrStore ( int opcode , int a , Adda address ) throws Exception { Value v = address . getArg1 ( ) ; int b , c ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; v = address . getArg2 ( ) ; if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } } else { if ( v . equals ( Type . getGBP ( ) ) ) { b = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { b = fp ; } else { b = location2 ( v ) ; } v = address . getArg2 ( ) ; if ( v instanceof Immediate ) { c = ( ( Immediate ) v ) . getValue ( ) ; opcode = opcode - 1 ; } else if ( v . equals ( Type . getGBP ( ) ) ) { c = gbp ; } else if ( v . equals ( Type . getFP ( ) ) ) { c = fp ; } else { c = location2 ( v ) ; } } emit ( DLX . assemble ( opcode , a , b , c ) ) ; }
tr	5	@ Override public String toString ( ) { switch ( this ) { case uneEtoile : return "\u2605" ; case deuxEtoiles : return "\u2605\u2605" ; case troisEtoiles : return "\u2605\u2605\u2605" ; case quatreEtoiles : return "\u2605\u2605\u2605\u2605" ; case cinqEtoiles : return "\u2605\u2605\u2605\u2605\u2605" ; } return null ; }
tr	8	public String deleteExtraSpace ( String str ) { if ( str == null ) { return null ; } if ( str . length ( ) == 0 || str . equals ( " " ) ) { return new String ( ) ; } char [ ] oldStr = str . toCharArray ( ) ; int len = str . length ( ) ; char [ ] tmpStr = new char [ len ] ; boolean keepSpace = false ; int j = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char tmpChar = oldStr [ i ] ; if ( oldStr [ i ] !=   ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = true ; } else if ( keepSpace ) { tmpStr [ j ++ ] = tmpChar ; keepSpace = false ; } } int newLen = j ; if ( tmpStr [ j - 1 ] ==   ) { newLen -- ; } char [ ] newStr = new char [ newLen ] ; for ( int i = 0 ; i < newLen ; i ++ ) { newStr [ i ] = tmpStr [ i ] ; } return new String ( newStr ) ; }
tr	9X	public static String getDescription ( short value ) { String description = "Undefined" ; switch ( value ) { case FVB : description = "FVB" ; break ; case RVB : description = "RVB" ; break ; case RPB : description = "RPB" ; break ; case FPB : description = "FPB" ; break ; case FVW : description = "FVW" ; break ; case RVW : description = "RVW" ; break ; case RPW : description = "RPW" ; break ; case FPW : description = "FPW" ; break ; case static : description = "Static" ; break ; case OTHER : description = "Other" ; break ; } return description ; }
tr	0	public void setUpvote ( boolean upvote ) { this . upvote = upvote ; }
tr	1	public void closeWriter ( ) { try { this . writer . flush ( ) ; this . writer . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	9X	public Geometry extrusion ( double [ ] [ ] O , double [ ] [ ] P ) { int m = O . length - 1 ; int n = P . length - 1 ; newRectangularMesh ( m , n ) ; boolean loop = same ( P [ 0 ] , P [ n ] ) ; int N = 0 ; for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k < 3 ; k ++ ) { U [ k ] = P [ j ] [ k + 3 ] ; W [ k ] = j < n ? P [ j + 1 ] [ k ] - P [ j ] [ k ] : loop ? P [ 1 ] [ k ] - P [ 0 ] [ k ] : P [ n ] [ k ] - P [ n - 1 ] [ k ] ; } double radius = Vec . norm ( U ) ; computeCrossVectors ( U , W , V ) ; for ( int i = 0 ; i <= m ; i ++ ) { double x = O [ i ] [ 0 ] ; double y = O [ i ] [ 1 ] ; double z = O [ i ] [ 2 ] ; for ( int k = 0 ; k < 3 ; k ++ ) vertices [ N ] [ k ] = ( P [ j ] [ k ] + radius * ( x * U [ k ] - y * V [ k ] + z * W [ k ] ) ) ; N ++ ; } } if ( loop ) for ( int i = 0 ; i <= nVertices ( ) ; i ++ ) for ( int k = 0 ; k < 3 ; k ++ ) if ( indx ( m , n , i , n ) < nVertices ( ) ) vertices [ indx ( m , n , i , n ) ] [ k ] = vertices [ indx ( m , n , i , 0 ) ] [ k ] ; return this ; }
tr	2	private void getReply ( DatagramSocket socket ) { while ( true ) { try { byte [ ] replybuffer = new byte [ 1024 ] ; DatagramPacket reply = new DatagramPacket ( replybuffer , replybuffer . length ) ; socket . receive ( reply ) ; System . out . println ( new String ( reply . getData ( ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
tr	1	@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; if ( getPolicyNames ( ) != null ) sb . append ( "PolicyNames: " + getPolicyNames ( ) + " " ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
tr	0	@ Override protected void selectNumber ( ) { System . out . println ( "\u9009\u4E00\u4E2A\u4E2D\u56FD\u8054\u901A\u7535\u8BDD\u53F7" ) ; }
tr	6	@ Override public byte [ ] toBytes ( Object value ) { String string = ( String ) value ; string = Normalizer . normalize ( string , Normalizer . Form . NFC ) ; if ( ! caseSensitive ) { string = string . toLowerCase ( locale ) ; } byte [ ] bytes = ENCODERS . get ( byteEncodeMode ) . toBytes ( string , locale ) ; for ( int i = 0 ; i <= bytes . length - 4 ; i ++ ) { if ( bytes [ i ] == 0 && bytes [ i + 1 ] == 0 && bytes [ i + 2 ] == 0 && bytes [ i + 3 ] == 0 ) { throw new RuntimeException ( "Encoded string value contains the end-of-field marker (zero byte)." ) ; } } return bytes ; }
tr	8	public static int search3 ( int [ ] A , int target ) { if ( A . length == 0 ) return - 1 ; int l = 0 ; int r = A . length - 1 ; int m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( target == A [ m ] ) { return m ; } else if ( A [ l ] <= A [ m ] ) { if ( target < A [ m ] && target >= A [ l ] ) { r = m - 1 ; } else { l = m + 1 ; } } else { if ( target <= A [ r ] && target > A [ m ] ) { l = m + 1 ; } else { r = m - 1 ; } } } return - 1 ; }
tr	9X	public static Object getDummyObject ( class cls ) { Object obj = null ; try { Constructor < ? > ctor = cls . getDeclaredConstructor ( ) ; Reflector . ensureIsAccessible ( ctor ) ; obj = ctor . newInstance ( ) ; } catch ( NoSuchMethodException e1 ) { final Constructor < ? > ctor = cls . getConstructors ( ) [ 0 ] ; class [ ] paramTypes = ctor . getParameterTypes ( ) ; List < Object > params = new ArrayList < Object > ( ) ; for ( class paramType : paramTypes ) params . add ( paramType . isPrimitive ( ) ? getTypeDefaultValue ( paramType . getName ( ) ) : null ) ; try { obj = ctor . newInstance ( params . toArray ( ) ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } catch ( SecurityException e1 ) { e1 . printStackTrace ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } finally { return obj ; } }
tr	7	static final public void sum ( ) throws ParseException { term ( ) ; label_1 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : case MINUS : ; break ; default : jj_la1 [ 1 ] = jj_gen ; break label_1 ; } switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case + : jj_consume_token ( + ) ; break ; case MINUS : jj_consume_token ( MINUS ) ; break ; default : jj_la1 [ 2 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } term ( ) ; } }
tr	9X	static double getMaxIntensity ( Spectrum spectrum , double intermediaryMax , double minMz , double maxMz ) { Number [ ] intValues = null ; Number [ ] mzValues = null ; List < BinaryDataArray > binDataArrayList ; List < CVParam > cvParamList ; binDataArrayList = spectrum . getBinaryDataArrayList ( ) . getBinaryDataArray ( ) ; for ( BinaryDataArray bda : binDataArrayList ) { cvParamList = bda . getCvParam ( ) ; for ( CVParam cv : cvParamList ) { if ( cv . getAccession ( ) . equals ( "MS:1000515" ) ) { intValues = bda . getBinaryDataAsNumberArray ( ) ; } if ( cv . getAccession ( ) . equals ( "MS:1000514" ) ) { mzValues = bda . getBinaryDataAsNumberArray ( ) ; } } } if ( intValues != null ) { int i ; if ( mzValues != null ) { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) mzValues [ i ] >= minMz && ( double ) mzValues [ i ] <= maxMz && ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } else { for ( i = 0 ; i < intValues . length ; ++ i ) { if ( ( double ) intValues [ i ] > intermediaryMax ) { intermediaryMax = ( double ) intValues [ i ] ; } } } } return intermediaryMax ; }
tr	3	public DeliverType getDeliverTypeById ( long deliverTypeId ) { Session session = null ; DeliverType deliverType = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; deliverType = ( DeliverType ) session . load ( DeliverType . class , deliverTypeId ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'findById'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return deliverType ; }
tr	2	@ Before public void setUp ( ) { try { class . forName ( "com.mysql.jdbc.Driver" ) ; } catch ( ClassNotFoundException e ) { System . out . println ( "MySQL JDBC Driver not found !!" ) ; return ; } Connection connect = null ; Statement statement = null ; try { connect = DriverManager . getConnection ( "jdbc:mysql://localhost/schoolmate" , "schoolmate" , "schoolmate" ) ; statement = connect . createStatement ( ) ; statement . execute ( "update courses set coursename=\"'><a>link</a>'\" where courseid=5 " ) ; } catch ( SQLException e ) { System . out . printf ( e . toString ( ) ) ; } tester . setBaseUrl ( "http://localhost/schoolmate" ) ; tester . beginAt ( "index.php" ) ; tester . setTextField ( "username" , "simoncelli" ) ; tester . setTextField ( "password" , "1" ) ; tester . submit ( ) ; }
tr	8	private boolean interpolateCollection ( Object obj , String basePath , Field field ) throws IllegalAccessException , InterpolationException { Collection c = ( Collection ) field . get ( obj ) ; if ( c != null && ! c . isEmpty ( ) ) { List originalValues = new ArrayList ( c ) ; try { c . clear ( ) ; } catch ( UnsupportedOperationException e ) { warningCollector . add ( new ObjectInterpolationWarning ( "Field is an unmodifiable collection. Skipping interpolation." , basePath + "." + field . getName ( ) , e ) ) ; return true ; } for ( Object value : originalValues ) { if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { c . add ( interpolated ) ; } else { c . add ( value ) ; } } else { c . add ( value ) ; if ( value . getClass ( ) . isArray ( ) ) { evaluateArray ( value , basePath + "." + field . getName ( ) ) ; } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "." + field . getName ( ) ) ) ; } } } else { c . add ( value ) ; } } } return false ; }
tr	1	public void paintComponent ( Graphics comp ) { super . paintComponent ( comp ) ; Graphics2D comp2D = ( Graphics2D ) comp ; int h = getHeight ( ) - 5 ; int w = getWidth ( ) - 5 ; if ( ! hasValidDrafter ( map , comp2D , hexSideInPixels ) ) { int leftMarginInPixels = 0 ; int topMarginInPixels = 0 ; Rectangle margins = new Rectangle ( leftMarginInPixels , topMarginInPixels , w , h ) ; drafter = new CanvasDrafter ( map , comp2D , hexSideInPixels , textDisplayer , margins ) ; loupe . setMargins ( margins ) ; } drafter . drawMap ( w , h , centerCellId ) ; }
tr	9X	public List < Integer > postorderTraversal ( TreeNode root ) { List < Integer > result = new ArrayList < > ( ) ; Stack < TreeNode > stack = new Stack < > ( ) ; if ( root != null ) stack . add ( root ) ; TreeNode prev = null ; while ( ! stack . isEmpty ( ) ) { root = stack . peek ( ) ; if ( prev == null || prev . left == root || prev . right == root ) { if ( root . left != null ) stack . push ( root . left ) ; else if ( root . right != null ) stack . push ( root . right ) ; } else if ( prev == root . left ) { if ( root . right != null ) stack . push ( root . right ) ; } else { result . add ( root . val ) ; stack . pop ( ) ; } prev = root ; } return result ; }
tr	6	public static void run ( final IUpdateInfo uInfo ) { if ( ! useStack . isEmpty ( ) ) { for ( final ElasticContact c : useStack ) { c . prepare ( uInfo ) ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( final ElasticContact c : useStack ) { c . solve ( uInfo ) ; } } while ( ! useStack . isEmpty ( ) ) { final ElasticContact c ; if ( ( c = useStack . pop ( ) ) != null ) { c . reset ( ) ; unusedStack . push ( c ) ; } } } }
tr	7	protected void prepare_sample_reading ( Header header , int allocation , int channel , float [ ] factor , int [ ] codelength , float [ ] c , float [ ] d ) { int channel_bitrate = header . bitrate_index ( ) ; if ( header . mode ( ) != Header . SINGLE_CHANNEL ) if ( channel_bitrate == 4 ) channel_bitrate = 1 ; else channel_bitrate -= 4 ; if ( channel_bitrate == 1 || channel_bitrate == 2 ) { groupingtable [ channel ] = table_cd_groupingtables [ allocation ] ; factor [ 0 ] = table_cd_factor [ allocation ] ; codelength [ 0 ] = table_cd_codelength [ allocation ] ; c [ 0 ] = table_cd_c [ allocation ] ; d [ 0 ] = table_cd_d [ allocation ] ; } else { if ( subbandnumber <= 2 ) { groupingtable [ channel ] = table_ab1_groupingtables [ allocation ] ; factor [ 0 ] = table_ab1_factor [ allocation ] ; codelength [ 0 ] = table_ab1_codelength [ allocation ] ; c [ 0 ] = table_ab1_c [ allocation ] ; d [ 0 ] = table_ab1_d [ allocation ] ; } else { groupingtable [ channel ] = table_ab234_groupingtables [ allocation ] ; if ( subbandnumber <= 10 ) { factor [ 0 ] = table_ab2_factor [ allocation ] ; codelength [ 0 ] = table_ab2_codelength [ allocation ] ; c [ 0 ] = table_ab2_c [ allocation ] ; d [ 0 ] = table_ab2_d [ allocation ] ; } else if ( subbandnumber <= 22 ) { factor [ 0 ] = table_ab3_factor [ allocation ] ; codelength [ 0 ] = table_ab3_codelength [ allocation ] ; c [ 0 ] = table_ab3_c [ allocation ] ; d [ 0 ] = table_ab3_d [ allocation ] ; } else { factor [ 0 ] = table_ab4_factor [ allocation ] ; codelength [ 0 ] = table_ab4_codelength [ allocation ] ; c [ 0 ] = table_ab4_c [ allocation ] ; d [ 0 ] = table_ab4_d [ allocation ] ; } } } }
tr	1	public final void startup ( ) { if ( ! running ) { running = true ; doStartup ( ) ; } }
tr	7	protected static void addObject ( IUnknown o ) { if ( apartmentInitialized . get ( ) == false ) { ComThread . InitSTA ( false ) ; apartmentInitialized . set ( true ) ; } if ( ! AUTO_GC ) return ; ReferenceQueue < IUnknown > deadObjects = deadPool . get ( ) ; objects . put ( new PointerWeakReference ( o , deadObjects ) , false ) ; if ( GC_COUNT != - 1 && ( count % GC_COUNT ) == 0 ) { System . gc ( ) ; } if ( ( count ++ % CULL_COUNT ) == 0 ) { int numberCulled = cullDeadPool ( deadObjects , objects ) ; if ( IUnknown . isDebugEnabled ( ) ) { if ( numberCulled > 0 ) { IUnknown . debug ( "ROT: added instance of " + o . getClass ( ) . getSimpleName ( ) + "->[+1  -" + numberCulled + "] with " + objects . size ( ) + " remaining live objects" ) ; } } } }
tr	7	@ Override public void setFailState ( int failState ) { if ( this . failstate == Fallible . DEAD && failState != Fallible . DEAD ) throw new IllegalStateException ( "Cannot change fail state: node is already DEAD" ) ; switch ( failState ) { case OK : this . failstate = Fallible . OK ; break ; case DEAD : this . index = - 1 ; this . failstate = Fallible . DEAD ; for ( int i = 0 ; i < this . protocol . length ; ++ i ) if ( this . protocol [ i ] instanceof Cleanable ) { ( ( Cleanable ) this . protocol [ i ] ) . onKill ( ) ; } break ; case DOWN : this . failstate = Fallible . DOWN ; break ; default : throw new IllegalArgumentException ( "failState=" + failState ) ; } }
tr	9X	public void setCurrentVar ( int mag_idx ) { assert ( mag_idx >= - 1 && mag_idx < PaneData . magnetList . size ( ) ) ; setVisible ( false ) ; this . removeAll ( ) ; this . mag_idx = mag_idx ; if ( mag_idx == - 1 ) { log . severe ( "Magnet Pane - Magnet unselected." ) ; setVisible ( true ) ; return ; } Magnet mag = ( Magnet ) PaneData . magnetList . get ( mag_idx ) ; String mag_name = mag . getMagnetName ( ) ; for ( int i = 0 ; i < PaneData . var_names . size ( ) ; i ++ ) { String var_name = ( String ) PaneData . var_names . get ( i ) ; if ( var_name . equalsIgnoreCase ( mag_name ) ) { this . var_idx = i ; break ; } } log . severe ( "Magnet Pane - [" + PaneData . var_names . get ( var_idx ) + "] is selected." ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; setLayout ( new GridBagLayout ( ) ) ; constraints . fill = GridBagConstraints . BOTH ; strMeasure = ( String ) PaneData . var_measures . get ( var_idx ) ; strType = ( String ) PaneData . var_types . get ( var_idx ) ; if ( strType . equals ( "S" ) && strMeasure . equals ( "O" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; assert PaneData . values_min . get ( var_idx ) instanceof Integer ; assert PaneData . values_max . get ( var_idx ) instanceof Integer ; int min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; int max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; chkboxList = new JCheckBox [ max - min + 1 ] ; ArrayList repelList = mag . getRepelList ( ) ; for ( int i = 0 ; i <= max - min ; i ++ ) { DataLabel label = ( DataLabel ) PaneData . var_labels . get ( var_idx ) ; chkboxList [ i ] = new JCheckBox ( label . get ( min + i ) + " (" + Integer . toString ( min + i ) + ")" ) ; if ( repelList == null ) chkboxList [ i ] . setSelected ( false ) ; else chkboxList [ i ] . setSelected ( ( ( boolean ) repelList . get ( i ) ) . booleanValue ( ) ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.05 ; constraints . gridx = 0 ; constraints . gridy = 3 + i ; add ( chkboxList [ i ] , constraints ) ; } } else if ( strMeasure . equals ( "Q" ) ) { JLabel label1 = new JLabel ( "Magnitude" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 0 ; add ( label1 , constraints ) ; sliderMag = new JSlider ( JSlider . HORIZONTAL , 0 , 20 , mag . getMagnitude ( ) ) ; sliderMag . setMinorTickSpacing ( 1 ) ; sliderMag . setMajorTickSpacing ( 5 ) ; sliderMag . setPaintTicks ( true ) ; sliderMag . setPaintLabels ( true ) ; sliderMag . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider slider = ( JSlider ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Magnitude [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 1 ; add ( sliderMag , constraints ) ; JLabel label2 = new JLabel ( "Repellent" ) ; constraints . weightx = 1.0 ; constraints . weighty = 0.1 ; constraints . gridx = 0 ; constraints . gridy = 2 ; add ( label2 , constraints ) ; double threshold = new double ( mag . getThreshold ( ) ) ; if ( strType . equals ( "I" ) ) { int min , max ; min = ( ( Integer ) PaneData . values_min . get ( var_idx ) ) . intValue ( ) ; max = ( ( Integer ) PaneData . values_max . get ( var_idx ) ) . intValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , min , max , threshold . intValue ( ) ) ; sliderRepel . setMinorTickSpacing ( ( max - min ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( max - min ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getValue ( ) + "]" ) ; } } ) ; } else if ( strType . equals ( "D" ) ) { double dmin , dmax ; dmin = ( ( double ) PaneData . values_min . get ( var_idx ) ) . doubleValue ( ) ; dmax = ( ( double ) PaneData . values_max . get ( var_idx ) ) . doubleValue ( ) ; sliderRepel = new JSlider2 ( JSlider . HORIZONTAL , dmin , dmax , threshold . doubleValue ( ) , 1 ) ; sliderRepel . setMinorTickSpacing ( ( dmax - dmin ) / 10 ) ; sliderRepel . setMajorTickSpacing ( ( dmax - dmin ) / 2 ) ; sliderRepel . setPaintTicks ( true ) ; sliderRepel . setPaintLabels ( true ) ; sliderRepel . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { JSlider2 slider = ( JSlider2 ) e . getSource ( ) ; PaneMagnetSelect pms = ( PaneMagnetSelect ) slider . getParent ( ) ; pms . apply ( ) ; log . severe ( "Magnet Pane - Repellent [" + PaneData . var_names . get ( pms . var_idx ) + "] is changed to [" + slider . getDoubleValue ( ) + "]" ) ; } } ) ; } else { assert false ; } constraints . weightx = 1.0 ; constraints . weighty = 0.2 ; constraints . gridx = 0 ; constraints . gridy = 3 ; add ( sliderRepel , constraints ) ; } else assert false ; this . setVisible ( true ) ; }
tr	1	public void executar ( AmbienteExecucao ambiente ) { try { comando . executar ( ambiente ) ; } catch ( IdentificadorJaDeclaradoException | IdentificadorNaoDeclaradoException e ) { e . printStackTrace ( ) ; } }
tr	7	public void drawOverlay ( Graphics g ) { this . tempColor = g . getColor ( ) ; this . tempFont = g . getFont ( ) ; if ( this . gameOver ) { g . setColor ( Color . RED ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "GAME OVER" , 220 , 200 ) ; g . drawString ( ( this . gameWin ? "YOU WIN!" : "YOU LOSE!" ) , 240 , 250 ) ; } g . setColor ( Color . BLUE ) ; g . setFont ( Fonts . BIG_FONT ) ; g . drawString ( "" + this . lives , 30 , 180 ) ; g . drawString ( "" + this . level , 30 , 330 ) ; if ( this . userEnabled ) g . drawString ( "" + this . currentPlayCount , 560 , 180 ) ; g . setFont ( Fonts . SMALL_FONT ) ; g . drawString ( "LIVES:" , 10 , 130 ) ; g . drawString ( "LEVEL:" , 10 , 280 ) ; g . drawString ( "TIMER:" , 550 , 130 ) ; g . drawString ( "SIMON 3-DIMENSIONUS" , 210 , 30 ) ; g . setFont ( Fonts . TINY_FONT ) ; g . drawString ( "A 3D version of the classic Simon memory game" , 180 , 45 ) ; g . drawString ( "Repeat the colored tones given at the start of each level" , 155 , 60 ) ; if ( this . flashOn ) { for ( int i = 0 ; i < this . currentFlash ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } if ( this . userEnabled ) { for ( int i = 0 ; i <= currentIndex ; i ++ ) { g . setColor ( SimonGame . DIFFUSE_COLOR_ARRAY [ this . repeatArray [ i ] ] ) ; g . fillPolygon ( this . polygonArray [ i ] ) ; } } g . setFont ( tempFont ) ; g . setColor ( tempColor ) ; }
tr	5	public static List < Employee > load ( InputStream input ) { List < Employee > employees = new ArrayList < Employee > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) break ; String [ ] values = line . split ( " " ) ; Employee employee = new Employee ( values [ 0 ] , values [ 1 ] , values [ 2 ] ) ; employees . add ( employee ) ; } return employees ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { } } } }
tr	6	public Object stringToValue ( String text ) throws ParseException { StringTokenizer tokenizer = new StringTokenizer ( text , "." ) ; byte [ ] a = new byte [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { int b = 0 ; if ( ! tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too few bytes" , 0 ) ; try { b = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Not an integer" , 0 ) ; } if ( b < 0 || b >= 256 ) throw new ParseException ( "Byte out of range" , 0 ) ; a [ i ] = ( byte ) b ; } if ( tokenizer . hasMoreTokens ( ) ) throw new ParseException ( "Too many bytes" , 0 ) ; return a ; }
tr	5	public void clicked ( Vec2f gamePosition ) { Vec2i mapPosition = new Vec2i ( ( int ) ( gamePosition . x / SQUARE_SIZE ) , ( int ) ( gamePosition . y / SQUARE_SIZE ) ) ; if ( isPlayerUnit ( mapPosition ) ) { Unit unit = units . get ( mapPosition ) ; unit . select ( ) ; if ( selected != null && ! selected . equals ( unit ) ) { selected . unselect ( ) ; } selected = unit ; } else { if ( selected != null && isPassable ( mapPosition ) ) { getPathTo ( selected , mapPosition ) ; } } }
tr	1	private static void testSplit ( ) { String src = "var arrayImg = new Array();" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822400403_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224023013_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/407899112014050822404702_640.jpg\";" + "arrayImg[0] = \"http://srimg1.meimei22.com/big/suren/2014-8-22/1/4078991120140508224114010_640.jpg\";" + "getImgString()" ; String [ ] arrs = src . split ( ";" ) ; for ( String arr : arrs ) { printStr ( arr ) ; } }
tr	8	public void method545 ( Stream stream , Class29 class29 ) { int i = stream . readUnsignedByte ( ) ; anIntArray665 [ 0 ] = i >> 4 ; anIntArray665 [ 1 ] = i & f ; if ( i != 0 ) { anIntArray668 [ 0 ] = stream . readUnsignedWord ( ) ; anIntArray668 [ 1 ] = stream . readUnsignedWord ( ) ; int j = stream . readUnsignedByte ( ) ; for ( int k = 0 ; k < 2 ; k ++ ) { for ( int l = 0 ; l < anIntArray665 [ k ] ; l ++ ) { anIntArrayArrayArray666 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ k ] [ 0 ] [ l ] = stream . readUnsignedWord ( ) ; } } for ( int i1 = 0 ; i1 < 2 ; i1 ++ ) { for ( int j1 = 0 ; j1 < anIntArray665 [ i1 ] ; j1 ++ ) if ( ( j & 1 << i1 * 4 << j1 ) != 0 ) { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = stream . readUnsignedWord ( ) ; } else { anIntArrayArrayArray666 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray666 [ i1 ] [ 0 ] [ j1 ] ; anIntArrayArrayArray667 [ i1 ] [ 1 ] [ j1 ] = anIntArrayArrayArray667 [ i1 ] [ 0 ] [ j1 ] ; } } if ( j != 0 || anIntArray668 [ 1 ] != anIntArray668 [ 0 ] ) class29 . method326 ( stream ) ; } else { anIntArray668 [ 0 ] = anIntArray668 [ 1 ] = 0 ; } }
tr	9X	public void addConnection ( Player player , Packet00Login packet ) { boolean alreadyConnected = false ; for ( Player p : connectedPlayers ) { if ( player . getName ( ) . equalsIgnoreCase ( p . getName ( ) ) ) { if ( p . getIP ( ) == null ) { p . setIP ( player . getIP ( ) ) ; } if ( p . getPort ( ) == - 1 ) { p . setPort ( player . getPort ( ) ) ; } alreadyConnected = true ; } else { sendData ( packet . getData ( ) , p . getIP ( ) , p . getPort ( ) ) ; String color = " " ; String race = " " ; String weapon = " " ; if ( p instanceof Human ) race = "human" ; else if ( p instanceof Cyborg ) race = "cyborg" ; if ( p . getColor ( ) != null ) color = p . getColor ( ) ; if ( p . getInHand ( ) instanceof Sword ) weapon = "sword" ; else if ( p . getInHand ( ) instanceof Bow ) weapon = "bow" ; Packet00Login oldPlayerPacket = new Packet00Login ( p . getName ( ) , race , color , weapon ) ; sendData ( oldPlayerPacket . getData ( ) , player . getIP ( ) , player . getPort ( ) ) ; } } if ( ! alreadyConnected ) { connectedPlayers . add ( player ) ; } }
tr	2	public static void pairsAndValues ( ) { int [ ] arr = { 1 , 2 , 3 } ; for ( int i = 0 ; i < arr . length ; i ++ ) for ( int j = 0 ; j < arr . length ; j ++ ) { System . out . print ( "Value : " + ( arr [ i ] + arr [ j ] ) ) ; System . out . println ( "  Pair : " + arr [ i ] + " and " + arr [ j ] ) ; } }
tr	3	private void initWindow ( ) { contentPanel = new JPanel ( ) ; contentPanel . setLayout ( new BoxLayout ( contentPanel , BoxLayout . PAGE_AXIS ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; tabbedPanel = new JTabbedPane ( ) ; tabbedPanel . setPreferredSize ( new Dimension ( 500 , 800 ) ) ; connectionTabPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userSettingsPanel . setLayout ( new BoxLayout ( userSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; userSettingsPanel . setBorder ( new TitledBorder ( "User Settings" ) ) ; userSettingsV1Panel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; usernameLabel = new JLabel ( "Username:" ) ; usernameText = new JTextField ( UserPreferences . PREF_USERNAME , 6 ) ; apiSecretLabel = new JLabel ( "API Secret:" ) ; apiSecretText = new JPasswordField ( UserPreferences . PREF_API_SECRET , 6 ) ; passwordLabel = new JLabel ( "Password:" ) ; passwordText = new JPasswordField ( UserPreferences . PREF_PASSWORD , 6 ) ; userSettingsV1Panel . add ( usernameLabel ) ; userSettingsV1Panel . add ( usernameText ) ; userSettingsV1Panel . add ( apiSecretLabel ) ; userSettingsV1Panel . add ( apiSecretText ) ; userSettingsV1Panel . add ( passwordLabel ) ; userSettingsV1Panel . add ( passwordText ) ; userTokenPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; userTokenPanel . setPreferredSize ( new Dimension ( 443 , 40 ) ) ; userTokenLabel = new JLabel ( "Token:" ) ; userTokenText = new JTextField ( UserPreferences . PREF_USERTOKEN , 10 ) ; userTokenButton = new JButton ( "Get your token" ) ; userTokenButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { GetToken . browse ( ) ; } } ) ; userTokenPanel . add ( userTokenLabel ) ; userTokenPanel . add ( userTokenText ) ; userTokenPanel . add ( userTokenButton ) ; userSettingsPanel . add ( userTokenPanel ) ; proxySettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; proxyUseCheck = new JCheckBox ( "Use Proxy" , UserPreferences . PREF_USE_PROXY ) ; proxyUseCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { if ( proxyUseCheck . isSelected ( ) ) { proxyAddressText . setEnabled ( true ) ; proxyPortText . setEnabled ( true ) ; } else { proxyAddressText . setEnabled ( false ) ; proxyPortText . setEnabled ( false ) ; } } } ) ; proxySettingsPanel . setBorder ( new TitledBorder ( "Proxy Settings" ) ) ; proxyAddressLabel = new JLabel ( "Proxy:" ) ; proxyAddressText = new JTextField ( UserPreferences . PREF_PROXY_ADDRESS , 15 ) ; proxyPortLabel = new JLabel ( "Port:" ) ; proxyPortText = new JTextField ( UserPreferences . PREF_PROXY_PORT , 3 ) ; proxySettingsPanel . add ( proxyUseCheck ) ; proxySettingsPanel . add ( proxyAddressLabel ) ; proxySettingsPanel . add ( proxyAddressText ) ; proxySettingsPanel . add ( proxyPortLabel ) ; proxySettingsPanel . add ( proxyPortText ) ; proxySettingsPanel . setPreferredSize ( new Dimension ( 455 , 60 ) ) ; serverSettingsPanel = new JPanel ( ) ; serverSettingsPanel . setLayout ( new BoxLayout ( serverSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; serverSettingsPanel . setBorder ( new TitledBorder ( "Server Settings" ) ) ; serverCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverCheckIntervalLabel = new JLabel ( "Server check interval (sec):" ) ; serverCheckIntervalText = new JTextField ( String . valueOf ( UserPreferences . PREF_SERVER_CHECK_INTERVAL ) , 3 ) ; autoCleanCheck = new JCheckBox ( "Delete empty folders (keeps account clean)" , UserPreferences . PREF_AUTO_CLEAN ) ; serverCheckPanel . add ( serverCheckIntervalLabel ) ; serverCheckPanel . add ( serverCheckIntervalText ) ; serverCheckPanel . add ( autoCleanCheck ) ; serverSortByPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; serverSortByLabel = new JLabel ( "Sort by default:" ) ; serverSortByCombo = new JComboBox < String > ( new String [ ] { "Name" , "Date" } ) ; serverSortByCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_SORT_BY ) ; serverSortByPanel . add ( serverSortByLabel ) ; serverSortByPanel . add ( serverSortByCombo ) ; serverFriendPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; loadSharedCheck = new JCheckBox ( "Load friends' files (this could take some time to load)" , UserPreferences . PREF_LOAD_SHARED ) ; serverFriendPanel . add ( loadSharedCheck ) ; serverSettingsPanel . add ( serverCheckPanel ) ; serverSettingsPanel . add ( serverSortByPanel ) ; serverSettingsPanel . add ( serverFriendPanel ) ; serverSettingsPanel . setPreferredSize ( new Dimension ( 455 , 120 ) ) ; connectionTabPanel . add ( userSettingsPanel ) ; connectionTabPanel . add ( proxySettingsPanel ) ; connectionTabPanel . add ( serverSettingsPanel ) ; tabbedPanel . addTab ( "Connection" , null , connectionTabPanel ) ; startupSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoConnectCheck = new JCheckBox ( "Connect on start automatically" , UserPreferences . PREF_AUTO_CONNECT ) ; startInTrayCheck = new JCheckBox ( "Start in system tray" , UserPreferences . PREF_START_IN_TRAY ) ; startupSettingsPanel . setBorder ( new TitledBorder ( "Startup Settings" ) ) ; startupSettingsPanel . add ( autoConnectCheck ) ; startupSettingsPanel . add ( startInTrayCheck ) ; tabbedPanel . addTab ( "Startup" , null , startupSettingsPanel ) ; downloadSettingsPanel = new JPanel ( ) ; downloadSettingsPanel . setLayout ( new BoxLayout ( downloadSettingsPanel , BoxLayout . PAGE_AXIS ) ) ; downloadSettingsPanel . setBorder ( new TitledBorder ( "Download Settings" ) ) ; autoDownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; autoDownloadCheck = new JCheckBox ( "Download on connect" , UserPreferences . PREF_AUTO_DOWNLOAD ) ; autoDownloadPanel . add ( autoDownloadCheck ) ; downloadTargetPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadTargetLabel = new JLabel ( "Target:" ) ; downloadTargetText = new JTextField ( UserPreferences . PREF_DOWNLOAD_TARGET , 20 ) ; downloadTargetText . setEditable ( false ) ; fileChooserButton = new JButton ( "Browse" ) ; fileChooserButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( fileChooser . showOpenDialog ( preferencesScreen ) == JFileChooser . APPROVE_OPTION ) { downloadTargetText . setText ( fileChooser . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } } } ) ; fileChooser = new JFileChooser ( downloadTargetText . getText ( ) ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; fileChooser . setDialogTitle ( "Select download directory" ) ; fileChooser . setAcceptAllFileFilterUsed ( false ) ; downloadTargetPanel . add ( downloadTargetLabel ) ; downloadTargetPanel . add ( downloadTargetText ) ; downloadTargetPanel . add ( fileChooserButton ) ; downloadWhatPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; downloadWhatLabel = new JLabel ( "Download:" ) ; everythingRadio = new JRadioButton ( "everything" ) ; selFoldersRadio = new JRadioButton ( "selected folders" ) ; selFoldersRadio . setToolTipText ( "Right clic folder -> Add to automatic download" ) ; downloadWhatGroup = new ButtonGroup ( ) ; downloadWhatGroup . add ( everythingRadio ) ; downloadWhatGroup . add ( selFoldersRadio ) ; downloadWhatPanel . add ( downloadWhatLabel ) ; downloadWhatPanel . add ( everythingRadio ) ; downloadWhatPanel . add ( selFoldersRadio ) ; downloadPartsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; maxParallelDownloadsLabel = new JLabel ( "Max parallel downloads:" ) ; maxParallelDownloadsText = new JTextField ( String . valueOf ( UserPreferences . PREF_MAX_DOWNLOADS ) , 2 ) ; downloadPartsLabel = new JLabel ( "Parts for each download:" ) ; downloadPartsText = new JTextField ( String . valueOf ( UserPreferences . PREF_DOWNLOAD_PART_COUNT ) , 2 ) ; downloadPartsPanel . add ( maxParallelDownloadsLabel ) ; downloadPartsPanel . add ( maxParallelDownloadsText ) ; downloadPartsPanel . add ( downloadPartsLabel ) ; downloadPartsPanel . add ( downloadPartsText ) ; fileSizeCheckPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; fileSizeCheckCheck = new JCheckBox ( "Skip download if size of the file is smaller than (MB):" , UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeCheckCheck . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent e ) { fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeDeleteCheck . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; } } ) ; fileSizeCheckText = new JTextField ( String . valueOf ( UserPreferences . PREF_FILE_SIZE_FOR_CHECK ) , 4 ) ; fileSizeCheckText . setEnabled ( fileSizeCheckCheck . isSelected ( ) ) ; fileSizeCheckPanel . add ( fileSizeCheckCheck ) ; fileSizeCheckPanel . add ( fileSizeCheckText ) ; fileSizeDeletePanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; fileSizeDeleteCheck = new JCheckBox ( "Also delete it from server automatically" , UserPreferences . PREF_FILE_SIZE_DELETE ) ; fileSizeDeleteCheck . setEnabled ( UserPreferences . PREF_FILE_SIZE_CHECK ) ; fileSizeDeletePanel . add ( fileSizeDeleteCheck ) ; downloadSettingsPanel . add ( autoDownloadPanel ) ; downloadSettingsPanel . add ( downloadTargetPanel ) ; downloadSettingsPanel . add ( downloadWhatPanel ) ; downloadSettingsPanel . add ( downloadPartsPanel ) ; downloadSettingsPanel . add ( fileSizeCheckPanel ) ; downloadSettingsPanel . add ( fileSizeDeletePanel ) ; tabbedPanel . addTab ( "Download" , null , downloadSettingsPanel ) ; conflictSettingsPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; conflictSettingsPanel . setBorder ( new TitledBorder ( "Conflict Settings" ) ) ; redownloadPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; redownloadCheck = new JCheckBox ( "Do not ask if file already downloaded. Apply following: " , UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { redownloadCombo . setEnabled ( redownloadCheck . isSelected ( ) ) ; } } ) ; redownloadCombo = new JComboBox < String > ( new String [ ] { "Download again" , "Skip" , "Skip and delete" } ) ; redownloadCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_DOWNLOAD_AGAIN ) ; redownloadCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_DOWNLOAD_AGAIN ) ; redownloadPanel . add ( redownloadCheck ) ; redownloadPanel . add ( redownloadCombo ) ; overwritePanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCheck = new JCheckBox ( "Do not ask if file already exits on disc. Apply following: " , UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwriteCheck . addChangeListener ( new ChangeListener ( ) { @ Override public void stateChanged ( ChangeEvent e ) { overwriteCombo . setEnabled ( overwriteCheck . isSelected ( ) ) ; } } ) ; overwriteComboPanel = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; overwriteCombo = new JComboBox < String > ( new String [ ] { "Overwrite" , "Skip" , "Skip and delete from server" , "Skip in case of same size" , "Skip in case of same size and delete from server" } ) ; overwriteCombo . setSelectedIndex ( UserPreferences . PREF_BEHAVIOR_OVERWRITE ) ; overwriteCombo . setEnabled ( UserPreferences . PREF_DONT_ASK_OVERWRITE ) ; overwritePanel . add ( overwriteCheck ) ; overwriteComboPanel . add ( overwriteCombo ) ; conflictSettingsPanel . add ( redownloadPanel ) ; conflictSettingsPanel . add ( overwritePanel ) ; conflictSettingsPanel . add ( overwriteComboPanel ) ; tabbedPanel . addTab ( "Conflict" , null , conflictSettingsPanel ) ; buttonsPanel = new JPanel ( new FlowLayout ( FlowLayout . CENTER ) ) ; saveAndCloseButton = new JButton ( "Save & Close" ) ; saveAndCloseButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { if ( saveSettings ( ) ) { preferencesScreen . setVisible ( false ) ; } } } ) ; closeButton = new JButton ( "Close" ) ; closeButton . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { preferencesScreen . setVisible ( false ) ; } } ) ; buttonsPanel . add ( saveAndCloseButton ) ; buttonsPanel . add ( closeButton ) ; contentPanel . add ( tabbedPanel ) ; contentPanel . add ( buttonsPanel ) ; this . getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; this . setTitle ( "Preferences" ) ; this . setSize ( new Dimension ( 490 , 370 ) ) ; this . setResizable ( false ) ; }
tr	8	private QuerySet < T > isNull ( String query ) { QuerySet < T > querySet = null ; if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { querySet = new QuerySet < T > ( ) ; query = query . trim ( ) . toLowerCase ( ) ; query = query . replace ( "__isnull" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; String fieldName = queryComponents [ 0 ] ; boolean isNull = boolean . parseBoolean ( queryComponents [ 1 ] ) ; Field field = null ; try { if ( fieldName . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { if ( isNull ) { if ( field . get ( model ) == null ) { querySet . add ( model ) ; } } else { if ( field . get ( model ) != null ) { querySet . add ( model ) ; } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } } return querySet ; }
tr	0	public void addPOS ( POS pos ) { posArray . add ( pos ) ; }
tr	4	public ListIterator < T > listIterator ( int start ) throws IndexOutOfBoundsException { if ( start < 0 || start > size ) throw new IndexOutOfBoundsException ( "Invalid start index: " + start ) ; Node cur = null ; for ( int i = 0 ; i < start ; ++ i ) { cur = ( cur == null ) ? head : cur . next ; } return listIterator ( start - 1 , cur ) ; }
tr	1	public byte [ ] decompress ( ) throws IOException { InflaterInputStream in = new InflaterInputStream ( getInStream ( ) ) ; ByteArrayOutputStream bout = new ByteArrayOutputStream ( 512 ) ; int b ; while ( ( b = in . read ( ) ) != - 1 ) { bout . write ( b ) ; } in . close ( ) ; bout . close ( ) ; return bout . toByteArray ( ) ; }
tr	6	private void startLevel ( ) { if ( currentlesson . isNoteLevel ( ) ) { if ( ! noteLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + noteLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isRhythmLevel ( ) ) { if ( ! rhythmLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + rhythmLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } else if ( currentlesson . isScoreLevel ( ) ) { if ( ! scoreLevel . isMessageEmpty ( ) ) { levelMessage . setTitle ( bundle . getString ( "_information" ) ) ; textlevelMessage . setText ( "  " + scoreLevel . getMessage ( ) + "  " ) ; levelMessage . pack ( ) ; levelMessage . setLocationRelativeTo ( this ) ; levelMessage . setVisible ( true ) ; } else { startButton . doClick ( ) ; } } }
tr	8	private static < AnyType extends Comparable < ? super AnyType >> void quickSelect ( AnyType [ ] a , int left , int right , int k ) { if ( left + CUTOFF <= right ) { AnyType pivot = median3 ( a , left , right ) ; int i = left , j = right - 1 ; for ( ; ; ) { while ( a [ ++ i ] . compareTo ( pivot ) < 0 ) { } while ( a [ -- j ] . compareTo ( pivot ) > 0 ) { } if ( i < j ) swapReferences ( a , i , j ) ; else break ; } swapReferences ( a , i , right - 1 ) ; if ( k <= i ) quickSelect ( a , left , i - 1 , k ) ; else if ( k > i + 1 ) quickSelect ( a , i + 1 , right , k ) ; } else insertionSort ( a , left , right ) ; }
tr	8	public static void release ( Object ... releasables ) { for ( Object obj : releasables ) { if ( obj != null ) { try { if ( obj instanceof ServerSocket ) { ( ( ServerSocket ) obj ) . close ( ) ; } else if ( obj instanceof Socket ) { ( ( Socket ) obj ) . close ( ) ; } else if ( obj instanceof Process ) { ( ( Process ) obj ) . destroy ( ) ; } else if ( obj instanceof Closeable ) { ( ( Closeable ) obj ) . close ( ) ; } else { throw new IllegalArgumentException ( "This method does not not how to release objects of type " + obj . getClass ( ) ) ; } } catch ( IOException ex ) { } catch ( RuntimeException ex ) { } } } }
tr	3	public static final Course readCourse ( File definitionFile ) { LOGGER . log ( Level . INFO , "Reading course from file '" + definitionFile + "'" ) ; JSONParser parser = new JSONParser ( ) ; JSONObject jsonObject = null ; try { jsonObject = ( JSONObject ) parser . parse ( new FileReader ( definitionFile ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( org . json . simple . parser . ParseException e ) { e . printStackTrace ( ) ; } Course course = new Course ( ( String ) jsonObject . get ( "name" ) , ( String ) jsonObject . get ( "address" ) , ( int ) ( ( long ) jsonObject . get ( "bestScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "averageScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "worstScore" ) ) , ( int ) ( ( long ) jsonObject . get ( "timesPlayed" ) ) , new ArrayList < Hole > ( ) , ( String ) jsonObject . get ( "userWithBestScore" ) , ( String ) jsonObject . get ( "description" ) ) ; LOGGER . log ( Level . INFO , "Created course '" + course . getName ( ) + "'" ) ; return course ; }
tr	4	public static boolean intersects ( final IShape shape1 , final Vector3f vertex ) { simplex . clear ( ) ; Element e = simplex . getNewElement ( ) ; MinkowskiDifference . getMaxSupport ( e , shape1 , vertex , v ) ; simplex . addElement ( ) ; v . set ( e . v ) ; float d_2 = v . . ( ) ; int i = 0 ; while ( d_2 > EPSILON_2 && i ++ < MAX_ITERATIONS ) { e = simplex . getNewElement ( ) ; MinkowskiDifference . getMinSupport ( e , shape1 , vertex , v ) ; if ( v . . ( e . v ) > 0 ) { return false ; } if ( simplex . contains ( e . v ) ) break ; simplex . addElement ( ) ; d_2 = closestPointToOrigin ( v , simplex ) ; } return true ; }
tr	6	public void removePriceStep ( double startPrice , double endPrice ) throws RemoteException { startPrice = round ( startPrice ) ; endPrice = round ( endPrice ) ; if ( startPrice < 0 || endPrice < 0 ) throw new PriceStepNegativeArgumentException ( ) ; PriceStep removeStep = null ; for ( PriceStep storedStep : priceSteps ) { if ( storedStep . getStartPrice ( ) == startPrice && storedStep . getEndPrice ( ) == endPrice ) { removeStep = storedStep ; } } if ( removeStep == null ) { throw new PriceStepIntervalNotFoundException ( ) ; } else { priceSteps . remove ( removeStep ) ; } }
tr	4	private void evaluateArray ( Object target , String basePath ) throws InterpolationException { int len = Array . getLength ( target ) ; for ( int i = 0 ; i < len ; i ++ ) { Object value = Array . get ( target , i ) ; if ( value != null ) { if ( String . class == value . getClass ( ) ) { String interpolated = interpolator . interpolate ( ( String ) value , recursionInterceptor ) ; if ( ! interpolated . equals ( value ) ) { Array . set ( target , i , interpolated ) ; } } else { interpolationTargets . add ( new InterpolationTarget ( value , basePath + "[" + i + "]" ) ) ; } } } }
tr	3	private void processNumber ( Object value ) { double doubleValue = ( ( Number ) value ) . doubleValue ( ) ; if ( double . isNaN ( average ) ) { average = doubleValue ; min = doubleValue ; max = doubleValue ; sum = doubleValue ; } else { if ( doubleValue < min ) { min = doubleValue ; } if ( doubleValue > max ) { max = doubleValue ; } sum += doubleValue ; average = average + ( doubleValue - average ) / count ; } }
tr	9X	private void addFriend ( long l ) { try { if ( l == 0 ) return ; if ( friendsCount >= 100 && anInt1046 != 1 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } if ( friendsCount >= 200 ) { pushMessage ( "Your friendlist is full. Max of 100 for free users  and 200 for members" , 0 , "" ) ; return ; } String s = TextClass . fixName ( TextClass . nameForLong ( l ) ) ; for ( int i = 0 ; i < friendsCount ; i ++ ) if ( friendsListAsLongs [ i ] == l ) { pushMessage ( s + " is already on your friend list" , 0 , "" ) ; return ; } for ( int j = 0 ; j < ignoreCount ; j ++ ) if ( ignoreListAsLongs [ j ] == l ) { pushMessage ( "Please remove " + s + " from your ignore list first" , 0 , "" ) ; return ; } if ( s . equals ( myPlayer . name ) ) { return ; } else { friendsList [ friendsCount ] = s ; friendsListAsLongs [ friendsCount ] = l ; friendsNodeIDs [ friendsCount ] = 0 ; friendsCount ++ ; needDrawTabArea = true ; outStream1 . createFrame ( 188 ) ; outStream1 . writeQWord ( l ) ; return ; } } catch ( RuntimeException runtimeexception ) { signlink . reporterror ( "15283  " + ( byte ) 68 + "  " + l + "  " + runtimeexception . toString ( ) ) ; } throw new RuntimeException ( ) ; }
tr	0	public static void showNewTimeWindow ( ) { timeBo . showNewTime ( ) ; }
tr	4	private void populateDto ( Msg dto , ResultSet rs ) throws SQLException { dto . setIdMsg ( new Integer ( rs . getInt ( COLUMN_ID_MSG ) ) ) ; try { dto . setMailer ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_MAILER ) ) ) ; } catch ( UserDaoException e3 ) { e3 . printStackTrace ( ) ; } try { dto . setRecipient ( new UserDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_RECIPIENT ) ) ) ; } catch ( UserDaoException e2 ) { e2 . printStackTrace ( ) ; } dto . setHeadMsg ( rs . getString ( COLUMN_HEAD_MSG ) ) ; dto . setBodyMsg ( rs . getString ( COLUMN_BODY_MSG ) ) ; try { dto . setStatusMsg ( new MsgStatusDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_STATUS_MSG ) ) ) ; } catch ( MsgStatusDaoException e1 ) { e1 . printStackTrace ( ) ; } try { dto . setTypeMsg ( new MsgTypeDaoImpl ( ) . findByPrimaryKey ( rs . getString ( COLUMN_TYPE_MSG ) ) ) ; } catch ( MsgTypeDaoException e ) { e . printStackTrace ( ) ; } dto . setSendOffDate ( rs . getTimestamp ( COLUMN_SEND_OFF_DATE ) ) ; }
tr	8	public void render ( Map map ) { if ( updateSenses ) { long startTime = System . currentTimeMillis ( ) ; playerSenses = map . getPlayerSenses ( ) ; long endTime = System . currentTimeMillis ( ) ; Log . print ( "Shadowcasting time: " + ( endTime - startTime ) ) ; updateSenses = false ; } HashMap < Integer , Tile > tileHashMap = playerSenses . getTiles ( ) ; HashMap < Integer , Actor > actorHashMap = playerSenses . getActors ( ) ; HashMap < Integer , ArrayList < Entity >> entities = playerSenses . getEntities ( ) ; Point top_left = new Point ( playerpos . getX ( ) - tilesx , playerpos . getY ( ) - tilesy ) ; for ( int x = top_left . getX ( ) ; x <= playerpos . getX ( ) + tilesx ; x ++ ) { for ( int y = top_left . getY ( ) ; y <= playerpos . getY ( ) + tilesy ; y ++ ) { if ( map . inBounds ( x , y ) ) { Tile tile = tileHashMap . get ( map . genKey ( x , y ) ) ; if ( tile != null ) { Image image = environment . getSprite ( tile . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } ArrayList < Entity > ents = entities . get ( map . genKey ( x , y ) ) ; if ( ents != null && ents . size ( ) > 0 ) { Entity entity = ents . get ( 0 ) ; Image image = environment . getSprite ( entity . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } Actor actor = actorHashMap . get ( map . genKey ( x , y ) ) ; if ( actor != null ) { Image image = actor_sprites . getSprite ( actor . getSpriteID ( ) ) ; image . draw ( ( float ) ( ( x - top_left . getX ( ) ) * ppt ) , ( float ) ( ( y - top_left . getY ( ) ) * ppt ) , scale ) ; } } } } Image player = actor_sprites . getSprite ( ActorSprite . player ) ; player . draw ( ( float ) ( ( playerpos . getX ( ) - top_left . getX ( ) ) * ppt ) , ( float ) ( ( playerpos . getY ( ) - top_left . getY ( ) ) * ppt ) , scale ) ; messageBox . render ( ) ; }
tr	7	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/train_weibo_balanced.arff" ; String pathoutput = "C:/Users/lin/Desktop/train_weibo_balanced(chongxinbianUniqueID).arff" ; File file = new File ( pathinput ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; String tempString = null ; OutputStreamWriter writer = new OutputStreamWriter ( new FileOutputStream ( pathoutput ) , "UTF-8" ) ; int num = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { if ( tempString . contains ( " {0 " ) ) { String t = tempString . substring ( 4 , 5 ) ; for ( int i = 1 ; i < 7 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + num ++ ; for ( int i = 8 ; i < 207 ; i ++ ) { String begin = "  " + i + " " ; String end = "  " + ( i + 1 ) + " " ; t += " " + tempString . substring ( tempString . indexOf ( begin ) + begin . length ( ) , tempString . indexOf ( end ) ) ; } t += " " + tempString . substring ( tempString . indexOf ( "  207 " ) + 6 , tempString . indexOf ( " }" ) ) ; writer . write ( t + "\r\n" ) ; } else { writer . write ( tempString + "\r\n" ) ; } } reader . close ( ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	2	void processSecurityMsg ( ) { vlog . debug ( "processing security message" ) ; int rc = security . processMsg ( this ) ; if ( rc == 0 ) throwAuthFailureException ( ) ; if ( rc == 1 ) { state_ = RFBSTATE_SECURITY_RESULT ; processSecurityResultMsg ( ) ; } }
tr	2	public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "] is not a number." ) ; } }
tr	2	public static String join ( Object [ ] ar , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Object obj : ar ) { buffer . append ( obj ) ; buffer . append ( delimiter ) ; } if ( ar . length > 0 ) buffer . deleteCharAt ( buffer . length ( ) - 1 ) ; return buffer . toString ( ) ; }
tr	0	@ Override public double getRotationDeg ( ) { return rotation ; }
tr	1	@ Test public void testIdentifierOptionalPresentButNull ( ) throws TemplateException { Identifier variable = new Identifier ( "$variable?" , new Cursor ( "-:l1:c1" ) ) ; populateModel ( "variable" , null ) ; try { variable . writeObject ( null , model , null ) ; fail ( "An exception must be raised." ) ; } catch ( TemplateIgnoreRenderingException e ) { assertEquals ( "Ignore rendering because key 'variable' is not present or has null value in the model map at position '-:l1:c1'." , e . getMessage ( ) ) ; } }
tr	5	private static void loadVersionProperties ( ) { ClassLoader loader = ReleaseInfo . class . getClassLoader ( ) ; Properties info = new Properties ( ) ; InputStream stream = loader . getResourceAsStream ( PROPERTY_FILE ) ; if ( stream == null ) stream = loader . getResourceAsStream ( "/" + PROPERTY_FILE ) ; if ( stream != null ) { try { info . load ( stream ) ; stream . close ( ) ; buildVersion = info . getProperty ( "version" ) ; buildDate = info . getProperty ( "build.date" ) ; } catch ( IOException e ) { } } if ( buildVersion == null ) buildVersion = "unknown" ; if ( buildDate == null ) buildDate = "unknown" ; }
tr	1	public static long sum ( long ... values ) { long sum = 0 ; for ( long l : values ) { sum += l ; } return sum ; }
tr	3	int [ ] [ ] allRolls ( ) { int [ ] [ ] ret = new int [ 24 ] [ ] ; int i = 0 ; for ( int k = 0 ; k < 6 ; k ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { ret [ i ++ ] = id . clone ( ) ; rollZ ( ) ; } if ( k % 2 == 1 ) rollY ( ) ; else rollX ( ) ; } return ret ; }
tr	5	public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { System . out . println ( "Please enter 3 numbers" ) ; int first = sc . nextInt ( ) ; int second = sc . nextInt ( ) ; int third = sc . nextInt ( ) ; if ( first == 0 && second == 0 && third == 0 ) { break ; } if ( ( first + second + third ) % 3 == 0 ) { System . out . println ( "Yes" ) ; } else { System . out . println ( "No" ) ; } } }
tr	7	public void SendPinMsg ( ) { message = msgs . getText ( ) ; subject = subj . getText ( ) ; HTTPClient hc = new HTTPClient ( ) ; hc . getConnectionString ( ) ; if ( ! AppFunctions . ntwkCon ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please check your network  Pin Broadcast requires BIS or Wifi" ) ; info . setText ( "Check your network connection" ) ; } } ) ; } else if ( AppFunctions . trialCount < 1 ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "You have exceeded the number of messages you can send. You have " + AppFunctions . trialCount + " left. Please Buy more messages by selecting the 'Buy Pin Message' menu for information on subscription. Select 'Verify Account' on the menu after subscription to send more messages." ) ; info . setText ( "Message number exceeded." ) ; } } ) ; } else if ( ContactArray . size ( ) > AppFunctions . trialCount ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "The contacts in your message exceeds what you have left (" + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) + "). Please subscribe and select 'Verify Account' on the menu for unlimited contacts or reduce the number of your contacts to " + AppFunctions . formatNumber ( AppFunctions . trialCount , 0 , " " ) ) ; } } ) ; } else { if ( message . length ( ) < 5 || subject . length ( ) < 3 || from . getText ( ) . length ( ) < 2 || FileSel == null ) { UiApplication . getUiApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { Dialog . inform ( "Please verify that From  Subject  Message and your Contact File has been entered properly before sending this message." ) ; info . setText ( "Error in message  please check again." ) ; } } ) ; } else { new Thread ( sndmsg ) . start ( ) ; } } }
tr	7	private void ulozitActionPerformed ( java . awt . event . ActionEvent evt ) { PanelRegistraceTymu fr = PanelRegistraceTymu . this ; EntityManager em = DBTools . getInstance ( ) . getEm ( ) ; EntityTransaction tx = DBTools . getInstance ( ) . getTx ( ) ; System . out . println ( "" ) ; System . out . println ( "ULOZIT" ) ; System . out . println ( "" ) ; String sql = "select * from kategorie where nazev=?" ; Query query = DBTools . getInstance ( ) . getEm ( ) . createNativeQuery ( sql , Kategorie . class ) ; query . setParameter ( 1 , fr . kategorieCombo . getSelectedItem ( ) . toString ( ) ) ; Kategorie kat = ( Kategorie ) query . getSingleResult ( ) ; tx . begin ( ) ; Tym tym = Tym . createTym ( fr . JmenoTymuField . getText ( ) , kat ) ; em . persist ( tym ) ; tx . commit ( ) ; tym = em . find ( Tym . class , tym . getTym_id ( ) ) ; System . out . println ( tym ) ; tx . begin ( ) ; TableModel jtm = fr . jezdecTable . getModel ( ) ; for ( int i = 0 ; i < jtm . getRowCount ( ) ; i ++ ) { long val = ( long ) jtm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyl vybran jezdec!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; tho . setJe_jezdec ( true ) ; em . persist ( tho ) ; } } TableModel ptm = fr . prisediciTable . getModel ( ) ; for ( int i = 0 ; i < ptm . getRowCount ( ) ; i ++ ) { long val = ( long ) ptm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni prisedici!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Osoba o = em . find ( Osoba . class , val ) ; System . out . println ( o ) ; TymyHasOsoby tho = TymyHasOsoby . createTymMaOsobu ( tym . getTym_id ( ) , o . getOsoba_id ( ) ) ; em . persist ( tho ) ; } } TableModel ktm = fr . koneTable . getModel ( ) ; for ( int i = 0 ; i < ktm . getRowCount ( ) ; i ++ ) { long val = ( long ) ktm . getValueAt ( i , 0 ) ; if ( val == null ) { JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Nelze ulozit! \nNebyli vybrani vsichni kone!" , "Pozor" , JOptionPane . ERROR_MESSAGE ) ; tx . rollback ( ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; return ; } else { Kun k = em . find ( Kun . class , val ) ; System . out . println ( k ) ; TymyHasKone thk = TymyHasKone . createTymMaKone ( tym . getTym_id ( ) , k . getKun_id ( ) ) ; em . persist ( thk ) ; } } try { tx . commit ( ) ; tx . begin ( ) ; tym . setZavodId ( em . find ( Zavody . class , 1 ) ) ; em . persist ( tym ) ; tx . commit ( ) ; dispose ( ) ; } catch ( RollbackException e ) { System . out . println ( "ERROR -> rollback" ) ; JOptionPane . showMessageDialog ( PanelRegistraceTymu . this , "Do\u0161lo k chyb\u011B: " + e . getMessage ( ) , "Chyba" , JOptionPane . ERROR_MESSAGE ) ; tx . begin ( ) ; em . remove ( em . find ( Tym . class , tym . getTym_id ( ) ) ) ; tx . commit ( ) ; } }
tr	2	public NewSplashScreen ( int maximumValue , Locale locMe ) { maxVal = maximumValue ; Logger log = LoggerFactory . getLogger ( "mars.mars.gui.NewSplashScreen" ) ; MarsResourceBundle mrbSplash = new MarsResourceBundle ( locMe ) ; textVal = mrbSplash . getRBString ( "mars.gui.splash.load" , "Loading..." ) ; log . finest ( "Splash Screen created for JSE 1.6 or higher  attempting to obtain the SplashScreen class." ) ; splash = SplashScreen . getSplashScreen ( ) ; if ( splash == null ) { log . finest ( "SplashScreen couldn't be obtained  must be running on pre 1.6." ) ; System . err . println ( mrbSplash . getRBString ( "mars.errors.SplashScreenNotCompatible" , "Splash screen is null. May be running on JSE 1.5 or earlier." ) ) ; configured = false ; return ; } g = ( Graphics2D ) splash . createGraphics ( ) ; if ( g == null ) { log . finest ( "Graphics2D class could not be obtained  currently null." ) ; System . err . println ( mrbSplash . getRBString ( "mars.errors.Graphics2DNotFound" , "Cannot obtain the Splash screen graphics2D class. It is currently null." ) ) ; configured = false ; return ; } }
tr	7	public JSONArray ( JSONTokener x ) throws JSONException { this ( ) ; if ( x . nextClean ( ) != [ ) { throw x . syntaxError ( "A JSONArray text must start with '['" ) ; } if ( x . nextClean ( ) != ] ) { x . back ( ) ; for ( ; ; ) { if ( x . nextClean ( ) ==   ) { x . back ( ) ; this . myArrayList . add ( JSONObject . null ) ; } else { x . back ( ) ; this . myArrayList . add ( x . nextValue ( ) ) ; } switch ( x . nextClean ( ) ) { case   : if ( x . nextClean ( ) == ] ) { return ; } x . back ( ) ; break ; case ] : return ; default : throw x . syntaxError ( "Expected a ' ' or ']'" ) ; } } } }
tr	0	@ Override public IGameController getController ( ) { return controller ; }
tr	6	public static class getType ( class c ) { if ( c == null ) { Logger . warn ( "no (typed) class given" ) ; return null ; } class ct = getActualType ( c . getGenericSuperclass ( ) ) ; if ( ct != null ) return ct ; Type [ ] interfaces = c . getGenericInterfaces ( ) ; if ( interfaces == null || interfaces . length == 0 ) return null ; for ( Type t : interfaces ) { ct = getActualType ( t ) ; if ( ct != null ) return ct ; } return null ; }
tr	2	public boolean isLeap ( ) { return ( ( year % 4 == 0 ) && ( year % 100 != 0 ) || ( year % 400 == 0 ) ) ; }
tr	8	public HashMap < Integer , Integer > getSgd2iesdhcmap ( ) { if ( sgd2iesdhcmap != null ) { return sgd2iesdhcmap ; } sgd2iesdhcmap = new HashMap < Integer , Integer > ( ) ; String SQL1 = "SELECT id  TIME_FORMAT(inicio '%H:%i') AS inicio  TIME_FORMAT(fin '%H:%i') AS fin FROM horascentro" ; try { Statement st = getSgd ( ) . createStatement ( ) ; ResultSet rs1 = getSgd ( ) . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { int id = rs1 . getInt ( "id" ) ; String inicio = rs1 . getString ( "inicio" ) ; String fin = rs1 . getString ( "fin" ) ; String SQL2 = "SELECT codigo from sig_hores_classe WHERE inicio='" + inicio + "' AND fin='" + fin + "'" ; Statement st2 = getMysql ( ) . createStatement ( ) ; ResultSet rs2 = getMysql ( ) . getResultSet ( SQL2 , st2 ) ; if ( rs2 != null && rs2 . next ( ) ) { sgd2iesdhcmap . put ( id , rs2 . getInt ( 1 ) ) ; } if ( rs2 != null ) { rs2 . close ( ) ; st2 . close ( ) ; } } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( HoraCentro . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return sgd2iesdhcmap ; }
tr	6	LocalSocket ( Socket socket , PassthroughConnection ptc ) { this . ptc = ptc ; this . socket = socket ; DataInputStream inLocal = null ; DataOutputStream outLocal = null ; try { inLocal = new DataInputStream ( socket . getInputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream to client" ) ; if ( inLocal != null ) { try { inLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream to client" ) ; } } in = null ; out = null ; success = false ; return ; } try { outLocal = new DataOutputStream ( socket . getOutputStream ( ) ) ; } catch ( IOException e ) { ptc . printLogMessage ( "Unable to open data stream from client" ) ; if ( outLocal != null ) { try { outLocal . close ( ) ; socket . close ( ) ; } catch ( IOException e1 ) { ptc . printLogMessage ( "Unable to close data stream from client" ) ; } } in = null ; out = null ; success = false ; return ; } in = inLocal ; out = outLocal ; success = true ; }
tr	2	protected void markCreatedNode ( Node newNode ) { if ( ! ( newNode instanceof ObjectNode ) ) return ; if ( ! containsAncestor ( createdNodes , newNode ) ) { Node . createdNodes . add ( newNode ) ; } }
tr	2	int clip ( int t , int lo , int hi ) { return t < lo ? lo : t > hi ? hi : t ; }
tr	2	public TestClient ( int port , String name ) { try { count ++ ; socket = new Socket ( InetAddress . getLocalHost ( ) , port ) ; this . name = name ; this . setName ( "TestClientThread-" + count ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	1	@ Override public E actual ( ) { if ( actual == null ) { throw new NullPointerException ( "Error: no se puede acceder el dato actual!" ) ; } return actual . getDato ( ) ; }
tr	0	@ Override public Object visit ( ASTVisitor v , Object arg ) throws Exception { return v . visitBinaryExpr ( this , arg ) ; }
tr	0	@ Override public void init ( GameContainer gc , StateBasedGame sbg ) throws SlickException { this . sbg = sbg ; logo = new Image ( "data/SVULogo.png" ) ; newgame = new Image ( "data/newgame.png" ) ; continuegame = new Image ( "data/loadgame.png" ) ; options = new Image ( "data/options.png" ) ; quit = new Image ( "data/quitgame.png" ) ; newgameroll = new Image ( "data/newgameglow.png" ) ; continuegameroll = new Image ( "data/loadgameglow.png" ) ; optionsroll = new Image ( "data/optionsglow.png" ) ; quitroll = new Image ( "data/quitgameglow.png" ) ; int logowidth = logo . getWidth ( ) ; logox = ( gc . getWidth ( ) - logowidth ) / 2 ; newgamex = ( gc . getWidth ( ) - newgame . getWidth ( ) ) / 2 ; continuex = ( gc . getWidth ( ) - continuegame . getWidth ( ) ) / 2 ; optionsx = ( gc . getWidth ( ) - options . getWidth ( ) ) / 2 ; quitx = ( gc . getWidth ( ) - quit . getWidth ( ) ) / 2 ; areas [ 0 ] = new MouseOverArea ( gc , newgame , newgamex , 300 , this ) ; areas [ 0 ] . setMouseOverImage ( newgameroll ) ; areas [ 1 ] = new MouseOverArea ( gc , continuegame , continuex , 350 , this ) ; areas [ 1 ] . setMouseOverImage ( continuegameroll ) ; areas [ 2 ] = new MouseOverArea ( gc , options , optionsx , 400 , this ) ; areas [ 2 ] . setMouseOverImage ( optionsroll ) ; areas [ 3 ] = new MouseOverArea ( gc , quit , quitx , 450 , this ) ; areas [ 3 ] . setMouseOverImage ( quitroll ) ; }
tr	3	private Object firstKey ( Object subtree ) { if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; return ary [ 0 ] ; } else { Node node = ( Node ) subtree ; if ( node . left == null ) { if ( node . key instanceof EquivalentMap ) return ( ( EquivalentMap ) node . key ) . contents . get ( 0 ) . key ; else return node . key ; } else return firstKey ( node . left ) ; } }
tr	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_BitcoinAcct ( swigCPtr ) ; } swigCPtr = 0 ; } super . delete ( ) ; }
tr	9X	public static JSONArray rowToJSONArray ( JSONTokener x ) throws JSONException { JSONArray ja = new JSONArray ( ) ; for ( ; ; ) { String value = getValue ( x ) ; char c = x . next ( ) ; if ( value == null || ( ja . length ( ) == 0 && value . length ( ) == 0 && c !=   ) ) { return null ; } ja . put ( value ) ; for ( ; ; ) { if ( c ==   ) { break ; } if ( c !=   ) { if ( c == '' || c == '' || c == 0 ) { return ja ; } throw x . syntaxError ( "Bad character '" + c + "' (" + ( int ) c + ")." ) ; } c = x . next ( ) ; } } }
tr	7	private void createFiles ( boolean test , HashMap < String , PrintToFile > filesMap , String cat ) { try { BufferedReader input = new BufferedReader ( new FileReader ( Classify . dataPath + "/rawData/train" + cat + ".csv" ) ) ; String line ; line = input . readLine ( ) ; HashMap < String , ContractorHolder > contractors = new HashMap < String , ContractorHolder > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { String [ ] tmpAr = line . split ( "\" \"" ) ; for ( int i = 0 ; i < tmpAr . length ; i ++ ) { tmpAr [ i ] = tmpAr [ i ] . replaceAll ( "\"" , "" ) ; } String contractor = tmpAr [ 2 ] . trim ( ) ; ContractorHolder contractorHolder = contractors . get ( contractor ) ; if ( contractorHolder == null ) { contractorHolder = new ContractorHolder ( ) ; contractors . put ( contractor , contractorHolder ) ; } String jobType = tmpAr [ 0 ] . trim ( ) ; String opening = tmpAr [ 1 ] . trim ( ) ; String client = tmpAr [ 30 ] . trim ( ) ; ClientHolder curClientHolder = clientHistory . get ( client ) ; if ( curClientHolder == null ) { curClientHolder = new ClientHolder ( ) ; clientHistory . put ( client , curClientHolder ) ; } createInstance ( filesMap . get ( ( test ? "test" : "train" ) + jobType ) , tmpAr , contractorHolder , curClientHolder , contractor ) ; if ( test ) filesMap . get ( "testHolder" + jobType ) . writeToFile ( opening + " " + contractor ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	5	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final SondageReponse other = ( SondageReponse ) obj ; if ( this . id != other . id ) { return false ; } if ( this . id_sondage != other . id_sondage ) { return false ; } if ( this . choix != other . choix ) { return false ; } return true ; }
tr	7	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Items . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new Items ( ) . setVisible ( true ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
tr	7	public Object nextValue ( ) throws JSONException { char c = this . nextClean ( ) ; String string ; switch ( c ) { case " : case ' : return this . nextString ( c ) ; case { : this . back ( ) ; return new JSONObject ( this ) ; case [ : this . back ( ) ; return new JSONArray ( this ) ; } StringBuffer sb = new StringBuffer ( ) ; while ( c >=   && " :]}/\\\"[{;=#" . indexOf ( c ) < 0 ) { sb . append ( c ) ; c = this . next ( ) ; } this . back ( ) ; string = sb . toString ( ) . trim ( ) ; if ( "" . equals ( string ) ) { throw this . syntaxError ( "Missing value" ) ; } return JSONObject . stringToValue ( string ) ; }
tr	7	public static String RegexExtraction ( String patternStr , String data ) { Pattern pattern ; if ( patternStr == null || patternStr . length ( ) == 0 || patternStr . isEmpty ( ) ) return null ; if ( RegexManager . getInstance ( ) . patternList . containsKey ( patternStr ) ) { pattern = RegexManager . getInstance ( ) . patternList . get ( patternStr ) ; } else { pattern = Pattern . compile ( patternStr ) ; RegexManager . getInstance ( ) . patternList . put ( patternStr , pattern ) ; } Matcher matcher = pattern . matcher ( data ) ; String res = "" ; if ( matcher . find ( ) ) { if ( patternStr . startsWith ( ParameterSetting . REGXWORDPATTERN_V2 ) ) { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ array . length - 1 ] . replace (   ,   ) . trim ( ) ; } else { String [ ] array = matcher . group ( 1 ) . split ( " " ) ; res = array [ 0 ] . replace (   ,   ) . trim ( ) ; } } if ( StopwordsFilter . getInstance ( ) . isStopWords ( res ) ) return null ; else return res ; }
tr	5	private LinkedList < String > extractKeywords ( String filename ) { LinkedList < String > keywords = new LinkedList < String > ( ) ; int posOfDot = filename . lastIndexOf ( . ) ; if ( posOfDot != - 1 ) { keywords . add ( filename . substring ( posOfDot ) ) ; filename = filename . substring ( 0 , posOfDot ) ; } filename = filename . replaceAll ( "[0-9]+" , " " ) . trim ( ) ; String [ ] splitCamelAndDelim = filename . split ( "((?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])|[ |.|_|\\-|\\(|\\)])" ) ; keywords . addAll ( Arrays . asList ( splitCamelAndDelim ) ) ; for ( Iterator < String > iter = keywords . iterator ( ) ; iter . hasNext ( ) ; ) { String item = iter . next ( ) . trim ( ) ; if ( item . length ( ) < 4 && ! ( item . length ( ) == 3 && item . equals ( item . toUpperCase ( ) ) ) ) iter . remove ( ) ; } return keywords ; }
tr	0	@ Override public TileEntity getTileEntity ( Tile parent ) { return new TileDoorEntity ( parent ) ; }
tr	8	@ SuppressWarnings ( "unchecked" ) @ Transactional public List < Merchant > getMerchantList ( String merchantName , String sortBy , String sortOrder ) throws Exception { List < Merchant > lstMerchants = new ArrayList < Merchant > ( ) ; Session session = null ; Criteria criteriaObj = null ; logger . info ( "merchantName---------->" + merchantName ) ; logger . info ( "sortBy--------------->" + sortBy ) ; logger . info ( "sortOrder------------>" + sortOrder ) ; String sName = merchantName ; try { session = sessionFactory . getCurrentSession ( ) ; logger . info ( "Entered into getMerchantList()--->" ) ; logger . info ( "Retrieving all merchants" ) ; if ( session != null ) { criteriaObj = session . createCriteria ( Merchant . class ) ; if ( merchantName != null ) { logger . info ( "Retrieving  merchants based on name" ) ; criteriaObj . add ( Restrictions . ilike ( "sName" , "%" + sName + "%" ) ) ; criteriaObj . add ( Restrictions . = ( "bdeletedFlag" , false ) ) ; } lstMerchants = criteriaObj . list ( ) ; logger . info ( "lstMerchants from DAO----------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "asc" ) { logger . info ( "Retrieving  merchants based on Ascending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . asc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } if ( sortBy != null && sortOrder == "desc" ) { logger . info ( "Retrieving  merchants based on Descending sort order for " + sortBy ) ; lstMerchants = criteriaObj . addOrder ( Order . desc ( sortBy ) ) . list ( ) ; logger . info ( "lstMerchants size-------->" + lstMerchants . size ( ) ) ; } Iterator < Merchant > it = lstMerchants . iterator ( ) ; while ( it . hasNext ( ) ) { Merchant merchant = it . next ( ) ; System . out . println ( "dao......." + merchant ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; logger . error ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; throw new Exception ( "Exception occured in getMerchantList()--->" + e . getMessage ( ) ) ; } return lstMerchants ; }
tr	7	private BufferedImage getView ( ) { if ( this . getWidth ( ) > 0 && this . getHeight ( ) > 0 ) { int mapSize = ( mapImage_Scaled . getHeight ( ) ) ; if ( viewPort . x + this . getWidth ( ) > mapSize ) { int moveXBy = viewPort . x + this . getWidth ( ) - mapSize ; moveView ( - moveXBy , 0 ) ; } if ( viewPort . y + this . getHeight ( ) > mapSize ) { int moveYBy = viewPort . y + this . getHeight ( ) - mapSize ; moveView ( 0 , - moveYBy ) ; } int windowHeight = this . getHeight ( ) ; int windowWidth = this . getWidth ( ) ; if ( this . getHeight ( ) > mapImage_Scaled . getHeight ( ) ) { windowHeight = mapImage_Scaled . getHeight ( ) ; viewPort . y = 0 ; } if ( this . getWidth ( ) > mapImage_Scaled . getWidth ( ) ) { windowWidth = mapImage_Scaled . getWidth ( ) ; viewPort . x = 0 ; } mapImage_View = null ; try { mapImage_View = mapImage_UnitAndBuildingsScaled . getSubimage ( viewPort . x , viewPort . y , windowWidth , windowHeight ) ; } catch ( Exception e ) { System . err . println ( "Error creating subview!" ) ; } } return mapImage_View ; }
tr	3	public void add ( int index , E value ) { if ( ( index < 0 ) || ( index > this . size ) ) { return ; } if ( index == 0 ) { this . addFront ( value ) ; } else { this . addAfter ( this . nodeAtPosition ( index - 1 ) , value ) ; } this . size ++ ; }
tr	7	public void connect ( TreeLinkNode root ) { if ( root == null || root . left == null || root . right == null ) { return ; } if ( root . left != null ) { root . left . next = root . right ; } if ( root . right != null && root . next != null ) { root . right . next = root . next . left == null ? null : root . next . left ; } connect ( root . left ) ; connect ( root . right ) ; }
tr	3	public void add ( T item ) { Node node = new Node ( item ) ; if ( current == null ) { node . next = head ; node . prev = null ; if ( head != null ) head . prev = node ; head = node ; } else { node . next = current . next ; node . prev = current ; if ( current . next != null ) current . next . prev = node ; current . next = node ; } ++ idx ; current = node ; ++ size ; }
tr	8	public boolean baca ( String no_beli ) { boolean adaKesalahan = false ; Connection cn = null ; this . no_beli = no_beli ; listKwitansi = null ; try { class . forName ( Koneksi . driver ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "JDBC Driver tidak ditemukan atau rusak\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { try { cn = DriverManager . getConnection ( Koneksi . database + "?user=" + Koneksi . user + "&password=" + Koneksi . password + "" ) ; } catch ( Exception ex ) { adaKesalahan = true ; JOptionPane . showMessageDialog ( null , "Koneksi ke " + Koneksi . database + " gagal\n" + ex , "Kesalahan" , JOptionPane . ERROR_MESSAGE ) ; } if ( ! adaKesalahan ) { String SQLStatemen ; Statement sta ; ResultSet rset ; try { SQLStatemen = "select * from kwitansi where no_beli='" + no_beli + "'" ; sta = cn . createStatement ( ) ; rset = sta . executeQuery ( SQLStatemen ) ; rset . next ( ) ; rset . last ( ) ; listKwitansi = new Object [ rset . getRow ( ) ] [ 4 ] ; rset . first ( ) ; int i = 0 ; do { if ( ! rset . getString ( "kode_buku" ) . equals ( "" ) ) { listKwitansi [ i ] = new Object [ ] { rset . getString ( "kode_buku" ) , rset . getInt ( "jumlah" ) , rset . getInt ( "harga" ) } ; } i ++ ; } while ( rset . next ( ) ) ; sta . close ( ) ; rset . close ( ) ; if ( listKwitansi . length > 0 ) { adaKesalahan = false ; } } catch ( Exception ex ) { adaKesalahan = true ; } } } return ! adaKesalahan ; }
tr	3	public JSONObject accumulate ( String key , Object value ) throws JSONException { testValidity ( value ) ; Object object = opt ( key ) ; if ( object == null ) { put ( key , value instanceof JSONArray ? new JSONArray ( ) . put ( value ) : value ) ; } else if ( object instanceof JSONArray ) { ( ( JSONArray ) object ) . put ( value ) ; } else { put ( key , new JSONArray ( ) . put ( object ) . put ( value ) ) ; } return this ; }
tr	9X	@ Override public Collection < ApiLocation > getLocationsWithMinerals ( ApiAuth < ? > character ) throws ApiException { Set < long > result = new TreeSet < long > ( ) ; api . setAuth ( character ) ; ApiConnector connector = EveApi . getConnector ( ) ; AssetListResponse response = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . ASSET_LIST , 2 , character ) , new AssetListHandler ( ) , AssetListResponse . class ) ; Stack < EveAsset < ? >> assets = new Stack < EveAsset < ? >> ( ) ; assets . addAll ( response . getAll ( ) ) ; while ( ! assets . isEmpty ( ) ) { EveAsset < ? > asset = assets . pop ( ) ; if ( asset . getAssets ( ) != null ) { assets . addAll ( asset . getAssets ( ) ) ; } if ( isMineral ( asset ) && asset . getLocationID ( ) != null ) { result . add ( asset . getLocationID ( ) ) ; } } long [ ] objects = result . toArray ( new long [ 0 ] ) ; long [ ] ids = new long [ objects . length ] ; for ( int i = 0 ; i < ids . length ; i ++ ) { ids [ i ] = objects [ i ] ; } String join = StringUtils . join ( " " , ids ) ; Map < String , String > params = Collections . singletonMap ( "IDs" , join ) ; LocationsResponse locationsResponse = connector . execute ( new ApiRequest ( ApiPath . CHARACTER , ApiPage . LOCATIONS , 2 , character , params ) , new LocationsHandler ( ) , LocationsResponse . class ) ; return locationsResponse . getAll ( ) ; }
tr	6	public void clickActionListener ( final JButton btn ) { btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { for ( int i = 0 ; i < suggestedButtonsNames . length ; i ++ ) if ( existingBoats . contains ( suggestedButtonsNames [ i ] ) ) { System . out . println ( "Ne mozes postaviti brod na to polje!" ) ; return ; } int sifraBroda = workingFrame . updateLabels ( ) ; if ( ( sifraBroda ) != - 1 ) { for ( int i = 0 ; i < 10 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) { if ( myButtonGameBoard [ i ] [ j ] . isBorderPainted ( ) ) { existingBoats . add ( myButtonGameBoard [ i ] [ j ] . getName ( ) ) ; myButtonGameBoard [ i ] [ j ] . setIcon ( shipImage ) ; gameBoardMask . FillStartMatrix ( i , j , sifraBroda ) ; } } } gameBoardMask . ispisi ( ) ; logicMatrix = gameBoardMask . gameBoard ; } } ) ; }
tr	0	public int process_id ( ) { return 2 ; }
tr	9X	public Individual run ( ) { int i , generation ; Individual offspring1 , offspring2 ; Individual . calculateAssignmentProbalityForDiefferentDepot ( problemInstance ) ; Individual . calculateProbalityForDiefferentVehicle ( problemInstance ) ; PopulationInitiator . initialisePopulation ( population , POPULATION_SIZE , problemInstance ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; int continuosInjection = 0 ; double previousBest = - 1 ; double bestBeforeInjection = - 1 ; for ( generation = 0 ; generation < NUMBER_OF_GENERATION ; generation ++ ) { Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; fussSelection . initialise ( population , false ) ; rouletteWheelSelection . initialise ( population , false ) ; i = 0 ; parent1 = population [ 0 ] ; parent2 = rouletteWheelSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; while ( i < NUMBER_OF_OFFSPRING ) { parent1 = rouletteWheelSelection . getIndividual ( population ) ; parent2 = fussSelection . getIndividual ( population ) ; offspring1 = new Individual ( problemInstance ) ; Uniform_VariedEdgeRecombnation_Crossover . crossOver_Uniform_VariedEdgeRecombination ( problemInstance , parent1 , parent2 , offspring1 ) ; offspringPopulation [ i ] = offspring1 ; i ++ ; } TotalCostCalculator . calculateCostofPopulation ( offspringPopulation , 0 , NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . concatPopulation ( parentOffspringTotalPopulation , population , offspringPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . validationTest ( ) == false ) { System . err . println ( "ERROR\nERROR\nERROR\nIndividual is invalid!!!" + " gen : " + generation + " index : " + p ) ; out . println ( "\n\nINVALID INDIVIDUAL : \n" ) ; parentOffspringTotalPopulation [ p ] . print ( ) ; return population [ 0 ] ; } } localImprovement . initialise ( parentOffspringTotalPopulation ) ; localImprovement . run ( parentOffspringTotalPopulation ) ; TotalCostCalculator . calculateCostofPopulation ( parentOffspringTotalPopulation , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( parentOffspringTotalPopulation ) ; for ( int p = 0 ; p < parentOffspringTotalPopulation . length - 1 ; p ++ ) { if ( parentOffspringTotalPopulation [ p ] . cost == parentOffspringTotalPopulation [ p + 1 ] . cost ) { if ( Individual . isDuplicate ( problemInstance , parentOffspringTotalPopulation [ p ] , parentOffspringTotalPopulation [ p + 1 ] ) ) { parentOffspringTotalPopulation [ p ] = new Individual ( problemInstance ) ; Initialise_ClosestDepot_GreedyCut . initialise ( parentOffspringTotalPopulation [ p ] ) ; TotalCostCalculator . calculateCost ( parentOffspringTotalPopulation [ p ] , loadPenaltyFactor , routeTimePenaltyFactor ) ; } } } Utility . sort ( parentOffspringTotalPopulation ) ; int elitistRatio = POPULATION_SIZE * 10 / 100 ; population [ 0 ] = parentOffspringTotalPopulation [ 0 ] ; int index2 = 1 ; int index1 = 1 ; while ( index1 < elitistRatio ) { population [ index1 ] = parentOffspringTotalPopulation [ index2 ] ; index1 ++ ; index2 ++ ; } Individual total [ ] = new Individual [ POPULATION_SIZE + NUMBER_OF_OFFSPRING - elitistRatio ] ; System . arraycopy ( parentOffspringTotalPopulation , elitistRatio , total , 0 , total . length ) ; survivalSelectionOperator . initialise ( total , true ) ; for ( i = elitistRatio ; i < POPULATION_SIZE ; i ++ ) { population [ i ] = survivalSelectionOperator . getIndividual ( total ) ; } Utility . sort ( population ) ; if ( Solver . singleRun ) { double tmpSum = 0 ; for ( int tmpi = 0 ; tmpi < POPULATION_SIZE ; tmpi ++ ) tmpSum += population [ tmpi ] . costWithPenalty ; System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible + " Avg : " + ( tmpSum / POPULATION_SIZE ) ) ; } } TotalCostCalculator . calculateCostofPopulation ( population , 0 , POPULATION_SIZE , loadPenaltyFactor , routeTimePenaltyFactor ) ; Utility . sort ( population ) ; Solver . gatherExcelData ( population , POPULATION_SIZE , generation ) ; if ( Solver . outputToFile ) { out . print ( "\n\n\n\n\n--------------------------------------------------\n" ) ; out . print ( "\n\n\nFINAL POPULATION\n\n" ) ; for ( i = 0 ; i < POPULATION_SIZE ; i ++ ) { out . println ( "\n\nIndividual : " + i ) ; population [ i ] . print ( ) ; } } System . out . println ( "Gen : " + generation + " Best : " + population [ 0 ] . costWithPenalty + " Feasibility : " + population [ 0 ] . isFeasible ) ; return population [ 0 ] ; }
tr	3	public String getMimetype ( String paramString ) { int i = paramString . lastIndexOf ( "." ) ; if ( ( i > 0 ) && ( i + 1 < paramString . length ( ) ) ) { String str1 = paramString . substring ( i + 1 ) ; if ( this . extensionToMimetypeMap . keySet ( ) . contains ( str1 ) ) { String str2 = ( String ) this . extensionToMimetypeMap . get ( str1 ) ; logger . info ( "Recognised extension '" + str1 + "'  mimetype is: '" + str2 + "'" ) ; return str2 ; } logger . info ( "Extension '" + str1 + "' is unrecognized in mime type listing" + "  using default mime type: '" + "application/octet-stream" + "'" ) ; } else { logger . info ( "File name has no extension  mime type cannot be recognised for: " + paramString ) ; } return "application/octet-stream" ; }
tr	9X	public static void main ( String [ ] args ) { CallParser parser = new CallParser ( ) ; parser . addLine ( 0 , "static sequence [pipe]function" ) ; parser . addLine ( 1 , "[o]:[p] s{var:I32=0}[ss] [s]:[^]a[var33  l] " ) ; parser . addLine ( 2 , "if{[qwerty]:{stuff}[xyz] xyz}: " ) ; parser . addLine ( 3 , "[a]asd[b]op[p]" ) ; parser . addLine ( 4 , ":elseif{something}:" ) ; parser . addLine ( 5 , ":elseif{somethingelse}: " ) ; parser . addLine ( 6 , "static sequence2" ) ; parser . addLine ( 7 , ":end" ) ; parser . addLine ( 8 , "EXECUTE{[a]:[>] [<  \" is sweet\"]PRINTLN  lol}" ) ; for ( Component com : parser . separateComponents ( ) ) System . out . print ( com . type + " " ) ; System . out . println ( ) ; parser . parse ( ) ; int indent = 0 ; for ( ParsedCall call : parser . calls ) { if ( call . isBlockEnd ) { indent -- ; } for ( int ind = 0 ; ind < indent ; ind ++ ) { System . out . print ( "  " ) ; } if ( call . isBlockEnd ) System . out . print ( ":" ) ; System . out . print ( "[" ) ; for ( String param : call . inParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; System . out . print ( call . callName ) ; if ( call . confNodes . length > 0 ) { System . out . print ( "{ " ) ; for ( String param : call . confNodes ) { System . out . print ( param + " " ) ; } System . out . print ( "}" ) ; } System . out . print ( "[" ) ; for ( String param : call . outParams ) { System . out . print ( param + " " ) ; } System . out . print ( "]" ) ; if ( call . isBlockStart ) { indent ++ ; System . out . print ( ":" ) ; } System . out . println ( ) ; } }
tr	9X	public File getFileChoice ( Component parent ) { if ( chooser . showSaveDialog ( parent ) == JFileChooser . APPROVE_OPTION ) { File newFile = chooser . getSelectedFile ( ) ; if ( chooser . getFileFilter ( ) == zipFilter ) { if ( ! newFile . getName ( ) . toUpperCase ( ) . endsWith ( ".ZIP" ) ) { newFile = new File ( newFile . getAbsoluteFile ( ) + ".zip" ) ; } } if ( newFile . exists ( ) ) { int confirmChoice = JOptionPane . showConfirmDialog ( parent , "File already exists. Do you want to replace it?" ) ; if ( confirmChoice == JOptionPane . YES_OPTION ) { newFile . delete ( ) ; } else if ( confirmChoice == JOptionPane . NO_OPTION ) { return getFileChoice ( parent ) ; } else { return null ; } } if ( ! newFile . exists ( ) ) { boolean fileCreated = false ; try { fileCreated = newFile . createNewFile ( ) ; } catch ( Exception e ) { } finally { if ( ! fileCreated ) { JOptionPane . showMessageDialog ( parent , "An Error Occurred" ) ; return null ; } } } return newFile ; } else { return null ; } }
tr	0	@ Override public void setPopulation ( TspPopulation p ) { population = p ; }
tr	4	public List < Integer > getRow ( int rowIndex ) { List < Integer > result = new ArrayList < Integer > ( ) ; List < Integer > temp = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i <= rowIndex ; i ++ ) { temp = new ArrayList < Integer > ( result ) ; result . clear ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 || j == i ) result . add ( 1 ) ; else { result . add ( temp . get ( j - 1 ) + temp . get ( j ) ) ; } } } return result ; }
tr	5	public static void main ( String [ ] args ) { Comparable [ ] arrayChar = { S , H , E , L , L , S , O , R , T , E , X , A , M , P , L , E } ; int length = arrayChar . length ; int h = 1 ; while ( h < length / 3 ) { h = h * 3 + 1 ; System . out . println ( "top==>" + h ) ; } while ( h >= 1 ) { for ( int i = h ; i < length ; i ++ ) { for ( int j = i ; j >= h && less ( arrayChar [ j ] , arrayChar [ j - h ] ) ; j -= h ) { exchange ( arrayChar , j , j - h ) ; } } h = h / 3 ; System . out . println ( h ) ; } show ( arrayChar ) ; }
tr	3	public void add_production ( production prod ) throws internal_error { if ( prod == null || prod . lhs ( ) == null || prod . lhs ( ) . the_symbol ( ) != this ) throw new internal_error ( "Attempt to add invalid production to non terminal production table" ) ; _productions . put ( prod , prod ) ; }
tr	5	public V checkBaseInterfaces ( class c ) { Map < class , V > possibles = new HashMap < class , V > ( ) ; for ( class base = c ; base != Object . class ; base = base . getSuperclass ( ) ) { for ( class itf : base . getInterfaces ( ) ) { V val = lookup . valAt ( itf ) ; if ( val != null ) possibles . put ( itf , val ) ; } } switch ( possibles . size ( ) ) { case 0 : return null ; case 1 : return possibles . values ( ) . iterator ( ) . next ( ) ; default : throw new RuntimeException ( "More thane one match for " + c ) ; } }
tr	9X	public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; byte p1 = 3 ; int p1Guess ; int p1Taken ; byte p2 = 3 ; int p2Guess ; int p2Taken ; boolean p1Turn = true ; byte round = 0 ; System . out . println ( "Stone game" ) ; while ( p1 > 0 && p2 > 0 ) { System . out . println ( "------------------" ) ; System . out . println ( "Round: " + ++ round ) ; System . out . println ( " You have " + p1 + " stones; CPU has " + p2 + " stones" ) ; System . out . println ( " How much stones you're taking: " ) ; do p1Taken = in . nextInt ( ) ; while ( p1Taken > p1 || p1Taken < 0 ) ; p2Taken = Game . randInt ( 0 , p2 ) ; if ( p1Turn ) { System . out . println ( " Your guess is: " ) ; p1Guess = in . nextInt ( ) ; do { int rand_min = p1Guess - p2 ; if ( rand_min < 0 ) rand_min = 0 ; p2Guess = Game . randInt ( rand_min , p1 + p2 ) ; } while ( p2Guess == p1Guess ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; } else { p2Guess = Game . randInt ( p2Taken , p2Taken + p1 ) ; System . out . println ( "CPU is thinking of: " + p2Guess ) ; System . out . println ( " Your guess is: " ) ; do p1Guess = in . nextInt ( ) ; while ( p1Guess == p2Guess ) ; } System . out . println ( "We took: " + p1Taken + " P2 took: " + p2Taken + " stones" ) ; if ( p1Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "We won " + round + ". round" ) ; -- p1 ; p1Turn = true ; } else if ( p2Guess == ( p1Taken + p2Taken ) ) { System . out . println ( "CPU won " + round + ". round" ) ; -- p2 ; p1Turn = false ; } else p1Turn = ! p1Turn ; } System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; if ( p1 == 0 ) System . out . println ( "PLAYER 1 HAS WON" ) ; else System . out . println ( "CPU HAS WON" ) ; System . out . println ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" ) ; }
tr	8	public StringBuilder streamOut ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < numLines ; i ++ ) { if ( i == 0 || i == numLines - 1 ) { buffer . append ( "2 w\n" ) ; } else if ( i == 1 ) { buffer . append ( "0.5 w\n" ) ; } buffer . append ( horzLines [ i ] . streamOut ( ) ) ; buffer . append ( vertLines [ i ] . streamOut ( ) ) ; } for ( OrdinalPt opt : ordPts ) { buffer . append ( opt . streamOut ( ) ) ; } for ( GoStone stone : goStones ) { buffer . append ( stone . streamOut ( ) ) ; } for ( GoLabel label : labels ) { buffer . append ( label . streamOut ( ) ) ; } for ( Triangle triangle : triangles ) { buffer . append ( triangle . streamOut ( ) ) ; } return buffer ; }
tr	4	public JSONWriter key ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null key." ) ; } if ( this . mode == k ) { try { this . stack [ this . top - 1 ] . putOnce ( string , boolean . true ) ; if ( this . , ) { this . writer . write (   ) ; } this . writer . write ( JSONObject . quote ( string ) ) ; this . writer . write ( : ) ; this . , = false ; this . mode = o ; return this ; } catch ( IOException e ) { throw new JSONException ( e ) ; } } throw new JSONException ( "Misplaced key." ) ; }
tr	7	public void radixSort ( int [ ] data ) { int max = data [ 0 ] , radix = 1 ; ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( max < data [ i ] ) { max = data [ i ] ; } } Node [ ] bucket = new Node [ 10 ] ; for ( int i = 0 ; i < bucket . length ; i ++ ) { bucket [ i ] = new Node ( ) ; } while ( max / radix > 0 ) { for ( int i = 0 ; i < data . length ; i ++ ) { bucket [ ( data [ i ] / radix ) % 10 ] . list . add ( data [ i ] ) ; } int pos = 0 ; for ( int i = 0 ; i < bucket . length ; i ++ ) { for ( int j = 0 ; j < bucket [ i ] . list . size ( ) ; j ++ ) { data [ pos ++ ] = bucket [ i ] . list . get ( j ) ; } bucket [ i ] . list . clear ( ) ; } radix *= 10 ; } }
tr	8	public void unobfuscateProject ( ) { String obfuscatedContent ; int totalSizeTransfert = 0 ; int numberOfFiles = 0 ; int fileSizeTransfert ; createDestinationDirectories ( ) ; List < File > codeFiles = new ArrayList < File > ( ) ; for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) || fileExtension . equals ( Constants . JAVA_FILE_EXTENSION ) ) { codeFiles . add ( file ) ; } } for ( FileObfuscationStructure structure : projectFileObfuscationStructureList ) { File obfuscatedFile = new File ( destinationDir + "\\" + structure . getFileName ( ) ) ; obfuscatedContent = handler . replaceVariables ( structure , commentRemover , whiteSpacesRemover ) ; fileSizeTransfert = McbcFileUtils . putFileContent ( obfuscatedFile , obfuscatedContent ) ; totalSizeTransfert += fileSizeTransfert ; numberOfFiles ++ ; } if ( ! copyOnlySource ) { for ( File file : projectFiles ) { String fileExtension = McbcFileUtils . getFilenameExtension ( file . getName ( ) ) ; if ( ! Constants . PHP_EXTENSION_TABLE . contains ( fileExtension ) && file . isFile ( ) ) { File newFile = new File ( destinationDir + "\\" + file . getAbsolutePath ( ) . substring ( sourceDir . length ( ) ) ) ; fileSizeTransfert = McbcFileUtils . copyFile ( file , newFile ) ; numberOfFiles ++ ; totalSizeTransfert += fileSizeTransfert ; } } } }
tr	8	public static void main ( String [ ] args ) { ConsistentGlobalProblemSetInitialisation starter = new ConsistentGlobalProblemSetInitialisation ( ) ; starter . initLanguage ( new char [ ] { 0 , 1 } , 10 , "(0|101|11(01)*(1|00)1|(100|11(01)*(1|00)0)(1|0(01)*(1|00)0)*0(01)*(1|00)1)*" ) ; int solutionFoundCounter = 0 ; int noSolutionFound = 0 ; List < long > cycleCount = new LinkedList < long > ( ) ; long tmpCycle ; long timeStamp ; int [ ] problemCount = new int [ 5 ] ; int [ ] candidatesCount = new int [ 5 ] ; int [ ] noCycles = new int [ 2 ] ; problemCount [ 0 ] = 10 ; problemCount [ 1 ] = 20 ; problemCount [ 2 ] = 30 ; problemCount [ 3 ] = 40 ; problemCount [ 4 ] = 50 ; candidatesCount [ 0 ] = 50 ; candidatesCount [ 1 ] = 100 ; candidatesCount [ 2 ] = 150 ; candidatesCount [ 3 ] = 200 ; candidatesCount [ 4 ] = 250 ; noCycles [ 0 ] = 250 ; noCycles [ 1 ] = 500 ; int pc = 0 ; int cc = 0 ; int nc = 0 ; for ( int x = 0 ; x < 10 ; x ++ ) { System . out . println ( "x:" + x ) ; for ( int n = 0 ; n < 25 ; n ++ ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd_HH_mm_ss" ) ; Logger l = new Logger ( "C_G_" + df . format ( new Date ( ) ) + ".log" , true ) ; pc = problemCount [ n % 5 ] ; cc = candidatesCount [ ( int ) Math . floor ( n / 5 ) ] ; nc = noCycles [ 1 ] ; l . log ( "Problem Count: " + pc ) ; l . log ( "CandidatesCount: " + cc ) ; l . log ( "Max Cycles: " + nc ) ; solutionFoundCounter = 0 ; noSolutionFound = 0 ; cycleCount = new LinkedList < long > ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { timeStamp = System . currentTimeMillis ( ) ; starter . initProblems ( pc ) ; starter . initCandidates ( cc ) ; tmpCycle = starter . startEvolution ( nc ) ; l . log ( i + ": finished (" + ( System . currentTimeMillis ( ) - timeStamp ) + "ms  " + tmpCycle + "cycles)" ) ; if ( starter . getWinner ( ) != null ) { GraphvizRenderer . renderGraph ( starter . getWinner ( ) . getObj ( ) , "winner.svg" ) ; solutionFoundCounter ++ ; cycleCount . add ( tmpCycle ) ; l . log ( i + ": Solution found." ) ; } else { noSolutionFound ++ ; l . log ( i + ": No solution found." ) ; } } long max = 0 ; long min = 10000 ; long sum = 0 ; for ( long no : cycleCount ) { sum += no ; max = ( no > max ? no : max ) ; min = ( no < min ? no : min ) ; } l . log ( "Solution Found: " + solutionFoundCounter ) ; l . log ( "Avg cycles: " + ( cycleCount . size ( ) > 0 ? sum / cycleCount . size ( ) : 0 ) ) ; l . log ( "Max cycles: " + max ) ; l . log ( "Min cycles: " + min ) ; l . log ( "No solution found: " + noSolutionFound ) ; l . finish ( ) ; } } }
tr	4	public static String readFile ( String filePath ) throws FileNotExistException { File file = new File ( filePath ) ; StringBuilder builder = new StringBuilder ( ) ; if ( ! file . exists ( ) ) { throw new FileNotExistException ( filePath ) ; } try { BufferedReader buffer = new BufferedReader ( new FileReader ( file ) ) ; String tmp = buffer . readLine ( ) ; while ( tmp != null ) { builder . append ( tmp ) ; tmp = buffer . readLine ( ) ; if ( tmp != null ) builder . append ( '' ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return builder . toString ( ) ; }
tr	4	@ Override public boolean getPoint ( int mouseX , int mouseY ) { int newX = - 1 ; int newY = - 1 ; if ( mouseX < 800 ) { int cx = Boot . getPlayer ( ) . getX ( ) ; int cy = Boot . getPlayer ( ) . getY ( ) ; newX = cx + ( mouseX / Standards . TILE_SIZE ) - 12 ; newY = cy + ( ( Standards . W_HEIGHT - mouseY ) / Standards . TILE_SIZE ) - 12 ; } if ( newX != - 1 && newY != - 1 ) { if ( picks == 0 ) { this . posX = newX ; this . posY = newY ; picks = 1 ; } else { this . posX2 = newX ; this . posY2 = newY ; picks = 0 ; } } return true ; }
tr	3	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	2	public FieldElement getElement ( Sprite sprite ) { Collection < FieldElement > keys ; Sprite currentSprite ; keys = table . keySet ( ) ; for ( FieldElement key : keys ) { currentSprite = table . get ( key ) ; if ( currentSprite . equals ( sprite ) ) { return key ; } } return null ; }
tr	6	private void handleNames ( Message m ) { if ( m . numArgs ( ) < 3 ) return ; if ( m . getCode ( ) == MessageCode . RPL_ENDOFNAMES ) { getChannel ( m . getArg ( 2 ) ) . usersChanged ( ) ; return ; } if ( m . numArgs ( ) < 5 || m . get ( 3 ) . charAt ( 0 ) == * ) return ; Channel c = getChannel ( m . getArg ( 3 ) ) ; StringTokenizer st = new StringTokenizer ( m . getMessage ( ) , " " ) ; User u ; String nick ; while ( st . hasMoreTokens ( ) ) { nick = st . nextToken ( ) ; ChannelUser . Mode mode = ChannelUser . Mode . getMode ( nick . charAt ( 0 ) ) ; if ( mode != ChannelUser . Mode . NONE ) nick = nick . substring ( 1 ) ; u = getUser ( nick ) ; u . addChannel ( c ) ; c . addUserToList ( u ) ; c . setUserMode ( u , mode ) ; } }
tr	8	public static void changeProtocolMetadataFile ( String tmpMetadataFile , String identifier ) { String newMetadataFile = "/tmp/PRO" + System . currentTimeMillis ( ) + ".xml" ; FileWriter fichero = null ; PrintWriter pw = null ; File archivo = new File ( tmpMetadataFile ) ; try { fichero = new FileWriter ( newMetadataFile ) ; BufferedReader in = new BufferedReader ( new FileReader ( archivo ) ) ; pw = new PrintWriter ( fichero ) ; String data = "" ; data = in . readLine ( ) ; String spaces = "" ; boolean secId = false ; while ( data != null ) { if ( data . indexOf ( "<identifier>" ) != - 1 ) { secId = true ; } int s = data . indexOf ( "<entry>" ) ; if ( s != - 1 && secId ) { secId = false ; for ( int i = 0 ; i < s ; i ++ ) spaces += " " ; data = spaces + "<entry>" + identifier + "</entry>" ; } pw . println ( data ) ; data = in . readLine ( ) ; } in . close ( ) ; } catch ( IOException e ) { System . out . println ( "unable to find file" ) ; } finally { try { if ( null != fichero ) { fichero . close ( ) ; Process proc = Runtime . getRuntime ( ) . exec ( "cp " + newMetadataFile + " " + tmpMetadataFile ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } }
tr	0	public String getMateria ( ) { return materia ; }
tr	2	private Expression expression0 ( ) throws RequiredTokenException { enterRule ( NonTerminal . EXPRESSION0 ) ; Expression lhs = expression1 ( ) ; if ( firstSetSatisfied ( NonTerminal . OP0 ) ) { Token op = null ; try { op = op0 ( ) ; lhs = Command . newExpression ( lhs , op , expression1 ( ) ) ; } catch ( FirstSetUnsatisfiedException e ) { lhs = new Error ( ( ( Command ) lhs ) . lineNumber ( ) , ( ( Command ) lhs ) . charPosition ( ) , String . format ( "First set unsatisfied for nonterminal of type \"%s\"." , e . Unsatisfied ) ) ; } } exitRule ( ) ; return lhs ; }
tr	9X	private static boolean isUnreserved ( char c ) { return ( c >= a && c <= z ) || ( c >= A && c <= Z ) || ( c >= 0 && c <= 9 ) || c == . || c == - || c == _ || c == ~ ; }
tr	6	public String perform ( HttpServletRequest request ) { List < String > errors = new ArrayList < String > ( ) ; request . setAttribute ( "errors" , errors ) ; try { SearchCustomerName form = formBeanFactory . create ( request ) ; request . setAttribute ( "form" , form ) ; Transaction . begin ( ) ; int customer_id = customerDAO . getCustomerId ( form . getUsername ( ) ) ; CustomerBean cb = customerDAO . getCustomerInfo ( customer_id ) ; if ( ! form . isPresent ( ) ) { Transaction . commit ( ) ; return "e_reset-pwd.jsp" ; } errors . addAll ( form . getValidationErrors ( ) ) ; if ( errors . size ( ) != 0 ) { Transaction . commit ( ) ; return "e_reset-pwd.jsp" ; } CustomerBean customer = ( CustomerBean ) request . getAttribute ( "userName" ) ; request . setAttribute ( "customer" , cb ) ; HttpSession session = request . getSession ( ) ; session . setAttribute ( "customer" , cb ) ; Transaction . commit ( ) ; return "e_reset-pfc.do" ; } catch ( RollbackException e ) { errors . add ( e . toString ( ) ) ; return "e_reset-pwd.jsp" ; } catch ( FormBeanException e ) { errors . add ( e . toString ( ) ) ; return "e_reset-pwd.jsp" ; } catch ( Exception e ) { errors . add ( e . getMessage ( ) ) ; return "e_reset-pwd.jsp" ; } finally { if ( Transaction . isActive ( ) ) Transaction . rollback ( ) ; } }
tr	9X	private void printMap ( ) { System . out . print ( "     " ) ; for ( int i = 0 ; i < map . getMapWidth ( ) ; i ++ ) { System . out . print ( String . format ( " %02d   " , i ) ) ; } System . out . println ( ) ; for ( int i = 0 ; i < map . getMapHeight ( ) ; i ++ ) { for ( int j = 0 ; j < map . getMapWidth ( ) ; j ++ ) { if ( j == 0 ) System . out . print ( String . format ( "%02d" , i ) ) ; System . out . print ( " " ) ; if ( map . cells [ i ] [ j ] == map . getStartCell ( ) ) { System . out . print ( "**S**" ) ; continue ; } if ( map . cells [ i ] [ j ] == map . getGoalCell ( ) ) { System . out . print ( "**G**" ) ; continue ; } if ( map . cells [ i ] [ j ] . isObstacle ) { System . out . print ( "|||||" ) ; continue ; } String rhsSymbol = map . cells [ i ] [ j ] . rhs == Integer . MAX_VALUE ? "M" : long . toString ( map . cells [ i ] [ j ] . rhs ) ; if ( this . shortestPath != null && this . shortestPath . contains ( map . cells [ i ] [ j ] ) ) { System . err . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } else { System . out . print ( String . format ( "..%2s." , rhsSymbol ) ) ; } } System . out . println ( ) ; } }
va	1	public int take ( int index ) { if ( register . get ( index ) ) { lastappend . remove ( index ) ; stack . add ( index ) ; } lastappend . add ( index ) ; register . set ( index , true ) ; return index ; }
va	7	private int packSpecifiedFrames ( byte [ ] bytes , int offset , String onlyId , String notId ) throws NotSupportedException { Iterator < ID3v2FrameSet > setIterator = frameSets . values ( ) . iterator ( ) ; while ( setIterator . hasNext ( ) ) { ID3v2FrameSet frameSet = setIterator . next ( ) ; if ( ( onlyId == null || onlyId . equals ( frameSet . getId ( ) ) ) && ( notId == null || ! notId . equals ( frameSet . getId ( ) ) ) ) { Iterator < ID3v2Frame > frameIterator = frameSet . getFrames ( ) . iterator ( ) ; while ( frameIterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) frameIterator . next ( ) ; if ( frame . getDataLength ( ) > 0 ) { byte [ ] frameData = frame . toBytes ( ) ; BufferTools . copyIntoByteBuffer ( frameData , 0 , frameData . length , bytes , offset ) ; offset += frameData . length ; } } } } return offset ; }
va	5	protected int countNeighbours ( int col , int row ) { int c = 0 ; for ( int i = - 1 ; i < 2 ; i ++ ) { for ( int j = - 1 ; j < 2 ; j ++ ) { if ( ! ( i == 0 && j == 0 ) && getCell ( j + col , i + row ) ) { c ++ ; } } } return c ; }
va	8	public static void main ( String [ ] args ) { String filename = "SimpleDynamicScenario.txt" ; String outputPath = "./" ; if ( args . length >= 2 ) { filename = args [ 0 ] ; outputPath = args [ 1 ] ; } if ( args . length > 2 ) System . err . println ( "WARNING: Only two arguments required. Ignoring arguments after the first two." ) ; if ( args . length <= 1 ) { System . err . println ( "WARNING: Two arguments required <setup_file_name> <ouput_dir_path>. Running simulation with default values \"properties.txt\" and \"./\"." ) ; } sfp = new SetupFileParser ( ) ; sfp . parseFileForProperties ( filename ) ; StandAloneSimulation sas = new StandAloneSimulation ( outputPath , "RunFrom" + ( new File ( filename ) ) . getName ( ) . replace ( "." , "_" ) + System . currentTimeMillis ( ) , sfp . generalProps . getProperty ( "seed" ) != null ? Integer . parseInt ( sfp . generalProps . getProperty ( "seed" ) ) : 0 , sfp . generalProps . getProperty ( "useDerby" ) != null ? boolean . parseBoolean ( sfp . generalProps . getProperty ( "useDerby" ) ) : true ) ; try { sas . setup ( false ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } sas . runSimulation ( ) ; boolean printKPIs = sfp . generalProps . getProperty ( "printKPIs" ) != null ? boolean . parseBoolean ( sfp . generalProps . getProperty ( "printKPIs" ) ) : false ; if ( printKPIs ) sas . printKPIs ( ) ; }
va	1	final int nextInt ( ) { if ( 0 == count -- ) { isaac ( ) ; count = SIZE - 1 ; } return ( rsl [ count ] ) ; }
va	2	@ Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( 2048 ) ; super . toString ( sb ) . append ( " { " ) ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( stats [ i ] . count != 0 ) { sb . append ( "\n        " ) . append ( stats [ i ] . toString ( ) ) ; } } return sb . append ( " }" ) . toString ( ) ; }
va	7	public static boolean searchMatrix ( int [ ] [ ] matrix , int target ) { if ( matrix == null || matrix . length == 0 || matrix [ 0 ] . length == 0 ) return false ; if ( target < matrix [ 0 ] [ 0 ] ) return false ; int row = search ( matrix , target ) ; int i = 0 ; int j = matrix [ row ] . length - 1 ; while ( i <= j ) { int mid = ( i + j ) / 2 ; if ( matrix [ row ] [ mid ] == target ) { return true ; } else if ( matrix [ row ] [ mid ] < target ) { i = mid + 1 ; } else { j = mid - 1 ; } } return false ; }
va	8	public void init ( ) { try { Level . loadBehaviors ( new DataInputStream ( ResourcesManager . class . getResourceAsStream ( "res/tiles.dat" ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } if ( level == null ) if ( isCustom ) { MyLevelGenerator clg = new MyLevelGenerator ( ) ; GamePlay gp = new GamePlay ( ) ; gp = gp . read ( "player.txt" ) ; currentLevel = ( Level ) clg . generateLevel ( gp ) ; String detailedInfo = FileHandler . readFile ( "DetailedInfo.txt" ) ; } else currentLevel = new RandomLevel ( 320 , 15 , levelSeed , levelDifficulty , levelType ) ; try { level = currentLevel . clone ( ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( ) ; } Art . startMusic ( 1 ) ; paused = false ; Sprite . spriteContext = this ; sprites . clear ( ) ; layer = new LevelRenderer ( level , graphicsConfiguration , 320 , 240 ) ; for ( int i = 0 ; i < 2 ; i ++ ) { int scrollSpeed = 4 >> i ; int w = ( ( level . getWidth ( ) * 16 ) - 320 ) / scrollSpeed + 320 ; int h = ( ( level . getHeight ( ) * 16 ) - 240 ) / scrollSpeed + 240 ; Level bgLevel = BgLevelGenerator . createLevel ( w / 32 + 1 , h / 32 + 1 , i == 0 , levelType ) ; bgLayer [ i ] = new BgRenderer ( bgLevel , graphicsConfiguration , 320 , 240 , scrollSpeed ) ; } double oldX = 0 ; if ( mario != null ) oldX = mario . x ; mario = new Mario ( this ) ; sprites . add ( mario ) ; startTime = 1 ; timeLeft = 200 * 15 ; tick = 0 ; switchPoints = new ArrayList < double > ( ) ; int squareSize = 16 ; int sections = 10 ; double startX = 32 ; double endX = level . getxExit ( ) * squareSize ; if ( ! isCustom && recorder == null ) recorder = new DataRecorder ( this , ( RandomLevel ) level , keys ) ; gameStarted = false ; }
va	3	public void requestShiftRight ( ) { boolean continueToMakeNew = true ; if ( ! saved ) { continueToMakeNew = promptToSaveState ( ) ; } if ( continueToMakeNew ) { continueToMakeNew = promptShiftRight ( ) ; if ( continueToMakeNew ) { } } }
va	7	public int longestValidParentheses ( String s ) { Stack < Character > sc = new Stack < Character > ( ) ; Stack < Integer > si = new Stack < Integer > ( ) ; int i = 0 , max = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( si . isEmpty ( ) || c == ( ) { si . push ( i ) ; sc . push ( c ) ; } else { if ( sc . peek ( ) == ( ) { sc . pop ( ) ; si . pop ( ) ; if ( si . isEmpty ( ) ) { if ( max < i + 1 ) { max = i + 1 ; } } else { if ( max < i - si . peek ( ) ) { max = i - si . peek ( ) ; } } } } } return max ; }
va	6	private void create ( String resource ) { InputStream input = getClass ( ) . getResourceAsStream ( resource ) ; if ( input != null ) { FileOutputStream output = null ; try { out . getParentFile ( ) . mkdirs ( ) ; output = new FileOutputStream ( out ) ; byte [ ] buf = new byte [ 8192 ] ; int length ; while ( ( length = input . read ( buf ) ) > 0 ) { output . write ( buf , 0 , length ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { try { input . close ( ) ; } catch ( Exception ignored ) { } try { if ( output != null ) output . close ( ) ; } catch ( Exception ignored ) { } } } }
va	0	@ Override public void handleEvent ( MatchEndedEvent domainEvent ) { PlayerReport playerReport = accountReportRepository . findById ( domainEvent . getAggregateId ( ) ) ; List < MatchReport > gamesStatistic = new ArrayList < MatchReport > ( ) ; gamesStatistic . addAll ( playerReport . getGamesStatistic ( ) ) ; gamesStatistic . add ( new MatchReport ( domainEvent . getAggregateId ( ) , domainEvent . getMatchResult ( ) ) ) ; accountReportRepository . add ( new PlayerReport ( domainEvent . getAggregateId ( ) , gamesStatistic , playerReport . getPlayerName ( ) ) ) ; }
va	0	public Arctg ( double acc ) { super ( acc ) ; }
va	3	@ Override protected void processMouseEvent ( MouseEvent e ) { if ( e . getID ( ) == MouseEvent . MOUSE_PRESSED ) { if ( e . getX ( ) >= XLEN || e . getY ( ) >= YLEN ) return ; point p = new point ( ( double ) e . getX ( ) / XLEN , ( double ) e . getY ( ) / YLEN , current_value ) ; point_list . addElement ( p ) ; draw_point ( p ) ; } }
va	3	private void switchMap ( StairTile stairs ) { Point oldPt = stairs . getpA ( ) ; Point nextPt = stairs . getpB ( ) ; Map nextMap = stairs . getMapB ( ) ; Tile nextLocation = nextMap . getTile ( nextPt . x , nextPt . y ) ; player . setLocation ( nextLocation ) ; stairs . getMapA ( ) . getTile ( oldPt . x , oldPt . y ) . removeOccupant ( ) ; stairs . getMapB ( ) . getTile ( nextPt . x , nextPt . y ) . setOccupant ( player ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( false ) ; this . map = nextMap ; messenger . drawMap ( nextMap ) ; messenger . updateTile ( nextPt ) ; resetTimeQueue ( ) ; if ( player . getFuturesightCounter ( ) > 0 ) this . revealMap ( true ) ; if ( nextMap . getTag ( ) != null ) { messenger . showTextDialog ( GameText . getText ( nextMap . getTag ( ) ) , nextMap . getTag ( ) ) ; player . setTextCollected ( player . getTextCollected ( ) + 1 ) ; nextMap . setTag ( null ) ; } messenger . centerMap ( nextPt ) ; }
va	9X	@ Override public void stateChanged ( ChangeEvent e ) { JSlider sliderOfInteraction = ( JSlider ) e . getSource ( ) ; switch ( sliderOfInteraction . getName ( ) ) { case "brightness" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; brightness = currentSliderValue * .001f ; if ( brightness < - .9f ) brightness = ( - .9f ) ; if ( brightness > 1f ) brightness = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , hsbvals [ 1 ] , ( hsbvals [ 2 ] + ( brightness ) < 0 ) ? 0 : ( hsbvals [ 2 ] + ( brightness ) > 1.0f ) ? 1.0f : hsbvals [ 2 ] + brightness ) ) ; } } break ; case "saturation" : for ( int x = 0 ; x < bi . getWidth ( ) ; x ++ ) { for ( int y = 0 ; y < bi . getHeight ( ) ; y ++ ) { currentSliderValue = sliderOfInteraction . getValue ( ) ; newColor = new Color ( bi . getRGB ( x , y ) ) ; Color . RGBtoHSB ( newColor . getRed ( ) , newColor . getGreen ( ) , newColor . getBlue ( ) , hsbvals ) ; saturation = currentSliderValue * .001f ; if ( saturation < - .9f ) saturation = ( - .9f ) ; if ( saturation > 1f ) saturation = 1f ; biOut . setRGB ( x , y , Color . HSBtoRGB ( hsbvals [ 0 ] , ( hsbvals [ 1 ] + saturation < 0 ) ? 0 : ( hsbvals [ 1 ] + ( saturation ) > 1.0f ) ? 1.0f : hsbvals [ 1 ] + saturation , hsbvals [ 2 ] ) ) ; } } break ; } oPanel . repaint ( ) ; }
va	8	public static void main ( String args [ ] ) throws Exception { if ( ( args . length < 2 ) || ( args . length > 3 ) ) throw new IllegalArgumentException ( "\u53C2\u6570\u4E0D\u6B63\u786E" ) ; String server = args [ 0 ] ; byte [ ] argument = args [ 1 ] . getBytes ( ) ; int servPort = ( args . length == 3 ) ? Integer . parseInt ( args [ 2 ] ) : 7 ; SocketChannel clntChan = SocketChannel . open ( ) ; clntChan . configureBlocking ( false ) ; if ( ! clntChan . connect ( new InetSocketAddress ( server , servPort ) ) ) { while ( ! clntChan . finishConnect ( ) ) { System . out . print ( "." ) ; } } System . out . print ( "\n" ) ; ByteBuffer writeBuf = ByteBuffer . wrap ( argument ) ; ByteBuffer readBuf = ByteBuffer . allocate ( argument . length ) ; int totalBytesRcvd = 0 ; int bytesRcvd ; while ( totalBytesRcvd < argument . length ) { if ( writeBuf . hasRemaining ( ) ) { clntChan . write ( writeBuf ) ; } if ( ( bytesRcvd = clntChan . read ( readBuf ) ) == - 1 ) { throw new SocketException ( "Connection closed prematurely" ) ; } totalBytesRcvd += bytesRcvd ; System . out . print ( "." ) ; } System . out . println ( "Received: " + new String ( readBuf . array ( ) , 0 , totalBytesRcvd ) ) ; clntChan . close ( ) ; }
va	9X	private void getScaleFactors_2 ( int gr , int ch ) { byte [ ] nr ; int i , band , slen , num , n = 0 , scf = 0 ; final boolean i_stereo = header . isIntensityStereo ( ) ; final ChannelInformation ci = channelInfo [ gr ] [ ch ] ; final int [ ] l = scalefacLong [ ch ] ; final int [ ] s = scalefacShort [ ch ] ; rzeroBandLong = 0 ; if ( ( ch > 0 ) && i_stereo ) slen = i_slen2 [ ci . scalefac_compress >> 1 ] ; else slen = n_slen2 [ ci . scalefac_compress ] ; ci . preflag = ( slen >> 15 ) & 1 ; ci . part2_length = 0 ; if ( ci . block_type == 2 ) { n ++ ; if ( ( ci . mixed_block_flag ) != 0 ) n ++ ; nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) s [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) s [ scf ++ ] = 0 ; } else { nr = nr_of_sfb [ n ] [ ( slen >> 12 ) & 7 ] ; for ( i = 0 ; i < 4 ; i ++ ) { num = slen & 7 ; slen >>= 3 ; if ( num != 0 ) { for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = maindataStream . getBits17 ( num ) ; ci . part2_length += nr [ i ] * num ; } else for ( band = 0 ; band < nr [ i ] ; band ++ ) l [ scf ++ ] = 0 ; } n = ( n << 1 ) + 1 ; for ( i = 0 ; i < n ; i ++ ) l [ scf ++ ] = 0 ; } }
va	5	public void turn ( int choice ) { if ( choice == 0 ) { attack ( true ) ; } else if ( choice == 1 ) { chooseSpell ( ) ; } else if ( choice == 2 ) { flee ( ) ; } if ( enemy . getHealth ( ) <= 0 ) { System . out . println ( "Thy enemy lies vanquished!" ) ; endBattle ( ) ; } else { attack ( false ) ; } if ( character . getHealth ( ) <= 0 ) { System . out . println ( "Thou hast been defeated!" ) ; youLose ( ) ; } }
va	9X	public void PatientDocFile ( JPanel ptPane , int loggedId ) { staffid = loggedId ; StringBuffer loggedUser = new StringBuffer ( ) ; JTextPane tpLoggedStaff = new JTextPane ( ) ; for ( int i = 0 ; i < staff . size ( ) ; i ++ ) { if ( staff . get ( i ) . getId ( ) == loggedId ) { loggedUser . append ( "<b>" + staff . get ( i ) . getLname ( ) ) ; loggedUser . append ( "  " ) ; loggedUser . append ( staff . get ( i ) . getFname ( ) + "</b>" ) ; if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "gp" ) ) loggedUser . append ( "  [logged as Dr.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ns" ) ) loggedUser . append ( "  [logged as R.N.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "ma" ) ) loggedUser . append ( "  [logged as Med.As.]" ) ; else if ( staff . get ( i ) . getPosition ( ) . equalsIgnoreCase ( "mo" ) ) loggedUser . append ( "  [logged as Med.Of.]" ) ; } } tpLoggedStaff . setContentType ( "text/html" ) ; tpLoggedStaff . setText ( loggedUser . toString ( ) ) ; this . function . setOpacity ( tpLoggedStaff ) ; tpLoggedStaff . setEditable ( false ) ; patientList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testList . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; function . makeElementWithBorder ( patientList , "Patients" , Color . GRAY , false ) ; patientList . setOpaque ( false ) ; patientList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; patientList . setSelectedIndex ( 0 ) ; patientList . setVisibleRowCount ( 3 ) ; function . makeElementWithBorder ( testList , "Tests" , Color . GRAY , false ) ; testList . setOpaque ( false ) ; testList . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; testList . setSelectedIndex ( 0 ) ; testList . setVisibleRowCount ( 3 ) ; this . patientListSP = new JScrollPane ( this . patientList ) ; this . function . setOpacity ( this . patientListSP ) ; patientListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; this . testListSP = new JScrollPane ( this . testList ) ; this . function . setOpacity ( this . testListSP ) ; testListSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; JScrollPane [ ] patientSP = new JScrollPane [ patientTP . length ] ; JScrollPane testSP = new JScrollPane ( this . testTP ) ; function . makeElementWithBorder ( testSP , "Test Results" , Color . DARK_GRAY , false ) ; testSP . setVisible ( true ) ; this . function . setOpacity ( testTP ) ; this . function . setOpacity ( testSP ) ; testTP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; testSP . setPreferredSize ( ( new Dimension ( 80 , 40 ) ) ) ; final JTextPane timeTP = new JTextPane ( ) ; timeTP . setContentType ( "text/html" ) ; timeTP . setPreferredSize ( new Dimension ( 20 , 15 ) ) ; timeTP . setEditable ( false ) ; timeTP . setOpaque ( false ) ; timeTP . setBorder ( null ) ; final SimpleDateFormat dateFormat = new SimpleDateFormat ( "EEEEE  MMMMM d  yyyy | h:mm:ss a" ) ; new javax . swing . Timer ( 1000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { Calendar date = Calendar . getInstance ( ) ; timeTP . setText ( "<b>" + dateFormat . format ( date . getTime ( ) ) + "</b>" ) ; } } ) . start ( ) ; String [ ] lb1 = { "Patient's General Information" , "Patient's Prescriptions" , "Patient's Anamnesis" , "Patient's Diagnosis" } ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { patientTP [ i ] = new JTextPane ( ) ; patientTP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; patientSP [ i ] = new JScrollPane ( patientTP [ i ] ) ; this . function . setOpacity ( this . patientTP [ i ] ) ; this . function . setOpacity ( patientSP [ i ] ) ; patientSP [ i ] . setPreferredSize ( new Dimension ( 600 , 100 ) ) ; function . makeElementWithBorder ( patientSP [ i ] , lb1 [ i ] , Color . DARK_GRAY , false ) ; patientSP [ i ] . setVisible ( true ) ; } String [ ] lb = { "Patient" , "Patient's birth date" } ; patientTF = new JTextField [ lb . length ] ; for ( int i = 0 ; i < lb . length ; i ++ ) { patientTF [ i ] = new JTextField ( 15 ) ; function . makeElementWithBorder ( patientTF [ i ] , lb [ i ] , Color . DARK_GRAY , false ) ; patientTF [ i ] . setOpaque ( false ) ; } patientTF [ 1 ] . setPreferredSize ( new Dimension ( 80 , 40 ) ) ; ptPane . add ( timeTP , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( tpLoggedStaff , new GridBagConstraints ( 0 , 0 , 1 , 1 , 0 , 0 , GridBagConstraints . NORTHWEST , GridBagConstraints . BOTH , new Insets ( 50 , 15 , 0 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 0 ] , new GridBagConstraints ( 1 , 0 , 2 , 1 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientTF [ 1 ] , new GridBagConstraints ( 3 , 0 , 2 , 1 , 0.2 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( patientListSP , new GridBagConstraints ( 4 , 1 , 1 , 3 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; ptPane . add ( testListSP , new GridBagConstraints ( 4 , 4 , 1 , 1 , 0.2 , 0.2 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 15 , 15 ) , 0 , 0 ) ) ; int pozY = 1 ; for ( int i = 0 ; i < lb1 . length ; i ++ ) { ptPane . add ( patientSP [ i ] , new GridBagConstraints ( 0 , pozY , 4 , 2 , 0.5 , 0.5 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 5 , 5 , 5 , 5 ) , 0 , 0 ) ) ; pozY += 2 ; } ptPane . add ( testSP , new GridBagConstraints ( 4 , 5 , 1 , 4 , 0.5 , 0 , GridBagConstraints . CENTER , GridBagConstraints . BOTH , new Insets ( 15 , 15 , 55 , 15 ) , 0 , 0 ) ) ; this . nextB . setText ( "Next" ) ; this . nextB . addActionListener ( this ) ; ptPane . add ( nextB , new GridBagConstraints ( 4 , 8 , 1 , 1 , 0 , 0.5 , GridBagConstraints . SOUTH , GridBagConstraints . NONE , new Insets ( 0 , 15 , 5 , 15 ) , 0 , 0 ) ) ; new javax . swing . Timer ( 500000 , new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { function . fillPatient ( patient ) ; patientTP [ 0 ] . setText ( null ) ; } } ) . start ( ) ; patientTF [ 0 ] . addKeyListener ( this ) ; patientList . addListSelectionListener ( this ) ; testList . addListSelectionListener ( this ) ; }
va	2	@ Override public int compareTo ( Match o ) { if ( this . gameStartMs > o . gameStartMs ) return 1 ; else if ( this . gameStartMs < o . gameStartMs ) return - 1 ; return 0 ; }
va	7	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; ProcedureHeadingNode that = ( ProcedureHeadingNode ) o ; if ( fparams != null ? ! fparams . equals ( that . fparams ) : that . fparams != null ) return false ; if ( subject != null ? ! subject . equals ( that . subject ) : that . subject != null ) return false ; return true ; }
va	0	public String getReturn ( ) { return _return ; }
va	5	public void kill ( ) { if ( socket == null ) return ; try { oos . close ( ) ; } catch ( IOException e ) { } try { ois . close ( ) ; } catch ( IOException e ) { } try { bis . close ( ) ; } catch ( IOException e ) { } try { socket . close ( ) ; socket = null ; } catch ( IOException e ) { } }
va	0	public static String Message_GetUsageCredits ( String THE_MESSAGE ) { return otapiJNI . OTAPI_Basic_Message_GetUsageCredits ( THE_MESSAGE ) ; }
va	2	public void updateValues ( ) { speed += acceleration ; speed *= dampingFactor ; iconCoordinateY += speed ; if ( iconCoordinateY < 0 ) { speed = - speed ; } if ( ( getHeight ( ) - icon . getHeight ( null ) ) < iconCoordinateY ) { speed = - speed ; } }
va	8	public static Highscore [ ] load ( InputStream in ) throws IOException { Vector highscores = new Vector ( 20 , 40 ) ; InputStreamReader inr = new InputStreamReader ( in ) ; String line ; while ( ( line = jgame . impl . EngineLogic . readline ( inr ) ) != null ) { Vector fields = new Vector ( 5 , 10 ) ; Vector tokens = jgame . impl . EngineLogic . tokenizeString ( line , 	 ) ; for ( Enumeration e = tokens . elements ( ) ; e . hasMoreElements ( ) ; ) { String tok = ( String ) e . nextElement ( ) ; if ( tok . equals ( "`" ) ) tok = "" ; fields . addElement ( tok ) ; } Highscore hs = null ; if ( fields . size ( ) == 1 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , "" ) ; } if ( fields . size ( ) >= 2 ) { hs = new Highscore ( Integer . parseInt ( ( String ) fields . elementAt ( 0 ) ) , ( String ) fields . elementAt ( 1 ) ) ; } if ( fields . size ( ) >= 3 ) { hs . fields = new String [ fields . size ( ) - 2 ] ; for ( int i = 2 ; i < fields . size ( ) ; i ++ ) { hs . fields [ i - 2 ] = ( String ) fields . elementAt ( i ) ; } } highscores . addElement ( hs ) ; } Highscore [ ] ret = new Highscore [ highscores . size ( ) ] ; for ( int i = 0 ; i < highscores . size ( ) ; i ++ ) { ret [ i ] = ( Highscore ) highscores . elementAt ( i ) ; } return ret ; }
va	0	@ Override public float getX ( ) { return this . pos . x ; }
va	1	private IGameMap createGameMap ( String path ) { IGameMap map = injector . getInstance ( IGameMap . class ) ; try ( InputStream in = getClass ( ) . getResourceAsStream ( path ) ) { map . readMap ( in ) ; } catch ( IOException ex ) { assert . fail ( ex . getMessage ( ) ) ; } return map ; }
va	7	public static ProbabilityDistribution respond ( ProbabilityDistribution pd , PricingPolicy policy , PricingPolicy baseline , double awareness , double sensitivity , String responseType ) { double w = 2 ; double [ ] previousHist = pd . getHistogram ( ) ; double [ ] newHist = new double [ Constants . MIN_IN_DAY ] ; double [ ] policyArr = policy . getTOUArray ( ) ; double [ ] baseArr = baseline . getTOUArray ( ) ; switch ( responseType ) { case "None" : return pd ; case "Optimal" : newHist = shiftingOptimal ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Normal" : newHist = shiftingNormal ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Discrete" : newHist = shiftingDiscrete ( previousHist , baseArr , policyArr , w * awareness , w * sensitivity ) ; break ; case "Daily" : newHist = shiftingDaily ( previousHist , baseArr , policyArr , awareness , sensitivity ) ; for ( int i = 0 ; i < newHist . length ; i ++ ) { if ( double . isNaN ( newHist [ i ] ) ) { newHist [ i ] = 0.0 ; } } break ; default : return pd ; } ProbabilityDistribution retPd = new Histogram ( newHist ) ; return retPd ; }
va	0	@ Before public void setUp ( ) { undertest = new MedianStore ( ) ; }
va	1	private FormalParametersNode formalParameters ( ) { List < FPSectionNode > fpsections = new ArrayList < FPSectionNode > ( ) ; FPSectionNode fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; while ( test ( SEMICOLON ) ) { read ( SEMICOLON , ";" ) ; fpsection = ( FPSectionNode ) fpSection ( ) ; fpsections . add ( fpsection ) ; } return new FormalParametersNode ( fpsections ) ; }
va	7	private boolean r_main_suffix ( ) { int among_var ; int v_1 ; int v_2 ; v_1 = limit - cursor ; if ( cursor < I_p1 ) { return false ; } cursor = I_p1 ; v_2 = limit_backward ; limit_backward = cursor ; cursor = limit - v_1 ; ket = cursor ; among_var = find_among_b ( a_0 , 29 ) ; if ( among_var == 0 ) { limit_backward = v_2 ; return false ; } bra = cursor ; limit_backward = v_2 ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; case 2 : if ( ! ( in_grouping_b ( g_s_ending , 98 , 122 ) ) ) { return false ; } slice_del ( ) ; break ; case 3 : slice_from ( "er" ) ; break ; } return true ; }
va	0	public void setFinalGrades ( boolean value ) { this . finalGrades = value ; }
va	3	private boolean checkUserExists ( String user ) { Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( "id " + user ) ; p . waitFor ( ) ; int exitValue = p . exitValue ( ) ; if ( exitValue != 0 ) { JOptionPane . showMessageDialog ( sif , "Invalid user - " + user + "\nPlease make sure the user exists in the system." , "Error" , JOptionPane . ERROR_MESSAGE ) ; return false ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null ) NativeCalls . releaseProcess ( p ) ; } return true ; }
va	0	public boolean blocksLineOfSight ( ) { return false ; }
va	0	@ Override public boolean isList ( ) { return false ; }
va	4	private void txtEdgeCostKeyPressed ( java . awt . event . KeyEvent evt ) { if ( evt . getKeyCode ( ) == 10 ) { if ( ! txtVertexName . getText ( ) . isEmpty ( ) && txtVertexName . getText ( ) . length ( ) != 0 ) { drawing . addVertex ( txtVertexName . getText ( ) ) ; txtVertexName . setText ( "" ) ; } int cost = 1 ; if ( ! txtEdgeCost . getText ( ) . isEmpty ( ) ) { cost = Integer . parseInt ( txtEdgeCost . getText ( ) ) ; } drawing . addEdge ( cost ) ; txtEdgeCost . setText ( "" ) ; txtVertexName . requestFocus ( ) ; } }
va	3	public void act ( List < Actor > newFoxes ) { incrementAge ( ) ; incrementHunger ( ) ; if ( isAlive ( ) ) { giveBirth ( newFoxes ) ; Location location = getLocation ( ) ; Location newLocation = findFood ( location ) ; if ( newLocation == null ) { newLocation = getField ( ) . freeAdjacentLocation ( location ) ; } if ( newLocation != null ) { setLocation ( newLocation ) ; } else { setDead ( ) ; } } }
va	8	@ SuppressWarnings ( { "unchecked" } ) public static < J , K , V > Map < J , Map < K , V >> generateComplexMap ( class < J > jType , class < K > keyType , class < V > valueType ) { Random random = new Random ( 987654321 ) ; Map < J , Map < K , V >> complexMap = new HashMap < J , Map < K , V >> ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { J family = null ; if ( jType == String . class ) { family = ( J ) String . valueOf ( random . nextInt ( ) ) ; } else if ( jType == Integer . class ) { family = ( J ) Integer . valueOf ( random . nextInt ( ) ) ; } else if ( jType == long . class ) { family = ( J ) long . valueOf ( random . nextLong ( ) ) ; } else if ( jType == double . class ) { family = ( J ) double . valueOf ( random . nextDouble ( ) ) ; } else if ( jType == byte [ ] . class ) { byte [ ] bytes = Bytes . toBytes ( random . nextInt ( ) ) ; family = ( J ) bytes ; } else if ( jType == float . class ) { family = ( J ) float . valueOf ( random . nextFloat ( ) ) ; } else if ( jType == boolean . class ) { family = ( J ) boolean . valueOf ( random . nextBoolean ( ) ) ; } Map < K , V > map = generateMapField ( keyType , valueType ) ; complexMap . put ( family , map ) ; } return complexMap ; }
va	6	public void Solve ( ) { int count = 0 ; for ( int x1 = 0 ; x1 <= _max ; x1 ++ ) { for ( int y1 = 0 ; y1 <= _max ; y1 ++ ) { for ( int x2 = 0 ; x2 <= _max ; x2 ++ ) { for ( int y2 = 0 ; y2 <= _max ; y2 ++ ) { if ( x1 + y1 + x2 + y2 == 0 ) { continue ; } int length1 = x1 * x1 + y1 * y1 ; int length2 = x2 * x2 + y2 * y2 ; int x3 = Math . abs ( x1 - x2 ) ; int y3 = Math . abs ( y1 - y2 ) ; int length3 = x3 * x3 + y3 * y3 ; if ( length1 + length2 == length3 ) { count ++ ; } } } } } System . out . println ( "Result=" + count / 2 ) ; }
va	8	public boolean wordBreak2 ( String s , Set < String > dict ) { if ( s == null || s . length ( ) == 0 || dict == null ) { return true ; } int length = s . length ( ) ; boolean [ ] dp = new boolean [ length + 1 ] ; for ( boolean b : dp ) { b = false ; } dp [ length ] = true ; for ( int i = length - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < length ; j ++ ) { String - = s . substring ( i , j + 1 ) ; if ( dict . contains ( - ) == true && dp [ j + 1 ] == true ) { dp [ i ] = true ; break ; } } } return dp [ 0 ] ; }
va	9X	public float getProjection ( Vector v ) throws GeometryException { if ( v . getDimensions ( ) < 3 && this . getDimensions ( ) > 3 || v . getDimensions ( ) > 3 && this . getDimensions ( ) < 3 || ( v . getDimensions ( ) < 3 && this . getDimensions ( ) < 3 && this . getDimensions ( ) != v . getDimensions ( ) ) ) throw new GeometryException ( "Vector projections require vectors of same dimensionality" ) ; float dp = 0.0f ; for ( int i = 0 ; i < ( ( this . getDimensions ( ) > 3 ) ? 3 : this . getDimensions ( ) ) ; i ++ ) dp += v . getCoordinate ( i ) * this . getCoordinate ( i ) ; return dp / this . getMeasure ( ) ; }
va	6	public String getType ( VesselType type ) { switch ( type ) { case SWIMMER : return "1 - Human (swimmer)" ; case SPEED_BOAT : return "2 - Speed Boat" ; case FISHING_BOAT : return "3 - Fishing Boat" ; case CARGO_BOAT : return "4 - Cargo Vessel" ; case PASSENGER_VESSEL : return "5 - Passenger Vessel" ; case UNKNOWN : return "6 - Unknown" ; default : return "6 - Unknown" ; } }
va	2	@ Override public String process ( HttpServletRequest request ) throws MissingRequiredParameter { String nombre = request . getParameter ( "nombre" ) ; try { connection = dataSource . getConnection ( ) ; statement = connection . createStatement ( ) ; ResultSet resultSet = null ; String query = "SELECT * FROM farmacias WHERE nombre='" + nombre + "'" ; resultSet = statement . executeQuery ( query ) ; resultSet . next ( ) ; int idfarmacia = resultSet . getInt ( "id_farmacia" ) ; if ( idfarmacia != 0 ) { statement . execute ( "delete from farmacias where id_farmacia ='" + idfarmacia + "';" ) ; } } catch ( SQLException e ) { return "{\"status\":\"KO\"  \"result\": \"Error en el acceso a la base de datos.\"}" ; } String result = "{\"status\":\"OK\"  \"result\": \"Farmacia eliminada correctamente.\"}" ; return result ; }
va	0	public void setAgility ( int agi ) { this . agility = agi ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( SpikeTester . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new SpikeTester ( ) . setVisible ( true ) ; } } ) ; }
va	4	@ Override public void notifySample ( Sample s ) { switch ( mode ) { case CLASSIFYING : System . out . println ( "add sample to classify" ) ; Gesture g = classifier . classifySample ( s ) ; gui . showClassifiedGesture ( g ) ; break ; case IDLE : System . out . println ( "Idle Sample" ) ; break ; case RECORDING : break ; case TRAINING : System . out . println ( "add Training Sample" ) ; Gesture currentGesture = gui . getCurrentGesture ( ) ; trainer . addSample ( s , currentGesture ) ; break ; default : break ; } }
va	9X	public Prototype load ( ) throws IOException { Prototype proto = new Prototype ( ) ; proto . source = readLuaString ( ) ; stream . skipBytes ( 8 ) ; proto . numUpvalues = read ( ) ; proto . numParams = read ( ) ; proto . isVararg = ( read ( ) & 2 ) != 0 ; proto . maxStacksize = read ( ) ; int length = 0 ; length = readInt ( ) ; int [ ] code = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) code [ index ] = readInt ( ) ; length = readInt ( ) ; Object [ ] constants = new Object [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { Object value = null ; int type = read ( ) ; switch ( type ) { case TYPE_NIL : break ; case TYPE_BOOLEAN : value = read ( ) != 0 ? boolean . true : boolean . false ; break ; case TYPE_NUMBER : value = double . longBitsToDouble ( readLong ( ) ) ; break ; case TYPE_STRING : value = readLuaString ( ) ; break ; default : throw new LuaException ( "Unknown constant type: " + type ) ; } constants [ index ] = value ; } length = readInt ( ) ; Prototype [ ] protos = new Prototype [ length ] ; for ( int index = 0 ; index < length ; index ++ ) protos [ index ] = load ( ) ; length = readInt ( ) ; int [ ] lines = new int [ length ] ; for ( int index = 0 ; index < length ; index ++ ) lines [ index ] = readInt ( ) ; length = readInt ( ) ; LocalVar [ ] locals = new LocalVar [ length ] ; for ( int index = 0 ; index < length ; index ++ ) locals [ index ] = new LocalVar ( readLuaString ( ) , readInt ( ) , readInt ( ) ) ; length = readInt ( ) ; String [ ] upvalues = new String [ length ] ; for ( int index = 0 ; index < length ; index ++ ) upvalues [ index ] = readLuaString ( ) ; proto . code = code ; proto . constants = constants ; proto . prototypes = protos ; proto . lines = lines ; proto . locals = locals ; proto . upvalues = upvalues ; return proto ; }
va	3	private JPanel getCenterPanel ( ) { if ( centerPanel == null ) { centerPanel = new JPanel ( ) ; centerPanel . setLayout ( new MigLayout ( "gap 0px 0px" , "[][][]" , "[][][][][][]" ) ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { buttonGameBoard [ i ] [ j ] . setSize ( 40 , 40 ) ; centerPanel . add ( buttonGameBoard [ i ] [ j ] , "cell " + j + " " + i + "" ) ; } } } return centerPanel ; }
va	1	protected void check ( String method ) { if ( mAmShutdown ) throw new RuntimeException ( "NetBase." + method + " called when NetBase isn't in initialized state" ) ; }
va	0	public boolean hasToChargeMove ( ) { return chargingMoveCount > 0 ; }
va	0	private void initializeComponents ( ) { this . setLayout ( new BorderLayout ( ) ) ; ingredientPanel = new IngredientPanel ( ) ; ingredientPanel . addChangeListener ( this ) ; textPanel = new JPanel ( new BorderLayout ( ) ) ; textPane = new JTextArea ( ) ; textPane . setLineWrap ( true ) ; textPane . setLineWrap ( true ) ; textPane . setWrapStyleWord ( true ) ; textPane . setEditable ( true ) ; textPane . getDocument ( ) . addDocumentListener ( new ChangeDocumentListener ( ) ) ; textScrollPane = new JScrollPane ( textPane ) ; textScrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; textScrollPane . setPreferredSize ( new Dimension ( 450 , 200 ) ) ; headline = new JTextField ( ) ; headline . getDocument ( ) . addDocumentListener ( new ChangeDocumentListener ( ) ) ; this . setPreferredSize ( new Dimension ( 750 , 250 ) ) ; }
va	7	public String toUpdateKML ( boolean suppressEnclosingTags ) { if ( ! isDirty ( ) ) { return "" ; } String change = "" ; boolean isPrimDirty = isPrimitiveDirty ( ) ; if ( isPrimDirty && ! suppressEnclosingTags ) { change += "<Create" ; change += ">\n" ; } change += super . toUpdateKML ( true ) ; if ( this . folder != null && this . folder . isDirty ( ) ) { change += this . folder . toUpdateKML ( ) ; } if ( isPrimDirty && ! suppressEnclosingTags ) { change += "</Create>\n" ; } setNotDirty ( ) ; return change ; }
va	2	private void siirraNappula ( Point p ) { if ( ! peli . logiikka . loppu ( ) && Pelilauta . hiiriPaalla ( p ) ) { int kor = ykoordinaatti ( p . y ) ; int lev = xkoordinaatti ( p . x ) ; peli . siirto ( 7 - korMis , levMis , 7 - kor , lev ) ; } }
va	9X	public String toString ( ) { String s = "" ; Node n = this ; while ( n != null ) { s += "[Node type=" ; s += nodeTypeString [ n . type ] ; s += " element=" ; if ( n . element != null ) s += n . element ; else s += "null" ; if ( n . type == TextNode || n . type == CommentTag || n . type == ProcInsTag ) { s += " text=" ; if ( n . textarray != null && n . start <= n . end ) { s += "\"" ; s += Lexer . getString ( n . textarray , n . start , n . end - n . start ) ; s += "\"" ; } else { s += "null" ; } } s += " content=" ; if ( n . content != null ) s += n . content . toString ( ) ; else s += "null" ; s += "]" ; if ( n . next != null ) s += " " ; n = n . next ; } return s ; }
va	3	private boolean r_Step_5b ( ) { ket = cursor ; if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } slice_del ( ) ; return true ; }
va	2	public void fireModelPagesJaukesChanged ( int i_typeChange ) { I_ModelPagesJaukesListener [ ] listenerModelPagesJaukes = ( I_ModelPagesJaukesListener [ ] ) listeners . getListeners ( I_ModelPagesJaukesListener . class ) ; for ( I_ModelPagesJaukesListener listener : listenerModelPagesJaukes ) { switch ( i_typeChange ) { case 0 : listener . criteriaPagesJaukesChange ( ) ; break ; default : System . err . println ( "ModelPagesJaukes.java - Erreur fonction criteriaPagesJaukesChange" ) ; break ; } } }
va	8	private boolean isScrambleCore ( String s1 , String s2 ) { boolean result = false ; List < String > key = new ArrayList < String > ( ) ; key . add ( s1 ) ; key . add ( s2 ) ; if ( cache . containsKey ( key ) ) return cache . get ( key ) ; if ( s1 . equals ( s2 ) ) { cache . put ( key , true ) ; return true ; } if ( s1 . length ( ) == 1 ) { cache . put ( key , false ) ; return false ; } int n = s1 . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { String s11 = s1 . substring ( 0 , i + 1 ) ; String s12 = s1 . substring ( i + 1 ) ; String s21 = s2 . substring ( 0 , i + 1 ) ; String s22 = s2 . substring ( i + 1 ) ; if ( isScrambleCore ( s11 , s21 ) && isScrambleCore ( s12 , s22 ) ) { result = true ; break ; } s21 = s2 . substring ( 0 , n - 1 - i ) ; s22 = s2 . substring ( n - 1 - i ) ; if ( isScrambleCore ( s11 , s22 ) && isScrambleCore ( s12 , s21 ) ) { result = true ; break ; } } cache . put ( key , result ) ; return result ; }
va	0	protected void informNextPlayerToGo ( String currentIP , int currentPort ) { int nextPlayerToGo = getNextTurnPlayerID ( pg . getPlayerIndex ( currentIP , currentPort ) ) ; srvrWaitingOnPlayerIndex = nextPlayerToGo ; pg . broadcastMessage ( "sTurn " + pg . getPlayer ( nextPlayerToGo ) . getNickName ( ) ) ; }
va	2	public static void test ( String s ) { String - ; for ( int c = 0 ; c < s . length ( ) ; c ++ ) { for ( int i = 1 ; i <= s . length ( ) - c ; i ++ ) { - = s . substring ( c , c + i ) ; System . out . println ( - ) ; } } }
va	5	public static void main ( String [ ] args ) { Suitors mySuitors = new Suitors ( ) ; for ( int i = 0 ; i < 22 ; i ++ ) mySuitors . add ( ) ; Suitor theSuitor = mySuitors . head ; boolean done = false ; int count = 0 ; while ( ! done ) { if ( theSuitor . next . number == theSuitor . number ) done = true ; else { theSuitor = theSuitor . next . next . next ; mySuitors . remove ( theSuitor ) ; count ++ ; if ( count > 0 && count % 5 == 0 ) { mySuitors . display ( ) ; System . out . println ( ) ; } } } System . out . println ( "And the winner is..." ) ; mySuitors . display ( ) ; }
va	0	public void _fatal ( Object context ) { }
va	6	public static void main ( String [ ] args ) { int N = 4 ; int gC [ ] = { 1 , 5 , 3 , 6 } ; int d [ ] = { 2 , 3 , 2 , 7 } ; int rF [ ] = { 0 , 0 , 0 , 0 } ; int l , i ; for ( l = 0 ; l < N ; l ++ ) { for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) rF [ i ] += gC [ ( l + i ) % N ] - d [ ( l + i ) % N ] ; } } for ( i = 0 ; i < N ; i ++ ) { if ( rF [ i ] >= 0 ) break ; } if ( i < N ) { System . out . println ( "The Starting point is:" + i ) ; } else { System . out . println ( "There is no Starting point" ) ; } }
va	5	public int getIndex ( Point p ) { final int x = p . x ; final int y = p . y ; if ( x < 0 || x >= 1 << order || y < 0 || y >= 1 << order ) return - 1 ; int index = 0 ; int sq = startsquare ; int o = order - 1 ; while ( o >= 0 ) { int i = ( ( ( ( x >> o ) & 1 ) << 1 ) | ( ( y >> o ) & 1 ) ) ; index = ( index << 2 ) | indexes [ sq ] [ i ] ; sq = squares [ sq ] [ i ] ; o -- ; } return index ; }
va	9X	public String checkDataEntry ( ) { if ( lhc_analysis_panel3 . lhcParamFileChosen . getText ( ) . equals ( "Selected Directory: " ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( lhc_analysis_panel3 . measures . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . measureScale . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . numberOfRunsPerParameterSet . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . mediansFileName . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . lhcSummaryFileName . getText ( ) . equals ( "" ) || lhc_analysis_panel3 . lhcCoEffsFileName . getText ( ) . equals ( "" ) ) { return "Error on Parameter Data Entry. Make sure all the boxes have been completed" ; } else if ( ! lhc_analysis_panel3 . mediansFileFormat . getText ( ) . equals ( "csv" ) && ! lhc_analysis_panel3 . mediansFileFormat . getText ( ) . equals ( "xml" ) ) { return "Result file format must be xml or csv" ; } else { try { int numRuns = Integer . parseInt ( lhc_analysis_panel3 . numberOfRunsPerParameterSet . getText ( ) ) ; if ( numRuns < 0 ) { return "Number of runs must be positive" ; } else { return null ; } } catch ( NumberFormatException e ) { return "Make sure the number of runs is an integer" ; } } }
va	1	private static TermURIs getURISet ( ) { if ( _singleton == null ) { _singleton = new TermURIs ( ) ; } return _singleton ; }
va	8	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Survey survey = ( Survey ) o ; if ( idsurvey != survey . idsurvey ) return false ; if ( date != null ? ! date . equals ( survey . date ) : survey . date != null ) return false ; if ( question != null ? ! question . equals ( survey . question ) : survey . question != null ) return false ; return true ; }
va	6	private void handleIOException ( SelectionKey key , WebSocket conn , IOException ex ) { if ( conn != null ) { conn . closeConnection ( CloseFrame . ABNORMAL_CLOSE , ex . getMessage ( ) ) ; } else if ( key != null ) { SelectableChannel channel = key . channel ( ) ; if ( channel != null && channel . isOpen ( ) ) { try { channel . close ( ) ; } catch ( IOException e ) { } if ( WebSocketImpl . DEBUG ) System . out . println ( "Connection closed because of" + ex ) ; } } }
va	6	void copyBGToBuf ( Graphics bufg , int sx1 , int sy1 , int sx2 , int sy2 , int dx1 , int dy1 ) { if ( sx2 <= sx1 || sy2 <= sy1 ) return ; int barrelx = el . scaleXPos ( el . moduloFloor ( el . xofs , el . tilex ) , false ) ; int barrely = el . scaleYPos ( el . moduloFloor ( el . yofs , el . tiley ) , false ) ; int barreldx = ( sx1 == 0 ) ? barrelx : 0 ; int barreldy = ( sy1 == 0 ) ? barrely : 0 ; barrelx = ( sx1 == 0 ) ? 0 : barrelx ; barrely = ( sy1 == 0 ) ? 0 : barrely ; int dx2 = dx1 + sx2 - sx1 ; int dy2 = dy1 + sy2 - sy1 ; bufg . drawImage ( background , dx1 * el . scaledtilex - barreldx , dy1 * el . scaledtiley - barreldy , dx2 * el . scaledtilex - barreldx , dy2 * el . scaledtiley - barreldy , barrelx + sx1 * el . scaledtilex , barrely + sy1 * el . scaledtiley , barrelx + sx2 * el . scaledtilex , barrely + sy2 * el . scaledtiley , this ) ; }
va	1	public void destroy ( ) { game . stopLWJGL ( ) ; if ( display_parent != null ) remove ( display_parent ) ; super . destroy ( ) ; }
va	3	public static String getPalindrome ( String s , int l , int r ) { char [ ] arr = s . toCharArray ( ) ; while ( l >= 0 && r < arr . length ) { if ( arr [ l ] != arr [ r ] ) break ; l -- ; r ++ ; } return s . substring ( l + 1 , r ) ; }
va	5	private boolean verificarMovimiento ( JPanelJuego jPanelJuego ) { if ( entroALaPuerta ) return false ; boolean movimiento = true ; if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . ARRIBA ) ) ) { setEstadoActual ( Estado . ARRIBA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . UP ) . play ( ) ; movimientoArriba ( ) ; } else if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . ABAJO ) ) ) { Sonidos . getInstance ( ) . getSonido ( Sonidos . UP ) . stop ( ) ; setEstadoActual ( Estado . ABAJO ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . DOWN ) . play ( ) ; movimientoAbajo ( ) ; } else { Sonidos . getInstance ( ) . detenerSonidos ( Sonidos . UP , Sonidos . DOWN ) ; movimiento = false ; } if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . DERECHA ) ) ) { setEstadoActual ( Estado . DERECHA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . LEFT ) . play ( ) ; movimientoDerecha ( ) ; movimiento = true ; } else if ( teclado . teclaPresionada ( gamePad . getBoton ( Botones . IZQUIERDA ) ) ) { Sonidos . getInstance ( ) . getSonido ( Sonidos . LEFT ) . stop ( ) ; setEstadoActual ( Estado . IZQUIERDA ) ; Sonidos . getInstance ( ) . getSonido ( Sonidos . RIGHT ) . play ( ) ; movimientoIzquierda ( ) ; movimiento = true ; } else { Sonidos . getInstance ( ) . detenerSonidos ( Sonidos . LEFT , Sonidos . RIGHT ) ; } return movimiento ; }
va	8	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case ID : if ( value == null ) { unsetId ( ) ; } else { setId ( ( Integer ) value ) ; } break ; case NOME : if ( value == null ) { unsetNome ( ) ; } else { setNome ( ( String ) value ) ; } break ; case EMAIL : if ( value == null ) { unsetEmail ( ) ; } else { setEmail ( ( String ) value ) ; } break ; case DATA : if ( value == null ) { unsetData ( ) ; } else { setData ( ( String ) value ) ; } break ; } }
va	8	@ Override public void write ( int theByte ) throws IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = EncFSBase64 . decode4to3 ( buffer , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new IOException ( "Invalid character in Base64 data." ) ; } } }
va	9X	@ SuppressWarnings ( "element-type-mismatch" ) public void removePart ( int i ) { if ( mouths . contains ( parts . get ( i ) ) ) { mouths . remove ( parts . get ( i ) ) ; } if ( eyes . contains ( parts . get ( i ) ) ) { eyes . remove ( parts . get ( i ) ) ; } if ( genitals . contains ( parts . get ( i ) ) ) { genitals . remove ( parts . get ( i ) ) ; } if ( legs . contains ( parts . get ( i ) ) ) { legs . remove ( parts . get ( i ) ) ; } if ( fats . contains ( parts . get ( i ) ) ) { fats . remove ( parts . get ( i ) ) ; } if ( brains . contains ( parts . get ( i ) ) ) { brains . remove ( parts . get ( i ) ) ; } if ( stomachs . contains ( parts . get ( i ) ) ) { stomachs . remove ( parts . get ( i ) ) ; } if ( stems . contains ( parts . get ( i ) ) ) { stems . remove ( parts . get ( i ) ) ; } if ( seeds . contains ( parts . get ( i ) ) ) { seeds . remove ( parts . get ( i ) ) ; } if ( leafs . contains ( parts . get ( i ) ) ) { leafs . remove ( parts . get ( i ) ) ; } parts . remove ( i ) ; }
va	8	public static void main ( String args [ ] ) throws IOException { Scanner obj = new Scanner ( System . in ) ; System . out . print ( " " ) ; int n = obj . nextInt ( ) ; int m = obj . nextInt ( ) ; int p = obj . nextInt ( ) ; int [ ] [ ] arr = new int [ n ] [ m ] ; int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i ] [ j ] = j ; } } while ( p -- > 0 ) { int i = obj . nextInt ( ) ; int j = obj . nextInt ( ) ; arr [ i - 1 ] [ j - 1 ] += 1 ; } for ( int i = 0 ; i < m ; ++ i ) { int j ; for ( j = m - 1 ; j > 0 ; -- j ) { if ( arr [ i ] [ j ] >= arr [ i ] [ j - 1 ] ) { brr [ i ] += arr [ i ] [ j ] - arr [ i ] [ j - 1 ] ; } else { break ; } } if ( j != 0 ) { brr [ i ] = - 1 ; } } for ( int i = 0 ; i < n ; ++ i ) { System . out . println ( brr [ i ] ) ; } }
va	3	public void initPanel ( ) { this . removeAll ( ) ; texte_options . setForeground ( Color . BLACK ) ; texte_options . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 40 ) ) ; texte_options . setBounds ( 360 , 20 , 500 , 50 ) ; texte . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; texte2 . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; texte3 . setFont ( new Font ( "Droid Serif" , Font . ITALIC | Font . BOLD , 15 ) ) ; spinner . setModel ( new SpinnerNumberModel ( fenetre . getModele ( ) . getOptions ( ) . getTailleGrille ( ) , 10 , 20 , 1 ) ) ; switch ( fenetre . getModele ( ) . getOptions ( ) . getNiveauIA ( ) ) { case FACILE : rb_facile . setSelected ( true ) ; break ; case MOYEN : rb_moyen . setSelected ( true ) ; break ; case DIFFICILE : rb_difficile . setSelected ( true ) ; break ; } pan . setLayout ( new GridLayout ( 6 , 1 ) ) ; pan . setBounds ( 50 , 110 , 400 , 410 ) ; pan2 . setLayout ( null ) ; pan2 . setBounds ( 480 , 110 , 360 , 150 ) ; pan3 . setLayout ( null ) ; pan3 . setBounds ( 480 , 300 , 360 , 220 ) ; texte2 . setBounds ( 10 , 10 , 400 , 20 ) ; spinner . setBounds ( 150 , 50 , 60 , 40 ) ; texte3 . setBounds ( 10 , 10 , 300 , 20 ) ; rb_facile . setBounds ( 20 , 50 , 100 , 20 ) ; rb_facile . setBackground ( null ) ; rb_moyen . setBounds ( 20 , 100 , 100 , 20 ) ; rb_moyen . setBackground ( null ) ; rb_difficile . setBounds ( 20 , 150 , 100 , 20 ) ; rb_difficile . setBackground ( null ) ; b_retour . setBounds ( 10 , 550 , 100 , 50 ) ; b_jouer . setBounds ( 780 , 550 , 100 , 50 ) ; bg . add ( rb_facile ) ; bg . add ( rb_moyen ) ; bg . add ( rb_difficile ) ; check1 . setFocusable ( false ) ; check2 . setFocusable ( false ) ; check3 . setFocusable ( false ) ; check4 . setFocusable ( false ) ; check5 . setFocusable ( false ) ; getCoches ( ) ; check1 . setState ( coches [ 0 ] ) ; check2 . setState ( coches [ 1 ] ) ; check3 . setState ( coches [ 2 ] ) ; check4 . setState ( coches [ 3 ] ) ; check5 . setState ( coches [ 4 ] ) ; pan . add ( texte ) ; pan . add ( check1 ) ; pan . add ( check2 ) ; pan . add ( check3 ) ; pan . add ( check4 ) ; pan . add ( check5 ) ; pan2 . add ( texte2 ) ; pan2 . add ( spinner ) ; pan3 . add ( texte3 ) ; pan3 . add ( rb_facile ) ; pan3 . add ( rb_moyen ) ; pan3 . add ( rb_difficile ) ; this . add ( texte_options ) ; this . add ( pan ) ; this . add ( pan2 ) ; this . add ( pan3 ) ; this . add ( b_jouer ) ; this . add ( b_retour ) ; }
va	0	protected BombImage ( Content parent , Game game , Point position , int range , Date end ) { super ( parent , game , position , range , end ) ; }
va	0	public String getMessage ( ) { return super . getMessage ( ) + SEPARATOR + getErrnoString ( ) + " [" + errno + "] " ; }
va	0	public void setPassword ( String password ) { this . password = password ; }
va	5	public Request < DescribeInstanceTypesRequest > marshall ( DescribeInstanceTypesRequest describeInstanceTypesRequest ) { if ( describeInstanceTypesRequest == null ) { throw new AmazonClientException ( "Invalid argument passed to marshall(...)" ) ; } Request < DescribeInstanceTypesRequest > request = new DefaultRequest < > ( describeInstanceTypesRequest , "AmazonEC2" ) ; request . addParameter ( "Action" , "DescribeInstanceTypes" ) ; request . addParameter ( "Version" , "2013-10-15" ) ; List < String > instanceTypesList = describeInstanceTypesRequest . getInstanceTypes ( ) ; int instanceTypesListIndex = 1 ; for ( String instanceTypesListValue : instanceTypesList ) { if ( instanceTypesListValue != null ) { request . addParameter ( "InstanceType." + instanceTypesListIndex , StringUtils . fromString ( instanceTypesListValue ) ) ; } instanceTypesListIndex ++ ; } if ( describeInstanceTypesRequest . getAvailability ( ) != null ) { request . addParameter ( "Availability" , StringUtils . fromBoolean ( describeInstanceTypesRequest . getAvailability ( ) ) ) ; } if ( describeInstanceTypesRequest . getVerbose ( ) != null ) { request . addParameter ( "Verbose" , StringUtils . fromBoolean ( describeInstanceTypesRequest . getVerbose ( ) ) ) ; } return request ; }
va	3	public static void main ( String [ ] args ) { SalariedEmployee salariedEmployee = new SalariedEmployee ( "John" , "Smith" , "111-11-1111" , 800.00 ) ; HourlyEmployee hourlyEmployee = new HourlyEmployee ( "Karen" , "Price" , "222-22-2222" , 16.75 , 40 ) ; CommissionEmployee commissionEmployee = new CommissionEmployee ( "Sue" , "Jones" , "333-33-3333" , 10000 , .06 ) ; BasePlusCommissionEmployee basePlusCommissionEmployee = new BasePlusCommissionEmployee ( "Bob" , "Lewis" , "444-44-4444" , 5000 , .04 , 300 ) ; System . out . println ( "Employees processed individually:\n" ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , salariedEmployee , "earned" , salariedEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , hourlyEmployee , "earned" , hourlyEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , commissionEmployee , "earned" , commissionEmployee . earnings ( ) ) ; System . out . printf ( "%s\n%s: $% .2f\n\n" , basePlusCommissionEmployee , "earned" , basePlusCommissionEmployee . earnings ( ) ) ; Employee [ ] employees = new Employee [ 4 ] ; employees [ 0 ] = salariedEmployee ; employees [ 1 ] = hourlyEmployee ; employees [ 2 ] = commissionEmployee ; employees [ 3 ] = basePlusCommissionEmployee ; System . out . println ( "Employees processed polymorphically:\n" ) ; for ( Employee currentEmployee : employees ) { System . out . println ( currentEmployee ) ; if ( currentEmployee instanceof BasePlusCommissionEmployee ) { BasePlusCommissionEmployee employee = ( BasePlusCommissionEmployee ) currentEmployee ; employee . setBaseSalary ( 1.10 * employee . getBaseSalary ( ) ) ; System . out . printf ( "new base salary with 10%% increase is: $% .2f\n" , employee . getBaseSalary ( ) ) ; } System . out . printf ( "earned $% .2f\n\n" , currentEmployee . earnings ( ) ) ; } for ( int j = 0 ; j < employees . length ; j ++ ) System . out . printf ( "Employee %d is a %s\n" , j , employees [ j ] . getClass ( ) . getName ( ) ) ; }
va	6	public int [ ] plusOne ( int [ ] digits ) { int carry = 1 ; if ( digits == null || digits . length == 0 ) { return digits ; } for ( int i = digits . length - 1 ; i >= 0 ; i -- ) { int sum = digits [ i ] + carry ; digits [ i ] = sum % 10 ; carry = sum / 10 ; if ( carry == 0 ) { break ; } } int [ ] result = null ; if ( carry > 0 ) { result = new int [ digits . length + 1 ] ; result [ 0 ] = carry ; for ( int i = 1 ; i <= digits . length ; i ++ ) { result [ i ] = digits [ i - 1 ] ; } } else { result = digits ; } return result ; }
va	8	public static boolean isWord ( int c ) { if ( c > 127 ) return true ; if ( c > 47 && c < 58 ) return true ; if ( c > 64 && c < 91 ) return true ; if ( c > 96 && c < 123 ) return true ; if ( c == _ ) return true ; return false ; }
va	4	public synchronized boolean doCresciDinosauro ( String token , String idDinosauro ) throws InvalidTokenException , GenericDinosauroException { Coord coordToRemove = null ; try { if ( getPlayerByToken ( token ) . getRazza ( ) . existsDinosauroWithId ( idDinosauro ) ) { coordToRemove = getPlayerByToken ( token ) . getRazza ( ) . getDinosauroById ( idDinosauro ) . getCoord ( ) ; getPlayerByToken ( token ) . getRazza ( ) . cresciDinosauro ( idDinosauro ) ; return true ; } return false ; } catch ( InvalidTokenException e ) { throw new InvalidTokenException ( ) ; } catch ( GenericDinosauroException e ) { if ( e . getMessage ( ) . equals ( "mortePerInedia" ) ) { getMappa ( ) . rimuoviIlDinosauroDallaCella ( coordToRemove ) ; } throw new GenericDinosauroException ( e . getMessage ( ) ) ; } }
va	5	public void update ( ) { totalTime ++ ; if ( totalTime > 200 && ! ( component . getScreen ( ) instanceof MainMenu ) ) setScreen ( new MainMenu ( component , this , input ) ) ; boolean switchScreen = false ; if ( logoTransparancy < 1.0f ) { logoTransparancy += ( float ) RTSComponent . MS_PER_TICK / 2000 ; } else { logoTransparancy = 1.0f ; switchScreen = true ; } if ( switchScreen ) { if ( ! ( component . getScreen ( ) instanceof MainMenu ) ) setScreen ( new MainMenu ( component , this , input ) ) ; } }
va	4	public List < SiteStatModel > map ( StatResultSet resultset , SiteModel siteModel , DateTime timeLimit ) { List < StatRow > statRows = resultset . getRows ( ) ; Map < long , SiteStatModel > siteStatModelMap = new HashMap < > ( ) ; for ( StatRow eachRow : statRows ) { DateTime hour = DateTimeFormatUtil . parseDateTime ( eachRow . getField ( ) . get ( 4 ) ) ; if ( hour == null ) { continue ; } if ( hour . getMillis ( ) < timeLimit . getMillis ( ) ) { SiteStatModel siteStatModel = new SiteStatModel ( ) ; siteStatModel . setUniqueVisitor ( Integer . parseInt ( eachRow . getField ( ) . get ( 1 ) ) ) ; siteStatModel . setPageView ( Integer . parseInt ( eachRow . getField ( ) . get ( 2 ) ) ) ; siteStatModel . setVisit ( Integer . parseInt ( eachRow . getField ( ) . get ( 3 ) ) ) ; siteStatModel . setHour ( hour ) ; siteStatModel . setVideo ( 0 ) ; siteStatModel . setSite ( siteModel ) ; if ( siteStatModelMap . get ( hour . getMillis ( ) ) == null ) { siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } else { siteStatModelMap . remove ( hour . getMillis ( ) ) ; siteStatModelMap . put ( hour . getMillis ( ) , siteStatModel ) ; } } } List < SiteStatModel > siteStatModels = new ArrayList < > ( siteStatModelMap . values ( ) ) ; return siteStatModels ; }
va	9X	@ SuppressWarnings ( "unchecked" ) protected Object get ( String [ ] parts ) { if ( parts . length == 0 ) { return root ; } if ( ! ( root instanceof Map < ? , ? > ) ) { return null ; } Map < Object , Object > node = ( Map < Object , Object > ) root ; for ( int i = 0 ; i < parts . length ; i ++ ) { String part = parts [ i ] ; Matcher m = indexPattern . matcher ( part ) ; int index = - 1 ; if ( m . matches ( ) ) { part = part . substring ( 0 , part . length ( ) - m . group ( 1 ) . length ( ) ) ; index = Integer . parseInt ( m . group ( 1 ) ) ; } Object o = node . get ( part ) ; if ( o == null ) { return null ; } else if ( i == parts . length - 1 ) { return getIndexOf ( o , index ) ; } try { node = ( Map < Object , Object > ) getIndexOf ( o , index ) ; } catch ( ClassCastException e ) { return null ; } } return null ; }
va	1	public void testService ( ) throws Exception { System . out . println ( "locating service:osgi" ) ; int count = 0 ; for ( ServiceLocationEnumeration services = TestActivator . locator . findServices ( new ServiceType ( "service:osgi" ) , null , null ) ; services . hasMoreElements ( ) ; ) { assertEquals ( services . next ( ) . toString ( ) , "service:osgi://gantenbein:123" ) ; count ++ ; } assertEquals ( count , 1 ) ; }
va	7	@ Override public boolean onResponse ( Message message ) { int hour = Calendar . getInstance ( ) . get ( Calendar . HOUR_OF_DAY ) ; if ( hour <= 9 ) { for ( String word : moringWords ) { if ( message . content . contains ( word ) ) { message . reply ( moringResponseWord [ new Random ( ) . nextInt ( moringResponseWord . length ) ] ) ; return true ; } } } else if ( hour >= 21 || hour < 3 ) { for ( String word : nigthWords ) { if ( message . content . contains ( word ) ) { message . reply ( nigthResponseWords [ new Random ( ) . nextInt ( nigthResponseWords . length ) ] ) ; return true ; } } } return false ; }
va	8	public static void main ( String [ ] args ) { int grade ; grade = Integer . parseInt ( args [ 0 ] ) ; if ( grade <= 100 && grade >= 85 ) System . out . println ( "HD" ) ; else if ( grade <= 84 && grade >= 75 ) System . out . println ( "D" ) ; else if ( grade <= 74 && grade >= 65 ) System . out . println ( "C" ) ; else if ( grade <= 64 && grade >= 50 ) System . out . println ( "P" ) ; else System . out . println ( "F" ) ; }
va	2	private List < Integer > getSelection ( ) { final List < Integer > sel = new LinkedList < > ( ) ; for ( int i = 0 ; i < cardList . size ( ) ; i ++ ) { if ( cardList . get ( i ) . selected ) { sel . add ( i ) ; } } return sel ; }
va	4	private String makeBetween ( LangFileElement lfe ) { if ( lfe . isNewElement ( ) ) { switch ( betweenType ) { case BETWEEN_ALIGNEMENT : int len = lfe . getPrefix ( ) . length ( ) + 9 + lfe . getLine ( ) . length ( ) ; String between = " " ; for ( int i = len ; i < betweenPadding ; i ++ ) { between += " " ; } return between ; case BETWEEN_STRING : default : return betweenString ; } } else { return lfe . getBetween ( ) ; } }
va	5	public static Platform getPlatform ( String platform ) { if ( isLinux ( platform ) ) { return LINUX ; } else if ( isWindows ( platform ) ) { return WINDOWS ; } else if ( isSolaris ( platform ) ) { return OPENSOLARIS ; } else if ( isFreeBSD ( platform ) ) { return FREEBSD ; } else if ( isMac ( platform ) ) { return MAC ; } return null ; }
va	2	public Grille ( int taille , Joueur joueur , boolean afficher_bateaux ) { this . taille_case = 320 / taille ; this . taille = taille ; this . cases = new case [ taille ] [ taille ] ; this . joueur = joueur ; this . afficher_bateaux = afficher_bateaux ; this . setBackground ( new Color ( 0 , 0 , 0 ) ) ; this . setLayout ( new GridLayout ( taille , taille , 0 , 0 ) ) ; for ( int i = 0 ; i < taille ; i ++ ) for ( int j = 0 ; j < taille ; j ++ ) cases [ i ] [ j ] = new case ( i + 1 , j + 1 , taille_case ) ; initialiserCases ( ) ; }
va	1	public synchronized boolean method234 ( int i , byte abyte0 [ ] , int j ) { boolean flag = method235 ( true , j , i , abyte0 ) ; if ( ! flag ) flag = method235 ( false , j , i , abyte0 ) ; return flag ; }
va	8	protected void encodeDocumentType ( DocumentType documentType ) throws IOException { alignToOctet ( ) ; current_octet |= FastInfosetConstants . DOCUMENT_TYPE_IDENTIFICATION ; boolean encodesystemid = ( documentType . systemIdentifier != null ) && ! documentType . systemIdentifier . isEmpty ( ) ; boolean encodepublicid = ( documentType . publicIdentifier != null ) && ! documentType . publicIdentifier . isEmpty ( ) ; if ( encodesystemid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_SYSTEMID_PRESENCE ; } if ( encodepublicid ) { current_octet |= FastInfosetConstants . DOCUMENT_TYPE_PUBLICID_PRESENCE ; } flush_currentoctet ( ) ; if ( encodesystemid ) { encodeIdentifyingStringOrIndex ( documentType . systemIdentifier , vocabulary . other_uris ) ; } if ( encodepublicid ) { encodeIdentifyingStringOrIndex ( documentType . publicIdentifier , vocabulary . other_uris ) ; } if ( documentType . instructions != null ) { for ( fastinfoset . Document . ProcessingInstruction instruction : documentType . instructions ) { encodeProcessingInstruction ( instruction . target , instruction . content ) ; } } current_octet |= FastInfosetConstants . TERMINATION_PATTERN << 4 ; }
va	9X	public void mouseDragged ( MouseEvent e ) { if ( isCtrlDown ( e ) || ( ! editMode && ! ctx . dragging ) ) { if ( panCurr != null ) { Point pt = new Point ( e . getX ( ) , e . getY ( ) ) ; if ( e . getComponent ( ) != null ) { SwingUtilities . convertPointToScreen ( pt , e . getComponent ( ) ) ; } int deltaX = pt . x - panCurr . x ; int deltaY = pt . y - panCurr . y ; prevPanCurr = panCurr ; panCurr = new PointAtTime ( pt . x , pt . y ) ; ctx . getScrollPane ( ) . getHorizontalScrollBar ( ) . setValue ( - deltaX + ctx . getScrollPane ( ) . getHorizontalScrollBar ( ) . getValue ( ) ) ; ctx . getScrollPane ( ) . getVerticalScrollBar ( ) . setValue ( - deltaY + ctx . getScrollPane ( ) . getVerticalScrollBar ( ) . getValue ( ) ) ; } } else { if ( ctx . dragging || ctx . rubberBanding ) { ctx . dragCurr = new Point ( e . getX ( ) , e . getY ( ) ) ; if ( ctx . rubberBanding ) { Point startP = ctx . getXY ( ctx . dragStart . x , ctx . dragStart . y ) ; Point endP = ctx . getXY ( ctx . dragCurr . x , ctx . dragCurr . y ) ; int temp ; if ( startP . x > endP . x ) { temp = startP . x ; startP . x = endP . x ; endP . x = temp ; } if ( startP . y > endP . y ) { temp = startP . y ; startP . y = endP . y ; endP . y = temp ; } ctx . clearSelection ( ) ; for ( CoverDetails cd : ctx . covers ) { if ( cd . getX ( ) >= startP . x && cd . getX ( ) <= endP . x && cd . getY ( ) >= startP . y && cd . getY ( ) <= endP . y ) { ctx . addSelection ( cd ) ; } } } ctx . mainRepaint ( ) ; } } }
va	3	public static Shader createShader ( String name ) { BufferedReader vertex ; try { vertex = new BufferedReader ( new FileReader ( new File ( ShaderLoader . class . getResource ( "/shaders/" + name + ".vert" ) . toURI ( ) ) ) ) ; } catch ( Exception e ) { return null ; } BufferedReader fragment ; try { fragment = new BufferedReader ( new FileReader ( new File ( ShaderLoader . class . getResource ( "/shaders/" + name + ".vert" ) . toURI ( ) ) ) ) ; } catch ( Exception e ) { try { vertex . close ( ) ; } catch ( IOException e2 ) { } return null ; } return createShader ( name , vertex , fragment ) ; }
va	4	private String toString ( Object obj ) { if ( null == obj ) { return "" ; } if ( obj . getClass ( ) . isArray ( ) ) { return Utils . join ( ( Object [ ] ) obj ) ; } if ( obj instanceof Collection ) { return Utils . join ( ( Collection < ? > ) obj ) ; } return obj . toString ( ) ; }
va	9X	public void InitializeGameWorld ( int numEnemyTanks , int numRocks , int numTrees ) { listObjects = new LinkedList < GameObject > ( ) ; tanks = new LinkedList < Tank > ( ) ; landscape = new LinkedList < LandscapeGameObject > ( ) ; projectiles = new LinkedList < Projectile > ( ) ; playerTank = getRandomPlayerTank ( 0 ) ; for ( int i = 0 ; i < numEnemyTanks ; i ++ ) { Tank tank = getRandomTank ( ) ; while ( collidesWithWorld ( tank ) ) { if ( Game . debug ) { System . out . println ( "tank placement collision" ) ; } tank = getRandomTank ( ) ; } addTank ( tank ) ; } for ( int j = 0 ; j < numRocks ; j ++ ) { Rock rock = getRandomRock ( j ) ; while ( collidesWithWorld ( rock ) ) { if ( Game . debug ) { System . out . println ( "rock placement collision" ) ; } rock = getRandomRock ( j ) ; } addLandscapeObject ( rock ) ; } for ( int k = 0 ; k < numTrees ; k ++ ) { Tree tree = getRandomTree ( k ) ; while ( collidesWithWorld ( tree ) ) { if ( Game . debug ) { System . out . println ( "tree placement collision" ) ; } tree = getRandomTree ( k ) ; } addLandscapeObject ( tree ) ; } addTank ( playerTank ) ; lives = startingLives ; score = 0 ; gameClock = 0 ; gameOver = false ; TotaltankCount = 0 ; notifyObservers ( ) ; }
va	3	< C > NodeFactory < C > getSimpleNodeBuilder ( final String namespace , class < C > dummy ) { final NodeFactory < C > factory = new ReflectNodeFactory < > ( new AutoQualifiedClassLoader ( namespace , _classLoader ) ) ; return new SimpleNodeFactory < C > ( ) { public Predicate < C > newPredicate ( String type , String attr ) { if ( factory . newPredicate ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newPredicate ( type , attr ) ; } @ Override public Action < C > newAction ( String type , String attr ) { if ( factory . newAction ( type , attr ) == null ) error ( type ) ; else ok ( type ) ; return super . newAction ( type , attr ) ; } private void ok ( String name ) { if ( VERBOSE ) System . out . printf ( "Class '%s' loaded\n" , name ) ; } private void error ( String name ) { System . err . printf ( "Class '%s' not found in '%s'\n" , name , namespace ) ; } } ; }
va	3	public static void benchmark ( ) throws Exception { int N = 100000 ; String [ ] methodsToCompare = { "canWriteLetterFromMagazine1" , "canWriteLetterFromMagazine2" , "canWriteLetterFromMagazine3" , "canWriteLetterFromMagazine4" , "canWriteLetterFromMagazine5" , "canWriteLetterFromMagazine6" , "canWriteLetterFromMagazine7" } ; String magazine = cleanInput ( "this is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazinethis is a pretty awesome magazine" ) ; String letter = cleanInput ( "hogs are swine" ) ; for ( String methodName : methodsToCompare ) { class clazz = class . forName ( "book.chapter.twelve.Problem12_09" ) ; Method method = clazz . getDeclaredMethod ( methodName , String . class , String . class ) ; long startTime = System . nanoTime ( ) ; for ( int i = 0 ; i < N ; i ++ ) { boolean retVal = ( boolean ) method . invoke ( null , letter , magazine ) ; if ( retVal == false ) throw new Exception ( "wrong result!" ) ; } long endTime = System . nanoTime ( ) ; System . out . println ( "Elapsed time for " + methodName + ": " + ( endTime - startTime ) / 1000000000.0 + " seconds" ) ; } }
va	2	public static int getSeqVal ( String sql ) { try { PreparedStatement stat = connection . prepareStatement ( sql ) ; ResultSet re = stat . executeQuery ( ) ; if ( re . next ( ) ) { return re . getInt ( 1 ) ; } else { return - 1 ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return - 1 ; }
va	7	@ Override public String getMCstring ( ) { String s = "" ; for ( int i = 0 ; i < mc . length ; i ++ ) { if ( mc [ i ] == true ) s = s . concat ( "1" ) ; else s = s . concat ( "0" ) ; if ( i == 5 || i == 10 || i == 15 || i == 20 || i == 25 ) s = s . concat ( " " ) ; } return s ; }
va	1	public void demote ( Instance instance ) { super . demote ( instance ) ; double rate = - ( double ) time * demotionRate ; s . add ( FeatureVector . staticScale ( rate , instance ) ) ; if ( bias ) sBiasValue += rate ; }
va	3	public static boolean areEqual ( DummyKVStorable [ ] first , DummyKVStorable [ ] second ) { if ( first . length != second . length ) return false ; for ( int i = 0 ; i < first . length ; i ++ ) { if ( ! first [ i ] . equals ( second [ i ] ) ) { System . out . println ( "First entry: " + first [ i ] ) ; System . out . println ( "Second entry: " + second [ i ] ) ; return false ; } } return true ; }
va	0	public void validate ( ) throws org . apache . thrift7 . TException { }
va	5	public static String toString ( int [ ] a , NumberFormat nf ) { if ( a == null ) return null ; if ( a . length == 0 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( "[" ) ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) { String s ; if ( nf == null ) { s = String . valueOf ( a [ i ] ) ; } else { s = nf . format ( a [ i ] ) ; } b . append ( s ) ; b . append ( "  " ) ; } String s ; if ( nf == null ) { s = String . valueOf ( a [ a . length - 1 ] ) ; } else { s = nf . format ( a [ a . length - 1 ] ) ; } b . append ( s ) ; b . append ( ] ) ; return b . toString ( ) ; }
va	9X	public class findClass ( String className ) { final class aClass = handleGenaratedClass ( className ) ; if ( aClass != null ) { return aClass ; } byte classByte [ ] ; class result = null ; result = ( class ) classes . get ( className ) ; if ( result != null ) { return result ; } try { return findSystemClass ( className ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { if ( jarFiles . size ( ) > 0 ) { for ( LibraryEntity jarFile : jarFiles ) { final String [ ] libNames = jarFile . getLibNames ( ) ; for ( String libName : libNames ) { JarFile jar = new JarFile ( ApplicationSettings . getInstance ( ) . getLibraryBasePath ( ) + libName ) ; final Enumeration < JarEntry > entries = jar . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry element = entries . nextElement ( ) ; final String accClassName = element . getName ( ) . replaceAll ( "/" , "." ) ; if ( ( className + ".class" ) . equals ( accClassName ) ) { InputStream is = jar . getInputStream ( element ) ; ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; int nextValue = is . read ( ) ; while ( - 1 != nextValue ) { byteStream . write ( nextValue ) ; nextValue = is . read ( ) ; } classByte = byteStream . toByteArray ( ) ; result = defineClass ( className , classByte , 0 , classByte . length , null ) ; classes . put ( className , result ) ; return result ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
va	1	public void displayPlayer ( ) { Iterator < PlayerID > iter = activePlayers . iterator ( ) ; PlayerID p ; System . out . println ( "--- PlayerIDs ---" ) ; while ( iter . hasNext ( ) ) { p = iter . next ( ) ; System . out . println ( "PlayerID: " + p . getPID ( ) + "  ConnectionID: " + p . getCID ( ) ) ; } }
va	0	public void removeColumn ( String columnID ) { htColumns . remove ( columnID ) ; }
va	7	private CfgGroup readGroup ( final CfgGroup group , final BufferedReader reader ) throws IOException { while ( true ) { String line = reader . readLine ( ) ; if ( line == null ) { return group ; } line = line + "\r\n" ; final String trimmedLine = line . trim ( ) ; if ( trimmedLine . equals ( "}" ) ) { group . addFooterLine ( new CfgRawLine ( line ) ) ; return group ; } if ( trimmedLine . equals ( "{" ) ) { group . addHeaderLine ( new CfgRawLine ( line ) ) ; continue ; } if ( trimmedLine . startsWith ( "//" ) ) { continue ; } if ( trimmedLine . isEmpty ( ) ) { continue ; } final int indexOfEquals = trimmedLine . indexOf ( = ) ; if ( indexOfEquals < 0 ) { final CfgLine groupNameLine = new CfgRawLine ( line ) ; final CfgGroup subgroup = new CfgGroup ( groupNameLine ) ; readGroup ( subgroup , reader ) ; group . addSubgroup ( subgroup ) ; } else { final CfgLine cfgLine = new CfgKeyValueLine ( line ) ; group . addLine ( cfgLine ) ; } } }
va	2	@ Override public synchronized boolean checkToken ( Token token ) { for ( Token to : tokens ) { if ( token . equals ( to ) ) { return true ; } } return false ; }
va	7	private void verifyForeignKeyConstraints ( Tuple tuple ) throws DatabaseException { for ( Schema . ForeignKey fk : schema . getForeignKeys ( ) ) { Table refTable = fk . getRefTable ( ) ; int [ ] localKeyPositions = fk . getForeignKeyPositions ( ) ; Object [ ] localKeyValues = new Object [ localKeyPositions . length ] ; Attribute . Type [ ] localKeyTypes = new Attribute . Type [ localKeyPositions . length ] ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { localKeyValues [ i ] = tuple . getValueAt ( localKeyPositions [ i ] ) ; localKeyTypes [ i ] = schema . getAttributes ( ) [ localKeyPositions [ i ] ] . getType ( ) ; } int [ ] refKeyPositions = refTable . getSchema ( ) . getPrimaryKeyPositions ( ) ; boolean matchFound = false ; for ( Tuple refTuple : refTable . getTuples ( ) ) { matchFound = true ; for ( int i = 0 ; i < localKeyPositions . length ; ++ i ) { if ( ! Tuple . valuesEqual ( localKeyTypes [ i ] , localKeyValues [ i ] , refTuple . getValueAt ( refKeyPositions [ i ] ) ) ) { matchFound = false ; break ; } } if ( matchFound ) break ; } if ( ! matchFound ) { throw new DatabaseException ( "Referential constraint to table '" + refTable . getName ( ) + "' not met." ) ; } } }
va	7	private static void test8 ( ) throws FileNotFoundException { String input = "new\n" + "pick up cell key\n" + "unlock cell door with cell key\n" + "quit\n" + "y\n" ; HashMap < Integer , String > output = new HashMap < Integer , String > ( ) ; boolean passed = true ; try { in = new ByteArrayInputStream ( input . getBytes ( ) ) ; System . setIn ( in ) ; out = new PrintStream ( "testing.txt" ) ; System . setOut ( out ) ; Game . main ( null ) ; } catch ( ExitException se ) { } catch ( Exception e ) { System . setOut ( stdout ) ; System . out . println ( "Error: " ) ; e . printStackTrace ( ) ; passed = false ; } finally { System . setOut ( stdout ) ; @ SuppressWarnings ( "resource" ) Scanner sc = new Scanner ( new File ( "testing.txt" ) ) ; ArrayList < String > testOutput = new ArrayList < String > ( ) ; while ( sc . hasNextLine ( ) ) { testOutput . add ( sc . nextLine ( ) ) ; } output . put ( 13 , "The guard walks toward your cell." ) ; output . put ( 14 , ">> You unlock the cell door." ) ; output . put ( 15 , "The guard peers into the cell  checking that the door is secured." ) ; output . put ( 16 , "The door swings open." ) ; output . put ( 17 , "You have been caught." ) ; output . put ( 18 , "YOU LOSE!" ) ; output . put ( testOutput . size ( ) - 1 , ">>" ) ; if ( passed ) { for ( Map . Entry < Integer , String > entry : output . entrySet ( ) ) { if ( ! testOutput . get ( entry . getKey ( ) ) . equals ( entry . getValue ( ) ) ) { passed = false ; System . out . println ( "test8 failed: Line " + entry . getKey ( ) ) ; System . out . println ( "\tExpected: " + entry . getValue ( ) ) ; System . out . println ( "\tReceived: " + testOutput . get ( entry . getKey ( ) ) ) ; } } if ( passed ) { System . out . println ( "test8 passed" ) ; } } else { System . out . println ( "test8 failed: error" ) ; } } }
va	3	public static int getPedidosNatural ( Perfil perfil ) throws SQLException { if ( perfil != null ) { sql = "SELECT SUM(CANTIDAD) " + "FROM CLIENTES_REMITOS INNER JOIN CLIENTES_DETALLE_REMITO ON " + "CLIENTES_REMITOS.IDREMITO = CLIENTES_DETALLE_REMITO.IDREMITO " + "WHERE (((CLIENTES_REMITOS.TIPODOC)=1 Or (CLIENTES_REMITOS.TIPODOC)=4) AND " + "((CLIENTES_REMITOS.ENTREGADO)=False) AND " + "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) AND " + "(COLOR = {COLOR}) AND (IDPERFIL = '{PERFIL}' ));" ; sql = sql . replace ( "{COLOR}" , Integer . toString ( ColorDP . ID_NATURAL ) ) ; sql = sql . replace ( "{PERFIL}" , perfil . getIdperf ( ) ) ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null && rs . next ( ) ) { return rs . getInt ( 1 ) ; } } } return 0 ; }
va	3	public int hyppaaTulevaSana ( String syote ) { int matka = 0 ; while ( matka < syote . length ( ) && ( ! syote . substring ( matka , matka + 1 ) . contentEquals ( " " ) ) && ( ! syote . substring ( matka , matka + 1 ) . contentEquals ( ")" ) ) ) { matka ++ ; } return matka ; }
va	9X	@ SuppressWarnings ( "unchecked" ) private void addDirectory ( File directory , Map < String , Object > mapping ) { File [ ] files = directory . listFiles ( ) ; if ( files == null || files . length == 0 ) { return ; } for ( File file : files ) { if ( file . isHidden ( ) ) { continue ; } String name = file . getName ( ) ; if ( name . length ( ) == 0 ) { continue ; } String var = null ; if ( file . isFile ( ) ) { int index = name . lastIndexOf ( . ) ; if ( index > 0 ) { name = name . substring ( 0 , index ) ; } } if ( name . startsWith ( "${" ) ) { int index = name . indexOf ( } ) ; if ( index > 0 ) { var = name . substring ( 2 , index ) ; name = "$" ; } } Map < String , Object > map = ( Map < String , Object > ) mapping . get ( name ) ; if ( map == null ) { map = new HashMap < String , Object > ( ) ; mapping . put ( name , map ) ; } if ( var != null && var . length ( ) > 0 ) { map . put ( "." , var ) ; } if ( file . isDirectory ( ) ) { addDirectory ( file , map ) ; } } }
va	7	public void brake ( double delta ) { if ( brakeFriction > 0 ) { if ( xa > 0 ) { xa = xa - ( brakeFriction * ( onGround ? 5 : 1 ) * delta ) ; } else if ( xa < 0 ) { xa = xa + ( brakeFriction * ( onGround ? 5 : 1 ) * delta ) ; } if ( xa <= 1 && xa >= - 1 ) { xa = 0.0 ; } } }
va	8	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<BalloonStyle" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . color != null ) { kml += "<color>" + SpecialCaseFormatter . toKMLString ( this . color ) + "</color>\n" ; } if ( this . bgColor != null ) { kml += "<bgColor>" + SpecialCaseFormatter . toKMLString ( this . bgColor ) + "</bgColor>\n" ; } if ( this . textColor != null ) { kml += "<textColor>" + SpecialCaseFormatter . toKMLString ( this . textColor ) + "</textColor>\n" ; } if ( this . text != null ) { kml += "<text>" + SpecialCaseFormatter . toKMLString ( this . text ) + "</text>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</BalloonStyle>\n" ; } return kml ; }
va	4	private static String longestWordFromOtherWords1 ( String [ ] words ) { int rl = - 1 ; String lwfow = null ; Arrays . sort ( words , new stringComparator ( ) ) ; HashMap < String , boolean > wordMap = new HashMap < String , boolean > ( ) ; for ( String w : words ) { if ( ! wordMap . containsKey ( w ) ) { wordMap . put ( w , true ) ; } } for ( String w : words ) { wordMap . remove ( w ) ; rl = longestWordFromOtherWords ( wordMap , w ) ; wordMap . put ( w , true ) ; if ( rl > 0 ) { lwfow = w ; break ; } } return lwfow ; }
va	6	private static void Merge ( int [ ] data , int left , int center , int right ) { int [ ] tmpArr = new int [ data . length ] ; int mid = center + 1 ; int index = left ; int tmp = left ; while ( left <= center && mid <= right ) { if ( data [ left ] <= data [ mid ] ) { tmpArr [ index ++ ] = data [ left ++ ] ; } else { tmpArr [ index ++ ] = data [ mid ++ ] ; } } while ( mid <= right ) { tmpArr [ index ++ ] = data [ mid ++ ] ; } while ( left <= center ) { tmpArr [ index ++ ] = data [ left ++ ] ; } while ( tmp <= right ) { data [ tmp ] = tmpArr [ tmp ++ ] ; } }
va	4	public Identifier BookBed ( Identifier userId , Identifier searchId ) { ArrayList < SearchBean < FreeBedDetailBean >> results = getLastSearchResult ( ) ; for ( SearchBean < FreeBedDetailBean > search : results ) { if ( search . getSearchId ( ) . equals ( searchId ) ) { FreeBedDetailBean bedDetail = search . getObjectInfo ( ) ; Identifier hostelId = search . getObjectId ( ) ; Booking booking = new Booking ( ) ; booking . setBedIds ( bedDetail . getBedIds ( ) ) ; ArrayList < Tariff > bedReservations = new ArrayList < Tariff > ( ) ; for ( int i = 0 ; i < booking . getBedIds ( ) . size ( ) ; i ++ ) { Tariff tariff = new Tariff ( bedDetail . getPrice ( ) . get ( i ) , bedDetail . getCheckIn ( ) , bedDetail . getCheckOut ( ) ) ; bedReservations . add ( tariff ) ; } booking . setBedReservations ( bedReservations ) ; booking . setBookingDate ( GenericUtility . getCurrentDateWithoutTime ( ) ) ; booking . setHostelId ( hostelId ) ; booking . setStatus ( BookingStatus . RESERVED ) ; booking . setUserId ( userId ) ; try { return Bookings . getInstance ( ) . create ( booking ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidIdentifierException | InvalidParameterException | ConflictException | IdentifierNotFoundException e ) { } } } return null ; }
va	5	void setViewOffset ( int xofs , int yofs ) { if ( bg_defined == null ) return ; this . xofs = xofs ; this . yofs = yofs ; int oldtilexofs = tilexofs ; int oldtileyofs = tileyofs ; tilexofs = divFloor ( xofs , tilex ) - 1 ; tileyofs = divFloor ( yofs , tiley ) - 1 ; xofs_scaled = scaleXPos ( xofs , false ) ; yofs_scaled = scaleYPos ( yofs , false ) ; calcPFWrapCenter ( ) ; int maxtilexofs = Math . max ( tilexofs , oldtilexofs ) ; int maxtileyofs = Math . max ( tileyofs , oldtileyofs ) ; int mintilexofs = Math . min ( tilexofs , oldtilexofs ) ; int mintileyofs = Math . min ( tileyofs , oldtileyofs ) ; for ( int yi = mintileyofs ; yi < maxtileyofs ; yi ++ ) { for ( int xi = 0 ; xi < viewnrtilesx + 3 ; xi ++ ) { bg_defined [ xi ] [ moduloFloor ( yi , viewnrtilesy + 3 ) ] = false ; } } for ( int xi = mintilexofs ; xi < maxtilexofs ; xi ++ ) { for ( int yi = 0 ; yi < viewnrtilesy + 3 ; yi ++ ) { bg_defined [ moduloFloor ( xi , viewnrtilesx + 3 ) ] [ yi ] = false ; } } }
va	2	@ Override public ArrayList < ProduktBatchKompDTO > getProduktBatchKompList ( int pbId ) throws DALException { ArrayList < ProduktBatchKompDTO > list = new ArrayList < ProduktBatchKompDTO > ( ) ; ResultSet rs = Connector . doQuery ( "SELECT pbk.*  rb.*  r.* FROM produktbatchkomponent pbk  raavarebatch rb  raavare r WHERE pbk.rb_id = rb.rb_id AND rb.raavare_id = r.raavare_id AND pbk.pb_id =  " + pbId ) ; try { while ( rs . next ( ) ) { RaavareDTO raavare = new RaavareDTO ( rs . getInt ( 10 ) , rs . getString ( 11 ) ) ; RaavareBatchDTO raavareBatch = new RaavareBatchDTO ( rs . getInt ( 5 ) , raavare , rs . getDouble ( 7 ) , rs . getTimestamp ( 8 ) , rs . getString ( 9 ) ) ; list . add ( new ProduktBatchKompDTO ( rs . getInt ( 1 ) , raavareBatch , rs . getDouble ( 3 ) , rs . getDouble ( 4 ) ) ) ; } } catch ( SQLException e ) { throw new DALException ( e ) ; } return list ; }
va	4	public static java . util . Date toUtilDateFromStrDateByFormat ( String p_strDate , String p_format ) throws ParseException { java . util . Date l_date = null ; java . text . DateFormat df = new java . text . SimpleDateFormat ( p_format ) ; if ( p_strDate != null && ( ! "" . equals ( p_strDate ) ) && p_format != null && ( ! "" . equals ( p_format ) ) ) { l_date = df . parse ( p_strDate ) ; } return l_date ; }
va	0	@ Override public double calculateDiscount ( double price , int qty ) { return ( qty * dollarAmt ) ; }
va	9X	private boolean r_prelude ( ) { int v_1 ; int v_2 ; int v_3 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { golab2 : while ( true ) { v_2 = cursor ; lab3 : do { if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } bra = cursor ; lab4 : do { v_3 = cursor ; lab5 : do { if ( ! ( eq_s ( 1 , "u" ) ) ) { break lab5 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab5 ; } slice_from ( "U" ) ; break lab4 ; } while ( false ) ; cursor = v_3 ; if ( ! ( eq_s ( 1 , "i" ) ) ) { break lab3 ; } ket = cursor ; if ( ! ( in_grouping ( g_v , 97 , 259 ) ) ) { break lab3 ; } slice_from ( "I" ) ; } while ( false ) ; cursor = v_2 ; break golab2 ; } while ( false ) ; cursor = v_2 ; if ( cursor >= limit ) { break lab1 ; } cursor ++ ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
va	8	@ Override public synchronized Object getValueAt ( int rowIndex , int columnIndex ) { Utente utente = getRow ( rowIndex ) ; switch ( columnIndex ) { case 0 : return utente . getId ( ) ; case 1 : return utente . nome ; case 2 : return utente . cognome ; case 3 : return utente . userName ; case 4 : { if ( utente . getUserType ( ) == Utente . ADMIN ) return "Admin" ; if ( utente . getUserType ( ) == Utente . CLIENTE ) return "Cliente" ; if ( utente . getUserType ( ) == Utente . OPERATORE ) return "Operatore" ; } default : return null ; } }
va	5	public Component getTableCellRendererComponent ( JTable table , Object val , boolean sel , boolean foc , int r , int c ) { JLabel label ; if ( val == Attendance . PRESENT ) label = new JLabel ( new ImageIcon ( check_icon ) ) ; else if ( val == Attendance . ABSENT ) label = new JLabel ( "-" , SwingConstants . CENTER ) ; else if ( val instanceof BidCounter ) label = new BidLabel ( ( BidCounter ) val ) ; else if ( val instanceof Player ) label = new JLabel ( val . toString ( ) , SwingConstants . LEFT ) ; else label = new JLabel ( val . toString ( ) , SwingConstants . CENTER ) ; label . setFont ( table . getFont ( ) ) ; if ( sel ) { label . setOpaque ( true ) ; label . setBackground ( SystemColor . textHighlight ) ; label . setForeground ( SystemColor . textHighlightText ) ; } return label ; }
va	3	public static boolean checkFileSizeExist ( String fn , long size ) { File file = new File ( fn ) ; if ( file . exists ( ) == true && file . isFile ( ) && file . length ( ) == size ) return true ; else return false ; }
va	7	public FeatureVector createCC2FeatureVector ( DependencyInstance inst , int arg , int head , int child ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] pos = inst . postagids ; int [ ] word = inst . formids ; int [ ] posA = inst . cpostagids ; int [ ] lemma = inst . lemmaids != null ? inst . lemmaids : inst . formids ; int [ ] [ ] feats = inst . featids ; int CP = pos [ arg ] ; int CW = word [ arg ] ; int HC = posA [ head ] ; int HL = lemma [ head ] ; int AC = posA [ child ] ; int AL = lemma [ child ] ; long code = 0 ; code = createArcCodePPP ( CC_CP_HC_AC , CP , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodeWWP ( CC_CP_HL_AL , HL , AL , CP ) ; addArcFeature ( code , fv ) ; code = createArcCodeWPP ( CC_CW_HC_AC , CW , HC , AC ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , pos [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodePP ( HP_MP , posA [ head ] , posA [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( HW_MP , lemma [ head ] , pos [ child ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWP ( MW_HP , lemma [ child ] , pos [ head ] ) ; addArcFeature ( code , fv ) ; code = createArcCodeWW ( HW_MW , lemma [ head ] , lemma [ child ] ) ; addArcFeature ( code , fv ) ; if ( feats [ head ] != null && feats [ child ] != null ) { for ( int fh = 0 ; fh < feats [ head ] . length ; ++ fh ) { if ( feats [ head ] [ fh ] <= 0 ) continue ; for ( int fc = 0 ; fc < feats [ child ] . length ; ++ fc ) { if ( feats [ child ] [ fc ] <= 0 ) continue ; int IDH = feats [ head ] [ fh ] ; int IDM = feats [ child ] [ fc ] ; code = createArcCodePP ( HP_MP , IDH , IDM ) ; addArcFeature ( code , fv ) ; } } } return fv ; }
va	6	public static String getCommonPrefix ( Automaton a ) { if ( a . isSingleton ( ) ) return a . singleton ; StringBuilder b = new StringBuilder ( ) ; HashSet < State > visited = new HashSet < State > ( ) ; State s = a . initial ; boolean done ; do { done = true ; visited . add ( s ) ; if ( ! s . accept && s . transitions . size ( ) == 1 ) { Transition t = s . transitions . iterator ( ) . next ( ) ; if ( t . min == t . max && ! visited . contains ( t . to ) ) { b . append ( t . min ) ; s = t . to ; done = false ; } } } while ( ! done ) ; return b . toString ( ) ; }
va	3	public void updateScoreWithEmptyProbList ( long submissionId , long questId ) { PreparedStatement statement = null ; Connection connection = null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Updating the score of an user in a questionnaire: " + questId ) ; } try { if ( logger . isDebugEnabled ( ) ) { logger . debug ( UPDATE_QUEST_SCORE_WITH_EMPTY_PROBLEM_LIST ) ; } connection = Connector . getConnection ( ) ; statement = connection . prepareStatement ( UPDATE_QUEST_SCORE_WITH_EMPTY_PROBLEM_LIST ) ; statement . setLong ( 1 , submissionId ) ; statement . setLong ( 2 , questId ) ; DeadLockHandler . executeUpdate ( statement ) ; } catch ( SQLException e ) { logger . error ( e . getMessage ( ) , e ) ; } finally { ResourcesUtil . release ( null , statement , connection ) ; } }
va	2	public T first ( UnaryFunction < T , boolean > predicate ) { while ( hasNext ( ) ) { final T value = next ( ) ; if ( predicate . invoke ( value ) ) { return value ; } } throw new NoSuchElementException ( ) ; }
va	9X	@ Override public void run ( ) { String line = null ; while ( true ) { try { line = readLine ( ) ; if ( line . startsWith ( EGame . START . toString ( ) ) ) controller . setPlayer ( Integer . parseInt ( line . substring ( EGame . START . toString ( ) . length ( ) ) ) == 1 ? EPlayer . P1 : EPlayer . P2 ) ; else if ( line . startsWith ( EGame . REQUEST_TURN . toString ( ) ) ) { new RequestTurn ( ) . start ( ) ; } else if ( line . startsWith ( EGame . REQUEST_CHOICE . toString ( ) ) ) { new RequestChoice ( ) . start ( ) ; } else if ( line . startsWith ( EGame . OTHER_TURN . toString ( ) ) ) controller . addTurn ( new Turn ( ) . fromString ( line . substring ( EGame . OTHER_TURN . toString ( ) . length ( ) ) ) ) ; else if ( line . startsWith ( EGame . OTHER_CHOICE . toString ( ) ) ) controller . addChoice ( Integer . parseInt ( line . substring ( EGame . OTHER_CHOICE . toString ( ) . length ( ) ) ) ) ; else if ( line . startsWith ( EGame . FINISHED . toString ( ) ) ) { break ; } else if ( line . startsWith ( EGame . INTERRUPTED . toString ( ) ) ) { break ; } } catch ( InterruptedException e ) { break ; } } controller . toLobby ( ) ; }
va	3	private void drawQuitButton ( ) { Box tempBox = new Box ( BoxLayout . X_AXIS ) ; statBox . add ( tempBox ) ; quit = new KulButton ( s ( "quit" ) ) ; quit . setPreferredSize ( new Dimension ( 140 , 50 ) ) ; quit . setMaximumSize ( new Dimension ( 140 , 50 ) ) ; quit . setForeground ( Color . WHITE ) ; quit . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseClicked ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) && ! bestScorePanel . isActive ( ) ) { String [ ] options = { s ( "yes" ) , s ( "no" ) } ; int choice = JOptionPane . showOptionDialog ( MainPanel . this , s ( "quitConfirm" ) , s ( "quit" ) , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE , null , options , 0 ) ; if ( choice == JOptionPane . OK_OPTION ) { main . Main . closeWindow ( ) ; } } } } ) ; tempBox . add ( quit ) ; }
va	3	@ Override protected void onButtonReleased ( GuiButton button ) { if ( button . id == 0 ) { this . parent . setBoard ( this . board ) ; GuiScreen . setGui ( this . parent ) ; } else if ( button . id == 1 ) { this . selectPage ( this . page - 1 ) ; } else if ( button . id == 2 ) { this . selectPage ( this . page + 1 ) ; } else { this . select ( button . id - 3 ) ; } }
va	1	public void setPanelEnabled ( boolean enabled ) { if ( ! enabled ) { dimensionGroup . clearSelection ( ) ; clearDimensionSelection . setEnabled ( false ) ; } d1 . setEnabled ( enabled ) ; d2 . setEnabled ( enabled ) ; d3 . setEnabled ( enabled ) ; d4 . setEnabled ( enabled ) ; odno . setEnabled ( enabled ) ; mnogo . setEnabled ( enabled ) ; malo . setEnabled ( enabled ) ; indi . setEnabled ( enabled ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ListaObjetos . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { ListaObjetos dialog = new ListaObjetos ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	6	void checkNotLinked ( ) { if ( min != null && min . isLinkedDeep ( ) || pref != null && pref . isLinkedDeep ( ) || max != null && max . isLinkedDeep ( ) ) throw new IllegalArgumentException ( "Size may not contain links" ) ; }
va	2	public String pedidoPorCliente ( Cliente cliente ) { String retorno = "" ; for ( Pedido p : lista ) { if ( p . getCliente ( ) . getCodigo ( ) == cliente . getCodigo ( ) ) retorno += p . toString ( ) ; } return retorno ; }
va	2	public void insert ( Object value , int index ) { int space = index ; while ( rawget ( space ) != null ) space ++ ; while ( space != index ) rawset ( space , rawget ( -- space ) ) ; rawset ( space , value ) ; }
va	1	private Request getBaseRequest ( Iterator < String > titles ) { try { Request ret = new Request ( BASE ) ; String joinedTitles = combineStrings ( titles , 50 ) ; ret . addQuery ( TITLES_KEY , joinedTitles ) ; return ret ; } catch ( MalformedURLException impossible ) { impossible . printStackTrace ( ) ; return null ; } }
va	4	@ Override public boolean equals ( Object that ) { if ( that == this ) return true ; if ( that == null || ! getClass ( ) . equals ( that . getClass ( ) ) ) return false ; Row other = ( Row ) that ; return option . equals ( other . option ) && description . equals ( other . description ) ; }
va	4	private AVLNode < E > verificationRight ( AVLNode < E > pnodo ) { switch ( pnodo . getBalance ( ) ) { case 0 : pnodo . setBalance ( 1 ) ; break ; case - 1 : _increase = false ; pnodo . setBalance ( 0 ) ; case 1 : AVLNode < E > right = pnodo . getRight ( ) ; if ( right . getBalance ( ) == 1 ) { pnodo = rotationRightRight ( pnodo ) ; } else { pnodo = rotationRightLeft ( pnodo ) ; } _increase = false ; break ; } return pnodo ; }
va	4	private void addContent ( ) { ScheduleDAO sdao = new ScheduleDAO ( db . connection ) ; for ( String day : StaticRes . WEEK_DAY_LIST ) { List < Schedule > list = sdao . getScheduleByDayList ( day ) ; TableModel model = new ScheduleTableModel ( list ) ; table = new JTable ( model ) ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . getColumnModel ( ) . getColumn ( 0 ) . setPreferredWidth ( 100 ) ; table . getColumnModel ( ) . getColumn ( 1 ) . setPreferredWidth ( 17 ) ; table . setRowHeight ( 20 ) ; table . addMouseListener ( new java . awt . event . MouseAdapter ( ) { @ Override public void mouseClicked ( java . awt . event . MouseEvent evt ) { if ( evt . getClickCount ( ) == 2 && evt . getButton ( ) == MouseEvent . BUTTON1 ) { int row = ( ( JTable ) evt . getSource ( ) ) . rowAtPoint ( evt . getPoint ( ) ) ; ; if ( row >= 0 ) { Schedule schedule = ( Schedule ) ( ( JTable ) evt . getSource ( ) ) . getValueAt ( row , - 1 ) ; Teacher teacher = ( Teacher ) cbTeacher . getSelectedItem ( ) ; submit ( schedule , teacher ) ; } } } } ) ; tabbedPane . addTab ( day , new JScrollPane ( table ) ) ; } }
va	3	private void checkBoxCollisions ( ) { for ( ImageView r : model . getBoxes ( ) ) { if ( r . isVisible ( ) && ball . intersects ( r . getBoundsInParent ( ) ) ) { model . getBoxesLeft ( ) . set ( model . getBoxesLeft ( ) . get ( ) - 1 ) ; r . setVisible ( false ) ; } } }
va	6	@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj == null || obj . getClass ( ) != this . getClass ( ) ) { return false ; } WordPOSKey myWordPOSKey = ( WordPOSKey ) obj ; boolean case1 = ( this . word == null ) ? myWordPOSKey . getWord ( ) == null : this . word . equals ( myWordPOSKey . getWord ( ) ) ; boolean case2 = ( this . pos == null ) ? myWordPOSKey . getPOS ( ) == null : this . pos . equals ( myWordPOSKey . getPOS ( ) ) ; return ( case1 && case2 ) ; }
va	2	public void setThresholds ( List < U > thresholds ) throws Exception { if ( thresholds . size ( ) != neurons . size ( ) ) { throw new Exception ( "threshold count doesnt match neuron count in this layer" ) ; } for ( int i = 0 ; i < neurons . size ( ) ; i ++ ) { neurons . get ( i ) . setThreshold ( thresholds . get ( i ) ) ; } }
va	5	public boolean ehEnPassant ( Posicao posicaoPeca , Posicao lado ) { if ( this . espiarPeca ( posicaoPeca ) . getTipoPeca ( ) == TipoPeca . PEAO ) { if ( ! estaForaDoTabuleiro ( lado ) ) if ( this . estaInimigo ( this . espiarPeca ( posicaoPeca ) . getCorJogador ( ) , lado ) ) if ( this . espiarPeca ( lado ) . getTipoPeca ( ) == TipoPeca . PEAO ) { Peao peaoInimigo = ( Peao ) this . espiarPeca ( lado ) ; if ( peaoInimigo . isPodeEnPassant ( ) ) return true ; } } return false ; }
va	5	private void getKeyRange ( BSTNode < Integer , String > node , int key1 , int key2 , SList < Integer > result ) { if ( node != null ) { int key = node . getKey ( ) ; if ( key1 <= key ) getKeyRange ( node . getLeftChild ( ) , key1 , key2 , result ) ; if ( key1 <= key && key <= key2 ) result . addLast ( key ) ; if ( key <= key2 ) getKeyRange ( node . getRightChild ( ) , key1 , key2 , result ) ; } }
va	5	public void inst_main ( String args [ ] ) { int iterations = 1000 ; String options = "" ; if ( args != null && args . length > 0 ) iterations = Integer . parseInt ( args [ 0 ] ) ; if ( args != null && args . length > 1 ) options = args [ 1 ] ; long startTime = System . currentTimeMillis ( ) ; for ( int j = 0 ; j < iterations ; ++ j ) { chainTest ( 100 ) ; projectionTest ( 100 ) ; } long endTime = System . currentTimeMillis ( ) ; total_ms = endTime - startTime ; System . out . println ( "DeltaBlue\tJava\t" + options + "\t" + iterations + "x\t" + ( ( double ) total_ms / iterations ) + " ms" ) ; }
va	0	public void setAddressId ( int value ) { addressId = value ; }
va	0	public StatTracker ( int health , int will , int power , int afinity , int clarity ) { super ( ) ; initialiseComponants ( health , will , afinity , power , clarity ) ; update ( ) ; }
va	3	int pack ( Buffer opb ) { byte [ ] temp = "Xiphophorus libVorbis I 20000508" . getBytes ( ) ; opb . write ( 03 , 8 ) ; opb . write ( _vorbis ) ; opb . write ( temp . length , 32 ) ; opb . write ( temp ) ; opb . write ( comments , 32 ) ; if ( comments != 0 ) { for ( int i = 0 ; i < comments ; i ++ ) { if ( user_comments [ i ] != null ) { opb . write ( comment_lengths [ i ] , 32 ) ; opb . write ( user_comments [ i ] ) ; } else { opb . write ( 0 , 32 ) ; } } } opb . write ( 1 , 1 ) ; return ( 0 ) ; }
va	8	public static void main ( String [ ] args ) { MyStore < Integer > a = new MyStore < Integer > ( ) ; a . add ( 1 ) ; a . add ( 2 ) ; a . add ( 3 ) ; a . add ( 4 ) ; a . add ( 5 ) ; System . out . println ( "a" + a ) ; MyStore < Integer > b = new MyStore < Integer > ( ) ; b . add ( 2 ) ; b . add ( 6 ) ; System . out . println ( "b" + b ) ; int res = b . moveToMe ( a ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; System . out . println ( res ) ; a . add ( 3 ) ; a . add ( 6 ) ; a . add ( 7 ) ; b . add ( 9 ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; MyStore < Integer > result = b . removeAllMatching ( a ) ; System . out . println ( "a" + a ) ; System . out . println ( "b" + b ) ; System . out . println ( "res" + result ) ; MyStore < Integer > c = new MyStore < Integer > ( ) ; c . moveToMe ( b ) ; System . out . println ( "c" + c ) ; System . out . println ( "b" + b ) ; c . moveToMe ( b ) ; System . out . println ( "c" + c ) ; System . out . println ( "b" + b ) ; MyStore < Integer > d = new MyStore < Integer > ( ) ; d . add ( 1 ) ; d . add ( 2 ) ; d . add ( 3 ) ; d . add ( 4 ) ; d . add ( 5 ) ; Iterator < Integer > it = d . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == 3 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; it = d . iterator ( ) ; while ( it . hasNext ( ) ) { Integer val = it . next ( ) ; if ( val == 1 ) { it . remove ( ) ; } if ( val == 2 ) { it . remove ( ) ; } if ( val == 5 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; it = d . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) == 4 ) { it . remove ( ) ; } } System . out . println ( "d" + d ) ; RunnableWithArgs funct = new RunnableWithArgs ( ) { @ Override public void run ( Object args ) { } } ; res = d . addAll ( c , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; res = d . addAll ( a , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; res = d . addAll ( a , funct ) ; System . out . println ( "d" + d ) ; System . out . println ( res ) ; }
va	1	@ Override public int hashCode ( ) { int hash = 0 ; hash += ( id != null ? id . hashCode ( ) : 0 ) ; return hash ; }
va	8	private Component cycle ( Component currentComponent , int delta ) { int index = - 1 ; loop : for ( int i = 0 ; i < m_Components . length ; i ++ ) { Component component = m_Components [ i ] ; for ( Component c = currentComponent ; c != null ; c = c . getParent ( ) ) { if ( component == c ) { index = i ; break loop ; } } } int initialIndex = index ; while ( true ) { int newIndex = indexCycle ( index , delta ) ; if ( newIndex == initialIndex ) { break ; } index = newIndex ; Component component = m_Components [ newIndex ] ; if ( component . isEnabled ( ) && component . isVisible ( ) && component . isFocusable ( ) ) { return component ; } } return currentComponent ; }
va	6	public Object tostring ( Object value ) { if ( value == null ) return "nil" ; if ( value instanceof String ) return ( String ) value ; if ( value instanceof boolean || value instanceof double ) return value . toString ( ) ; if ( isCallable ( value ) ) return "function: " + System . identityHashCode ( value ) ; Object meta = getMetaValue ( value , "__tostring" ) ; if ( meta != null ) return call ( meta , value ) ; return value . toString ( ) ; }
va	2	public Signals ( int x , int y , int h , String data [ ] ) { this . x = x ; this . y = y ; fontHeight = ( h - 2 ) * 2 / 3 ; newFontHeight = fontHeight ; if ( data != null ) for ( int n = 0 ; n < data . length ; n ++ ) addSignal ( data [ n ] ) ; }
va	4	public void applyTransformation ( int frameId ) { if ( vertexSkin == null ) return ; if ( frameId == - 1 ) return ; Animation animationFrame = Animation . forFrameId ( frameId ) ; if ( animationFrame == null ) return ; Skins skins = animationFrame . animationSkins ; vertexModifierX = 0 ; vertexModifierY = 0 ; vertexModifierZ = 0 ; for ( int stepId = 0 ; stepId < animationFrame . frameCount ; stepId ++ ) { int opcode = animationFrame . opcodeTable [ stepId ] ; transformFrame ( skins . opcodes [ opcode ] , skins . skinList [ opcode ] , animationFrame . transformationX [ stepId ] , animationFrame . transformationY [ stepId ] , animationFrame . transformationZ [ stepId ] ) ; } }
va	7	public static void knapsackBits ( int [ ] weights , int [ ] values , long maxWeight ) { int n = weights . length ; long numSets = ( long ) Math . pow ( 2 , n ) ; long bestSet = 0 ; long bestValue = 0 ; long bestWeight = 0 ; for ( long set = 1 ; set < numSets ; set ++ ) { long weight = 0 ; long value = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( set >> i ) & 1 ) == 1 ) { weight += weights [ i ] ; value += values [ i ] ; } } if ( weight <= maxWeight && value > bestValue ) { bestValue = value ; bestWeight = weight ; bestSet = set ; } } for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( ( bestSet >> i ) & 1 ) == 1 ) { System . out . print ( "[i=" + i + "  w=" + weights [ i ] + "  v=" + values [ i ] + "] " ) ; } } System . out . println ( ) ; System . out . println ( "Weight = " + bestWeight + "  Value = " + bestValue ) ; }
va	9X	private List < String > collectInclude ( ) { List < String > list = new ArrayList < String > ( ) ; if ( javaChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JAVA ) ; } if ( txtChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_TXT ) ; } if ( jtlChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JTL ) ; } if ( cvsChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_CVS ) ; } if ( datChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_DAT ) ; } if ( htmlChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_HTML ) ; } if ( jspChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JSP ) ; } if ( cssChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_CSS ) ; } if ( jsChekBox . isSelected ( ) ) { list . add ( FINAL_WITH_JS ) ; } String udp = includeField . getText ( ) ; if ( udp == null || udp . isEmpty ( ) || udp . equals ( INCLUDE_RECOMMAND_STRING ) ) { } else { for ( String temp : udp . split ( ";" ) ) { list . add ( temp ) ; } } return list ; }
va	7	public int minPathSum ( int [ ] [ ] grid ) { int sum = 0 ; if ( grid == null || grid . length == 0 || grid [ 0 ] . length == 0 ) return sum ; int [ ] prev = new int [ grid [ 0 ] . length ] ; int [ ] curr = new int [ grid [ 0 ] . length ] ; prev [ 0 ] = grid [ 0 ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) prev [ j ] = prev [ j - 1 ] + grid [ 0 ] [ j ] ; for ( int i = 1 ; i < grid . length ; i ++ ) { curr [ 0 ] = prev [ 0 ] + grid [ i ] [ 0 ] ; for ( int j = 1 ; j < grid [ 0 ] . length ; j ++ ) { curr [ j ] = Math . min ( prev [ j ] , curr [ j - 1 ] ) + grid [ i ] [ j ] ; } for ( int j = 0 ; j < grid [ 0 ] . length ; j ++ ) dbg ( curr [ j ] ) ; System . out . println ( ) ; int [ ] tmp = curr ; curr = prev ; prev = tmp ; } return prev [ prev . length - 1 ] ; }
va	0	public boolean containsFamily ( String family ) { return families . contains ( family ) ; }
va	9X	public byte detectMapType ( ) { if ( this . file == null ) return new byte ( null ) . byteValue ( ) ; String fileName = this . file . getName ( ) ; ArrayList < byte > possiblities = new ArrayList < byte > ( ) ; if ( fileName . indexOf ( "map-AirD" ) > - 1 ) possiblities . add ( Channel . TYPE_AIR ) ; if ( fileName . indexOf ( "map-CableD" ) > - 1 ) possiblities . add ( Channel . TYPE_CABLE ) ; if ( fileName . indexOf ( "map-SateD" ) > - 1 ) possiblities . add ( Channel . TYPE_SAT ) ; if ( fileName . endsWith ( "clone.bin" ) ) possiblities . add ( Channel . TYPE_CLONE ) ; if ( possiblities . size ( ) == 1 ) return possiblities . get ( 0 ) . byteValue ( ) ; if ( possiblities . size ( ) == 0 ) { possiblities . add ( Channel . TYPE_AIR ) ; possiblities . add ( Channel . TYPE_CABLE ) ; possiblities . add ( Channel . TYPE_SAT ) ; possiblities . add ( Channel . TYPE_CLONE ) ; } HashMap < byte , String > captions = new HashMap < byte , String > ( 4 ) ; captions . put ( Channel . TYPE_AIR , "Air" ) ; captions . put ( Channel . TYPE_CABLE , "Cable" ) ; captions . put ( Channel . TYPE_SAT , "Satellite" ) ; captions . put ( Channel . TYPE_CLONE , "Clone File" ) ; String [ ] choices = new String [ possiblities . size ( ) ] ; for ( byte b : possiblities ) { choices [ possiblities . indexOf ( b ) ] = captions . get ( b ) ; } String chosenType = ( String ) JOptionPane . showInputDialog ( null , "Could not detect correct file type. Please choose the right one:" , "File Type" , JOptionPane . WARNING_MESSAGE , null , choices , choices [ 0 ] ) ; if ( chosenType != null && chosenType . length ( ) > 0 ) { for ( Map . Entry < byte , String > entry : captions . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( chosenType ) ) return ( ( byte ) entry . getKey ( ) ) . byteValue ( ) ; } } return new byte ( null ) . byteValue ( ) ; }
va	1	public void loadData ( DadesHotel hotel ) { TitledBorder leftBorder = BorderFactory . createTitledBorder ( hotel . nom ) ; leftBorder . setTitleJustification ( TitledBorder . LEFT ) ; this . setBorder ( leftBorder ) ; nomHotel = hotel . nom ; hotelDescriptionLabel . setText ( hotel . desc ) ; DefaultListModel model = new DefaultListModel ( ) ; for ( DadesHabitacio hab : hotel . habs ) { String dada = hab . tipusHab + " (" + hab . preu + "\u20AC) - " + hab . numeroDisp + " disponibles" ; model . addElement ( dada ) ; nomsTipus . add ( hab . tipusHab ) ; } tipusHabitacionsList . setModel ( model ) ; }
va	2	public boolean intersects ( AABB aabb ) { final Vector3f h1 = getHalfsize ( ) ; final Vector3f h2 = aabb . getHalfsize ( ) ; final Vector3f p1 = getPosition ( ) ; final Vector3f p2 = aabb . getPosition ( ) ; return Math . abs ( p2 . x - p1 . x ) < h2 . x + h1 . x && Math . abs ( p2 . y - p1 . y ) < h2 . y + h1 . y && Math . abs ( p2 . z - p1 . z ) < h2 . z + h1 . z ; }
va	4	public String toString ( ) { String s = "" ; try { s = String . format ( "{%s: id = %s  " , this . getClass ( ) . getSimpleName ( ) , this . getClass ( ) . getSuperclass ( ) . getDeclaredField ( "id" ) . get ( this ) ) ; Field [ ] fields = this . getClass ( ) . getDeclaredFields ( ) ; for ( Field f : fields ) { f . setAccessible ( true ) ; if ( f . getName ( ) . equals ( "serialVersionUID" ) ) continue ; if ( f . getName ( ) . equalsIgnoreCase ( "objects" ) ) continue ; s += String . format ( "%s = %s  " , f . getName ( ) , f . get ( this ) ) ; } s = s . substring ( 0 , s . lastIndexOf ( " " ) ) ; s += "}" ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return s ; }
va	4	@ Override public boolean parseField ( String name , String value ) { if ( super . parseField ( name , value ) ) { return true ; } if ( name != null && value != null ) { PeripheralFieldHandler handler = EnumUtils . lookup ( PeripheralFieldHandler . class , name ) ; if ( handler != null ) { return handler . handle ( device , value ) ; } else { return false ; } } return false ; }
va	7	@ Override public JsonElement serialize ( Criteria criteria , Type type , JsonSerializationContext jsc ) { JsonObject json = new JsonObject ( ) ; json . addProperty ( "field" , criteria . getField ( ) . ordinal ( ) + 1 ) ; try { String operator = criteria . getOperator ( ) . toString ( ) ; if ( operator . equals ( Operators . StartWith . toString ( ) ) ) operator = "START%20WITH" ; else if ( operator . equals ( Operators . Equals . toString ( ) ) ) operator = URLEncoder . encode ( "=" , "UTF-8" ) ; else if ( operator . equals ( Operators . GreaterThan . toString ( ) ) ) operator = URLEncoder . encode ( ">" , "UTF-8" ) ; else if ( operator . equals ( Operators . GreaterThanEqual . toString ( ) ) ) operator = URLEncoder . encode ( ">=" , "UTF-8" ) ; else if ( operator . equals ( Operators . LessThan . toString ( ) ) ) operator = URLEncoder . encode ( "<" , "UTF-8" ) ; else if ( operator . equals ( Operators . LessThanEqual . toString ( ) ) ) operator = URLEncoder . encode ( "<=" , "UTF-8" ) ; json . addProperty ( "operator" , operator ) ; } catch ( UnsupportedEncodingException ex ) { Logger . getLogger ( CriteriaSerializer . class . getName ( ) ) . log ( Level . SEVERE , "Wrong encoding scheme!" , ex ) ; } json . addProperty ( "value" , criteria . getValue ( ) ) ; return json ; }
va	1	public static byte [ ] decompress ( byte [ ] data ) throws IOException , DataFormatException { Inflater inflater = new Inflater ( ) ; inflater . setInput ( data ) ; inflater . finished ( ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( data . length ) ; byte [ ] buffer = new byte [ 1024 ] ; while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; outputStream . write ( buffer , 0 , count ) ; } outputStream . close ( ) ; byte [ ] output = outputStream . toByteArray ( ) ; inflater . end ( ) ; return output ; }
va	6	private static int outcode ( double pX , double pY , double rectX , double rectY , double rectWidth , double rectHeight ) { int out = 0 ; if ( rectWidth <= 0 ) { out |= OUT_LEFT | OUT_RIGHT ; } else if ( pX < rectX ) { out |= OUT_LEFT ; } else if ( pX > rectX + rectWidth ) { out |= OUT_RIGHT ; } if ( rectHeight <= 0 ) { out |= OUT_TOP | OUT_BOTTOM ; } else if ( pY < rectY ) { out |= OUT_TOP ; } else if ( pY > rectY + rectHeight ) { out |= OUT_BOTTOM ; } return out ; }
va	4	@ Override public synchronized boolean add ( Plugin plugin ) { Iterator < Plugin > iter = this . iterator ( ) ; while ( iter . hasNext ( ) ) { if ( iter . next ( ) . getName ( ) . equals ( plugin . getName ( ) ) ) { return false ; } } plugin . addPropertyChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . equals ( "plugin_files_compared" ) ) { int pos = PluginList . this . indexOf ( evt . getNewValue ( ) ) ; propertyChange . firePropertyChange ( "plugin_status_changed" , null , pos ) ; } } } ) ; if ( messageDatabase != null ) { plugin . setMessageDatabase ( messageDatabase ) ; } return super . add ( plugin ) ; }
va	6	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PosListaPrecioEntityPK that = ( PosListaPrecioEntityPK ) o ; if ( pcaIdElemento != that . pcaIdElemento ) return false ; if ( pcaPosId != null ? ! pcaPosId . equals ( that . pcaPosId ) : that . pcaPosId != null ) return false ; return true ; }
va	1	public int setRib ( String rib ) { if ( rib . length ( ) > ConfigGlobale . longueurRIB ) { return - 1 ; } else { this . rib = rib ; return 0 ; } }
va	7	public static BufferedImage getImage ( Card card ) { int rowNumber ; int colNumber ; if ( card . getSuit ( ) . equals ( Suit . CLUBS ) ) { rowNumber = 0 ; } else if ( card . getSuit ( ) . equals ( Suit . DIAMONDS ) ) { rowNumber = 1 ; } else if ( card . getSuit ( ) . equals ( Suit . HEARTS ) ) { rowNumber = 2 ; } else if ( card . getSuit ( ) . equals ( Suit . SPADES ) ) { rowNumber = 3 ; } else { rowNumber = 4 ; } if ( card . getCardValue ( ) . equals ( CardValue . ACE ) ) { colNumber = 0 ; } else if ( card . getCardValue ( ) . equals ( CardValue . JOKER ) ) { if ( card . getSuit ( ) . equals ( Suit . BLACK ) ) { colNumber = 0 ; } else { colNumber = 1 ; } } else { colNumber = card . getCardValue ( ) . getValue ( ) ; } return ImageCard . getInstance ( ) . image . getSubimage ( colNumber * ImageCard . getInstance ( ) . getCardWidth ( ) , rowNumber * ImageCard . getInstance ( ) . getCardHeight ( ) , ImageCard . getInstance ( ) . getCardWidth ( ) , ImageCard . getInstance ( ) . getCardHeight ( ) ) ; }
va	2	public long inserir ( InstituicaoCooperadora instituicaocooperadora ) throws Exception { String sql = "INSERT INTO instituicaocooperadora(nome) VALUES (?)" ; long idGerado = 0 ; try { PreparedStatement stmt = ConnectionFactory . getConnection ( ) . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; stmt . setString ( 1 , instituicaocooperadora . getNome ( ) ) ; stmt . executeUpdate ( ) ; ResultSet rs = stmt . getGeneratedKeys ( ) ; if ( rs . next ( ) ) { idGerado = rs . getLong ( 1 ) ; } } catch ( SQLException e ) { throw e ; } return idGerado ; }
va	1	private static char [ ] reverse ( char [ ] a , int len ) { char [ ] b = new char [ len ] ; for ( int i = len - 1 , j = 0 ; i >= 0 ; i -- , j ++ ) { b [ j ] = a [ i ] ; } return b ; }
va	2	public int generarBoleto ( int sucursal_id , int usuario_id ) { Connection cn = conexion . Conectar ( ) ; PreparedStatement pst ; PreparedStatement pst2 ; ResultSet rs ; int idObtenido = 0 ; String queryInsertar = "INSERT INTO boletos(sucursal_id  usuario_id) VALUES (" + sucursal_id + " " + usuario_id + ")" ; String queryObtenerId = "SELECT max(boleto_id) as id FROM boletos" ; try { pst = cn . prepareStatement ( queryInsertar ) ; pst2 = cn . prepareStatement ( queryObtenerId ) ; pst . executeUpdate ( ) ; rs = pst2 . executeQuery ( ) ; while ( rs . next ( ) ) { idObtenido = rs . getInt ( "id" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , "Error al generar el boleto: " + ex ) ; } return idObtenido ; }
va	1	private static void assertNotNull ( Object o ) { if ( o == null ) { throw new RuntimeException ( "expected no null value" ) ; } }
va	6	public T getEdge ( int i , int j ) throws IllegalArgumentException { if ( i < 0 || i >= numberOfVertices || j < 0 || j >= numberOfVertices ) { String errorMessage = "Allows vertex indizes are 0.." + ( numberOfVertices - 1 ) + "." ; throw new IllegalArgumentException ( errorMessage ) ; } for ( T e : adjacencyList [ i ] ) { if ( e . getTarget ( ) == j ) { return e ; } } return null ; }
va	9X	private static StringBuilder build ( final StringBuilder result , final Object subject , final int indent ) { if ( null == subject ) return result . append ( null ) ; else if ( subject . getClass ( ) . isArray ( ) ) return buildIterable ( result , new ArrayIterator ( subject ) , indent ) ; else if ( subject instanceof Map < ? , ? > ) return buildIterable ( result , ( ( Map < ? , ? > ) subject ) . entrySet ( ) . iterator ( ) , indent ) ; else if ( subject instanceof Iterable < ? > ) return buildIterable ( result , ( ( Iterable < ? > ) subject ) . iterator ( ) , indent ) ; else if ( subject instanceof Map . Entry < ? , ? > ) return buildEntry ( result , ( Map . Entry < ? , ? > ) subject , indent ) ; else return result . append ( subject . toString ( ) ) ; }
va	1	public void run ( ) { if ( program != null ) { program . execute ( this ) ; } else { defaultProgram ( ) ; } }
va	6	public Builder mergeFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { com . google . protobuf . UnknownFieldSet . Builder unknownFields = com . google . protobuf . UnknownFieldSet . newBuilder ( this . getUnknownFields ( ) ) ; while ( true ) { int tag = input . readTag ( ) ; switch ( tag ) { case 0 : this . setUnknownFields ( unknownFields . build ( ) ) ; onChanged ( ) ; return this ; default : { if ( ! parseUnknownField ( input , unknownFields , extensionRegistry , tag ) ) { this . setUnknownFields ( unknownFields . build ( ) ) ; onChanged ( ) ; return this ; } break ; } case 10 : { bitField0_ |= 00000001 ; type_ = input . readBytes ( ) ; break ; } case 16 : { bitField0_ |= 00000002 ; gov_ = input . readInt32 ( ) ; break ; } case 24 : { bitField0_ |= 00000004 ; dep_ = input . readInt32 ( ) ; break ; } } } }
va	2	private static List < String > readStringSubKeys ( Preferences root , int hkey , String key ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { List < String > results = new ArrayList < String > ( ) ; int [ ] handles = ( int [ ] ) regOpenKey . invoke ( root , new Object [ ] { new Integer ( hkey ) , toCstr ( key ) , new Integer ( KEY_READ ) } ) ; if ( handles [ 1 ] != REG_SUCCESS ) { return null ; } int [ ] info = ( int [ ] ) regQueryInfoKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; int count = info [ 0 ] ; int maxlen = info [ 3 ] ; for ( int index = 0 ; index < count ; index ++ ) { byte [ ] name = ( byte [ ] ) regEnumKeyEx . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) , new Integer ( index ) , new Integer ( maxlen + 1 ) } ) ; results . add ( new String ( name ) . trim ( ) ) ; } regCloseKey . invoke ( root , new Object [ ] { new Integer ( handles [ 0 ] ) } ) ; return results ; }
va	3	private void checkConvexCut ( Point [ ] points , Point a , Point n ) { Point [ ] [ ] hullp = convexCut ( convexHull ( points ) , a , n ) ; System . out . println ( Arrays . deepToString ( hullp ) ) ; assertTrue ( isConvex ( hullp ) ) ; for ( Point p : points ) { int type = isInConvex ( p , hullp ) ; double d = a . subtract ( p ) . . ( n ) ; if ( approxEquals ( d , 0 ) ) assertTrue ( type == 2 ) ; else if ( d > 0 ) assertTrue ( type != 0 ) ; else assertTrue ( type == 0 ) ; } }
va	1	public final void update ( Graphics g ) { if ( graphics == null ) graphics = g ; shouldClearScreen = true ; raiseWelcomeScreen ( ) ; }
va	9X	public Matrix solve ( Matrix B ) { if ( B . getRowDimension ( ) != m ) { throw new IllegalArgumentException ( "Matrix row dimensions must agree." ) ; } if ( ! this . isNonsingular ( ) ) { throw new RuntimeException ( "Matrix is singular." ) ; } int nx = B . getColumnDimension ( ) ; Matrix Xmat = B . getMatrix ( piv , 0 , nx - 1 ) ; double [ ] [ ] X = Xmat . getArray ( ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = k + 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ k ] [ j ] /= LU [ k ] [ k ] ; } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { X [ i ] [ j ] -= X [ k ] [ j ] * LU [ i ] [ k ] ; } } } return Xmat ; }
va	6	public static boolean clicked ( int button ) { if ( button == MouseEvent . BUTTON1 ) return m1 && ! oldm1 ; else if ( button == MouseEvent . BUTTON2 ) return m2 && ! oldm2 ; else if ( button == MouseEvent . BUTTON3 ) return m3 && ! oldm3 ; else return false ; }
va	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; HostRef other = ( HostRef ) obj ; if ( hostId == null ) { if ( other . hostId != null ) return false ; } else if ( ! hostId . equals ( other . hostId ) ) return false ; return true ; }
va	0	protected void start ( ) { start ( null ) ; }
va	6	public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; FileImageSource other = ( FileImageSource ) obj ; if ( file == null ) { if ( other . file != null ) return false ; } else if ( ! file . equals ( other . file ) ) return false ; return true ; }
va	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Service other = ( Service ) obj ; if ( clusterRef == null ) { if ( other . clusterRef != null ) return false ; } else if ( ! clusterRef . equals ( other . clusterRef ) ) return false ; if ( name == null ) { if ( other . name != null ) return false ; } else if ( ! name . equals ( other . name ) ) return false ; if ( serviceState != other . serviceState ) return false ; if ( type != other . type ) return false ; return true ; }
va	7	public FeatureVector createLabeledArcFeatures ( DependencyInstance inst , int h , int c , int type ) { int attDist = getBinnedDistance ( h - c ) ; FeatureVector fv = new FeatureVector ( numLabeledArcFeats ) ; addBasic1OFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OPosFeatures ( fv , inst , h , c , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . postagids [ h ] , inst . formids [ c ] , inst . postagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . postagids [ h ] , inst . lemmaids [ c ] , inst . postagids [ c ] , attDist , type ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . cpostagids [ h ] , inst . formids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . cpostagids [ h ] , inst . lemmaids [ c ] , inst . cpostagids [ c ] , attDist , type ) ; if ( inst . featids [ h ] != null && inst . featids [ c ] != null ) { for ( int i = 0 , N = inst . featids [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = inst . featids [ c ] . length ; j < M ; ++ j ) { addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . featids [ h ] [ i ] , inst . formids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; if ( inst . lemmas != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . featids [ h ] [ i ] , inst . lemmaids [ c ] , inst . featids [ c ] [ j ] , attDist , type ) ; } } return fv ; }
va	7	public String getPopulationDetails ( Field field ) { StringBuffer buffer = new StringBuffer ( ) ; if ( ! countsValid ) { generateCounts ( field ) ; } for ( class key : counters . keySet ( ) ) { Counter info = counters . get ( key ) ; int stringLength = info . getName ( ) . length ( ) ; buffer . append ( info . getName ( ) . substring ( 10 , stringLength ) ) ; buffer . append ( ": " ) ; buffer . append ( info . getCount ( ) ) ; buffer . append (   ) ; if ( info . getName ( ) . equals ( "src.model.Fox" ) ) { foxCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Bear" ) ) { bearCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Rabbit" ) ) { rabbitCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Wolf" ) ) { wolfCount = info . getCount ( ) ; } if ( info . getName ( ) . equals ( "src.model.Grass" ) ) { grassCount = info . getCount ( ) ; } } return buffer . toString ( ) ; }
va	0	public String getStr ( ) { return str ; }
va	3	static Header fromString ( String stringHeader ) throws MalformedRequestException { String [ ] parts = stringHeader . split ( ": " ) ; if ( parts . length != 2 ) { throw new MalformedRequestException ( "unknown format of Header [" + stringHeader + "]" ) ; } for ( HTTPHeader m : HTTPHeader . values ( ) ) { if ( stringHeader . startsWith ( m . headerText ) ) { return new Header ( m , parts [ 1 ] ) ; } } return new Header ( HTTPHeader . UnknownHeader , parts [ 1 ] ) ; }
va	7	void funcargs ( ExpDesc f ) { FuncState fs = this . fs ; ExpDesc args = new ExpDesc ( ) ; int base , nparams ; int line = this . linenumber ; switch ( this . t . token ) { case ( : { if ( line != this . lastline ) this . syntaxerror ( "ambiguous syntax (function call x new statement)" ) ; this . next ( ) ; if ( this . t . token == ) ) args . k = VVOID ; else { this . explist1 ( args ) ; fs . setmultret ( args ) ; } this . check_match ( ) , ( , line ) ; break ; } case { : { this . constructor ( args ) ; break ; } case TK_STRING : { this . codestring ( args , this . t . ts ) ; this . next ( ) ; break ; } default : { this . syntaxerror ( "function arguments expected" ) ; return ; } } FuncState . _assert ( f . k == VNONRELOC ) ; base = f . info ; if ( hasmultret ( args . k ) ) nparams = FuncState . LUA_MULTRET ; else { if ( args . k != VVOID ) fs . exp2nextreg ( args ) ; nparams = fs . freereg - ( base + 1 ) ; } f . init ( VCALL , fs . codeABC ( FuncState . OP_CALL , base , nparams + 1 , 2 ) ) ; fs . fixline ( line ) ; fs . freereg = base + 1 ; }
va	9X	private static Expression parseExpression ( ProgramNode program , Scanner s , CodeParser cp , PrefixProcessor p ) { if ( Parser . gobble ( "fuelLeft" , s ) ) return new SensorNode ( SensorType . FUELLEFT ) ; else if ( Parser . gobble ( "oppLR" , s ) ) return new SensorNode ( SensorType . OPPLR ) ; else if ( Parser . gobble ( "oppFB" , s ) ) return new SensorNode ( SensorType . OPPFB ) ; else if ( Parser . gobble ( "numBarrels" , s ) ) return new SensorNode ( SensorType . NUMBARRELS ) ; else if ( Parser . gobble ( "barrelLR" , s ) ) { SensorNode sensor = new SensorNode ( SensorType . BARRELLR ) ; if ( Parser . gobble ( Parser . OPENPAREN , s ) ) { sensor . setExpression ( parseExpression ( program , s , cp , p ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "Missing closing parenthesis on barrelLR with args" , s ) ; } return sensor ; } else if ( Parser . gobble ( "barrelFB" , s ) ) { SensorNode sensor = new SensorNode ( SensorType . BARRELFB ) ; if ( Parser . gobble ( Parser . OPENPAREN , s ) ) { sensor . setExpression ( parseExpression ( program , s , cp , p ) ) ; if ( ! Parser . gobble ( Parser . CLOSEPAREN , s ) ) Parser . fail ( "Missing closing parenthesis on barrelFB with args" , s ) ; } return sensor ; } else if ( Parser . gobble ( "wallDist" , s ) ) return new SensorNode ( SensorType . WALLDIST ) ; else if ( s . hasNext ( variable ) ) return new VariableNode ( program , s . next ( variable ) ) ; else if ( s . hasNext ( Parser . NUMPAT ) ) return new NumberNode ( double . parseDouble ( s . next ( Parser . NUMPAT ) ) ) ; else return new OperationNode ( ) . parse ( s , cp , p ) ; }
va	3	public void testMapBranch ( ) { Mapping mapping = new Mapping ( ) ; VirtualNode virtualNode = requests . get ( 0 ) . getVirtualNodes ( ) . get ( 0 ) ; VirtualLink virtualLink = ( VirtualLink ) virtualNode . getAttachedLinks ( ) . get ( 0 ) ; VirtualNode virtualDestinyNode = ( VirtualNode ) virtualLink . getNodeAttachedTo ( virtualNode ) ; for ( PhysicalNode physicalNode : substrateNetwork . getHashNodes ( ) . values ( ) ) { if ( ! mapping . isNodeMapped ( virtualNode ) && physicalNode . canHost ( virtualNode ) ) { mapping . addNodeMapping ( virtualNode , physicalNode ) ; } } assertTrue ( mapper . mapBranch ( virtualNode , virtualDestinyNode , virtualLink , substrateNetwork , mapping ) ) ; }
va	0	public void setCodTipoPagamento ( Integer codTipoPagamento ) { this . codTipoPagamento = codTipoPagamento ; }
va	9X	private String getSelect ( List < String > tables , Map < String , Object > params ) { if ( tables . size ( ) < 1 ) { return "ERROR: The tables list is empty" ; } StringBuffer sql = new StringBuffer ( ) ; sql . append ( "SELECT " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } sql . append ( " FROM " ) ; for ( int i = 0 ; i < tables . size ( ) ; i ++ ) { String table = tables . get ( i ) ; sql . append ( table ) ; sql . append ( " " ) ; sql . append ( table . toLowerCase ( ) ) ; if ( i < tables . size ( ) - 1 ) { sql . append ( "  " ) ; } } if ( params . isEmpty ( ) ) { return sql . toString ( ) ; } sql . append ( " WHERE " ) ; int i = 0 ; for ( String paramName : params . keySet ( ) ) { Object paramValue = params . get ( paramName ) ; sql . append ( paramName ) ; sql . append ( "=" ) ; if ( paramValue instanceof java . sql . Date ) { sql . append ( "'" ) ; sql . append ( paramValue ) ; sql . append ( "'" ) ; } else if ( paramValue instanceof String ) { sql . append ( "\"" ) ; sql . append ( paramValue ) ; sql . append ( "\"" ) ; } else { sql . append ( paramValue ) ; } if ( i < params . size ( ) - 1 ) { sql . append ( " AND " ) ; } i ++ ; } return sql . toString ( ) ; }
va	5	public JSONObject increment ( String key ) throws JSONException { Object value = this . opt ( key ) ; if ( value == null ) { this . put ( key , 1 ) ; } else if ( value instanceof Integer ) { this . put ( key , ( ( Integer ) value ) . intValue ( ) + 1 ) ; } else if ( value instanceof long ) { this . put ( key , ( ( long ) value ) . longValue ( ) + 1 ) ; } else if ( value instanceof double ) { this . put ( key , ( ( double ) value ) . doubleValue ( ) + 1 ) ; } else if ( value instanceof float ) { this . put ( key , ( ( float ) value ) . floatValue ( ) + 1 ) ; } else { throw new JSONException ( "Unable to increment [" + quote ( key ) + "]." ) ; } return this ; }
va	4	public static String nullSafeToString ( long [ ] array ) { if ( array == null ) { return NULL_STRING ; } int length = array . length ; if ( length == 0 ) { return EMPTY_ARRAY ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( i == 0 ) { sb . append ( ARRAY_START ) ; } else { sb . append ( ARRAY_ELEMENT_SEPARATOR ) ; } sb . append ( array [ i ] ) ; } sb . append ( ARRAY_END ) ; return sb . toString ( ) ; }
va	2	public void insertAtEnd ( int element ) { SNode newNode = new SNode ( ) ; newNode . data = element ; if ( HEADER == null ) { HEADER = newNode ; newNode . next = HEADER ; } else { SNode current = HEADER ; while ( current . next != HEADER ) current = current . next ; current . next = newNode ; newNode . next = HEADER ; } }
va	5	public void read_scalefactor ( Bitstream stream , Header header ) { super . read_scalefactor ( stream , header ) ; if ( channel2_allocation != 0 ) { switch ( channel2_scfsi ) { case 0 : channel2_scalefactor1 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor2 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 1 : channel2_scalefactor1 = channel2_scalefactor2 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 2 : channel2_scalefactor1 = channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; case 3 : channel2_scalefactor1 = scalefactors [ stream . get_bits ( 6 ) ] ; channel2_scalefactor2 = channel2_scalefactor3 = scalefactors [ stream . get_bits ( 6 ) ] ; break ; } prepare_sample_reading ( header , channel2_allocation , 1 , channel2_factor , channel2_codelength , channel2_c , channel2_d ) ; } }
va	2	public void removeBogusLegs ( ) { Iterator < Leg > it = legs . iterator ( ) ; while ( it . hasNext ( ) ) { Leg leg = it . next ( ) ; if ( leg . isBogusNonTransitLeg ( ) ) { it . remove ( ) ; } } }
va	4	public static int [ ] swap ( int [ ] a , int i , int j ) { if ( i < 0 || j < 0 || i > a . length || j > a . length ) { throw new IllegalArgumentException ( "Illegal argument!" ) ; } else { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } System . out . println ( "swap : " + QuickSort . toString ( a ) ) ; return a ; }
va	3	public void setNumberType ( int type ) { if ( renderer != null ) { renderer . removeListener ( this ) ; } if ( type == BenoitNumber . DOUBLE_TYPE ) { renderer = new FastDoublesRenderer ( ) ; } else if ( type == BenoitNumber . BIG_TYPE ) { renderer = new BigDecimalRenderer ( ) ; } else { throw new IllegalArgumentException ( "invalid number type" ) ; } numericType = type ; getParameters ( ) . setType ( type ) ; renderer . addListener ( this ) ; fireChange ( RENDERER_CHANGED ) ; }
va	8	Vector < Integer > getNeighboringIndexes ( int index ) { Vector < Integer > result = new Vector < Integer > ( 6 ) ; int row = getRow ( index ) ; int col = getColumn ( index ) ; int offset = getOffset ( row ) ; if ( row < numRows - 1 ) { if ( col + offset > 0 ) { result . add ( getIndex ( row + 1 , col + offset - 1 ) ) ; } if ( col + offset < numColumns - 1 ) { result . add ( getIndex ( row + 1 , col + offset ) ) ; } } if ( col > 0 ) { result . add ( getIndex ( row , col - 1 ) ) ; } if ( col < numColumns - 1 ) { result . add ( getIndex ( row , col + 1 ) ) ; } if ( row > 0 ) { if ( col + offset > 0 ) { result . add ( getIndex ( row - 1 , col + offset - 1 ) ) ; } if ( col + offset < numColumns - 1 ) { result . add ( getIndex ( row - 1 , col + offset ) ) ; } } result . trimToSize ( ) ; return result ; }
va	2	public static String hashcode ( String message ) { String hash = null ; try { MessageDigest cript = MessageDigest . getInstance ( "SHA-1" ) ; cript . reset ( ) ; cript . update ( message . getBytes ( "utf8" ) ) ; hash = new BigInteger ( 1 , cript . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return hash ; }
va	5	public void changeSupplier ( String id , String newSupplier ) { String oldSupplier = getSupplierName ( id ) ; if ( oldSupplier == newSupplier ) { return ; } if ( oldSupplier == null ) { addItem ( id , newSupplier ) ; } if ( suppliers . indexOf ( oldSupplier ) > - 1 ) { int oindex = suppliers . indexOf ( oldSupplier ) ; if ( supplierItems . get ( oindex ) . indexOf ( id ) > - 1 ) { int nindex = supplierItems . get ( oindex ) . indexOf ( id ) ; int addIndex = suppliers . indexOf ( newSupplier ) ; supplierItems . get ( oindex ) . remove ( nindex ) ; if ( addIndex > - 1 ) { supplierItems . get ( addIndex ) . add ( id ) ; } } } }
va	9X	public void helper ( String s , int count ) { if ( count == 3 ) { if ( s . charAt ( 0 ) == 0 && s . length ( ) > 1 ) return ; if ( s . length ( ) > 3 ) { int hh = 0 ; while ( s . length ( ) - hh > 3 ) { if ( s . charAt ( hh ) != 0 ) return ; hh ++ ; } } if ( Integer . parseInt ( s ) > 255 ) return ; else { temp . add ( s ) ; String ss = "" ; for ( int i = 0 ; i < 4 ; i ++ ) { ss = ss + "." + temp . get ( i ) ; } ss = ss . substring ( 1 ) ; ret . add ( ss ) ; temp . remove ( temp . size ( ) - 1 ) ; } } else { for ( int i = 0 ; i < s . length ( ) - 3 + count ; i ++ ) { if ( Integer . parseInt ( s . substring ( 0 , i + 1 ) ) > 255 ) break ; temp . add ( s . substring ( 0 , i + 1 ) ) ; helper ( s . substring ( i + 1 , s . length ( ) ) , count + 1 ) ; temp . remove ( temp . size ( ) - 1 ) ; if ( s . charAt ( 0 ) == 0 ) break ; } } }
va	8	public void actionPerformed ( ActionEvent e ) { if ( e . getSource ( ) == left ) { halign = Alignment . LEFT ; return ; } if ( e . getSource ( ) == center ) { halign = Alignment . CENTER ; return ; } if ( e . getSource ( ) == right ) { halign = Alignment . RIGHT ; return ; } if ( e . getSource ( ) == top ) { valign = Alignment . TOP ; return ; } if ( e . getSource ( ) == middle ) { valign = Alignment . MIDDLE ; return ; } if ( e . getSource ( ) == bottom ) { valign = Alignment . BOTTOM ; return ; } if ( e . getSource ( ) == fButton ) { Font newFont = FontDialog . getFont ( font ) ; if ( newFont == null ) return ; font = newFont ; fButton . setFont ( font ) ; } }
va	7	protected void addPointToHull ( Vertex eyeVtx ) { horizon . clear ( ) ; unclaimed . clear ( ) ; if ( debug ) { System . out . println ( "Adding point: " + eyeVtx . pnt . toString ( ) ) ; System . out . println ( " which is " + eyeVtx . face . distanceToPlane ( eyeVtx . pnt ) + " above face " + eyeVtx . face . getVertexString ( ) ) ; } removePointFromFace ( eyeVtx , eyeVtx . face ) ; calculateHorizon ( eyeVtx . pnt , null , eyeVtx . face , horizon ) ; newFaces . clear ( ) ; addNewFaces ( newFaces , eyeVtx , horizon ) ; for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . VISIBLE ) { while ( doAdjacentMerge ( face , NONCONVEX_WRT_LARGER_FACE ) ) ; } } for ( Face face = newFaces . first ( ) ; face != null ; face = face . next ) { if ( face . mark == Face . NON_CONVEX ) { face . mark = Face . VISIBLE ; while ( doAdjacentMerge ( face , NONCONVEX ) ) ; } } resolveUnclaimedPoints ( newFaces ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ListaDinamica . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new ListaDinamica ( ) . setVisible ( true ) ; } } ) ; }
va	0	public String getDate ( ) { return date ; }
va	8	@ Override public Vector3f [ ] getAllMinAlongDirection ( Vector3f [ ] result , Vector3f dir , int count , float eps ) { if ( count > 0 ) { eps /= dir . length ( ) ; float dotmindir = vertices [ 0 ] . . ( dir ) ; result [ 0 ] . set ( vertices [ 0 ] ) ; int j = 1 ; for ( int i = vertices . length - 1 ; i > 0 ; i -- ) { final float dotshapedir = vertices [ i ] . . ( dir ) ; if ( dotshapedir <= dotmindir ) { if ( dotshapedir <= dotmindir - eps ) { result [ 0 ] . set ( vertices [ i ] ) ; j = 1 ; } else if ( j < count ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } dotmindir = dotshapedir ; } else if ( j < count && dotshapedir - eps <= dotmindir ) { result [ j ] . set ( vertices [ i ] ) ; j ++ ; } } for ( ; j < count ; j ++ ) { result [ j ] . set ( 0 , 0 , 0 ) ; } } return result ; }
va	4	public static Point2 getPositionAfterMovement ( Entity entity ) { switch ( entity . orientation ) { case NORTH : return new Point2 ( entity . position . x , entity . position . y - 1 ) ; case EAST : return new Point2 ( entity . position . x + 1 , entity . position . y ) ; case SOUTH : return new Point2 ( entity . position . x , entity . position . y + 1 ) ; case WEST : return new Point2 ( entity . position . x - 1 , entity . position . y ) ; default : return new Point2 ( entity . position . x , entity . position . y ) ; } }
va	4	public void run ( ) { for ( int i = 0 ; i < 100 ; i ++ ) { try { Thread . sleep ( 10 ) ; } catch ( InterruptedException exception ) { } Integer [ ] snapshot = buffer . snapshot ( ) ; assert snapshot . length > 18 : "Larger trim than expected!: " + snapshot . length ; assert snapshot . length <= 20 : "Buffer is too large: " + snapshot . length ; for ( int j = 0 ; j < snapshot . length ; j ++ ) { if ( snapshot [ j ] == null ) { assert false : "Found uninitialized value in snapshot: " + j + ":\n" + Arrays . toString ( snapshot ) ; } } assert snapshot [ 0 ] < snapshot [ snapshot . length - 1 ] : "Values do not appear to be coming out in order" ; Thread . yield ( ) ; } }
va	8	private void jMenuItem1ActionPerformed ( java . awt . event . ActionEvent evt ) { final String inputValue = JOptionPane . showInputDialog ( "Enter a chatroom name" ) ; final JButton btnClose = new JButton ( "x" ) ; if ( inputValue . isEmpty ( ) ) { JOptionPane . showMessageDialog ( GUI . this , "Please enter a name." , "Input Error" , JOptionPane . WARNING_MESSAGE ) ; } else { try { client . sendJoinChatRoomMessage ( inputValue ) ; } catch ( JMSException e ) { throw new RuntimeException ( e ) ; } ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof ChatRoomUsersMessage ) ) return ; final ChatRoomUsersMessage ulm = ( ChatRoomUsersMessage ) m ; if ( ulm . getChatRoom ( ) . equals ( tabbedPane . getTitleAt ( tabbedPane . getSelectedIndex ( ) ) ) ) { userList . setModel ( new javax . swing . AbstractListModel ( ) { List < String > strings = ulm . getUsers ( ) ; public int getSize ( ) { return strings . size ( ) ; } public Object getElementAt ( int i ) { return strings . get ( i ) ; } } ) ; } } } ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof JoinChatRoomMessage ) ) return ; try { client . sendChatRoomUserListMessage ( inputValue ) ; } catch ( JMSException e ) { throw new RuntimeException ( e ) ; } final JTextArea jta = new JTextArea ( ) ; tabbedPane . addTab ( inputValue , null , jta , null ) ; ChatClientApplicationGUI . addServerMessageListener ( new ServerMessageListener ( ) { public void onMessageReceived ( ChatMessage m ) { if ( ! ( m instanceof ChatTextMessage ) ) return ; final ChatTextMessage ulm = ( ChatTextMessage ) m ; jta . append ( "[" + ulm . getUsername ( ) + "]: " + ulm . getText ( ) + "\n" ) ; } } ) ; int index = tabbedPane . indexOfTab ( inputValue ) ; JPanel pnlTab = new JPanel ( ) ; pnlTab . setOpaque ( false ) ; JLabel lblTitle = new JLabel ( inputValue ) ; pnlTab . add ( lblTitle ) ; pnlTab . add ( btnClose ) ; tabbedPane . setTabComponentAt ( index , pnlTab ) ; btnClose . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnCloseActionPerformed ( evt ) ; } private void btnCloseActionPerformed ( ActionEvent evt ) { Point mousePos = tabbedPane . getMousePosition ( ) ; int mouseX = mousePos . x ; int mouseY = mousePos . y ; int index = tabbedPane . indexAtLocation ( mouseX , mouseY ) ; Component selected = tabbedPane . getComponentAt ( index ) ; if ( selected != null ) { tabbedPane . remove ( selected ) ; } } } ) ; jta . append ( "[System]: Joined " + inputValue + "\n" ) ; ChatClientApplicationGUI . removeServerMessageListener ( this ) ; } } ) ; } }
va	1	@ Override public DataUnit read ( Protocol p , ReadableByteChannel channel ) throws IOException { ReadableByteChannel currentChannel = channel ; DataUnit dataUnit = headerProcessor . read ( p , currentChannel ) ; int totalLength = ProtocolUtil . getTotalLength ( dataUnit , p ) ; if ( totalLength != - 1 ) { int toRead = totalLength - ProtocolUtil . getHeaderBytes ( p ) ; byte [ ] bytes = IoUtil . readBytes ( toRead , currentChannel ) ; currentChannel = Channels . newChannel ( new ByteArrayInputStream ( bytes ) ) ; } dataUnit = unitProcessor . fromStream ( dataUnit , p , currentChannel ) ; currentChannel = channel ; return dataUnit ; }
va	1	public static INDITextProperty createSaveableTextProperty ( INDIDriver driver , String name , String label , String group , PropertyStates state , PropertyPermissions permission ) throws IllegalArgumentException { INDITextProperty tp = loadTextProperty ( driver , name ) ; if ( tp == null ) { tp = new INDITextProperty ( driver , name , label , group , state , permission ) ; tp . setSaveable ( true ) ; } return tp ; }
va	8	private ChatRemoteManager ( ) { addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . QUIT ; } @ Override protected void onAction ( HashMap < String , String > params ) { if ( connection != null ) { connection . close ( ) ; } interrupt ( ) ; } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . CONNECT_REQUEST ; } @ Override protected void onAction ( HashMap < String , String > params ) { if ( params != null && params . containsKey ( "host" ) ) { try { connection = new ServerConnection ( params . get ( "host" ) , Main . TCP_SERVERPORT ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CONNECT_SUCCESS ; } @ Override public HashMap < String , String > getParameters ( ) { return null ; } } ) ; } catch ( NetworkException e ) { e . printStackTrace ( ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CONNECT_FAILED ; } @ Override public HashMap < String , String > getParameters ( ) { return null ; } } ) ; } } } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . CUSER_REQUESTNAMECHANGE ; } @ Override protected void onAction ( final HashMap < String , String > params ) { if ( params != null && params . containsKey ( "username" ) ) { if ( connection . auth ( params . get ( "username" ) ) ) { Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CUSER_NAMECHANGE ; } @ Override public HashMap < String , String > getParameters ( ) { return params ; } } ) ; } else { Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . CUSER_REQUESTNAMECHANGEFAILED ; } @ Override public HashMap < String , String > getParameters ( ) { return params ; } } ) ; } } } } ) ; addListener ( new ActionListener ( ) { @ Override protected TaskAction getListenAction ( ) { return TaskAction . FETCHUSER_REQUEST ; } @ Override protected void onAction ( HashMap < String , String > params ) { try { String response = connection . requestUserList ( ) ; final HashMap < String , String > userList = InfoParser . parseInfoResponse ( response ) ; Manager . getInstance ( ) . publishTask ( new Task ( ) { @ Override public TaskAction getAction ( ) { return TaskAction . FETCHUSER_PROCESS ; } @ Override public HashMap < String , String > getParameters ( ) { return userList ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; }
va	8	private static int getPrecedence ( String s ) { switch ( s . charAt ( 0 ) ) { case ( : case ) : return 1 ; case _ : return 4 ; case * : case / : return 3 ; case + : case - : return 2 ; case ^ : return 5 ; default : return 0 ; } }
va	9X	private void spawnGroundItem ( int i , int j ) { NodeList class19 = groundArray [ plane ] [ i ] [ j ] ; if ( class19 == null ) { worldController . method295 ( plane , i , j ) ; return ; } int k = fa0a1f01 ; Object obj = null ; for ( Item item = ( Item ) class19 . reverseGetFirst ( ) ; item != null ; item = ( Item ) class19 . reverseGetNext ( ) ) { ItemDef itemDef = ItemDef . forID ( item . ID ) ; int l = itemDef . value ; if ( itemDef . stackable ) l *= item . anInt1559 + 1 ; if ( l > k ) { k = l ; obj = item ; } } class19 . insertTail ( ( ( Node ) ( obj ) ) ) ; Object obj1 = null ; Object obj2 = null ; for ( Item class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetFirst ( ) ; class30_sub2_sub4_sub2_1 != null ; class30_sub2_sub4_sub2_1 = ( Item ) class19 . reverseGetNext ( ) ) { if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && obj1 == null ) obj1 = class30_sub2_sub4_sub2_1 ; if ( class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj ) ) . ID && class30_sub2_sub4_sub2_1 . ID != ( ( Item ) ( obj1 ) ) . ID && obj2 == null ) obj2 = class30_sub2_sub4_sub2_1 ; } int i1 = i + ( j << 7 ) + 60000000 ; worldController . method281 ( i , i1 , ( ( Animable ) ( obj1 ) ) , method42 ( plane , j * 128 + 64 , i * 128 + 64 ) , ( ( Animable ) ( obj2 ) ) , ( ( Animable ) ( obj ) ) , plane , j ) ; }
va	7	private void handleActionComplete ( MqttToken token ) throws MqttException { final String methodName = "handleActionComplete" ; synchronized ( token ) { log . fine ( className , methodName , "705" , new Object [ ] { token . internalTok . getKey ( ) } ) ; token . internalTok . notifyComplete ( ) ; if ( ! token . internalTok . isNotified ( ) ) { if ( mqttCallback != null && token instanceof MqttDeliveryToken && token . isComplete ( ) ) { mqttCallback . deliveryComplete ( ( MqttDeliveryToken ) token ) ; } fireActionEvent ( token ) ; } if ( token instanceof MqttDeliveryToken && token . isComplete ( ) ) { token . internalTok . setNotified ( true ) ; } if ( token . isComplete ( ) ) { clientState . notifyComplete ( token ) ; } } }
va	2	public void select ( ) { switch ( current ) { case 0 : case 1 : } }
va	7	@ SuppressWarnings ( "unchecked" ) private static int countRunAndMakeAscending ( Object [ ] a , int lo , int hi ) { if ( DEBUG ) { assert lo < hi ; } int runHi = lo + 1 ; if ( runHi == hi ) { return 1 ; } if ( ( ( Comparable ) a [ runHi ++ ] ) . compareTo ( a [ lo ] ) < 0 ) { while ( runHi < hi && ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - 1 ] ) < 0 ) { runHi ++ ; } reverseRange ( a , lo , runHi ) ; } else { while ( runHi < hi && ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - 1 ] ) >= 0 ) { runHi ++ ; } } return runHi - lo ; }
va	1	public static void main ( String [ ] args ) { File dictionary = new File ( "dictionary.txt" ) ; try { List < List < String >> anagrams = getAnagramsHT ( dictionary ) ; System . out . println ( anagrams . toString ( ) ) ; } catch ( IOException e ) { System . err . println ( "IO EXCEPTION ENCOUNTERED!!" ) ; e . printStackTrace ( ) ; } }
va	9X	public void rotateCounterClockwise ( ) { boolean temp [ ] [ ] = new boolean [ PIECE_SIZE ] [ PIECE_SIZE ] ; for ( int i = 0 ; i < PIECE_SIZE ; ++ i ) { for ( int j = 0 ; j < PIECE_SIZE ; ++ j ) { temp [ i ] [ j ] = currentShape [ j ] [ PIECE_SIZE - i - 1 ] ; } } currentShape = temp ; while ( shiftUp ( ) ) ; int tmp = width ; width = height ; height = tmp ; switch ( state ) { case 0 : state = 3 ; break ; case 1 : state = 0 ; break ; case 2 : state = 1 ; break ; case 3 : state = 2 ; break ; case 4 : state = 7 ; break ; case 5 : state = 4 ; break ; case 6 : state = 5 ; break ; case 7 : state = 6 ; break ; } }
va	0	public Location ( int x , int y ) { this . x = x ; this . y = y ; }
va	6	protected byte [ ] convertPasswordToKey ( String password ) { if ( password == null ) return null ; int count = password . length ( ) ; if ( count < 8 ) password += "         " . substring ( count ) ; byte [ ] pw = password . getBytes ( ) ; count = pw . length ; int pos = 0 ; byte [ ] key = new byte [ 7 ] ; for ( ; ; ) { for ( int n = 0 ; n < 7 ; n ++ ) { int p1 = pw [ pos + n ] & FF ; p1 >>= n ; int p2 = pw [ pos + n + 1 ] & FF ; p2 <<= ( 7 - n ) ; key [ n ] = ( byte ) ( p1 + p2 ) ; } pos += 8 ; if ( pos == count ) return key ; int pending = count - pos ; if ( pending < 8 ) pos -= 8 - pending ; encrypt ( key , pw , pos , 8 ) ; } }
va	4	private boolean r_e_ending ( ) { int v_1 ; B_e_found = false ; ket = cursor ; if ( ! ( eq_s_b ( 1 , "e" ) ) ) { return false ; } bra = cursor ; if ( ! r_R1 ( ) ) { return false ; } v_1 = limit - cursor ; if ( ! ( out_grouping_b ( g_v , 97 , 232 ) ) ) { return false ; } cursor = limit - v_1 ; slice_del ( ) ; B_e_found = true ; if ( ! r_undouble ( ) ) { return false ; } return true ; }
va	7	private static boolean KawigiEdit_RunTest ( int testNum , String [ ] p0 , boolean hasAnswer , int p1 ) { System . out . print ( "Test " + testNum + ": [" + "{" ) ; for ( int i = 0 ; p0 . length > i ; ++ i ) { if ( i > 0 ) { System . out . print ( " " ) ; } System . out . print ( "\"" + p0 [ i ] + "\"" ) ; } System . out . print ( "}" ) ; System . out . println ( "]" ) ; AlienAndGame obj ; int answer ; obj = new AlienAndGame ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . getNumber ( p0 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p1 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p1 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
va	8	public String execute ( DeleteCalendarObject deleteCalendarObject ) throws SQLException { String answer = "" ; resultSet = queryBuilder . selectFrom ( "Calendars" ) . where ( "CalendarName" , "=" , deleteCalendarObject . getCalendarToDelete ( ) ) . ExecuteQuery ( ) ; resultSet . next ( ) ; String calendarID = resultSet . getString ( "calendarID" ) ; resultSet = queryBuilder . selectFrom ( "Users" ) . where ( "UserName" , "=" , deleteCalendarObject . getuserID ( ) ) . ExecuteQuery ( ) ; resultSet . next ( ) ; int userID = resultSet . getInt ( "userID" ) ; boolean author = false ; boolean imported = true ; resultSet = queryBuilder . selectFrom ( "Calendars" ) . where ( "calendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; if ( resultSet . next ( ) ) { if ( resultSet . getInt ( "imported" ) == 0 ) { imported = false ; } } if ( imported == false ) { resultSet = queryBuilder . selectFrom ( "AutherRights" ) . where ( "CalendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; while ( resultSet . next ( ) ) { if ( resultSet . getInt ( "userID" ) == userID ) { author = true ; } } if ( author ) { resultSet = queryBuilder . selectFrom ( "Events" ) . where ( "CalendarID" , "=" , calendarID ) . ExecuteQuery ( ) ; while ( resultSet . next ( ) ) { String eventID = resultSet . getString ( "eventID" ) ; try { queryBuilder . deleteFrom ( "Notes" ) . where ( "eventID" , "=" , eventID ) ; } catch ( Exception e ) { System . err . print ( e . getStackTrace ( ) ) ; } } queryBuilder . deleteFrom ( dbConfig . getEvents ( ) ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( "subscription" ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( "autherrights" ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; queryBuilder . deleteFrom ( dbConfig . getCalendar ( ) ) . where ( "CalendarID" , "=" , calendarID ) . Execute ( ) ; answer = String . format ( "Calendar " + deleteCalendarObject . getCalendarToDelete ( ) + " has been deleted  along with all associated events and notes." ) ; } else { answer = "You do not have the rights to delete this calendar." ; } } else { answer = "This is an imported calendar and cannot be deleted." ; } return answer ; }
va	5	public boolean canAppend ( WriteCommand command ) throws IOException { switch ( command . opItem . op ) { case OpItem . OP_DEL : if ( command . opItem . number != this . number ) { return false ; } break ; case OpItem . OP_ADD : if ( this . dataFile . getLength ( ) + command . data . length >= JournalStore . FILE_SIZE ) { return false ; } if ( this . dataSize + command . data . length >= DataFileAppender . this . maxWriteBatchSize ) { return false ; } break ; default : throw new RuntimeException ( "Unknow op type " + command . opItem ) ; } return true ; }
va	8	public void executeSearch ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { response . setContentType ( "text/xml" ) ; Writer writer = response . getWriter ( ) ; String [ ] ownerIds = request . getParameterValues ( OWNERID ) ; if ( ownerIds == null || ownerIds . length != 1 ) { logger . debug ( "User didn't supply an ownerId" ) ; System . err . println ( ownerIds ) ; String error = "You must supply an ownerId" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } String ownerId = ownerIds [ 0 ] ; String [ ] filterParamss = request . getParameterValues ( FILTERPARAMS ) ; if ( filterParamss == null || filterParamss . length != 1 ) { logger . debug ( "User didn't supply any filterParams" ) ; String error = "You must supply one set of filterParams" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } String filterParams = filterParamss [ 0 ] ; FilterParams filterParamsObj = new FilterParams ( ) ; try { JAXBContext context = JAXBContext . newInstance ( FilterParams . class ) ; Unmarshaller um = context . createUnmarshaller ( ) ; filterParamsObj = ( FilterParams ) um . unmarshal ( new StringReader ( filterParams ) ) ; } catch ( JAXBException jbe ) { logger . warn ( "user supplied badly formed filterParams" ) ; String error = "Please make sure the filterParams is well formatted" ; response . setStatus ( 400 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } try { DetermineWorkToDo work = new DetermineWorkToDo ( null , ownerId , filterParamsObj ) ; Integer jobSize = work . FilterCompoundsInDatabase ( ) . size ( ) ; response . setStatus ( 200 ) ; writer . write ( CreateShortReturn . createShortResponse ( jobSize . toString ( ) , false ) ) ; } catch ( AmazonServiceException ase ) { logger . error ( ase ) ; String error = "Error in AWS please try again later." ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } catch ( AmazonClientException ace ) { logger . error ( ace ) ; String error = "Internal error please try again" ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } catch ( SQLException sqle ) { logger . error ( sqle ) ; String error = "Error connecting to SQL please try again later" ; response . setStatus ( 500 ) ; writer . write ( CreateShortReturn . createShortResponse ( error , true ) ) ; return ; } }
va	6	public String nextTo ( String delimiters ) { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '' || c == '' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } }
va	1	public void skipPast ( String to ) { this . myIndex = this . mySource . indexOf ( to , this . myIndex ) ; if ( this . myIndex < 0 ) { this . myIndex = this . mySource . length ( ) ; } else { this . myIndex += to . length ( ) ; } }
va	3	public static String toString ( char what ) { switch ( what ) { case EPSILON : return "eps" ; case else : return "else" ; case BLANK : return "blank" ; default : return "" + what ; } }
va	1	public void delete ( Tongiao persistentInstance ) { log . debug ( "deleting Tongiao instance" ) ; try { sessionFactory . getCurrentSession ( ) . delete ( persistentInstance ) ; log . debug ( "delete successful" ) ; } catch ( RuntimeException re ) { log . error ( "delete failed" , re ) ; throw re ; } }
va	5	private void addFileDropTarget ( Composite parent ) { final FileTransfer fileTransfer = FileTransfer . getInstance ( ) ; DropTarget target = new DropTarget ( parent , DND . DROP_COPY | DND . DROP_DEFAULT ) ; target . setTransfer ( new Transfer [ ] { fileTransfer } ) ; target . addDropListener ( new DropTargetListener ( ) { public void dragEnter ( DropTargetEvent event ) { if ( event . detail == DND . DROP_DEFAULT ) { if ( ( event . operations & DND . DROP_COPY ) > 0 ) { event . detail = DND . DROP_COPY ; } else { event . detail = DND . DROP_NONE ; } } } public void drop ( DropTargetEvent event ) { if ( fileTransfer . isSupportedType ( event . currentDataType ) ) { String [ ] files = ( String [ ] ) event . data ; for ( String file : files ) { try { controller . openFile ( file ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; displayErrorMessage ( "Error loading file: " + e . getMessage ( ) ) ; } } } } public void dropAccept ( DropTargetEvent event ) { } public void dragOver ( DropTargetEvent event ) { } public void dragOperationChanged ( DropTargetEvent event ) { } public void dragLeave ( DropTargetEvent event ) { } } ) ; }
va	5	public int [ ] compute ( int source ) { ZippedArray arr = ZippedArray . arrayWithDefaultValue ( 1000 ) ; int n = graph . getVerticesCount ( ) ; arr . set ( 0 , 0 , source ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int v = 0 ; v < n ; v ++ ) { int oldValue = ( Integer ) arr . get ( i - 1 , v ) ; int minValue = Integer . MAX_VALUE ; List < Edge > edges = graph . getEdgesTo ( v ) ; for ( Edge edge : edges ) { int x = edge . getX ( ) ; int w = edge . getWeight ( ) ; int t = ( Integer ) arr . get ( i - 1 , x ) + w ; if ( t < minValue ) minValue = t ; } arr . set ( Math . min ( oldValue , minValue ) , i , v ) ; } } int [ ] result = new int [ graph . getVerticesCount ( ) ] ; for ( int i = 0 ; i < graph . getVerticesCount ( ) ; i ++ ) { result [ i ] = ( Integer ) arr . get ( n - 1 , i ) ; } return result ; }
va	5	public void fileNew ( SimpleFrame frame ) { frame . setAction ( false ) ; frame . setIsFileNameSetted ( false ) ; frame . setTitle ( "Text Editor" ) ; JFileChooser chooser = new JFileChooser ( ) ; if ( frame . getIsChanged ( ) ) { int selection = JOptionPane . showConfirmDialog ( null , "Do you want save document?" , "Warrning" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( selection == JOptionPane . NO_OPTION ) { frame . getText ( ) . setText ( "" ) ; frame . setIsChanged ( false ) ; frame . setTitle ( "Text Editor" ) ; } if ( selection == JOptionPane . YES_OPTION ) { chooser . setCurrentDirectory ( new File ( "." ) ) ; int result = chooser . showSaveDialog ( null ) ; if ( result == JFileChooser . APPROVE_OPTION ) { frame . fileName = chooser . getSelectedFile ( ) . getPath ( ) ; PrintWriter out ; try { out = new PrintWriter ( new FileWriter ( frame . fileName ) ) ; String str = frame . getText ( ) . getText ( ) ; out . print ( str ) ; out . close ( ) ; } catch ( IOException e ) { JOptionPane . showMessageDialog ( frame , "Saving error" ) ; } } frame . getText ( ) . setText ( "" ) ; frame . setIsChanged ( false ) ; frame . setTitle ( "Text Editor" ) ; } } else { frame . getText ( ) . setText ( "" ) ; } frame . setAction ( true ) ; }
va	4	private void generatePressureFile ( ) { File file = new File ( this . pressFile ) ; ArrayList < Edge > edges = modelo . getEdges ( ) ; try { BufferedWriter output = new BufferedWriter ( new FileWriter ( file ) ) ; for ( Edge e : edges ) { String line ; int i = 1 ; for ( int vec : e . getFlowUnitVector ( ) ) { if ( vec != 0 ) { line = e . getNumber ( ) + " " + i + " " + vec + "\n" ; output . write ( line ) ; } i ++ ; } } output . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Model . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	8	public void menuAction ( JMenu selectMenu ) { MainFrame mainFrame = MainFrame . getInstance ( ) ; AttdFrame workingFrame = mainFrame . getCurrentFrame ( ) ; workingFrame . setVisible ( false ) ; for ( int i = 0 ; i < menu . length ; i ++ ) { if ( menu [ i ] . equals ( selectMenu ) ) { switch ( i ) { case 0 : mainFrame . setCurrentFrameEditCourse ( ) ; break ; case 1 : mainFrame . setCurrentFrameEditStudent ( ) ; break ; case 2 : mainFrame . setCurrentFrameCourseEnroll ( ) ; break ; case 3 : mainFrame . setCurrentFrameAttendance ( ) ; break ; case 4 : mainFrame . setCurrentFrameShowClassAR ( ) ; break ; case 5 : mainFrame . setCurrentFrameShowClassRP ( ) ; break ; default : break ; } break ; } } workingFrame = mainFrame . getCurrentFrame ( ) ; workingFrame . display ( ) ; }
va	4	public static KeyAction [ ] compile ( String s ) { final List < KeyAction > actions = new ArrayList < KeyAction > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { final char c = s . charAt ( i ) ; if ( c == K && s . substring ( i ) . startsWith ( "KeyEvent.VK_" ) ) try { final int k = s . indexOf ( . , i + "KeyEvent.VK_" . length ( ) ) ; final String vk = s . substring ( i + "KeyEvent." . length ( ) , k ) ; final int code = KeyEvent . class . getField ( vk ) . getInt ( null ) ; i = k + 1 ; actions . add ( new KeyAction ( code , Type . valueOf ( s . charAt ( i ) ) ) ) ; } catch ( Exception e ) { throw new RuntimeException ( "Compilation error: s=" + s + "  i=" + i + "  c=" + c , e ) ; } else compile ( c , actions ) ; } return actions . toArray ( new KeyAction [ actions . size ( ) ] ) ; }
va	7	private void updateDataTableTimeKeeping ( int n , int month , int year ) { Object [ ] [ ] objData = new Object [ n ] [ ] ; Object [ ] objColumn = new Object [ ] { "Working" , "Date" } ; int day ; String date ; if ( currentEmployee != null ) { Contract correctContract = currentEmployee . searchCorrespondingContract ( year , month ) ; if ( correctContract != null ) { TimeKeepingBook keepBook = correctContract . getTimeKeeping ( ) ; if ( keepBook != null ) { TimeKeepingSheet keepSheet = keepBook . get ( month , year ) ; if ( keepSheet == null ) { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } else { for ( int i = 0 ; i < keepSheet . size ( ) ; i ++ ) { TimeKeepingDetailInfo infor = keepSheet . get ( i ) ; day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( infor . getIsWorking ( ) ) , date } ; objData [ i ] = objValue ; } } } } } else { for ( int i = 0 ; i < n ; i ++ ) { day = i + 1 ; date = getStringOfDate ( year , month , day ) ; Object [ ] objValue = new Object [ ] { new boolean ( false ) , date } ; objData [ i ] = objValue ; } } timeKeepingBookFrame . getTableModelTimeKeeping ( ) . setDataVector ( objData , objColumn ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellRenderer ( new MyTableCellRenderer ( ) ) ; timeKeepingBookFrame . getTableTimeKeeping ( ) . getColumn ( "Working" ) . setCellEditor ( new MyTableCellEditor ( ) ) ; }
va	4	protected Tile getTile ( Tile t , Direction step ) { Point location = t . getLocation ( ) ; switch ( step ) { case EAST : return getTile ( new Point ( location . x + 1 , location . y ) ) ; case NORTH : return getTile ( new Point ( location . x , location . y - 1 ) ) ; case SOUTH : return getTile ( new Point ( location . x , location . y + 1 ) ) ; case WEST : return getTile ( new Point ( location . x - 1 , location . y ) ) ; default : return null ; } }
va	1	@ Test public void testByZero ( ) { try { DivisionResult dr = Util . divideByApproximatelyEqualParts ( 2 , 0 ) ; fail ( "ae expected  but obtained " + dr ) ; } catch ( ArithmeticException ae ) { } }
va	4	public void repairGeneTree ( Abaddon abaddon ) { while ( ! uncheckedGenes . isEmpty ( ) ) { GeneTrait currentGene = uncheckedGenes . remove ( 0 ) ; if ( currentGene instanceof ParentTrait ) { ParentTrait currentParent = ( ParentTrait ) currentGene ; for ( int i = 0 ; i < currentParent . getChildCount ( ) ; i ++ ) { GeneTrait currentChild = currentParent . getChild ( i ) ; if ( ! genes . contains ( currentChild ) ) { abaddon . growChild ( this , currentParent , i ) ; } } } } }
va	7	public void drawPolygon ( double [ ] x , double [ ] y , JGColor [ ] col , int len , boolean filled , boolean pf_relative ) { if ( buf_gfx == null ) return ; int [ ] xpos = new int [ 3 ] ; int [ ] ypos = new int [ 3 ] ; xpos [ 0 ] = el . scaleXPos ( x [ 0 ] , pf_relative ) ; ypos [ 0 ] = el . scaleYPos ( y [ 0 ] , pf_relative ) ; xpos [ 1 ] = el . scaleXPos ( x [ 1 ] , pf_relative ) ; ypos [ 1 ] = el . scaleYPos ( y [ 1 ] , pf_relative ) ; xpos [ 2 ] = el . scaleXPos ( x [ len - 1 ] , pf_relative ) ; ypos [ 2 ] = el . scaleYPos ( y [ len - 1 ] , pf_relative ) ; if ( ! filled ) { if ( col != null ) setColor ( buf_gfx , col [ 1 ] ) ; buf_gfx . drawLine ( xpos [ 0 ] , ypos [ 0 ] , xpos [ 1 ] , ypos [ 1 ] ) ; if ( col != null ) setColor ( buf_gfx , col [ 0 ] ) ; buf_gfx . drawLine ( xpos [ 2 ] , ypos [ 2 ] , xpos [ 0 ] , ypos [ 0 ] ) ; } for ( int i = 2 ; i < len ; i ++ ) { xpos [ 2 ] = el . scaleXPos ( x [ i ] , pf_relative ) ; ypos [ 2 ] = el . scaleYPos ( y [ i ] , pf_relative ) ; if ( col != null ) setColor ( buf_gfx , col [ i ] ) ; if ( filled ) { buf_gfx . fillPolygon ( xpos , ypos , 3 ) ; } else { buf_gfx . drawLine ( xpos [ 1 ] , ypos [ 1 ] , xpos [ 2 ] , ypos [ 2 ] ) ; } xpos [ 1 ] = xpos [ 2 ] ; ypos [ 1 ] = ypos [ 2 ] ; } }
va	7	public void addItem ( Item item , int amount ) { System . out . println ( "added " + amount + " of " + item + " to " + owner ) ; if ( item . isStackable ( ) ) { for ( int i = 0 ; i < 30 ; i ++ ) { if ( objectType [ i ] . id == item . id && objectType [ i ] . subID == item . subID && objectNumber [ i ] < 999 ) { objectNumber [ i ] = objectNumber [ i ] + amount ; return ; } } } for ( int i = 0 ; i < size ; i ++ ) { if ( objectType [ i ] . id == 0 ) { objectType [ i ] = item ; objectNumber [ i ] = amount ; return ; } } System . out . println ( "warning  inventory is full" ) ; }
va	7	public static int numPaths ( int x , int y ) { if ( x == 1 && y == 1 ) { return 0 ; } if ( x == 2 && y == 1 ) { return 1 ; } if ( x == 1 && y == 2 ) { return 1 ; } if ( ! isLegal ( x , y ) ) { return 0 ; } return numPaths ( x - 1 , y ) + numPaths ( x , y - 1 ) ; }
va	7	@ Override public long [ ] getLongData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; long [ ] out = new long [ ( int ) length ] ; long elem = ( long ) ( data [ 0 ] != null ? data [ 0 ] . length ( ) : 0 ) ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = elem ; } return out ; } else { long [ ] res = new long [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { res [ i ] = ( long ) ( data [ i ] != null ? data [ i ] . length ( ) : 0 ) ; } return res ; } } }
va	2	@ Override public void action ( RuleContext _localctx , int ruleIndex , int actionIndex ) { switch ( ruleIndex ) { case 34 : WS_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; case 37 : COMMENTLIN_action ( ( RuleContext ) _localctx , actionIndex ) ; break ; } }
va	5	public final boolean isValidRate ( final String rate ) { final String methodName = "isValidRate" ; DatabaseLogger . entering ( CLASS_NAME , methodName , rate ) ; boolean validRate = true ; if ( isEmptyValue ( rate ) ) { validRate = false ; } else if ( ! rate . startsWith ( "$" ) ) { validRate = false ; } else { try { final String rateAmount = rate . substring ( 1 ) ; double rateDouble = double . parseDouble ( rateAmount ) ; if ( ( rateDouble <= 0 ) || ( rateDouble > DatabaseConstants . MAX_RATE_VALUE ) ) { validRate = false ; } } catch ( NumberFormatException e ) { validRate = false ; } } DatabaseLogger . exiting ( CLASS_NAME , methodName , validRate ) ; return validRate ; }
va	8	public static void main ( String [ ] args ) { boolean all_right ; all_right = true ; long p0 ; int p1 ; int p2 ; String p3 ; p0 = 10 ; p1 = 6 ; p2 = 3 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 0 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 10 ; p1 = 5 ; p2 = 3 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 1 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 50 ; p1 = 100 ; p2 = 2 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 2 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 120 ; p1 = 10 ; p2 = 11 ; p3 = "Impossible" ; all_right = KawigiEdit_RunTest ( 3 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 10 ; p1 = 10 ; p2 = 9999 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 4 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 1000 ; p1 = 100 ; p2 = 10 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 5 , p0 , p1 , p2 , true , p3 ) && all_right ; p0 = 1000010000100001 ; p1 = 1100011 ; p2 = 1000000000 ; p3 = "Possible" ; all_right = KawigiEdit_RunTest ( 6 , p0 , p1 , p2 , true , p3 ) && all_right ; if ( all_right ) { System . out . println ( "You're a stud (at least on the example cases)!" ) ; } else { System . out . println ( "Some of the test cases had errors." ) ; } }
va	9X	public void postInstall ( ) { String plUser = Configuration . getConfig ( Configuration . CONFIG_PIPELINE_USER ) ; String startServer = Configuration . getConfig ( Configuration . START_PIPELINE_SERVER ) ; String configureServer = Configuration . getConfig ( Configuration . CONFIGURE_PIPELINE_SERVER ) ; String startClient = Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT ) ; boolean needsServerStart = startServer != null ? boolean . parseBoolean ( startServer ) : false ; boolean needsConfigureServer = configureServer != null ? boolean . parseBoolean ( configureServer ) : false ; boolean needsClientStart = startClient != null ? boolean . parseBoolean ( startClient ) : false ; if ( needsClientStart || needsConfigureServer || needsServerStart ) { StringBuilder cmd = new StringBuilder ( System . getProperty ( "user.dir" ) ) ; cmd . append ( "/install_files/postInstall.sh " ) ; cmd . append ( plUser ) ; cmd . append ( " " ) ; cmd . append ( Configuration . getConfig ( Configuration . CONFIG_PIPELINE_LOCATION ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsServerStart ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsConfigureServer ) ) ; cmd . append ( " " ) ; cmd . append ( String . valueOf ( needsClientStart ) ) ; if ( Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT_ARGUMENTS ) != null ) { cmd . append ( " " ) ; cmd . append ( Configuration . getConfig ( Configuration . START_PIPELINE_CLIENT_ARGUMENTS ) ) ; } Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( cmd . toString ( ) ) ; if ( ! needsConfigureServer ) { StreamReader isr = new StreamReader ( p . getInputStream ( ) , 1 ) ; StreamReader esr = new StreamReader ( p . getErrorStream ( ) , 2 ) ; isr . start ( ) ; esr . start ( ) ; p . waitFor ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } finally { if ( p != null && ! needsConfigureServer ) NativeCalls . releaseProcess ( p ) ; if ( needsConfigureServer ) Configuration . setConfig ( Configuration . CONFIGURE_PIPELINE_SERVER , "false" ) ; } } }
va	1	public ActionDialog ( SkyQuestUtility util , JComponent parent ) { super ( util , true ) ; this . util = util ; this . parent = parent ; save = new JButton ( "Save" ) ; cancel = new JButton ( "Cancel" ) ; amodel = new DefaultListModel < ActionType > ( ) ; atypes = new JList < ActionType > ( amodel ) ; for ( ActionType a : QuestManager . getInstance ( ) . getRegisteredActionTypes ( ) ) amodel . addElement ( a ) ; setLayout ( new BorderLayout ( ) ) ; JPanel buttons = new JPanel ( ) ; buttons . setLayout ( new BoxLayout ( buttons , BoxLayout . X_AXIS ) ) ; buttons . add ( save ) ; buttons . add ( cancel ) ; JPanel ap = new JPanel ( ) ; ap . setLayout ( new BorderLayout ( ) ) ; ap . add ( "Center" , atypes ) ; ap . add ( "North" , new JLabel ( "Type" ) ) ; add ( "South" , buttons ) ; cancel . addActionListener ( this ) ; save . addActionListener ( this ) ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( jfSelColor . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { jfSelColor dialog = new jfSelColor ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
va	5	public DataFrame parse ( ) throws ParseException { DataFrame retval = null ; Tag tag = null ; do { tag = readTag ( ) ; if ( tag == null ) { break ; } } while ( tag . isComment ( ) || tag . isPreamble ( ) ) ; if ( ( tag != null ) && tag . isOpenTag ( ) ) { retval = readFrame ( tag ) ; } return retval ; }
va	8	@ Override public void widgetSelected ( SelectionEvent e ) { if ( e . getSource ( ) == add_button ) { String username = ua_uname_text . getText ( ) ; String name = ua_name_text . getText ( ) ; String pass = ua_pass_text . getText ( ) ; String confirm = ua_cpass_text . getText ( ) ; if ( pass . equals ( confirm ) ) { if ( Sanitizer . isCleanInput ( username ) && Sanitizer . isCleanInput ( name ) && Sanitizer . isCleanInput ( pass ) ) { ADD newuser = null ; try { newuser = new ADD ( username , name , Hash . getSHA256 ( pass . getBytes ( "UTF-8" ) ) , session . getName ( ) , session . getPassHash ( ) ) ; } catch ( UnsupportedEncodingException e2 ) { System . out . println ( "nope" ) ; e2 . printStackTrace ( ) ; } try { System . out . println ( portclient . exchange ( newuser ) ) ; } catch ( UserNotFoundException e1 ) { System . out . println ( "did not go through  sorry" ) ; e1 . printStackTrace ( ) ; } } else { MessageBox messageBox = new MessageBox ( shlPortunesAdministrator , SWT . ICON_ERROR ) ; messageBox . setMessage ( "Invalid Input(s)." ) ; messageBox . open ( ) ; } } else { MessageBox messageBox = new MessageBox ( shlPortunesAdministrator , SWT . ICON_ERROR ) ; messageBox . setMessage ( "Passwords do not match." ) ; messageBox . open ( ) ; } } else if ( e . getSource ( ) == clear_button ) { ua_uname_text . setText ( "" ) ; ua_name_text . setText ( "" ) ; ua_pass_text . setText ( "" ) ; ua_cpass_text . setText ( "" ) ; } }
va	4	@ Override public void showHints ( int level ) { for ( int x = 1 ; x <= 16 ; x ++ ) { for ( int y = 1 ; y <= 16 ; y ++ ) { Point p = new Point ( x , y ) ; if ( ! isReadOnly ( p ) ) { BitSet markUp = getHints ( p , level ) ; if ( level == 0 ) { System . out . println ( String . format ( "(%s  %s) : %s" , x , y , markUp ) ) ; } else { System . out . println ( String . format ( "(%s  %s) : %s [%s]" , x , y , markUp , getHints ( p , 0 ) ) ) ; } } } } System . out . println ( ) ; }
va	4	public static void main ( String [ ] args ) { SelectionSort ss = new SelectionSort ( 10 ) ; System . out . println ( ss . toString ( ) ) ; for ( int i = 0 ; i < ss . sort . length ; i ++ ) { int min = ss . sort [ i ] ; int nr = 0 ; boolean changed = false ; for ( int j = i + 1 ; j < ss . sort . length ; j ++ ) { if ( ss . sort [ j ] < min ) { min = ss . sort [ j ] ; nr = j ; changed = true ; } } if ( changed ) { ss . sort [ nr ] = ss . sort [ i ] ; ss . sort [ i ] = min ; } ss . sorted ( ss . sort ) ; } ss . sorted ( ss . sort ) ; System . out . println ( ss . toString ( ) ) ; }
va	2	protected void criarMetaObjeto ( ) { framePai . dispose ( ) ; switch ( listaSemiPontos . size ( ) ) { case 1 : this . criarPonto ( ) ; break ; case 2 : this . criarReta ( ) ; break ; default : this . criarPoligono ( ) ; } }
va	3	public EnterTeams ( MainGUI gui ) { initComponents ( ) ; this . gui = gui ; GraphicsEnvironment g = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = g . getScreenDevices ( ) ; int width = devices [ 0 ] . getDisplayMode ( ) . getWidth ( ) ; int height = devices [ 0 ] . getDisplayMode ( ) . getHeight ( ) ; int w = this . getSize ( ) . width ; int h = this . getSize ( ) . height ; int x = ( width - w ) / 2 ; int y = ( height - h ) / 2 ; this . setLocation ( x , y ) ; numberOfMatchesField . setValue ( 1 ) ; matchField . setValue ( 1 ) ; saveMatchesButton . setEnabled ( false ) ; teamArray = new JTextField [ 6 ] ; teamArray [ 0 ] = redAllianceTeam1 ; teamArray [ 1 ] = redAllianceTeam2 ; teamArray [ 2 ] = redAllianceTeam3 ; teamArray [ 3 ] = blueAllianceTeam1 ; teamArray [ 4 ] = blueAllianceTeam2 ; teamArray [ 5 ] = blueAllianceTeam3 ; if ( ! "" . equals ( Competition . getCompetitionName ( ) ) || Competition . getCompetitionName ( ) != null ) { competitionNameField . setText ( Competition . getCompetitionName ( ) ) ; } if ( Competition . getNumberOfMatches ( ) != 0 ) { numberOfMatchesField . setValue ( Competition . getNumberOfMatches ( ) ) ; } DynamicArray teams = new DynamicArray ( 20 ) ; }
va	3	void getLatestVersions ( vslIndexView < String > cur , StringBuffer out ) throws vslInputException { if ( cur . getNextViews ( ) == null ) { if ( cur . isDelete ( ) ) { out . append ( " DELETED " ) ; } else { out . append ( " " ) . append ( cur . getData ( ) ) . append ( " " ) ; } } else { for ( vslIndexView < String > nv : cur . getNextViews ( ) ) { getLatestVersions ( nv , out ) ; } } }
va	2	public Node expand ( Board board , String mcColor ) { String newColor ; Random generator = new Random ( ) ; int randomIndex = generator . nextInt ( this . untriedMoves . size ( ) ) ; Tuple < Integer , Integer > move = this . untriedMoves . get ( randomIndex ) ; this . untriedMoves . remove ( randomIndex ) ; try { board . makeMove ( move , color ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( this . color . equals ( "w" ) ) { newColor = "b" ; } else { newColor = "w" ; } Node node = new Node ( this , move , newColor , board , this . moveNumber + 1 , mcColor ) ; this . children . add ( node ) ; return node ; }
va	7	public boolean postMortem ( PostMortem pm ) { boolean result = true ; Symbol that = ( Symbol ) pm ; if ( this . integer != that . integer || this . weight != that . weight ) { return false ; } if ( ( this . back != null ) != ( that . back != null ) ) { return false ; } Symbol zero = this . zero ; Symbol one = this . one ; if ( zero == null ) { if ( that . zero != null ) { return false ; } } else { result = zero . postMortem ( that . zero ) ; } if ( one == null ) { if ( that . one != null ) { return false ; } } else { result = one . postMortem ( that . one ) ; } return result ; }
va	5	public Writer write ( Writer writer ) throws JSONException { try { boolean b = false ; int len = length ( ) ; writer . write ( [ ) ; for ( int i = 0 ; i < len ; i += 1 ) { if ( b ) { writer . write (   ) ; } Object v = this . myArrayList . get ( i ) ; if ( v instanceof JSONObject ) { ( ( JSONObject ) v ) . write ( writer ) ; } else if ( v instanceof JSONArray ) { ( ( JSONArray ) v ) . write ( writer ) ; } else { writer . write ( JSONObject . valueToString ( v ) ) ; } b = true ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
va	3	MapCell getCell ( Position pos ) { Preconditions . checkArgument ( pos . getX ( ) < mapWidth && pos . getX ( ) >= 0 && pos . getY ( ) < mapHeight && pos . getY ( ) >= 0 ) ; return map [ pos . getX ( ) ] [ pos . getY ( ) ] ; }
va	1	public static long readLong ( byte [ ] b , int start ) { long l = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { l <<= 8 ; l |= b [ start + i ] & ff ; } return l ; }
va	8	public boolean hasAdjacentEmptyTile ( JavaCell cell ) { int x = cell . getX ( ) ; int y = cell . getY ( ) ; if ( x + 1 == 13 ) { if ( map [ 13 ] [ y ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( x - 1 == 0 ) { if ( map [ 0 ] [ y ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( y + 1 == 13 ) { if ( map [ x ] [ 13 ] . getCellType ( ) . equals ( "blank" ) ) return true ; } if ( y - 1 == 0 ) { if ( map [ x ] [ 0 ] . getCellType ( ) . equals ( "blank" ) ) return true ; } return false ; }
va	6	public Color getColor ( VesselType type ) { switch ( type ) { case SWIMMER : return Color . PINK ; case SPEED_BOAT : return Color . GREEN ; case FISHING_BOAT : return Color . CYAN ; case CARGO_BOAT : return Color . ORANGE ; case PASSENGER_VESSEL : return Color . MAGENTA ; case UNKNOWN : return Color . WHITE ; default : return Color . WHITE ; } }
va	1	@ Test public void testSplitLeafs ( ) { StringBuilder expected = new StringBuilder ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { bpTree . put ( i , i ) ; expected . append ( "<put>" ) . append ( "<not-contain-key>" ) . append ( "<get>" ) . append ( "<not-contain>" ) . append ( "<leaf-put>" ) . append ( "<new-key>" ) ; } expected . append ( "<create-new-root>" ) ; assertThat ( bpTree . getWay ( ) , is ( expected . toString ( ) ) ) ; }
va	8	public static String allScores ( String fileName ) throws IOException { Scanner scan ; String [ ] usernames ; long [ ] wins , losses ; int fileLength = 0 , win = - 1 , lose = - 1 ; try { scan = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException ex ) { System . err . println ( "File not found: " + fileName ) ; FileWriter writeToFile = new FileWriter ( fileName ) ; writeToFile . write ( "//BEGIN\r\n" + "//END" ) ; writeToFile . close ( ) ; scan = new Scanner ( new File ( fileName ) ) ; } String fileContents = "" , fileLine = scan . nextLine ( ) ; while ( ! fileLine . equals ( "//END" ) ) { fileLine = scan . nextLine ( ) ; if ( ! fileLine . equals ( "//END" ) ) fileLength ++ ; } if ( fileLength == 0 ) return "There are no scores in the scoreboard!\nSave yours and get 1st place ;3" ; usernames = new String [ fileLength ] ; wins = new long [ fileLength ] ; losses = new long [ fileLength ] ; scan = new Scanner ( new File ( fileName ) ) ; String spare = scan . next ( ) ; int i ; for ( i = 0 ; i < fileLength ; i ++ ) { try { usernames [ i ] = scan . next ( ) ; wins [ i ] = scan . nextLong ( ) ; losses [ i ] = scan . nextLong ( ) ; } catch ( InputMismatchException ex ) { changeScore ( fileName , usernames [ i ] , 0 , 0 ) ; } } usernames = readNames ( usernames ) ; fileContents = "Username\t Wins\t Losses\n" ; for ( i = 0 ; i < fileLength ; i ++ ) { fileContents += ( i + 1 + ": " + usernames [ i ] + ( usernames [ i ] . length ( ) < 5 ? "\t\t" : "\t " ) + wins [ i ] + "\t " + losses [ i ] + "\n" ) ; } return ( fileContents ) ; }
va	1	public void printRes ( ) { for ( int i = 0 ; i < n ; i ++ ) { Vertex v = res . get ( i ) ; System . out . println ( v . vertex + " : " + v . timestamp1 + " / " + v . timestamp2 ) ; } }
va	9X	public String toKML ( boolean suppressEnclosingTags ) { String kml = "" ; if ( ! suppressEnclosingTags ) { kml += "<LookAt" ; if ( this . id != null ) { kml += " id=\"" + this . getId ( ) + "\"" ; } if ( this . targetId != null ) { kml += " targetId=\"" + this . getTargetId ( ) + "\"" ; } kml += ">\n" ; } kml += super . toKML ( true ) ; if ( this . longitude != DEFAULT_LONGITUDE ) { kml += "<longitude>" + this . longitude + "</longitude>\n" ; } if ( this . latitude != DEFAULT_LATITUDE ) { kml += "<latitude>" + this . latitude + "</latitude>\n" ; } if ( this . altitude != DEFAULT_ALTITUDE ) { kml += "<altitude>" + this . altitude + "</altitude>\n" ; } kml += "<range>" + this . range + "</range>\n" ; if ( this . tilt != DEFAULT_TILT ) { kml += "<tilt>" + this . tilt + "</tilt>\n" ; } if ( this . heading != DEFAULT_HEADING ) { kml += "<heading>" + this . heading + "</heading>\n" ; } if ( this . altitudeMode != null ) { kml += "<altitudeMode>" + SpecialCaseFormatter . toKMLString ( this . altitudeMode ) + "</altitudeMode>\n" ; } if ( ! suppressEnclosingTags ) { kml += "</LookAt>\n" ; } return kml ; }
va	6	public static int addDef ( int piece , boolean isPieceWhite ) { if ( isPieceWhite && piece == DraughtsState . WHITEPIECE || piece == DraughtsState . WHITEKING ) { return 5 ; } if ( ! isPieceWhite && piece == DraughtsState . BLACKPIECE || piece == DraughtsState . BLACKKING ) { return 5 ; } return 0 ; }
va	0	public String getSrcText ( ) { return "" ; }
va	5	public User validateUser ( String username , String password ) { try { if ( username . length ( ) > 40 ) return null ; if ( password . length ( ) > 40 ) return null ; select1 . setString ( 1 , username ) ; ResultSet rs = select1 . executeQuery ( ) ; while ( rs . next ( ) ) { if ( rs . getString ( "password" ) . equals ( password ) ) { return new User ( rs . getString ( "username" ) , rs . getString ( "password" ) , rs . getString ( "displayname" ) , PermissionsList . fromByteArray ( rs . getBytes ( "permissions" ) ) ) ; } } rs = null ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
va	6	@ Override public boolean preHandle ( HttpServletRequest request , HttpServletResponse response , Object handler ) throws Exception { String uri = request . getRequestURI ( ) ; if ( ! uri . endsWith ( "index.htm" ) && ! uri . endsWith ( "login.htm" ) && ! uri . endsWith ( "logout.htm" ) ) { Login userData = ( Login ) request . getSession ( ) . getAttribute ( Login . class . getName ( ) ) ; if ( userData == null || Util . nullOrEmptyOrBlank ( userData . getEmail ( ) ) || ( new Date ( ) . getTime ( ) - userData . getLastAccessed ( ) ) > 30 * 60 * 1000 ) { response . sendRedirect ( "index.htm" ) ; return false ; } else { userData . setLastAccessed ( new Date ( ) . getTime ( ) ) ; } } return true ; }
va	4	public void print ( GroupedWriter fout ) { super . print ( fout ) ; fout . print ( "alphabet " ) ; fout . printlnGroup ( alphabet ) ; if ( guard != null && guard . length ( ) > 0 ) { fout . print ( "guard " ) ; fout . printlnGroup ( guard ) ; } if ( clocksToReset != null && clocksToReset . length > 0 ) { fout . print ( "clocksToReset " ) ; fout . printlnGroup ( Arrays . toString ( clocksToReset ) ) ; } fout . print ( "offset " ) ; fout . printlnGroup ( double . toString ( offset_theta ) ) ; }
va	9X	private boolean findBranchingRoute ( Agent a , Box obstacle ) { dir boxDir = null ; BacktrackTree root = new BacktrackTree ( a . desire . box . getAtField ( ) , a . getAtField ( ) , null ) ; BacktrackTree currentNode = null ; Set < BacktrackTree > closedSet = new HashSet < BacktrackTree > ( ) ; LinkedList < BacktrackTree > queue = new LinkedList < BacktrackTree > ( ) ; HashMap < Field , ArrayList < Field >> exploredStates = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( a . desire . box . getAtField ( ) ) ; exploredStates . put ( a . getAtField ( ) , tempList ) ; queue . add ( root ) ; currentNode = queue . pop ( ) ; while ( currentNode . boxLocation != a . desire . goal ) { boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > foundCommands = a . addPossibleCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation ) ; for ( Command command : foundCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( exploredStates . containsKey ( agentLocation ) ) { if ( exploredStates . get ( agentLocation ) . contains ( boxLocation ) ) continue ; else { exploredStates . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; exploredStates . put ( agentLocation , tempListe ) ; } BacktrackTree bt = new BacktrackTree ( boxLocation , agentLocation , command ) ; bt . parent = currentNode ; boolean setupInClosedSet = false ; for ( BacktrackTree closedTree : closedSet ) { if ( closedTree . agentLocation . x == bt . agentLocation . x && closedTree . agentLocation . y == bt . agentLocation . y && closedTree . boxLocation . x == bt . boxLocation . x && closedTree . boxLocation . y == bt . boxLocation . y ) { setupInClosedSet = true ; } } if ( ! setupInClosedSet ) { queue . add ( bt ) ; closedSet . add ( bt ) ; } } if ( queue . isEmpty ( ) ) { return false ; } currentNode = queue . pop ( ) ; } ArrayList < Command > commands = new ArrayList < Command > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; for ( Command command : commands ) { a . commandQueueDONOTUSE . add ( command ) ; } return true ; }
va	9X	final public CreateTableCommand CreateTable_suffix ( ) throws ParseException { String tableName ; List < CreateTableCommand . AttributeDescriptor > attributeDescriptors = new ArrayList < CreateTableCommand . AttributeDescriptor > ( ) ; List < String > primaryKeyAttrNames = new ArrayList < String > ( ) ; List < CreateTableCommand . ForeignKeyDescriptor > foreignKeyDescriptors = new ArrayList < CreateTableCommand . ForeignKeyDescriptor > ( ) ; CreateTableCommand . AttributeDescriptor attributeDescriptor ; CreateTableCommand . ForeignKeyDescriptor foreignKeyDescriptor ; String name ; jj_consume_token ( KW_TABLE ) ; tableName = Identifier ( ) ; jj_consume_token ( 52 ) ; label_2 : while ( true ) { attributeDescriptor = AttrDecl ( ) ; jj_consume_token ( 51 ) ; attributeDescriptors . add ( attributeDescriptor ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case IDENTIFIER : ; break ; default : jj_la1 [ 6 ] = jj_gen ; break label_2 ; } } jj_consume_token ( KW_PRIMARY ) ; jj_consume_token ( KW_KEY ) ; jj_consume_token ( 52 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; label_3 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 7 ] = jj_gen ; break label_3 ; } jj_consume_token ( 51 ) ; name = Identifier ( ) ; primaryKeyAttrNames . add ( name ) ; } jj_consume_token ( 53 ) ; label_4 : while ( true ) { switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case 51 : ; break ; default : jj_la1 [ 8 ] = jj_gen ; break label_4 ; } jj_consume_token ( 51 ) ; foreignKeyDescriptor = ForeignKeyDecl ( ) ; foreignKeyDescriptors . add ( foreignKeyDescriptor ) ; } jj_consume_token ( 53 ) ; { if ( true ) return new CreateTableCommand ( token , tableName , attributeDescriptors , primaryKeyAttrNames , foreignKeyDescriptors ) ; } throw new Error ( "Missing return statement in function" ) ; }
va	8	public double getHammingDis ( int [ ] actDeps , int [ ] actLabs , int [ ] predDeps , int [ ] predLabs ) { double dis = 0 ; for ( int i = 1 ; i < actDeps . length ; ++ i ) if ( options . learnLabel ) { if ( labelLossType == 0 ) { if ( actDeps [ i ] != predDeps [ i ] ) dis += 0.5 ; if ( actLabs [ i ] != predLabs [ i ] ) dis += 0.5 ; } else if ( actDeps [ i ] != predDeps [ i ] || actLabs [ i ] != predLabs [ i ] ) dis += 1 ; } else { if ( actDeps [ i ] != predDeps [ i ] ) dis += 1 ; } return dis ; }
va	1	private boolean matchExact ( String expected , String actual ) { return matchMode == MatchMode . EXACT && actual . equals ( expected ) ; }
va	0	private static void writeFile ( File destFile , String content ) throws IOException { BufferedWriter writer = new BufferedWriter ( new FileWriter ( destFile ) ) ; writer . write ( content ) ; writer . flush ( ) ; writer . close ( ) ; writer = null ; }
va	4	public static boolean writeSalesOrder ( MessageHeader header , List < com . adammargherio . xml . schemas . salesorder . LineItem > items ) { if ( conn == null ) { getConnection ( ) ; } try { String sql = "INSERT INTO tblETSalesHeader VALUES (? ? ? ? ? ? ?)" ; PreparedStatement peHeader = conn . prepareStatement ( sql ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } for ( com . adammargherio . xml . schemas . salesorder . LineItem l : items ) { try { String item = "INSERT INTO tblETSalesDetail VALUES (? ? ? ? ? ?)" ; PreparedStatement peItem = conn . prepareStatement ( item ) ; peItem . setString ( 1 , l . getLineNo ( ) ) ; peItem . setString ( 2 , l . getItemCode ( ) ) ; peItem . setString ( 3 , l . getProductName ( ) ) ; peItem . setInt ( 4 , l . getQuantity ( ) . intValue ( ) ) ; peItem . setString ( 5 , l . getUnitOfMeasure ( ) ) ; peItem . setInt ( 6 , l . getBasePrice ( ) . intValue ( ) ) ; peItem . execute ( ) ; conn . commit ( ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } } return true ; }
va	2	public void append ( Color fg , Color bg , String text ) { try { StyledDocument doc = ( StyledDocument ) getDocument ( ) ; Style style = doc . addStyle ( "StyleName" , null ) ; if ( bg != null ) StyleConstants . setBackground ( style , bg ) ; StyleConstants . setForeground ( style , fg ) ; doc . insertString ( doc . getLength ( ) , text , style ) ; } catch ( BadLocationException ignored ) { } }
va	4	public int numTrees2 ( int n ) { if ( n == 0 || n == 1 ) return 1 ; int [ ] num = new int [ n + 1 ] ; num [ 0 ] = 1 ; num [ 1 ] = 1 ; num [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) { int cnt = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { int left = j - 1 ; int right = i - j ; cnt += num [ left ] * num [ right ] ; } num [ i ] = cnt ; } return num [ n ] ; }
va	8	private void setCharacterValue ( StringBuilder aCharacters ) throws SAXException { if ( "published" . equals ( currentElement ) ) { try { tweet . setPublished ( dateFormat . parse ( aCharacters . toString ( ) ) ) ; } catch ( ParseException anExc ) { throw new SAXException ( anExc ) ; } } else if ( ( "title" . equals ( currentElement ) ) && ( tweet != null ) ) { tweet . setTitle ( aCharacters . toString ( ) ) ; } else if ( "content" . equals ( currentElement ) ) { content . setValue ( aCharacters . toString ( ) ) ; } else if ( "twitter:lang" . equals ( currentElement ) ) { tweet . setLanguage ( aCharacters . toString ( ) ) ; } else if ( "name" . equals ( currentElement ) ) { author . setName ( aCharacters . toString ( ) ) ; } else if ( "uri" . equals ( currentElement ) ) { author . setUri ( aCharacters . toString ( ) ) ; } }
va	6	@ Override public int updateByLogic ( Object ... pojos ) throws DataAccessException { int r = 0 ; for ( Object obj : pojos ) { SqlUpdGenerator sqlGenerator = new SqlUpdGenerator ( obj , false ) ; try { r += execute ( sqlGenerator . getSql ( ) , sqlGenerator . getArgs ( ) ) ; } catch ( IllegalArgumentException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( IllegalAccessException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( NoSuchFieldException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( SecurityException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } catch ( ParseException e ) { logger . error ( "init update sql error! exec number : {}" , r , e ) ; throw new DataAccessException ( "init update sql error!" , e ) ; } } return r ; }
va	1	public String informaNomeJogador ( int posicao ) { if ( posicao == 1 ) { return jogador1 . obterNome ( ) ; } else { return jogador2 . obterNome ( ) ; } }
va	9X	public boolean setRobot ( final int robot , final int position , final boolean allowSwapRobots ) { if ( ( robot < 0 ) || ( robot >= this . robots . length ) || ( position < 0 ) || ( position >= this . size ) || this . isObstacle ( position ) || ( ( false == allowSwapRobots ) && ( this . getRobotNum ( position ) >= 0 ) && ( this . getRobotNum ( position ) != robot ) ) ) { return false ; } else { final int otherRobot = this . getRobotNum ( position ) ; final int oldPosition = this . robots [ robot ] ; if ( ( otherRobot >= 0 ) && ( otherRobot != robot ) && ( oldPosition >= 0 ) ) { this . robots [ otherRobot ] = oldPosition ; } this . robots [ robot ] = position ; return true ; } }
va	0	public void setC ( float C ) { this . C = C ; }
va	1	private int getNextIndicator ( ) throws IOException { if ( this . indicator == 0 ) { this . indicator = in . read ( ) ; } return this . indicator ; }
va	8	public boolean areAnagramsCount ( String a , String b ) { if ( a == null && b == null ) return false ; else if ( a == null || b == null ) return false ; else { int [ ] count = new int [ 256 ] ; char [ ] ac = a . toCharArray ( ) ; for ( char c : ac ) { count [ c ] ++ ; } char [ ] bc = b . toCharArray ( ) ; for ( char c : bc ) { count [ c ] -- ; } for ( int i : count ) { if ( i != 0 ) return false ; } } return true ; }
va	6	subMapIterator ( Coord startCoord , int rangeX , int rangeY ) { this . latoDellaMappaIterator = getLatoDellaMappa ( ) ; if ( ! ( 0 <= startCoord . getX ( ) ) || ! ( 0 <= startCoord . getY ( ) ) || ! ( startCoord . getX ( ) < latoDellaMappaIterator ) || ! ( startCoord . getY ( ) < latoDellaMappaIterator ) || ! ( 0 <= rangeX ) || ! ( 0 <= rangeY ) ) throw new IndexOutOfBoundsException ( ) ; this . startRow = startCoord . getY ( ) ; this . startColumn = startCoord . getX ( ) ; this . rowRange = rangeY ; this . columnRange = rangeX ; this . latoDellaMappaIterator = getLatoDellaMappa ( ) ; curCoord = new Coord ( startColumn , startRow ) ; }
va	4	public String toNVPString ( String prefix ) throws UnsupportedEncodingException { StringBuilder sb = new StringBuilder ( ) ; if ( this . requestEnvelope != null ) { String newPrefix = prefix + "requestEnvelope." ; sb . append ( this . requestEnvelope . toNVPString ( newPrefix ) ) ; } if ( this . createAccountKey != null ) { sb . append ( prefix ) . append ( "createAccountKey=" ) . append ( NVPUtil . encodeUrl ( this . createAccountKey ) ) ; sb . append ( "&" ) ; } if ( this . countryCode != null ) { sb . append ( prefix ) . append ( "countryCode=" ) . append ( NVPUtil . encodeUrl ( this . countryCode ) ) ; sb . append ( "&" ) ; } if ( this . languageCode != null ) { sb . append ( prefix ) . append ( "languageCode=" ) . append ( NVPUtil . encodeUrl ( this . languageCode ) ) ; sb . append ( "&" ) ; } return sb . toString ( ) ; }
va	5	public void edit ( Expending expending ) throws NonexistentEntityException { EntityManager em = null ; try { em = getEntityManager ( ) ; em . getTransaction ( ) . begin ( ) ; expending = em . merge ( expending ) ; em . getTransaction ( ) . commit ( ) ; } catch ( Exception ex ) { String msg = ex . getLocalizedMessage ( ) ; if ( msg == null || msg . length ( ) == 0 ) { Integer id = expending . getId ( ) ; if ( findExpending ( id ) == null ) { throw new NonexistentEntityException ( Constant . NON_EXISTS_ERROR_MSG ) ; } } throw ex ; } finally { if ( em != null ) { em . close ( ) ; } } }
va	7	public void generateAggregatedReport ( ) { long start , end ; start = System . currentTimeMillis ( ) ; File reportFile = new File ( reportFileName ) ; PrintWriter reportOut = null ; boolean once = true ; try { reportOut = new PrintWriter ( reportFile ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } reportOut . println ( "Report Generation Time   " + timeStamp ) ; for ( int instanceNo = 0 ; instanceNo < instanceFiles . length ; instanceNo ++ ) { ProblemInstance problemInstance = createProblemInstance ( instanceFiles [ instanceNo ] , singleOutputFileName ) ; Scheme6 ga = new Scheme6 ( problemInstance ) ; if ( once ) { once = false ; reportOut . format ( "Number Of Generation  Population Size  Offspring Population Size  LoadPenalty  RouteTime Penalty\n" ) ; reportOut . format ( "%d  %d  %d  %f  %f\n" , ga . NUMBER_OF_GENERATION , ga . POPULATION_SIZE , ga . NUMBER_OF_OFFSPRING , loadPenaltyFactor , routeTimePenaltyFactor ) ; reportOut . println ( ) ; reportOut . println ( ) ; reportOut . format ( "Instance Name  Min  Avg  Max  Feasible \n" ) ; } double min = FFFFFF ; double max = - 1 ; double sum = 0 ; double avg ; int feasibleCount = 0 ; for ( int i = 0 ; i < runSize ; i ++ ) { Individual sol = ga . run ( ) ; if ( sol . isFeasible == true ) { feasibleCount ++ ; } sum += sol . costWithPenalty ; if ( sol . costWithPenalty > max ) max = sol . costWithPenalty ; if ( sol . costWithPenalty < min ) min = sol . costWithPenalty ; } avg = sum / runSize ; reportOut . format ( "%s  %f  %f  %f  %d \n" , instanceFiles [ instanceNo ] , min , avg , max , feasibleCount ) ; reportOut . flush ( ) ; System . out . format ( "%s  %f  %f  %f  %d \n" , instanceFiles [ instanceNo ] , min , avg , max , feasibleCount ) ; } end = System . currentTimeMillis ( ) ; long duration = ( end - start ) / 1000 ; long minute = duration / 60 ; long seconds = duration % 60 ; reportOut . println ( "\nELAPSED TIME : " + minute + " minutes " + seconds + " seconds" ) ; reportOut . flush ( ) ; reportOut . close ( ) ; }
va	8	protected void UnZip ( ) throws PrivilegedActionException { String path = ( String ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws Exception { return ( new StringBuilder ( ) ) . append ( Util . getWorkingDirectory ( ) ) . append ( File . separator ) . toString ( ) ; } final GameUpdater this$0 ; { this$0 = GameUpdater . this ; } } ) ; String szZipFilePath = ( new StringBuilder ( String . valueOf ( path ) ) ) . append ( "bin" ) . append ( File . separator ) . append ( "additional.zip" ) . toString ( ) ; File f = new File ( szZipFilePath ) ; if ( ! f . exists ( ) ) System . out . println ( ( new StringBuilder ( "\nNot found: " ) ) . append ( szZipFilePath ) . toString ( ) ) ; if ( f . isDirectory ( ) ) System . out . println ( ( new StringBuilder ( "\nNot file: " ) ) . append ( szZipFilePath ) . toString ( ) ) ; System . out . println ( "Enter path to extract files: " ) ; String szExtractPath = path ; File f1 = new File ( szExtractPath ) ; if ( ! f1 . exists ( ) ) System . out . println ( ( new StringBuilder ( "\nNot found: " ) ) . append ( szExtractPath ) . toString ( ) ) ; if ( ! f1 . isDirectory ( ) ) System . out . println ( ( new StringBuilder ( "\nNot directory: " ) ) . append ( szExtractPath ) . toString ( ) ) ; Vector zipEntries = new Vector ( ) ; try { teststring = szExtractPath + "/buildcraft" ; File fil = new File ( teststring ) ; del_cat ( fil ) ; teststring = szExtractPath + "/config" ; File fil2 = new File ( teststring ) ; del_cat ( fil2 ) ; teststring = szExtractPath + "/mods" ; File fil3 = new File ( teststring ) ; del_cat ( fil3 ) ; teststring = szExtractPath + "/redpower" ; File fil4 = new File ( teststring ) ; del_cat ( fil4 ) ; teststring = szExtractPath + "/resources" ; File fil5 = new File ( teststring ) ; del_cat ( fil5 ) ; ZipFile zf = new ZipFile ( szZipFilePath ) ; for ( Enumeration en = zf . entries ( ) ; en . hasMoreElements ( ) ; zipEntries . addElement ( ( ZipEntry ) en . nextElement ( ) ) ) ; for ( int i = 0 ; i < zipEntries . size ( ) ; i ++ ) { ZipEntry ze = ( ZipEntry ) zipEntries . elementAt ( i ) ; extractFromZip ( szZipFilePath , szExtractPath , ze . getName ( ) , zf , ze ) ; } zf . close ( ) ; if ( ! f . isDirectory ( ) ) f . delete ( ) ; System . out . println ( "Done!" ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
va	9X	public Administratorapp ( ) throws FileNotFoundException , IOException { int i ; BufferedReader fisier ; try { listModelSecretari = new DefaultListModel ( ) ; listModelProfesori = new DefaultListModel ( ) ; listModelElevi = new DefaultListModel ( ) ; fisier = new BufferedReader ( new FileReader ( "credentials" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( i = 0 ; i < vector . size ( ) ; i = i + 5 ) { if ( vector . get ( i + 4 ) . equals ( "Secretar" ) ) listModelSecretari . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Profesor" ) ) listModelProfesori . addElement ( vector . get ( i ) ) ; if ( vector . get ( i + 4 ) . equals ( "Elev" ) ) listModelElevi . addElement ( vector . get ( i ) ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Login . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } initComponents ( ) ; BufferedReader fisier2 = new BufferedReader ( new FileReader ( "clase" ) ) ; ArrayList < String > vector = new ArrayList < > ( ) ; for ( String line ; ( line = fisier2 . readLine ( ) ) != null ; ) { vector . add ( line ) ; } for ( int j = 0 ; j < vector . size ( ) ; j ++ ) clasaDeSters . addItem ( vector . get ( j ) ) ; BufferedReader fisier3 = new BufferedReader ( new FileReader ( "fmaterii" ) ) ; ArrayList < String > vector2 = new ArrayList < > ( ) ; for ( String line ; ( line = fisier3 . readLine ( ) ) != null ; ) { vector2 . add ( line ) ; } for ( int k = 0 ; k < vector . size ( ) ; k ++ ) materieDeSters . addItem ( vector2 . get ( k ) ) ; }
va	2	public static ProcessorLayer createProcessorLayerWithProcessorNeuron ( int neuronsNum , boolean bias ) { ProcessorLayer layer = new ProcessorLayer ( ) ; if ( bias ) { layer . addNeuron ( new BiasNeuron ( ) ) ; } for ( int i = 0 ; i < neuronsNum ; i ++ ) layer . addNeuron ( new ProcessorNeuron ( ) ) ; return layer ; }
va	9X	public ArrayList < ArrayList < Integer >> zigzagLevelOrder ( TreeNode root ) { ArrayList < ArrayList < Integer >> out = new ArrayList < ArrayList < Integer >> ( ) ; if ( root == null ) return out ; ValPack p = new ValPack ( ) ; p . node = root ; p . level = 0 ; LinkedList < ValPack > nodeList = new LinkedList < ValPack > ( ) ; LinkedList < ValPack > list = new LinkedList < ValPack > ( ) ; nodeList . addLast ( p ) ; int curLevel = 0 ; while ( nodeList . size ( ) != 0 ) { p = nodeList . removeFirst ( ) ; if ( p . level != curLevel ) { ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; list = new LinkedList < ValPack > ( ) ; curLevel = p . level ; } list . addLast ( p ) ; if ( p . node . left != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . left ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } if ( p . node . right != null ) { ValPack v = new ValPack ( ) ; v . node = p . node . right ; v . level = p . level + 1 ; nodeList . addLast ( v ) ; } } ArrayList < Integer > item = new ArrayList < Integer > ( ) ; while ( ! list . isEmpty ( ) ) { if ( curLevel % 2 == 0 ) item . add ( list . removeFirst ( ) . node . val ) ; else item . add ( list . removeLast ( ) . node . val ) ; } out . add ( item ) ; return out ; }
va	7	Writer write ( Writer writer , int indentFactor , int indent ) throws JSONException { try { boolean commanate = false ; int length = this . length ( ) ; writer . write ( [ ) ; if ( length == 1 ) { JSONObject . writeValue ( writer , this . myArrayList . get ( 0 ) , indentFactor , indent ) ; } else if ( length != 0 ) { final int newindent = indent + indentFactor ; for ( int i = 0 ; i < length ; i += 1 ) { if ( commanate ) { writer . write (   ) ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , newindent ) ; JSONObject . writeValue ( writer , this . myArrayList . get ( i ) , indentFactor , newindent ) ; commanate = true ; } if ( indentFactor > 0 ) { writer . write ( '' ) ; } JSONObject . indent ( writer , indent ) ; } writer . write ( ] ) ; return writer ; } catch ( IOException e ) { throw new JSONException ( e ) ; } }
va	5	@ Override public void work ( ) { try { Vertex v = getClickedVertex ( ) ; if ( v == null ) { gui . console ( "Choose a vertex" ) ; return ; } doFillVertex = true ; Queue < Vertex > q = new LinkedList < Vertex > ( ) ; v . visited = true ; q . add ( v ) ; while ( ! q . isEmpty ( ) ) { v = q . poll ( ) ; v . vColor = Color . RED ; for ( Edge e : v . adj ) { Vertex w = e . dest ; if ( ! w . visited ) { w . visited = true ; q . add ( w ) ; } } repaint ( ) ; sleep ( GUI_EXECUTION_PAUSE ) ; } } catch ( Exception e ) { } clearAll ( ) ; repaint ( ) ; }
va	1	public int length ( ) { LinkedListNode iter = this ; int acc = 0 ; while ( iter != null ) { acc ++ ; iter = iter . next ; } return acc ; }
va	8	@ Override public void actionPerformed ( ActionEvent e ) { String cmd = e . getActionCommand ( ) ; switch ( cmd ) { case FILTRAR : ctrlInformacion . filtrarContratos ( ) ; break ; case NOTAS_APTO_VER : ctrlInformacion . cargarDialogoVerNotasParticulares ( ) ; break ; case NOTAS_GRAL_VER : ctrlInformacion . cargarDialogoVerNotasGenerales ( ) ; break ; case NOTA_APTO_NUEVO : ctrlInformacion . cargarDialogoNuevaNotaParticular ( ) ; break ; case NOTA_GRAL_NUEVO : ctrlInformacion . cargarDialogoNuevaNotaGeneral ( ) ; break ; case RECARGAR_CONTRATOS : ctrlInformacion . cargarContratos ( ) ; break ; case VER_DATOS_RESPONSABLES : ctrlInformacion . cargarDialogoVerDatosResponsables ( ) ; break ; case VER_TELEFONOS : ctrlInformacion . cargarDialogoVerTelefonos ( ) ; break ; } }
va	0	public Sprite ( BufferedImage image , int frameHeight , int numberOfTiles , int frameDurations [ ] ) { animation = new Animation ( ) ; SpriteLoader . parseSprite ( image , frameHeight , numberOfTiles , frameDurations , animation ) ; }
va	6	void trace ( PgPolygonSet output , PdVector seed , int steps , double stepSize ) { output . addVertex ( seed ) ; PdVector cur = seed ; for ( int s = 1 ; s <= steps ; ++ s ) { PdVector last = cur ; cur = next ( cur , stepSize ) ; if ( cur == null ) { break ; } int vertex = output . addVertex ( cur ) ; output . addPolygon ( new PiVector ( vertex - 1 , vertex ) ) ; if ( PdVector . dist ( last , cur ) < ( stepSize / 10d ) ) { break ; } boolean stop = false ; for ( PdVector v : m_stops ) { if ( PdVector . dist ( v , cur ) < ( stepSize / 10d ) ) { stop = true ; break ; } } if ( stop ) { break ; } } }
va	0	public void setBankSwiftNo ( String bankSwiftNo ) { this . bankSwiftNo = bankSwiftNo ; }
va	9X	public static Op IT ( Op a , Op b ) { if ( a == null ) return null ; if ( b == null ) return a ; int at = a . getOpType ( ) , bt = b . getOpType ( ) ; if ( at == OpType . INSERT_CHAR && bt == OpType . INSERT_CHAR ) return ii ( ( Insertion ) a , ( Insertion ) b ) ; if ( at == OpType . DELETE_CHAR && bt == OpType . DELETE_CHAR ) return dd ( ( Deletion ) a , ( Deletion ) b ) ; if ( at == OpType . INSERT_CHAR && bt == OpType . DELETE_CHAR ) return id ( ( Insertion ) a , ( Deletion ) b ) ; if ( at == OpType . DELETE_CHAR && bt == OpType . INSERT_CHAR ) return di ( ( Deletion ) a , ( Insertion ) b ) ; return null ; }
va	3	public Ouvrage rechOuvrage ( String isbn ) { Ouvrage ouv = this . getOuvrage ( isbn ) ; if ( ouv == null ) { Message dialog = new Message ( "Ouvrage inconnu" ) ; } else { if ( this . getVue ( ) instanceof VueSaisieExemplaire ) { ouv . addObserver ( this . getVue ( ) ) ; this . getVue ( ) . setEtat ( Vue . inter1 ) ; ( ( VueSaisieExemplaire ) this . getVue ( ) ) . alimente ( ouv ) ; } if ( this . getVue ( ) instanceof VueConsultOuvrage ) { this . getVue ( ) . setEtat ( Vue . finale ) ; ( ( VueConsultOuvrage ) this . getVue ( ) ) . alimente ( ouv ) ; } } return ouv ; }
va	0	public void setId ( Integer id ) { this . id = id ; }
va	7	public void updateLyricsPane ( final Track t ) { if ( ! currentTrack . equals ( t ) ) { currentTrack = t ; new Thread ( ) { @ Override public void run ( ) { String artist = t . get ( "artist" ) ; String title = t . get ( "title" ) ; String lyrics ; if ( artist . equals ( "DOOOOOM" ) && title . equals ( "Please Give Us All An A" ) ) { lyrics = "Professor Bhola  give us all A's\n" ; lyrics += "Because we need to graduate!\n" ; lyrics += "[awesome guitar solo]\n" ; lyrics += "Professor Bhola  give us all A's\n" ; lyrics += "Because we need to graduate!\n" ; } else { if ( artist != null && ! artist . isEmpty ( ) && title != null && ! title . isEmpty ( ) ) { System . out . println ( "." ) ; lyrics = LyricsFetcher . fetchLyrics ( t . get ( "artist" ) , t . get ( "title" ) ) ; } else { lyrics = "[lyrics unavailable]" ; } } Platform . runLater ( new Runnable ( ) { String lyrics ; @ Override public void run ( ) { lyrics_text . setText ( lyrics ) ; } public Runnable init ( String lyrics ) { this . lyrics = lyrics ; return this ; } } . init ( lyrics ) ) ; } } . start ( ) ; } }
va	8	@ Override public void actionPerformed ( ActionEvent event ) { String userId = textField . getText ( ) ; String userList = textArea . getText ( ) ; if ( event . getSource ( ) == btn [ 0 ] ) { if ( userList . equals ( "" ) ) { JOptionPane . showMessageDialog ( null , "Add User" ) ; } else { StringTokenizer tokenizer = new StringTokenizer ( userList , "\n" ) ; String targetId [ ] = new String [ userList . length ( ) ] ; int i = 0 ; while ( tokenizer . hasMoreTokens ( ) ) { targetId [ i ] = tokenizer . nextToken ( ) ; i ++ ; } String data = ClientLauncher . getUser ( ) . getId ( ) + "\t" + ClientLauncher . getFrame ( ) . getDirectoryListPanel ( ) . getDirectoryID ( ) + "\t" + i ; int type = Constants . PacketType . ShareRequest . getType ( ) ; for ( int j = 0 ; j < i ; j ++ ) { data += "\t" + targetId [ j ] ; } int length = data . length ( ) ; ClientLauncher . getConnector ( ) . sendPacket ( type , 0 , length , data ) ; } textField . setText ( "" ) ; } if ( event . getSource ( ) == btn [ 1 ] ) { dispose ( ) ; initialize ( ) ; } if ( event . getSource ( ) == btn [ 2 ] ) { if ( userId . equals ( "" ) ) JOptionPane . showMessageDialog ( null , "Input user ID" ) ; else if ( userId . equals ( ClientLauncher . getUser ( ) . getId ( ) ) ) JOptionPane . showMessageDialog ( null , "Can't add your ID" ) ; else { String data = userId ; int type = Constants . PacketType . IdCheckRequest . getType ( ) ; int length = data . length ( ) ; ClientLauncher . getConnector ( ) . sendPacket ( type , 0 , length , data ) ; } } }
va	7	public Contact [ ] resize ( int currentSize , Integer capacity , Contact [ ] c ) { Contact [ ] copy ; if ( capacity == null ) { int j = 0 ; while ( j < c . length ) { if ( c [ j ] == null ) break ; j ++ ; } copy = new Contact [ j ] ; for ( int i = 0 ; i < copy . length ; i ++ ) { copy [ i ] = c [ i ] ; } return copy ; } copy = new Contact [ capacity ] ; if ( capacity > currentSize ) { for ( int i = 0 ; i < currentSize ; i ++ ) { copy [ i ] = c [ i ] ; } } else { for ( int i = 0 ; i < capacity ; i ++ ) { copy [ i ] = c [ i ] ; } } return copy ; }
va	5	public static MinimumCostInsertionInfo minimumCostInsertionPosition ( ProblemInstance problemInstance , int vehicle , int client , ArrayList < Integer > route ) { double min = 99999999 ; int chosenInsertPosition = - 1 ; double cost ; double [ ] [ ] costMatrix = problemInstance . costMatrix ; int depotCount = problemInstance . depotCount ; int depot = problemInstance . depotAllocation [ vehicle ] ; if ( route . size ( ) == 0 ) { MinimumCostInsertionInfo info = new MinimumCostInsertionInfo ( ) ; info . cost = costMatrix [ depot ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depot ] ; info . insertPosition = 0 ; info . loadViolation = - 1 ; info . vehicle = vehicle ; return info ; } cost = 0 ; cost = costMatrix [ depot ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depotCount + route . get ( 0 ) ] ; cost -= ( costMatrix [ depot ] [ depotCount + route . get ( 0 ) ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = 0 ; } for ( int insertPosition = 1 ; insertPosition < route . size ( ) ; insertPosition ++ ) { cost = costMatrix [ depotCount + route . get ( insertPosition - 1 ) ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depotCount + route . get ( insertPosition ) ] ; cost -= ( costMatrix [ depotCount + route . get ( insertPosition - 1 ) ] [ depotCount + route . get ( insertPosition ) ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = insertPosition ; } } cost = costMatrix [ depotCount + route . get ( route . size ( ) - 1 ) ] [ depotCount + client ] + costMatrix [ depotCount + client ] [ depot ] ; cost -= ( costMatrix [ depotCount + route . get ( route . size ( ) - 1 ) ] [ depot ] ) ; if ( cost < min ) { min = cost ; chosenInsertPosition = route . size ( ) ; } MinimumCostInsertionInfo info = new MinimumCostInsertionInfo ( ) ; info . cost = min ; info . insertPosition = chosenInsertPosition ; info . loadViolation = - 1 ; info . vehicle = vehicle ; return info ; }
va	9X	private QuerySet < T > range ( String query ) { QuerySet < T > querySet = null ; try { if ( query != null && ! query . trim ( ) . isEmpty ( ) ) { query = query . replace ( "__range" , "" ) ; query = query . replace ( "  " , " " ) ; query = query . replaceAll ( "['\\[\\]]" , "" ) ; String [ ] queryComponents = query . split ( "=" ) ; if ( queryComponents != null && queryComponents . length > 0 ) { querySet = new QuerySet < T > ( ) ; querySet . entity ( this . entity ) ; String fieldName = queryComponents [ 0 ] ; String [ ] fieldValues = queryComponents [ 1 ] . split ( " " ) ; Field field = null ; if ( fieldName . trim ( ) . equalsIgnoreCase ( "id" ) ) { field = this . entity . getSuperclass ( ) . getDeclaredField ( fieldName ) ; } else { field = this . entity . getDeclaredField ( fieldName ) ; } field . setAccessible ( true ) ; for ( T model : this ) { for ( int fieldValue = Integer . parseInt ( fieldValues [ 0 ] ) ; fieldValue <= Integer . parseInt ( fieldValues [ 1 ] ) ; fieldValue ++ ) { if ( field . get ( model ) . equals ( fieldValue ) ) { querySet . add ( model ) ; } } } } } } catch ( Exception e ) { e . printStackTrace ( ) ; } return querySet ; }
va	0	public void mouseExited ( MouseEvent e ) { }
va	5	public String getDescription ( ) { if ( kinds . size ( ) == 0 ) return "Gathering resources" ; String result = "Gathering " ; int i = 0 ; for ( Resource res : kinds ) { if ( i == kinds . size ( ) - 1 && i != 0 ) { result += " and " ; } else if ( i != 0 ) { result += "  " ; } result += res . name ; ++ i ; } return result ; }
va	2	public String toString ( ) { return "CREATE " + ( temporary ? "TEMPORARY " : "" ) + "TABLE " + ( exists ? "IF NOT EXISTS " : "" ) + name ; }
va	0	public double getPriceLevel3 ( ) { return priceLevel3 ; }
va	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( viewNGram . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new viewNGram ( ) . setVisible ( true ) ; } } ) ; }
va	7	@ Override public User getUser ( String login , String password ) throws DAOException { final String filename = Constants . ResourcePath + ConstantsXML . USERS_FILE_NAME ; final String CSV_SPLITTER = ";" ; Scanner sc = null ; synchronized ( CSVUserDAO . class ) { try { boolean found = false ; sc = new Scanner ( new FileReader ( filename ) ) ; Role role = null ; String [ ] str = null ; while ( sc . hasNext ( ) ) { str = sc . nextLine ( ) . split ( CSV_SPLITTER ) ; if ( str [ LOGIN_NUM ] . equals ( login ) && str [ PASSWORD_NUM ] . equals ( password ) ) { role = Role . valueOf ( str [ ROLE_NUM ] . toUpperCase ( ) ) ; found = true ; break ; } } if ( ! found ) { throw new DAOException ( Constants . INVALID_NAME_OR_PASSWORD ) ; } return new User ( login , password , str [ EMAIL_NUM ] , str [ PHONE_NUM ] , role , Integer . parseInt ( str [ ID_NUM ] ) ) ; } catch ( DAOException e ) { throw new DAOException ( e ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new DAOException ( Constants . INTERNAL_ERROR ) ; } finally { if ( sc != null ) { sc . close ( ) ; } } } }
va	5	@ Override public synchronized void onPlayerMove ( final Board b , int playerNr , int move ) { if ( playerNr == getNumber ( ) ) return ; if ( root . children . isEmpty ( ) ) throw new IllegalStateException ( "root has no children" ) ; for ( int i = 0 ; i < root . children . size ( ) ; i ++ ) { Node child = root . children . get ( i ) ; if ( child . move == move ) { child . parent . apply ( rootBoard ) ; child . parent = null ; root = child ; child . apply ( rootBoard ) ; if ( ! rootBoard . equals ( b ) ) { rootBoard . print ( ) ; b . print ( ) ; throw new IllegalStateException ( "boards do not match" ) ; } return ; } } throw new IllegalStateException ( "cannot move to the correct state" ) ; }
va	1	public double getRadius ( ) { if ( launched ) return 0 ; return 15 ; }
va	1	public void set ( int index , Object element ) throws illegalIndexException { if ( index < 0 ) { throw new illegalIndexException ( ) ; } tablica_stosu [ index ] = element ; }
va	1	public static TextureRegion get ( int x , int y , int width , int height ) { if ( texture == null ) texture = new Texture ( "spritesheet.png" , GL_LINEAR , GL_LINEAR ) ; return new TextureRegion ( texture , x , y , width , height ) ; }
va	7	public boolean isSolid ( int x , int y ) { if ( x < 0 || y < 0 || x >= surface . length || y >= surface . length ) return true ; if ( surface [ x ] [ y ] . isSolid ( ) ) return true ; for ( Entity e : entities ) { if ( e . isSolid ( x , y ) ) return true ; } return false ; }
va	3	private void refreshObservers ( ) { if ( client . isConnect ( ) ) { Integer studentsCount = client . getStudentsCount ( ) ; if ( studentsCount == null ) { studentsCount = - 1 ; } maxObserver . setText ( Integer . toString ( studentsCount ) ) ; Integer viewSize = client . getViewSize ( ) ; if ( viewSize == null ) { viewSize = - 1 ; } observer . setText ( Integer . toString ( viewSize ) ) ; } }
va	1	private static void createProduct ( ) { ProductUI productMenu = new ProductUI ( ) ; ProductService productService = new ProductService ( new ProductDAO ( ) ) ; try { ProductModel newProduct = productMenu . createProduct ( ) ; newProduct = productService . createProduct ( newProduct ) ; productMenu . showCreateSuccess ( newProduct ) ; } catch ( WebshopAppException e ) { ExceptionUI . printException ( e ) ; } }
va	6	@ Override public String getMessage ( ) { if ( this . server != null && this . server2 != null ) { return String . format ( "%s %s %s" , this . getCommandName ( ) , this . server , this . server2 ) ; } if ( this . server != null && this . server2 == null ) { return String . format ( "%s %s" , this . getCommandName ( ) , this . server ) ; } if ( this . server == null && this . server2 != null ) { return String . format ( "%s :%s" , this . getCommandName ( ) , this . server2 ) ; } throw new RuntimeException ( "This state should not happen. There is probably a bug in a constructor." ) ; }
va	6	private String getPage ( int page , Map < String , Object > map ) { int factor = 5 ; int index = ( page - 1 ) * factor ; int listSize = map . size ( ) ; if ( index > listSize ) { return "" ; } int upper = index + factor ; if ( upper >= listSize ) { upper = listSize ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( ChatColor . RED ) . append ( plugin . getName ( ) ) . append ( "\n" ) . append ( ChatColor . RESET ) ; sb . append ( "Page " ) . append ( page ) . append ( "/" ) . append ( ( int ) Math . ceil ( ( double ) listSize / ( double ) factor ) ) ; sb . append ( "\n" ) . append ( ChatColor . RESET ) ; String [ ] list = map . keySet ( ) . toArray ( new String [ listSize ] ) ; Arrays . sort ( list ) ; for ( int i = index ; i < upper ; i ++ ) { Object test = map . get ( list [ i ] ) ; if ( test != null ) { if ( test instanceof SubCommand ) { SubCommand db = ( SubCommand ) map . get ( list [ i ] ) ; sb . append ( db . getHelp ( ) [ 0 ] ) . append ( " - " ) . append ( db . getHelp ( ) [ 1 ] ) ; } if ( i != upper - 1 ) { sb . append ( "\n" ) ; } } } sb . append ( '' ) . append ( ChatColor . YELLOW ) . append ( "Use /ttp help <command> to get help for a specific command" ) ; return sb . toString ( ) ; }
va	7	static public Automaton concatenate ( Automaton a1 , Automaton a2 ) { if ( a1 . isSingleton ( ) && a2 . isSingleton ( ) ) return BasicAutomata . makeString ( a1 . singleton + a2 . singleton ) ; if ( isEmpty ( a1 ) || isEmpty ( a2 ) ) return BasicAutomata . makeEmpty ( ) ; boolean deterministic = a1 . isSingleton ( ) && a2 . isDeterministic ( ) ; if ( a1 == a2 ) { a1 = a1 . cloneExpanded ( ) ; a2 = a2 . cloneExpanded ( ) ; } else { a1 = a1 . cloneExpandedIfRequired ( ) ; a2 = a2 . cloneExpandedIfRequired ( ) ; } for ( State s : a1 . getAcceptStates ( ) ) { s . accept = false ; s . addEpsilon ( a2 . initial ) ; } a1 . deterministic = deterministic ; a1 . clearHashCode ( ) ; a1 . checkMinimizeAlways ( ) ; return a1 ; }
va	0	public synchronized long getHMillis ( ) { return ( long ) ( p . H * 1000.0 ) ; }
va	3	private void createTable ( ORMHash ht , ORMTable table ) throws SQLException { String createSQL = ht . createSQL ( ) ; String tableName = table . tableName ( ) ; int hashSize = ht . hashSize ( ) ; if ( hashSize < 1 ) { hashSize = 1 ; } List < String > alreadyExistTableList = dao . queryForSimpObjectList ( "show tables like '" + tableName + "%'" , new Object [ ] { } , String . class ) ; MessageFormat mf = new MessageFormat ( createSQL ) ; String hashTableName = null ; for ( int i = 0 ; i < hashSize ; i ++ ) { hashTableName = tableName + "_" + DBUtils . getInstance ( ) . hash ( i , hashSize ) ; if ( alreadyExistTableList . contains ( hashTableName ) ) { logger . trace ( "Hash Table[{}] is already exist!" , hashTableName ) ; } else { logger . info ( "Init hash table:{};" , hashTableName ) ; dao . update ( mf . format ( new Object [ ] { hashTableName } ) ) ; logger . info ( "Init hash table[{}] finish." , hashTableName ) ; } } }
va	3	@ Override public Storeable deserialize ( Table table , String value ) throws ParseException { JsonArray json = ( ( new JsonParser ( ) . parse ( value ) ) ) . getAsJsonArray ( ) ; List < Object > values = new ArrayList < > ( ) ; for ( int i = 0 ; i < json . size ( ) ; ++ i ) { values . add ( json . get ( i ) ) ; } Storeable storeable ; try { storeable = createFor ( table , values ) ; } catch ( IndexOutOfBoundsException e ) { throw new ParseException ( "Invalud number of arguments!" , 0 ) ; } catch ( ColumnFormatException e ) { throw new ParseException ( e . getMessage ( ) , 0 ) ; } return storeable ; }
va	4	@ Override public boolean equals ( Object otherObject ) { if ( this == otherObject ) return true ; if ( null == otherObject ) return false ; if ( getClass ( ) != otherObject . getClass ( ) ) return false ; StringsList other = ( StringsList ) otherObject ; return super . equals ( other ) && count == other . count ; }
va	2	private void parseErrorFromFile ( String filename , Kind ... expectedErrorKind ) { TokenStream stream = null ; try { stream = new TokenStream ( new BufferedReader ( new FileReader ( filename ) ) ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } Scanner s = new Scanner ( stream ) ; try { s . scan ( ) ; Parser p = new Parser ( stream ) ; p . parse ( ) ; int numErrors = p . errorList . size ( ) ; assertEquals ( expectedErrorKind . length , numErrors ) ; } catch ( LexicalException e ) { System . out . println ( "Lexical error parsing program: " ) ; System . out . println ( filename ) ; System . out . println ( e . toString ( ) ) ; System . out . println ( "---------" ) ; fail ( ) ; } }
va	5	private void handleFailed ( ) { uncompletedCount = 0 ; completedCount = 0 ; for ( OnDemandData onDemandData = ( OnDemandData ) requested . peekLast ( ) ; onDemandData != null ; onDemandData = ( OnDemandData ) requested . reverseGetNext ( ) ) if ( onDemandData . incomplete ) uncompletedCount ++ ; else completedCount ++ ; while ( uncompletedCount < 10 ) { OnDemandData onDemandData_1 = ( OnDemandData ) aClass19_1368 . popHead ( ) ; if ( onDemandData_1 == null ) break ; if ( filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] != 0 ) filesLoaded ++ ; filePriorities [ onDemandData_1 . dataType ] [ onDemandData_1 . id ] = 0 ; requested . insertHead ( onDemandData_1 ) ; uncompletedCount ++ ; closeRequest ( onDemandData_1 ) ; waiting = true ; } }
va	8	public void read ( org . apache . thrift . protocol . TProtocol iprot , MentionEntity struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TField schemeField ; iprot . readStructBegin ( ) ; while ( true ) { schemeField = iprot . readFieldBegin ( ) ; if ( schemeField . type == org . apache . thrift . protocol . TType . STOP ) { break ; } switch ( schemeField . id ) { case 1 : if ( schemeField . type == org . apache . thrift . protocol . TType . I64 ) { struct . id = iprot . readI64 ( ) ; struct . setIdIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 2 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . name = iprot . readString ( ) ; struct . setNameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; case 3 : if ( schemeField . type == org . apache . thrift . protocol . TType . STRING ) { struct . screen_name = iprot . readString ( ) ; struct . setScreen_nameIsSet ( true ) ; } else { org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } break ; default : org . apache . thrift . protocol . TProtocolUtil . skip ( iprot , schemeField . type ) ; } iprot . readFieldEnd ( ) ; } iprot . readStructEnd ( ) ; struct . validate ( ) ; }
va	4	@ Test public void doPriorityQueue ( ) { init ( ) ; int count = 0 ; while ( true ) { Point x = prQueue . poll ( ) ; squares . add ( x ) ; Point [ ] ppp = getPotentialPoints ( x , getCrossPoint ( x ) ) ; prQueue . add ( ppp [ 0 ] ) ; prQueue . add ( ppp [ 1 ] ) ; if ( count > 800000 ) break ; count ++ ; if ( x . hx == 3 && x . hy == 3 ) System . out . println ( "RESULT " + squares . size ( ) ) ; } System . out . println ( squares . get ( 49 ) . hx + " " + squares . get ( 49 ) . hy ) ; }
va	3	public void setRows ( int newRows ) { if ( newRows < 0 ) throw new IllegalArgumentException ( "number of rows cannot be negative" ) ; if ( newRows == 0 && cols == 0 ) throw new IllegalArgumentException ( "number of columns is already 0" ) ; this . rows = newRows ; }
va	2	private void AddNewUpdateTime ( float newTime ) { float addTime = newTime ; if ( addTime > 50 ) { addTime = 50 ; } if ( updateTimes . size ( ) >= NUM_UPDATE_TIMES ) { updateTimes . remove ( 0 ) ; } updateTimes . add ( newTime ) ; runTime += newTime ; }
va	2	public void registerProcessor ( OspreyProcessor < ? > processor ) { if ( null != processors . putIfAbsent ( processor . interest ( ) , processor ) ) { LOGGER . warn ( "Register Processor[" + processor . interest ( ) + "  " + processor + "]." , new Exception ( ) ) ; } }
va	5	public void runScript ( InputStream stream ) throws JStrykerException , IllegalArgumentException { if ( stream == null ) { throw new IllegalArgumentException ( "Stream cannot be null." ) ; } try { List < String > commands = parse ( stream ) ; for ( String command : commands ) { Statement statement = null ; try { statement = connection . createStatement ( ) ; statement . execute ( command . toString ( ) ) ; } finally { if ( statement != null ) { statement . close ( ) ; } } } } catch ( SQLException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } catch ( IOException e ) { throw new JStrykerException ( e . getMessage ( ) , e ) ; } }
va	5	@ Override public int hashCode ( ) { int result = gitPath != null ? gitPath . hashCode ( ) : 0 ; result = 31 * result + ( folder != null ? folder . hashCode ( ) : 0 ) ; result = 31 * result + ( filePath != null ? filePath . hashCode ( ) : 0 ) ; result = 31 * result + ( revision != null ? revision . hashCode ( ) : 0 ) ; result = 31 * result + ( charset != null ? charset . hashCode ( ) : 0 ) ; return result ; }
va	0	public BIOSwitch ( String onString , String offString ) { super ( onString ) ; create ( ) ; setOffString ( offString ) ; }
va	3	private boolean r_Step_5b ( ) { ket = cursor ; if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } bra = cursor ; if ( ! r_R2 ( ) ) { return false ; } if ( ! ( eq_s_b ( 1 , "l" ) ) ) { return false ; } slice_del ( ) ; return true ; }
va	3	public Queue getQueueById ( long queueId ) { Session session = null ; Queue queue = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; queue = ( Queue ) session . load ( Queue . class , queueId ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 'findById'" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } return queue ; }
va	0	public int getIdp ( ) { return this . idp ; }
va	4	public static boolean checkBSTInOrderTraversal ( Node root ) { if ( root == null ) { return true ; } if ( ! checkBSTInOrderTraversal ( root . left ) ) { return false ; } if ( root . value < min ) { return false ; } min = root . value ; if ( ! checkBSTInOrderTraversal ( root . right ) ) { return false ; } return true ; }
va	6	@ SuppressWarnings ( "deprecation" ) public static void insertTestData ( Connection databaseConnection ) throws SQLException { List < Student > studentList = new ArrayList < Student > ( ) ; studentList . add ( new Student ( "firstname_1" , "lastname_1" , new Date ( 80 , 1 , 1 ) , 2.1 ) ) ; studentList . add ( new Student ( "firstname_2" , "lastname_2" , new Date ( 80 , 1 , 2 ) , 2.2 ) ) ; studentList . add ( new Student ( "firstname_3" , "lastname_3" , new Date ( 80 , 1 , 3 ) , 2.3 ) ) ; studentList . add ( new Student ( "firstname_4" , "lastname_4" , new Date ( 80 , 1 , 4 ) , 2.4 ) ) ; studentList . add ( new Student ( "firstname_5" , "lastname_5" , new Date ( 80 , 1 , 5 ) , 2.5 ) ) ; studentList . add ( new Student ( "firstname_6" , "lastname_6" , new Date ( 80 , 1 , 6 ) , 2.6 ) ) ; studentList . add ( new Student ( "firstname_7" , "lastname_7" , new Date ( 80 , 1 , 7 ) , 2.7 ) ) ; studentList . add ( new Student ( "firstname_8" , "lastname_8" , new Date ( 80 , 1 , 8 ) , 2.8 ) ) ; PreparedStatement preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO STUDENT (FIRSTNAME  LASTNAME  BIRTHDATE  GPA) VALUES (? ? ? ?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Student student : studentList ) { preparedStatement . setString ( 1 , student . firstname ) ; preparedStatement . setString ( 2 , student . lastname ) ; preparedStatement . setDate ( 3 , student . birthdate ) ; preparedStatement . setDouble ( 4 , student . gpa ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { student . id = resultSet . getInt ( 1 ) ; } } List < Course > courseList = new ArrayList < Course > ( ) ; courseList . add ( new Course ( "course_1" ) ) ; courseList . add ( new Course ( "course_2" ) ) ; courseList . add ( new Course ( "course_3" ) ) ; courseList . add ( new Course ( "course_4" ) ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO COURSE (NAME) VALUES (?)" , PreparedStatement . RETURN_GENERATED_KEYS ) ; for ( Course course : courseList ) { preparedStatement . setString ( 1 , course . name ) ; preparedStatement . executeUpdate ( ) ; ResultSet resultSet = preparedStatement . getGeneratedKeys ( ) ; if ( resultSet . next ( ) ) { course . id = resultSet . getInt ( 1 ) ; } } Map < Integer , String > studentGradeMap = new HashMap < Integer , String > ( ) ; studentGradeMap . put ( 1 , "A" ) ; studentGradeMap . put ( 2 , "A-" ) ; studentGradeMap . put ( 3 , "B+" ) ; studentGradeMap . put ( 4 , "B" ) ; preparedStatement = databaseConnection . prepareStatement ( "INSERT INTO GRADE (STUDENT_ID  COURSE_ID  GRADE) VALUES (? ? ?)" ) ; for ( int i = 0 ; i < courseList . size ( ) ; i ++ ) { for ( int j = 0 ; j < ( i + 1 ) * 2 ; j ++ ) { int studentID = studentList . get ( j ) . id ; int courseID = courseList . get ( i ) . id ; String grade = studentGradeMap . get ( i + 1 ) ; preparedStatement . setInt ( 1 , studentID ) ; preparedStatement . setInt ( 2 , courseID ) ; preparedStatement . setString ( 3 , grade ) ; preparedStatement . executeUpdate ( ) ; } } }
va	0	public Iterator < ChannelUser > iterChannelUsers ( ) { return users . iterator ( ) ; }
va	9X	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; Option option = ( Option ) o ; if ( idoption != option . idoption ) return false ; if ( surveyIdsurvey != option . surveyIdsurvey ) return false ; if ( content != null ? ! content . equals ( option . content ) : option . content != null ) return false ; if ( number != null ? ! number . equals ( option . number ) : option . number != null ) return false ; return true ; }
va	4	@ Override public void add ( E pdato , int index ) { if ( 0 > index || _lenght < index ) { throw new IndexOutOfBoundsException ( "Fuera de rango: " + index ) ; } else if ( index == 0 ) { addi ( pdato ) ; } else if ( index == _lenght ) { add ( pdato ) ; } else { NodeDouble < E > tmp = getIndex ( index ) ; NodeDouble < E > tmp2 = new NodeDouble < E > ( pdato ) ; tmp . getPrev ( ) . setNext ( tmp2 ) ; tmp2 . setPrev ( tmp . getPrev ( ) ) ; tmp . setPrev ( tmp2 ) ; tmp2 . setNext ( tmp ) ; _lenght ++ ; } }
va	5	public Posicion obtenerPosicionRelativa ( final Posicion posicion , final int offset ) { int indice = - 1 ; for ( int i = 0 ; i < posiciones . size ( ) && indice == - 1 ; i ++ ) { if ( posiciones . get ( i ) == posicion ) { indice = i ; } } int posicionRelativa = indice + offset ; if ( posicionRelativa < 0 || posicionRelativa > posiciones . size ( ) - 1 ) { return new PosicionInexistente ( ) ; } return posiciones . get ( posicionRelativa ) ; }
va	6	private JsonSchema parse ( JsonNode rawSchema , URL currentSchemaLocation ) { if ( ! rawSchema . isObject ( ) ) { throw new IllegalArgumentException ( "A valid json schema must be an object" ) ; } JsonNode ref = rawSchema . get ( "$ref" ) ; if ( ref != null ) { URL referencedSchemaLocation ; try { referencedSchemaLocation = new URL ( currentSchemaLocation , ref . textValue ( ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( "The schema reference is malformed" , e ) ; } scheduleSchemaForProcessing ( referencedSchemaLocation ) ; return new SchemaReference ( cache , referencedSchemaLocation ) ; } String type = rawSchema . get ( "type" ) . asText ( ) ; if ( isSimpleTypeSchema ( type ) ) { return parseSimpleTypeSchema ( rawSchema ) ; } else if ( isObjectSchema ( type ) ) { return parseObjectSchema ( rawSchema , currentSchemaLocation ) ; } else if ( isArraySchema ( type ) ) { return parseArraySchema ( rawSchema , currentSchemaLocation ) ; } throw new IllegalArgumentException ( "Illegal schema type " + type ) ; }
va	4	private Node < V > addNextLessGreater ( Node < V > node , char c ) { while ( node . letter != c ) { if ( c < node . letter ) { if ( node . less == null ) { node . less = new Node < V > ( c ) ; return node . less ; } node = node . less ; } else { if ( node . greater == null ) { node . greater = new Node < V > ( c ) ; return node . greater ; } node = node . greater ; } } return node ; }
va	5	private void labelVertex ( Segment segment , long crossProduct , Path path ) { if ( crossProduct > 0 ) { if ( path . isInverted ) segment . end . type = Vertex . OUTIE ; else segment . end . type = Vertex . INNIE ; } else if ( crossProduct < 0 ) { if ( path . isInverted ) segment . end . type = Vertex . INNIE ; else segment . end . type = Vertex . OUTIE ; } else if ( segment . start . type != Vertex . NOT_SET ) segment . end . type = segment . start . type ; else segment . end . type = Vertex . INNIE ; }
va	7	public static void domNodeToTree ( Node domNode , TreeDomNode parentTreeNode , boolean displayNodeValue ) { if ( domNode instanceof Text ) return ; TreeDomNode treeNode = new TreeDomNode ( domNode , displayNodeValue ) ; parentTreeNode . add ( treeNode ) ; NamedNodeMap attributeNodes = domNode . getAttributes ( ) ; if ( ( attributeNodes != null ) && ( attributeNodes . getLength ( ) > 0 ) ) { for ( int i = 0 ; i < attributeNodes . getLength ( ) ; i ++ ) { treeNode . add ( new TreeDomNode ( attributeNodes . item ( i ) , displayNodeValue ) ) ; } } NodeList childNodes = domNode . getChildNodes ( ) ; if ( ( childNodes != null ) && ( childNodes . getLength ( ) > 0 ) ) { for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) domNodeToTree ( childNodes . item ( i ) , treeNode , displayNodeValue ) ; } }
va	3	public static void startClient ( ) { if ( ( client != null ) && client . isAlive ( ) ) { return ; } try { client = new Client ( ( Inet4Address ) Inet4Address . getLocalHost ( ) , Constants . port ) ; client . start ( ) ; } catch ( Exception e ) { GameLog . warn ( e ) ; } }
va	5	public static String replaceVariablesWithKeyword ( final String line ) { String text = line ; Pattern pattern = Pattern . compile ( "([_A-Za-z0-9\\.]{1 50})(?=(| )[\\;\\ \\+-\\=\\<\\>\\)\\[\\!])" ) ; Matcher matcher = pattern . matcher ( text ) ; while ( matcher . find ( ) ) { final String match = matcher . group ( ) ; String result = "\u00BAV" ; if ( utils . text . equals ( match , "true" ) ) { result = "\u00BATE" ; } else if ( utils . text . equals ( match , "false" ) ) { result = "\u00BAF" ; } else if ( utils . text . equals ( match , "null" ) ) { result = "\u00BANU" ; } else if ( utils . text . equals ( match , "return" ) ) { result = "\u00BAR" ; } text = text . replace ( matcher . group ( ) , result ) ; } return text ; }
va	9X	public Point getConnectionPoint ( Point ep ) { Point A = new Point ( position . x , position . y ) ; Point B = new Point ( position . x + getWidth ( ) , position . y ) ; Point C = new Point ( position . x , position . y + getHeight ( ) ) ; Point D = new Point ( position . x + getWidth ( ) , position . y + getHeight ( ) ) ; double distAB = new Line2D . float ( A , B ) . ptLineDist ( ep ) ; double distBD = new Line2D . float ( B , D ) . ptLineDist ( ep ) ; double distDC = new Line2D . float ( D , C ) . ptLineDist ( ep ) ; double distAC = new Line2D . float ( A , C ) . ptLineDist ( ep ) ; if ( distAB < distBD && distAB < distDC && distAB < distAC ) { return new Point ( ( position . x + getWidth ( ) ) / 2 , position . y ) ; } else if ( distBD < distAB && distBD < distDC && distBD < distAC ) { return new Point ( ( position . x + getWidth ( ) ) , ( position . y + getHeight ( ) ) ) ; } else if ( distDC < distAB && distDC < distBD && distDC < distAC ) { return new Point ( ( position . x + getWidth ( ) ) / 2 , ( position . y + getHeight ( ) ) ) ; } else if ( distAC < distAB && distAC < distBD && distAC < distDC ) { return new Point ( position . x , ( position . y + getHeight ( ) ) / 2 ) ; } else { return null ; } }
va	6	@ Override public boolean podeSeMover ( Posicao origem , Posicao destino , TabuleiroXadrez tabuleiro ) { if ( super . podeSeMover ( origem , destino , tabuleiro ) && tabuleiro . podeRealizarMovimentacao ( origem , destino ) ) if ( ( this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) == 0 ) && ( this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) > 0 ) || ( this . medeDeslocamentoPeca ( origem . getLinha ( ) , destino . getLinha ( ) ) > 0 ) && ( this . medeDeslocamentoPeca ( origem . getColuna ( ) , destino . getColuna ( ) ) == 0 ) ) return true ; return false ; }
va	2	private void listAllEmail ( List < Email > emailList , POP3Session session ) { String responseStr = null ; for ( int i = 0 ; i < emailList . size ( ) ; i ++ ) { if ( emailList . get ( i ) . isDeleted ( ) == false ) { responseStr = i + 1 + " " + EmailUtil . getEmailSize ( emailList . get ( i ) ) ; session . sendResponse ( responseStr ) ; } } }
va	2	public void back ( ) throws JSONException { if ( this . usePrevious || this . index <= 0 ) { throw new JSONException ( "Stepping back two steps is not supported" ) ; } this . index -= 1 ; this . character -= 1 ; this . usePrevious = true ; this . eof = false ; }
va	8	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { new DeliverClient ( ) . setVisible ( true ) ; } catch ( UnknownHostException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( DeliverClient . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; }
va	5	@ Override public void run ( ) { while ( beatWork ) { heartRate = messageResource . getHR ( ) ; if ( heartRate != 0 ) { int sleep = 1000 / heartRate ; try { Thread . sleep ( 40 * sleep ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } beat ( 1 ) ; try { Thread . sleep ( 20 * sleep ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } beat ( 0 ) ; } else { try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Main . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } }
va	7	public boolean initializeDb ( ) { try { if ( ! isdabaseInitialized ( ) ) { getDbConnection ( ) . createStatement ( ) . execute ( createString1 ) ; getDbConnection ( ) . createStatement ( ) . execute ( createString2 ) ; updateDb101b ( ) ; updateDb102b ( ) ; initStationData ( ) ; return true ; } if ( ! updatedTo ( APP_VERSION_101 ) && ! updatedTo ( APP_VERSION_102 ) ) { if ( ! updateDb101b ( ) ) { log . error ( "Unexpceted error  can't update to current version" ) ; System . exit ( 0 ) ; } } if ( ! updatedTo ( APP_VERSION_102 ) ) { if ( ! updateDb102b ( ) ) { log . error ( "Unexpceted error  can't update to current version" ) ; System . exit ( 0 ) ; } } } catch ( SQLException e ) { log . error ( "Error" , e ) ; } return false ; }
va	4	public static boolean getActionState ( int player , ACTION a ) { if ( player < 0 || player + 1 > KeyboardInput . number_players ) { DebugConsole . PrintError ( "Invalid player number: " + player ) ; return false ; } if ( KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 0 ] == true && KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 1 ] == true ) { KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 0 ] = false ; KeyboardInput . action [ player ] [ a . ordinal ( ) ] [ 1 ] = false ; return true ; } else return false ; }
va	2	@ Override public void onPairFailed ( ) { synchronized ( mListeners ) { for ( DiscoveryListener listener : mListeners ) { try { listener . onPairFailed ( ) ; } catch ( RuntimeException e ) { System . out . println ( "Error notifying listener." ) ; } } } System . out . println ( "onPairFailed" ) ; }
va	4	public void loadAbrev ( final MyDatabase mysql ) { String SQL1 = "SELECT abrev FROM sig_professorat where idSGD='" + this . idProfesor + "' " ; try { Statement st = mysql . createStatement ( ) ; ResultSet rs1 = mysql . getResultSet ( SQL1 , st ) ; while ( rs1 != null && rs1 . next ( ) ) { this . abrev = rs1 . getString ( "abrev" ) ; } if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( Profesores . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
va	2	public boolean removePrefFile ( CommonPrefEPFResource pfRem ) { if ( pfRem == null || pfRem . isConfig ( ) ) return false ; return prefFiles . remove ( pfRem ) ; }
va	5	private void analyze ( ) { double minPrice = double . POSITIVE_INFINITY ; for ( int i = 0 ; i < pricings . size ( ) ; i ++ ) { if ( pricings . get ( i ) . getType ( ) . equalsIgnoreCase ( "Base" ) ) bases . add ( i ) ; else if ( pricings . get ( i ) . getType ( ) . equalsIgnoreCase ( "Reward" ) ) rewards . add ( i ) ; else penalties . add ( i ) ; if ( minPrice > pricings . get ( i ) . getCurrentPrice ( ) ) { minPrice = pricings . get ( i ) . getCurrentPrice ( ) ; indexOfCheapest . clear ( ) ; indexOfCheapest . add ( i ) ; } else if ( minPrice == pricings . get ( i ) . getCurrentPrice ( ) ) { indexOfCheapest . add ( i ) ; } } }
va	6	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( AlcoholPolicy == null ) ? 0 : AlcoholPolicy . hashCode ( ) ) ; result = prime * result + ( ( CancellationDeadLine == null ) ? 0 : CancellationDeadLine . hashCode ( ) ) ; result = prime * result + ( ( CancellationPenalty == null ) ? 0 : CancellationPenalty . hashCode ( ) ) ; result = prime * result + ( ( CheckInTime == null ) ? 0 : CheckInTime . hashCode ( ) ) ; result = prime * result + ( ( CheckOutTime == null ) ? 0 : CheckOutTime . hashCode ( ) ) ; result = prime * result + ( ( SmokingPolicy == null ) ? 0 : SmokingPolicy . hashCode ( ) ) ; return result ; }
va	3	public Matrix getU ( ) { Matrix X = new Matrix ( n , n ) ; double [ ] [ ] U = X . getArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i <= j ) { U [ i ] [ j ] = LU [ i ] [ j ] ; } else { U [ i ] [ j ] = 0.0 ; } } } return X ; }
va	9X	public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append (   ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf (   ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( '' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == " ) ) { sb . append ( " ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >=   && c != " ) { sb . append ( c ) ; } } sb . append ( " ) ; } else { sb . append ( string ) ; } } } sb . append ( '' ) ; return sb . toString ( ) ; }
va	3	public int iterer ( int nb_plots , double vitesse , double intervalle_de_temps ) { int plot_indice = 1 , plots_restants = nb_plots ; this . plots = new ArrayList < Plot > ( ) ; this . distance_parcourue += this . vecteur_vitesse . getModule ( ) ; if ( this . distance_parcourue >= this . distance_totale ) { this . distance_restante = this . distance_parcourue - this . distance_totale ; this . distance_parcourue = this . distance_totale ; this . totalement_parcouru = true ; } this . position_courante . deplacerDe ( this . vecteur_vitesse ) ; this . plots . add ( new Plot ( this . position_courante ) ) ; if ( nb_plots <= 1 ) return nb_plots ; for ( plot_indice = 0 ; plot_indice < nb_plots - 1 ; plot_indice ++ ) { this . plots . add ( this . plots . get ( plot_indice ) . suivant ( this . vecteur_vitesse ) ) ; plots_restants -- ; } return plots_restants ; }
va	9X	public static void main ( String [ ] args ) { boolean ok = false ; long startTime , endTime ; LinkedList < Drone > mDroneArm = new LinkedList < > ( ) ; DroneQueue droneQueue = new DroneQueue ( mDroneArm ) ; Config config = Config . getInstance ( ) ; config . load ( "config.xml" ) ; clearKMLs ( ) ; String dirs [ ] = config . getOption ( Config . GTFS_DIRS ) . split ( " " ) ; int timeGap = config . getIntOption ( Config . GTFS_TIME_GAP ) ; GraphFrame gp = null ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp = new GraphFrame ( ) ; } final String password = Config . getInstance ( ) . getOption ( Config . SERVER_PASSWORD ) ; final int port = Config . getInstance ( ) . getIntOption ( Config . SERVER_PORT ) ; GPSPortal g = new GPSPortal ( port , password ) ; int id = 1 ; final double busSpeed = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_SPEED ) ; final double busUpdateTime = Config . getInstance ( ) . getDoubleOption ( Config . DRONE_UPDATE_SPEED ) ; boolean dronesActive = config . getBooleanOption ( Config . DRONES_ACTIVE ) ; if ( dronesActive ) { System . out . println ( "Drones Active!" ) ; } ArrayList < GTFS > gtfs = new ArrayList < > ( ) ; for ( String dir : dirs ) { dir = dir . trim ( ) ; System . out . println ( dir + "\n----------" ) ; try { startTime = System . currentTimeMillis ( ) ; GTFS current = new GTFS ( dir , timeGap ) ; gtfs . add ( current ) ; endTime = System . currentTimeMillis ( ) ; System . out . println ( dir + " loaded and parsed in " + ( ( endTime - startTime ) / 1000.0 ) + " seconds" ) ; System . out . println ( dir + " id: " + current . getID ( ) ) ; if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . adjustViewport ( current . getMinLon ( ) , current . getMinLat ( ) , current . getMaxLon ( ) , current . getMaxLat ( ) ) ; gp . addPaths ( current . getPaths ( ) ) ; } if ( dronesActive ) { for ( int i = 0 ; i < current . getPaths ( ) . size ( ) ; i ++ ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; if ( current . isValidService ( current . getPaths ( ) . get ( i ) . getServiceID ( ) ) && current . getPaths ( ) . get ( i ) . getEndTimecode ( ) > now ) { System . out . println ( dir + ": " + current . getPaths ( ) . get ( i ) ) ; droneQueue . addDrone ( new Drone ( id , current . getPaths ( ) . get ( i ) , busSpeed , busUpdateTime , "http://127.0.0.1:8080" , password , false ) ) ; id ++ ; } } } ok = true ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( ) ; } if ( config . getBooleanOption ( Config . DEBUG_DISPLAY ) ) { gp . setVisible ( true ) ; } boolean running = true ; int vListTimeout = Config . getInstance ( ) . getIntOption ( Config . VEHICLE_LIST_TIMEOUT ) ; System . out . println ( "Running..." ) ; while ( running ) { int now = timeToMinutes ( new SimpleDateFormat ( "HH:mm:ss" ) . format ( new Date ( ) ) ) ; Vehicle . cleanUp ( vListTimeout ) ; droneQueue . check ( now ) ; try { Thread . sleep ( 1000 ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( WTBBackend . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } System . gc ( ) ; running = ! droneQueue . isEmpty ( ) ; } }
va	9X	public void saveTraining ( String fileDict , String fileNgrams , String fileDMC , String fileHMM , String fileVLMC , boolean clear ) { if ( fileDict != null ) { trainDict ( ) ; dict . save ( fileDict ) ; if ( clear ) { dict = null ; dictTrained = false ; } } if ( fileNgrams != null ) { trainNgram ( ) ; ngrams . save ( fileNgrams ) ; if ( clear ) { ngrams = null ; ngramTrained = false ; } } if ( fileDMC != null ) { trainDMC ( ) ; dmc . save ( fileDMC ) ; if ( clear ) { dmc = null ; ngramTrained = false ; } } if ( fileHMM != null ) { trainHMM ( ) ; hmm . save ( fileHMM ) ; if ( clear ) { hmm = null ; hmmTrained = false ; } trainHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".end" ) ; trainCleanHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".clean.end" ) ; trainReestimatedHMMEnd ( ) ; hmmEnd . save ( fileHMM + ".reestimated.end" ) ; } if ( fileVLMC != null ) { trainVLMC ( ) ; vlmc . save ( fileVLMC ) ; if ( clear ) { vlmc = null ; vlmcTrained = false ; } } }
va	1	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser fc = new JFileChooser ( ) ; fc . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; int returnVal = fc . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { this . localBackupTF . setText ( fc . getSelectedFile ( ) . getAbsolutePath ( ) ) ; } }
va	6	public boolean act ( Agent agent , Action action ) { if ( energy_level <= 0 ) { agent . die ( ) ; updateViews ( msg ) ; return false ; } boolean flag = ( action != null ) ; if ( flag ) { SimulatedAgent a = ( SimulatedAgent ) agent ; int x = ( ( Integer ) a . getAttribute ( X ) ) . intValue ( ) ; int y = ( ( Integer ) a . getAttribute ( Y ) ) . intValue ( ) ; Percept p = sense ( a ) ; String msg = null ; String act = action . getCode ( ) ; int actionID = language . getActionIndex ( act ) ; switch ( actionID ) { case 4 : if ( ( ( boolean ) p . getAttribute ( language . getPercept ( 5 ) ) ) . booleanValue ( ) ) { structure [ x ] [ y ] |= ( 1 << 15 ) ; int bit_flag = ( 1 << 10 ) ; if ( ( structure [ x ] [ y ] & bit_flag ) == bit_flag ) { System . out . println ( "Eating good food..." ) ; energy_level = Math . min ( energy_level + INC_ENERGY_LEVEL , MAX_ENERGY_LEVEL ) ; } else { System . out . println ( "Eating bad food..." ) ; energy_level = Math . max ( energy_level - DEC_ENERGY_LEVEL , 0 ) ; } } else { msg = SimpleView . ERROR + "[There is not food. Eat action not executed]" ; } updateViews ( msg ) ; break ; default : if ( actionID == 2 ) { energy_level -- ; System . out . println ( energy_level ) ; } super . act ( agent , action ) ; break ; } } return flag ; }
va	5	public void writeRow ( RowDetails rowDetails ) { Util . checkForNotNull ( rowDetails , "rowDetails" ) ; generateRowData ( rowDetails ) ; DataExporterCallback callback = rowDetails . getTable ( ) . getCallback ( ) ; if ( callback != null ) { callback . beforeRow ( rowDetails ) ; } beforeRow ( rowDetails ) ; for ( int columnIndex = 0 ; columnIndex < rowDetails . getTable ( ) . getColumns ( ) . size ( ) ; columnIndex ++ ) { CellDetails cellDetails = new CellDetails ( rowDetails , columnIndex ) ; cellDetails . setCellValue ( rowDetails . getRow ( ) . getCellValue ( cellDetails ) ) ; cellDetails . setCellValue ( rowDetails . getRow ( ) . getCellValue ( cellDetails ) ) ; if ( callback != null ) { callback . beforeCell ( cellDetails ) ; } beforeRowCell ( cellDetails ) ; writeRowCell ( cellDetails ) ; afterRowCell ( cellDetails ) ; if ( callback != null ) { callback . afterCell ( cellDetails ) ; } } afterRow ( rowDetails ) ; if ( callback != null ) { callback . afterRow ( rowDetails ) ; } }
va	9X	public static void main ( String [ ] args ) throws Exception { int e1TotalWins = 0 , totalDraws = 0 , e1TotalLoses = 0 , e1WinAsPlayer1 = 0 , e1DrawAsPlayer1 = 0 , e1LoseAsPlayer1 = 0 , e1WinAsPlayer2 = 0 , e1DrawAsPlayer2 = 0 , e1LoseAsPlayer2 = 0 , e2TotalWins = 0 , e2TotalLoses = 0 , e2WinAsPlayer1 = 0 , e2DrawAsPlayer1 = 0 , e2LoseAsPlayer1 = 0 , e2WinAsPlayer2 = 0 , e2DrawAsPlayer2 = 0 , e2LoseAsPlayer2 = 0 ; Board boardTest1 = null ; Board initialPositionTest1 = null ; Board [ ] boardCollectionTest1 = null ; int currentIndexTest1 = 0 ; int numberOfMoveTest1 = 0 ; Player [ ] playersTest1 = { new Player ( "BoltzmannH5" , "BoltzmannH5" , "w" , 100000 ) , new Player ( "Charles_2" , "Charles_2" , "b" , 0 ) } ; int totalNumberOfMovesTest1 = 46 ; try { FileInputStream fisTest1 = new FileInputStream ( "50_boards_3.sav" ) ; ObjectInputStream oisTest1 = new ObjectInputStream ( fisTest1 ) ; boardCollectionTest1 = ( Board [ ] ) oisTest1 . readObject ( ) ; } catch ( Exception e ) { System . err . println ( "Error" + e . getMessage ( ) ) ; } long startTime = 0 , endTime = 0 ; startTime = System . currentTimeMillis ( ) ; for ( int testIndex = 1 ; testIndex <= 100 ; ++ testIndex ) { System . out . println ( "Test1: " + testIndex + " / 100" ) ; currentIndexTest1 = 0 ; numberOfMoveTest1 = 0 ; Player tmp = playersTest1 [ 0 ] ; playersTest1 [ 0 ] = playersTest1 [ 1 ] ; playersTest1 [ 1 ] = tmp ; if ( testIndex % 2 == 1 ) { boardTest1 = boardCollectionTest1 [ ( Integer ) testIndex / 2 ] ; initialPositionTest1 = boardTest1 . duplicate ( ) ; } else { boardTest1 = initialPositionTest1 . duplicate ( ) ; } while ( numberOfMoveTest1 < totalNumberOfMovesTest1 ) { if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "BoltzmannH5" ) ) { Tuple < Integer , Integer > move ; MonteCarloH5Boltzmann mc = new MonteCarloH5Boltzmann ( boardTest1 . duplicate ( ) , playersTest1 [ currentIndexTest1 ] . getColor ( ) , numberOfMoveTest1 , totalNumberOfMovesTest1 ) ; move = mc . uct ( playersTest1 [ currentIndexTest1 ] . getSimulationNumber ( ) ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } else if ( playersTest1 [ currentIndexTest1 ] . getType ( ) . equals ( "Charles_2" ) ) { Tuple < Integer , Integer > move ; Charles_2 charles = new Charles_2 ( playersTest1 [ currentIndexTest1 ] . getColor ( ) , boardTest1 ) ; move = charles . getMove ( ) ; boardTest1 . makeMove ( move , playersTest1 [ currentIndexTest1 ] . getColor ( ) ) ; ++ numberOfMoveTest1 ; currentIndexTest1 = ( currentIndexTest1 + 1 ) % 2 ; } } String gameOutcome = Rules . calculateScore ( boardTest1 ) ; BufferedWriter outputTest1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; outputTest1 . append ( "Match #" + testIndex ) ; outputTest1 . newLine ( ) ; outputTest1 . append ( "Player 1: " + playersTest1 [ 0 ] . getName ( ) + " Player 2: " + playersTest1 [ 1 ] . getName ( ) ) ; outputTest1 . newLine ( ) ; if ( gameOutcome . equals ( "0" ) ) { ++ totalDraws ; outputTest1 . append ( "Result: draw" ) ; outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1DrawAsPlayer1 ++ ; e2DrawAsPlayer2 ++ ; } else { e1DrawAsPlayer2 ++ ; e2DrawAsPlayer1 ++ ; } } else { if ( gameOutcome . equals ( playersTest1 [ 0 ] . getColor ( ) ) ) { outputTest1 . append ( "Result: " + playersTest1 [ 0 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 0 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer1 ++ ; e2LoseAsPlayer2 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer1 ++ ; e1LoseAsPlayer2 ++ ; } } else { outputTest1 . append ( "Result: " + playersTest1 [ 1 ] . getName ( ) + " wins" ) ; if ( playersTest1 [ 1 ] . getName ( ) . equals ( "Charles_2" ) ) { e1TotalWins ++ ; e2TotalLoses ++ ; e1WinAsPlayer2 ++ ; e2LoseAsPlayer1 ++ ; } else { e2TotalWins ++ ; e1TotalLoses ++ ; e2WinAsPlayer2 ++ ; e1LoseAsPlayer1 ++ ; } } outputTest1 . newLine ( ) ; outputTest1 . close ( ) ; } } endTime = System . currentTimeMillis ( ) ; BufferedWriter output1Test1 = new BufferedWriter ( new FileWriter ( "results_100k_3b_BoltzmannH5vCharles_2.txt" , true ) ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "*Summary (100k) 3-point board (t=2.5)*" ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Draw occurred: " + totalDraws ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 total wins: " + e2TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 total wins: " + e1TotalWins ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Play time: " + ( endTime - startTime ) / 1000 + " seconds." ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #1 : " + e2WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 wins as player #2 : " + e2WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #1 : " + e2DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 draws as player #2 : " + e2DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #1 : " + e2LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "BoltzmannH5 loses as player #2 : " + e2LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #1 : " + e1WinAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 wins as player #2 : " + e1WinAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #1 : " + e1DrawAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 draws as player #2 : " + e1DrawAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #1 : " + e1LoseAsPlayer1 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "Charles_2 loses as player #2 : " + e1LoseAsPlayer2 ) ; output1Test1 . newLine ( ) ; output1Test1 . append ( "========================================" ) ; output1Test1 . close ( ) ; }
va	4	public void fill ( final Color [ ] [ ] frameBuffer ) { if ( frameBuffer == null ) { throw new NullPointerException ( "'frameBuffer' must not be 'null'" ) ; } Color c = ( getAttributes ( ) . containsKey ( "color" ) ) ? ( Color ) getAttributes ( ) . get ( "color" ) : Color . white ; for ( int i = getP ( ) . get ( 0 , 0 ) . intValue ( ) ; i < getP ( ) . get ( 0 , 0 ) . intValue ( ) + getD ( ) . get ( 0 , 0 ) . intValue ( ) ; ++ i ) { for ( int j = getP ( ) . get ( 1 , 0 ) . intValue ( ) ; j < getP ( ) . get ( 1 , 0 ) + getD ( ) . get ( 1 , 0 ) ; ++ j ) { frameBuffer [ i ] [ j ] = c ; } } }
va	4	public static void main ( String args [ ] ) { if ( args . length == 0 ) { try { System . out . println ( "Enter file path:" ) ; wc ( new InputStreamReader ( System . in ) ) ; System . out . println ( lines + " " + words + " " + chars ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } ; } else { int twords = 0 , tchars = 0 , tlines = 0 ; for ( int i = 0 ; i < args . length ; i ++ ) { try { words = chars = lines = 0 ; wc ( new FileReader ( args [ i ] ) ) ; twords += words ; tchars += chars ; tlines += lines ; System . out . println ( args [ i ] + ": " + lines + " " + words + " " + chars ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . out . println ( args [ i ] + ": error." ) ; } } System . out . println ( "total: " + tlines + " " + twords + " " + tchars ) ; } }
va	2	public synchronized void delete ( ) { if ( swigCPtr != 0 ) { if ( swigCMemOwn ) { swigCMemOwn = false ; otapiJNI . delete_Storable ( swigCPtr ) ; } swigCPtr = 0 ; } }
va	6	public static void main ( String [ ] args ) { if ( args . length <= 0 ) { System . out . println ( "At least one arg (pebbler project) must be" + "specified" ) ; } String projectFileName = args [ 0 ] ; String nextFlag = args . length > 1 ? args [ 1 ] : "" ; boolean createBook = nextFlag . equals ( "--createBook" ) ? true : false ; File projectFile = new File ( projectFileName ) ; if ( ! projectFile . exists ( ) || ! projectFile . isFile ( ) ) { System . out . println ( "Couldn't find file: " + projectFile . getPath ( ) ) ; System . exit ( - 1 ) ; } System . out . println ( "Getting file from: " + projectFile . getPath ( ) ) ; PebblerProject project = PebblerProject . fromJson ( silentRead ( projectFile ) ) ; File fullFile = new File ( projectFile . getAbsolutePath ( ) ) ; String fullPath = fullFile . getParentFile ( ) . getAbsolutePath ( ) ; project . compile ( fullPath ) ; if ( createBook ) { TypeSetter typeSetter = new TypeSetter ( project ) ; typeSetter . createBook ( fullPath ) ; } }
va	2	public static int getStats ( ) { if ( found == 0 || all == 0 ) return 0 ; int stats = ( int ) ( ( 100 * found ) / all ) ; return stats ; }
va	8	public String ValidarCampo ( ComprobanteVenta BEEntidades ) { Result rs = new Result ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( Common . IsMinorOrEqualsZero ( BEEntidades . getNumero ( ) ) ? "Numero inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getEmpresa ( ) ) ? "Empresa inv\u00E1lido " : "" ) ; sb . append ( Common . IsMinorOrEqualsZero ( BEEntidades . getMoneda ( ) ) ? "Moneda inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_emision ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_vencimiento ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getFecha_pago ( ) ) ? "Fecha inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getObservaciones ( ) ) ? "Observacion inv\u00E1lido " : "" ) ; sb . append ( Common . IsNullOrEmpty ( BEEntidades . getEstado ( ) ) ? "Esado inv\u00E1lido " : "" ) ; rs . SetResult ( ResultType . Advertencia , "Error de campo" , sb . toString ( ) ) ; return rs . toString ( ) ; }
te	0	public boolean isFinished ( ) { return isFinished ; }
te	6	public void run ( ) { isRunning = true ; int frames = 0 ; double frameCounter = 0 ; game . init ( ) ; double lastTime = Time . getTime ( ) ; double unprocessedTime = 0 ; while ( isRunning ) { boolean render = false ; double startTime = Time . getTime ( ) ; double passedTime = startTime - lastTime ; lastTime = startTime ; unprocessedTime += passedTime ; frameCounter += passedTime ; while ( unprocessedTime > frameTime ) { render = true ; unprocessedTime -= frameTime ; if ( Window . isCloseRequested ( ) ) stop ( ) ; game . input ( ( float ) frameTime ) ; Input . update ( ) ; game . update ( ( float ) frameTime ) ; if ( frameCounter >= 1 ) { frames = 0 ; frameCounter = 0 ; } } if ( render ) { game . render ( renderingEngine ) ; Window . render ( ) ; frames ++ ; } else { try { Thread . sleep ( 1 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } cleanup ( ) ; }
te	3	public static boolean isLeapYear ( int y ) { if ( ( y % 4 == 0 && y % 100 != 100 ) || y % 400 == 0 ) return true ; else return false ; }
te	7	public static String [ ] delimitedListToStringArray ( String str , String delimiter , String charsToDelete ) { if ( str == null ) { return new String [ 0 ] ; } if ( delimiter == null ) { return new String [ ] { str } ; } List < String > result = new ArrayList < String > ( ) ; if ( "" . equals ( delimiter ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result . add ( deleteAny ( str . substring ( i , i + 1 ) , charsToDelete ) ) ; } } else { int pos = 0 ; int delPos ; while ( ( delPos = str . indexOf ( delimiter , pos ) ) != - 1 ) { result . add ( deleteAny ( str . substring ( pos , delPos ) , charsToDelete ) ) ; pos = delPos + delimiter . length ( ) ; } if ( str . length ( ) > 0 && pos <= str . length ( ) ) { result . add ( deleteAny ( str . substring ( pos ) , charsToDelete ) ) ; } } return toStringArray ( result ) ; }
te	0	public boolean isAlreadyExistPassenger ( Passenger passenger ) { log . debug ( "Start isAlreadyExistPassenger select" ) ; List results = em . createQuery ( "select count(*)\n" + "from Passenger passenger \n" + "where passenger.firstname = ?\n" + "and passenger.lastname = ?\n" + "and passenger.birthday = ?" ) . setParameter ( 1 , passenger . getFirstname ( ) ) . setParameter ( 2 , passenger . getLastname ( ) ) . setParameter ( 3 , passenger . getBirthday ( ) ) . getResultList ( ) ; return ( long ) results . get ( 0 ) != 0 ; }
te	6	protected void sendRequest ( StatesOfClient state ) { resetState ( ) ; setState ( state ) ; pmfc . printWhichStateIsTesting ( ) ; try { if ( CURL_HTTP_PORT != 443 ) { client = vertx . createHttpClient ( ) . setPort ( CURL_HTTP_PORT ) . setHost ( CURL_HTTP_HOST ) ; } else { client = vertx . createHttpClient ( ) . setSSL ( true ) . setTrustAll ( true ) . setPort ( CURL_HTTP_PORT ) . setHost ( CURL_HTTP_HOST ) ; } mCurlCommandsSetter = mCurlCommandsSetterFactory . createSetter ( getState ( ) ) ; mCurlCommandsSetter . execute ( state ) ; pmfc . printCurrentRequestAndPathInCurlCommand ( ) ; requestSendFromClienttoServer = client . request ( BehaviorOfCurlCommandsSetter . currentRequest , BehaviorOfCurlCommandsSetter . currentPath , new Handler < HttpClientResponse > ( ) { @ Override public void handle ( HttpClientResponse responseRecievedAtClientFromServer ) { statusCode = responseRecievedAtClientFromServer . statusCode ( ) ; responseRecievedAtClientFromServer . bodyHandler ( new Handler < Buffer > ( ) { @ Override public void handle ( Buffer body ) { try { try { pmfc . printMessageFromServer ( body ) ; currentServerResponseInJsonFormat = new JsonObject ( body . toString ( ) ) ; getDataFromDB ( ) ; } catch ( Exception e ) { } mAssertionChecker = mAssertionCheckerFactory . createChecker ( getState ( ) ) ; mAssertionChecker . execute ( getState ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { pmfc . printEnd ( ) ; testComplete ( ) ; } } } ) ; } } ) . exceptionHandler ( new Handler < Throwable > ( ) { @ Override public void handle ( Throwable t ) { t . printStackTrace ( ) ; } } ) ; try { headersSetUp ( ) ; jsonBodySetUp ( ) ; } catch ( Exception e ) { } } catch ( Exception e ) { fail ( e . getMessage ( ) ) ; } finally { if ( client != null ) { client . close ( ) ; } } }
te	9X	@ Override public boolean equals ( Object obj ) { boolean result = false ; if ( this == obj ) { result = true ; } else if ( obj != null && obj instanceof Contributor ) { Contributor other = ( Contributor ) obj ; if ( ( this . domain == null && this . domain == other . domain ) || ( this . domain != null && this . domain . equals ( other . domain ) ) ) { if ( ( this . name == null && this . name == other . name ) || ( this . name != null && this . name . equals ( other . name ) ) ) { result = true ; } } } return result ; }
te	1	public void test_SimpleDateFormat_parse_minusYyyy ( ) { final String target = "-2007-04-05 00:00:00" ; final SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss" ) ; Date date ; try { date = format . parse ( target ) ; } catch ( ParseException e ) { throw new RuntimeException ( "Failed to parse the string: " + target , e ) ; } String actual = toString ( date , "GGGyyyy-MM-dd HH:mm:ss.SSS" ) ; log ( actual ) ; assertEquals ( "\u7D00\u5143\u524D2008-04-05 00:00:00.000" , actual ) ; assertNotNull ( date ) ; }
te	9X	private void paint ( Display display , GC gc ) { Color white = colors . getWhite ( ) ; Color black = colors . getBlack ( ) ; Color grey30 = colors . getGrey30 ( ) ; Color grey50 = colors . getGrey50 ( ) ; Color grey80 = colors . getGrey80 ( ) ; Color grey120 = colors . getGrey120 ( ) ; int clientWidth = nWhiteKeys * keyWidth + 10 ; int leftMargin = ( getWidget ( ) . getBounds ( ) . width - clientWidth - 20 ) / 2 + 5 ; Pitch pitch ; pitch = new Pitch ( "a0" ) ; gc . setBackground ( grey30 ) ; gc . fillRectangle ( leftMargin - borderWidth , topMargin - borderWidth - 1 , nWhiteKeys * keyWidth + borderWidth * 2 + 1 , keyHeight + borderWidth + 2 ) ; gc . setBackground ( grey30 ) ; gc . setForeground ( grey120 ) ; gc . fillGradientRectangle ( leftMargin - borderWidth + 1 , topMargin - borderWidth , nWhiteKeys * keyWidth + borderWidth * 2 - 1 , topMargin , true ) ; for ( int x = 0 ; x < nWhiteKeys ; x ++ ) { Color selected = getSelectedColor ( pitch ) ; gc . setForeground ( black ) ; gc . setBackground ( ( selected != null ) ? selected : white ) ; gc . fillRectangle ( leftMargin + keyWidth * x , topMargin , keyWidth , keyHeight ) ; gc . drawRectangle ( leftMargin + keyWidth * x , topMargin , keyWidth , keyHeight ) ; pitch = pitch . nextSemitone ( ) ; if ( x % 7 != 1 && x % 7 != 4 ) { pitch = pitch . nextSemitone ( ) ; } } pitch = new Pitch ( "a#0" ) ; for ( int x = 0 ; x < nWhiteKeys - 1 ; x ++ ) { if ( x % 7 == 1 || x % 7 == 4 ) { pitch = pitch . nextSemitone ( ) ; continue ; } Color selected = getSelectedColor ( pitch ) ; int left = leftMargin + keyWidth * x + keyWidth / 2 + blackMargin ; int width = keyWidth - blackMargin * 2 + 1 ; gc . setForeground ( black ) ; gc . setBackground ( ( selected != null ) ? selected : black ) ; gc . fillRectangle ( left , topMargin , width , blackKeyHeight ) ; gc . drawRectangle ( left , topMargin , width , blackKeyHeight ) ; if ( selected == null ) { gc . setBackground ( grey50 ) ; gc . fillRectangle ( left + 1 , topMargin + blackKeyHeight - 5 , width - 1 , 5 ) ; gc . setForeground ( grey80 ) ; gc . drawLine ( left + 1 , topMargin + blackKeyHeight - 5 , left + width - 1 , topMargin + blackKeyHeight - 5 ) ; } pitch = pitch . nextSemitone ( ) ; pitch = pitch . nextSemitone ( ) ; } }
te	2	public void loadExtension ( class < ? > cls ) { try { enableExtension ( this . instantiateExtension ( cls ) ) ; } catch ( ExtensionException e ) { MinePing . staticlogger . log ( Level . SEVERE , "Failed to load Extension: " + e ) ; } }
te	5	public SLA checkSLAAllocationCostMin ( SLA slaTemplate ) { SLA slaAllocation = ( SLA ) slaTemplate . clone ( ) ; Map < String , Type [ ] > allocations = new HashMap < String , Type [ ] > ( ) ; Set < Type > allTypes = slaAllocation . getHeadNode ( ) . getConnectedTypes ( ) ; Type someType = allTypes . iterator ( ) . next ( ) ; List < Resource > orderedResources = new ArrayList < Resource > ( ) ; orderedResources . addAll ( resources . values ( ) ) ; Collections . sort ( orderedResources , new CostMinComparator ( someType . getStartTime ( ) , someType . getDuration ( ) ) ) ; Iterator < Resource > resourceIterator = orderedResources . iterator ( ) ; Iterator < Type > typeIterator = allTypes . iterator ( ) ; Resource r = resourceIterator . next ( ) ; List < Type > typesForAResource = new ArrayList < Type > ( ) ; while ( typeIterator . hasNext ( ) ) { Type t = typeIterator . next ( ) ; typesForAResource . add ( t ) ; while ( ! r . isTypesFitting ( typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ) { typesForAResource . remove ( t ) ; if ( resourceIterator . hasNext ( ) ) { if ( typesForAResource . size ( ) > 0 ) { allocations . put ( r . getId ( ) , typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ; typesForAResource = new ArrayList < Type > ( ) ; } typesForAResource . add ( t ) ; r = resourceIterator . next ( ) ; } else { return null ; } } } if ( typesForAResource . size ( ) > 0 ) { allocations . put ( r . getId ( ) , typesForAResource . toArray ( new Type [ typesForAResource . size ( ) ] ) ) ; } slaAllocation . setAllocation ( allocations ) ; return slaAllocation ; }
te	5	public static void print ( java . lang . String format , int amount , boolean vertical , Object ... objects ) { if ( objects != null ) { java . lang . String [ ] formats = null ; if ( format != null && ! format . isEmpty ( ) ) { formats = format . split ( " " ) ; } if ( formats . length == objects . length ) { for ( int i = 0 ; i < objects . length ; i ++ ) { $ . print ( formats [ i ] , objects [ i ] , 1 , vertical ) ; } } } }
te	2	public void processLogout ( Login login ) { if ( login != null && ! Util . nullOrEmptyOrBlank ( login . getEmail ( ) ) ) { Volunteer volunteer = getVolunteerByEmail ( login . getEmail ( ) ) ; LoggedInVolunteer loggedInVolunteer = volunteer . getLogin ( ) ; loggedInVolunteer . setLoggedout ( new Date ( ) ) ; sessionFactory . getCurrentSession ( ) . update ( loggedInVolunteer ) ; } }
te	8	private Section processSection ( StartElement se , XMLEventReader eventReader , String derivedNamespace ) throws XMLStreamException { Section s = new Section ( ) ; Iterator < Attribute > attributes = se . getAttributes ( ) ; while ( attributes . hasNext ( ) ) { Attribute attr = attributes . next ( ) ; s . addAttribute ( attr . getName ( ) . getLocalPart ( ) , attr . getValue ( ) ) ; } boolean endTagReached = false ; while ( ! endTagReached ) { XMLEvent event = eventReader . nextTag ( ) ; if ( event . isStartElement ( ) ) { se = event . asStartElement ( ) ; if ( se . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Obs" ) && se . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( derivedNamespace ) ) { Obs o = processObs ( se , eventReader ) ; s . getObs ( ) . add ( o ) ; } } else if ( event . isEndElement ( ) ) { EndElement ee = event . asEndElement ( ) ; if ( ee . getName ( ) . getLocalPart ( ) . equalsIgnoreCase ( "Section" ) && ee . getName ( ) . getNamespaceURI ( ) . equalsIgnoreCase ( derivedNamespace ) ) { endTagReached = true ; } } } return s ; }
te	7	private static void argsCommand ( String [ ] args ) { for ( int i = 0 ; i < args . length ; i ++ ) { switch ( args [ i ] . toLowerCase ( ) ) { case "-ip" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { networkIP = args [ i + 1 ] . split ( ":" , 2 ) [ 0 ] . trim ( ) ; rmiPort = Integer . parseInt ( args [ i + 1 ] . split ( ":" , 2 ) [ 1 ] . trim ( ) ) ; i ++ ; } else { System . out . println ( "Invalid arguments for -ip" ) ; } break ; case "-tcp" : tcpPort = Integer . parseInt ( args [ i + 1 ] . trim ( ) ) ; i ++ ; break ; case "-multicast" : if ( args [ i + 1 ] . trim ( ) . split ( ":" ) . length == 2 ) { multicastIP = args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 0 ] ; multicastPort = Integer . parseInt ( args [ i + 1 ] . trim ( ) . split ( ":" , 2 ) [ 1 ] ) ; i ++ ; } else { System . out . println ( "Invalid arguments for -multicast" ) ; } break ; case "-help" : System . out . println ( "SystemY Server application - 2014" ) ; System . out . println ( "Starts the server for connecting to SystemY. SystemY is a distributed file system for local networks." ) ; System . out . println ( "\nOptions: " ) ; System . out . println ( "\t-ip {ip}:{port}\t\tThe given ip will be used for all communication from the server to the network.\n\t\t\t\tThe ip must be the ip of the physical interface connected to the local network with SystemY." ) ; System . out . println ( "\t-tcpPort {port}\tThis feature is for future purposes." ) ; System . out . println ( "\t-multicast {ip}:{port}\tThis feature is for future purposes." ) ; System . exit ( 0 ) ; default : System . out . println ( "Unkown option '" + args [ i ] + "'" ) ; break ; } } }
te	3	public boolean writeObject ( Object o ) throws ConnectionLostException { if ( socket == null ) throw new ConnectionLostException ( ) ; if ( o != null ) { try { oos . reset ( ) ; oos . writeObject ( o ) ; oos . flush ( ) ; return true ; } catch ( IOException e ) { System . err . println ( "Socket Exception: Cannot write to socket." ) ; socket = null ; throw new ConnectionLostException ( "Socket Exception: Cannot write to socket." ) ; } } return false ; }
te	5	public static void main ( final String [ ] argv ) throws IOException { if ( argv . length == 0 ) { printInfoAndExit ( ) ; } else if ( "-index" . equals ( argv [ 0 ] ) && argv . length >= 4 ) { final int length = argv . length - 4 ; final String [ ] arrPKsToIgnore = new String [ length ] ; System . arraycopy ( argv , 4 , arrPKsToIgnore , 0 , length ) ; index ( argv [ 1 ] , argv [ 2 ] , argv [ 3 ] , arrPKsToIgnore ) ; } else if ( "-benchmark" . equals ( argv [ 0 ] ) && argv . length >= 3 ) { final int length = argv . length - 2 ; final String [ ] arrConfigFiles = new String [ length ] ; System . arraycopy ( argv , 2 , arrConfigFiles , 0 , length ) ; benchmark ( argv [ 1 ] , arrConfigFiles ) ; } else { printInfoAndExit ( ) ; } }
te	3	private void addMountanSides ( ) { for ( int i = 0 ; i < map . length - 2 ; i ++ ) { for ( int j = 0 ; j < map [ 0 ] . length - 2 ; j ++ ) { if ( map [ i ] [ j ] . existTileOfType ( new Mountains ( ) ) ) { map [ i ] [ j + 1 ] . add ( new MountainSide ( ) ) ; map [ i ] [ j + 2 ] . add ( new MountainSide ( ) ) ; } } } }
te	6	public void transform ( String originalFile , String thumbnailFile , int thumbWidth , int thumbHeight , int quality ) throws Exception { try { Image image = javax . imageio . ImageIO . read ( new File ( originalFile ) ) ; double thumbRatio = ( double ) thumbWidth / ( double ) thumbHeight ; int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; double imageRatio = ( double ) imageWidth / ( double ) imageHeight ; if ( thumbRatio < imageRatio ) { thumbHeight = ( int ) ( thumbWidth / imageRatio ) ; } else { thumbWidth = ( int ) ( thumbHeight * imageRatio ) ; } if ( imageWidth < thumbWidth && imageHeight < thumbHeight ) { thumbWidth = imageWidth ; thumbHeight = imageHeight ; } else if ( imageWidth < thumbWidth ) thumbWidth = imageWidth ; else if ( imageHeight < thumbHeight ) thumbHeight = imageHeight ; BufferedImage thumbImage = new BufferedImage ( thumbWidth , thumbHeight , BufferedImage . TYPE_INT_RGB ) ; Graphics2D graphics2D = thumbImage . createGraphics ( ) ; graphics2D . setBackground ( Color . WHITE ) ; graphics2D . setPaint ( Color . WHITE ) ; graphics2D . fillRect ( 0 , 0 , thumbWidth , thumbHeight ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; graphics2D . drawImage ( image , 0 , 0 , thumbWidth , thumbHeight , null ) ; javax . imageio . ImageIO . write ( thumbImage , "JPG" , new File ( thumbnailFile ) ) ; } catch ( Exception e ) { System . out . println ( "Image not found" ) ; } }
te	8	private void initContent ( ) { setBounds ( 100 , 100 , 450 , 306 ) ; getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; contentPanel . setLayout ( null ) ; lblName = new JLabel ( "Name:" ) ; lblName . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblName . setBounds ( 21 , 22 , 86 , 20 ) ; contentPanel . add ( lblName ) ; lblLevel = new JLabel ( "Level:" ) ; lblLevel . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblLevel . setBounds ( 21 , 51 , 86 , 20 ) ; contentPanel . add ( lblLevel ) ; { lblCapacity = new JLabel ( "Capacity:" ) ; lblCapacity . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblCapacity . setBounds ( 21 , 82 , 86 , 20 ) ; contentPanel . add ( lblCapacity ) ; } { lblStudentAge = new JLabel ( "Student Age:" ) ; lblStudentAge . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblStudentAge . setBounds ( 21 , 113 , 86 , 20 ) ; contentPanel . add ( lblStudentAge ) ; } { lblTeacher = new JLabel ( "Teacher(s):" ) ; lblTeacher . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblTeacher . setBounds ( 21 , 144 , 86 , 20 ) ; contentPanel . add ( lblTeacher ) ; } { panel_1 = new JPanel ( ) ; panel_1 . setBorder ( new TitledBorder ( UIManager . getBorder ( "TitledBorder.border" ) , "Schedule" , TitledBorder . LEADING , TitledBorder . TOP , null , new Color ( 0 , 0 , 0 ) ) ) ; panel_1 . setBounds ( 277 , 6 , 155 , 158 ) ; contentPanel . add ( panel_1 ) ; panel_1 . setLayout ( null ) ; JButton btnAdd = new JButton ( "Add" ) ; btnAdd . setFocusTraversalKeysEnabled ( false ) ; btnAdd . setFocusable ( false ) ; btnAdd . setFocusPainted ( false ) ; btnAdd . setPreferredSize ( new Dimension ( 30 , 23 ) ) ; btnAdd . setMargin ( new Insets ( 2 , 2 , 2 , 2 ) ) ; btnAdd . setMaximumSize ( new Dimension ( 40 , 23 ) ) ; btnAdd . setMinimumSize ( new Dimension ( 30 , 23 ) ) ; btnAdd . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; btnAdd . setBounds ( 10 , 13 , 67 , 23 ) ; btnAdd . setIcon ( StaticRes . ADD16_ICON ) ; btnAdd . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { ScheduleSelectDialog ssd ; try { Group_schedule group_schedule = new Group_schedule ( ) ; group_schedule . setGroup ( group . getId ( ) ) ; ssd = new ScheduleSelectDialog ( null , "Schedule for " + group . getName ( ) , ModalityType . DOCUMENT_MODAL , GroupsDialog . this , group_schedule ) ; ssd . setVisible ( true ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } } } ) ; panel_1 . add ( btnAdd ) ; DefaultListModel listModel = new DefaultListModel ( ) ; for ( Group_schedule obj : this . schedule_list ) { listModel . addElement ( obj ) ; } list = new JList ( listModel ) ; list . setVisibleRowCount ( 5 ) ; list . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; list . setCellRenderer ( new ListCellRenderer ( ) { protected DefaultListCellRenderer defaultRenderer = new DefaultListCellRenderer ( ) ; @ Override public Component getListCellRendererComponent ( JList list , Object o , int i , boolean selected , boolean cellHasFocus ) { JLabel label = ( JLabel ) defaultRenderer . getListCellRendererComponent ( list , o , i , selected , cellHasFocus ) ; Group_schedule gschedule = ( Group_schedule ) o ; label . setText ( gschedule . getName ( ) ) ; return label ; } } ) ; list . setBounds ( 10 , 40 , 135 , 107 ) ; panel_1 . add ( list ) ; JButton btnRemove = new JButton ( "Remove" ) ; btnRemove . setBounds ( 78 , 13 , 67 , 23 ) ; btnRemove . setFocusTraversalKeysEnabled ( false ) ; btnRemove . setFocusable ( false ) ; btnRemove . setFocusPainted ( false ) ; btnRemove . setPreferredSize ( new Dimension ( 30 , 23 ) ) ; btnRemove . setMargin ( new Insets ( 2 , 2 , 2 , 2 ) ) ; btnRemove . setMaximumSize ( new Dimension ( 40 , 23 ) ) ; btnRemove . setMinimumSize ( new Dimension ( 30 , 23 ) ) ; btnRemove . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; btnRemove . setIcon ( StaticRes . DELETE16_ICON ) ; btnRemove . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { int index = list . getSelectedIndex ( ) ; Group_schedule gschedule = ( Group_schedule ) list . getSelectedValue ( ) ; if ( index >= 0 ) { ( ( DefaultListModel ) list . getModel ( ) ) . removeElement ( gschedule ) ; lblDispTeacher . setText ( getTeacher ( getTeacherFromList ( ) ) ) ; } } } ) ; panel_1 . add ( btnRemove ) ; } txtName = new JTextField ( ) ; txtName . setBounds ( 117 , 24 , 150 , 20 ) ; txtName . setText ( this . name ) ; contentPanel . add ( txtName ) ; txtName . setColumns ( 10 ) ; { txtCapacity = new JTextField ( ) ; txtCapacity . setColumns ( 10 ) ; txtCapacity . setText ( String . valueOf ( this . capacity ) ) ; txtCapacity . setBounds ( 117 , 84 , 150 , 20 ) ; txtCapacity . addKeyListener ( new KeyAdapter ( ) { public void keyTyped ( KeyEvent ke ) { char c = ke . getKeyChar ( ) ; if ( ! Character . isDigit ( c ) ) ke . consume ( ) ; } } ) ; contentPanel . add ( txtCapacity ) ; } LevelDAO lDAO = new LevelDAO ( db . connection ) ; cbLevel = new JComboBox ( ) ; if ( this . level_id < 1 ) { Level l = new Level ( ) ; l . setName ( "Select level" ) ; l . setId ( 0 ) ; cbLevel . addItem ( l ) ; } List < Level > levelList = lDAO . getLevelList ( ) ; for ( Level level : levelList ) { cbLevel . addItem ( level ) ; if ( level . getId ( ) == this . level_id ) { cbLevel . setSelectedItem ( level ) ; } } cbLevel . setRenderer ( new ComboBoxRenderer ( ) ) ; cbLevel . setBounds ( 117 , 53 , 150 , 20 ) ; contentPanel . add ( cbLevel ) ; cbStudentAge = new JComboBox ( ) ; cbStudentAge . setBounds ( 117 , 115 , 150 , 20 ) ; contentPanel . add ( cbStudentAge ) ; lblDispTeacher = new JLabel ( getTeacher ( getTeacherFromList ( ) ) ) ; lblDispTeacher . setFont ( new Font ( "Tahoma" , Font . PLAIN , 14 ) ) ; lblDispTeacher . setBounds ( 117 , 144 , 150 , 20 ) ; contentPanel . add ( lblDispTeacher ) ; { panel = new JPanel ( ) ; panel . setBorder ( UIManager . getBorder ( "MenuBar.border" ) ) ; FlowLayout flowLayout = ( FlowLayout ) panel . getLayout ( ) ; flowLayout . setAlignment ( FlowLayout . LEFT ) ; getContentPane ( ) . add ( panel , BorderLayout . NORTH ) ; { lblGroup = new JLabel ( "Group" ) ; lblGroup . setFont ( new Font ( "Tahoma" , Font . PLAIN , 18 ) ) ; lblGroup . setIcon ( StaticRes . GROUP48_ICON ) ; panel . add ( lblGroup ) ; } } { JPanel buttonPane = new JPanel ( ) ; buttonPane . setLayout ( new FlowLayout ( FlowLayout . RIGHT ) ) ; getContentPane ( ) . add ( buttonPane , BorderLayout . SOUTH ) ; { JButton okButton = new JButton ( "OK" ) ; okButton . setIcon ( StaticRes . OK_ICON ) ; okButton . setActionCommand ( "OK" ) ; okButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . out . println ( "OK Clicked!" ) ; if ( checkAndSaveGroup ( ) ) { dispose ( ) ; result . returnObject ( GroupsDialog . this . group ) ; } else { } } } ) ; buttonPane . add ( okButton ) ; getRootPane ( ) . setDefaultButton ( okButton ) ; } { JButton cancelButton = new JButton ( "Cancel" ) ; cancelButton . setActionCommand ( "Cancel" ) ; cancelButton . setIcon ( StaticRes . CANCEL_ICON ) ; cancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { System . out . println ( "Cancel Clicked!" ) ; dispose ( ) ; } } ) ; buttonPane . add ( cancelButton ) ; } } }
te	1	public int anotaClase ( String idProf , String idProfReal , int idHoras , ArrayList < Integer > grupAsigInClass ) { int nup = 0 ; Iterator it = grupAsigInClass . iterator ( ) ; while ( it . hasNext ( ) ) { int idgrupasig = ( ( Number ) it . next ( ) ) . intValue ( ) ; nup += new ClasesAnotadas ( idProf , idProfReal , idHoras , idgrupasig , client ) . save ( ) ; } return nup ; }
te	1	public void startRepairGUI ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { frame = new RepairGUI ( ) ; frame . setVisible ( true ) ; result = query . query ( nameTBL , 1 , nameID ) ; maxID = query . getLastID ( nameTBL , nameID ) ; insertValues ( result ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; }
te	5	public static boolean interactSlot ( int slot , String action ) { if ( ! checkIndex ( slot ) || ! setExpanded ( true ) ) return false ; if ( action == null || action . length ( ) == 0 ) return useSlot ( slot ) ; WidgetChild child = getMainChild ( slot ) ; if ( child . visible ( ) ) { return child . interact ( action ) ; } return false ; }
te	8	public void enterElement ( String name , Attributes attrs ) throws Exception { if ( customParser != null ) { customParser . enterElement ( name , attrs ) ; return ; } if ( name . equals ( "Keyring" ) ) { done = false ; return ; } if ( name . equals ( "Protocols" ) ) { return ; } if ( name . equals ( "Protocol" ) ) { String type = attrs . getValue ( "type" ) ; String clName = attrs . getValue ( "class" ) ; try { class < ? > cl = class . forName ( clName ) ; AP_Generic . registerHandler ( type , cl . asSubclass ( AP_Generic . class ) ) ; } catch ( Exception e ) { throw new SAXException ( "Unknown authentication protocol class: " + clName ) ; } return ; } if ( name . equals ( "Identity" ) ) { proto = attrs . getValue ( "proto" ) ; domain = attrs . getValue ( "domain" ) ; AP_Generic parser = AP_Generic . getInstance ( proto ) ; if ( parser == null ) throw new SAXException ( "Unknown authentication protocol: " + proto ) ; parser . initParse ( attrs ) ; customParser = parser ; return ; } }
te	0	@ Override public HandlerList getHandlers ( ) { return handlers ; }
te	9X	public static < KEY , VALUE > Map < KEY , VALUE > runIdempotentTasks ( Collection < ? extends IDependentTask < KEY , VALUE >> tasks , ExecutorService es , int maxRounds ) throws Exception { final Map < KEY , VALUE > out = new HashMap < KEY , VALUE > ( ) ; Map < KEY , IDependentTask < KEY , VALUE >> allTasks = new HashMap < KEY , MraUtils . IDependentTask < KEY , VALUE >> ( ) ; for ( IDependentTask < KEY , VALUE > t : tasks ) { allTasks . put ( t . getTaskID ( ) , t ) ; } Set < KEY > remaining = new HashSet < KEY > ( allTasks . keySet ( ) ) ; Set < KEY > done = new HashSet < KEY > ( ) ; Map < KEY , Integer > failures = new HashMap < KEY , Integer > ( ) ; while ( remaining . size ( ) > 0 ) { Set < KEY > toRun = new HashSet < KEY > ( ) ; for ( KEY k : remaining ) { if ( done . containsAll ( allTasks . get ( k ) . getDependsOn ( ) ) ) { toRun . add ( k ) ; } } if ( toRun . size ( ) == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } Map < KEY , Future < VALUE >> futures = new HashMap < KEY , Future < VALUE >> ( ) ; int submitted = 0 ; for ( KEY k : toRun ) { final IDependentTask < KEY , VALUE > t = allTasks . get ( k ) ; boolean block = false ; if ( failures . containsKey ( k ) ) { if ( failures . get ( k ) > maxRounds ) { block = true ; } } if ( ! block ) { submitted ++ ; futures . put ( k , es . submit ( new Callable < VALUE > ( ) { @ Override public VALUE call ( ) throws Exception { return t . call ( out ) ; } } ) ) ; } } if ( submitted == 0 ) { throw new IllegalStateException ( "can't run any more tasks" ) ; } for ( KEY k : futures . keySet ( ) ) { try { out . put ( k , futures . get ( k ) . get ( ) ) ; done . add ( k ) ; } catch ( Exception e ) { if ( failures . containsKey ( k ) ) { failures . put ( k , failures . get ( k ) + 1 ) ; } else { failures . put ( k , 1 ) ; } logger . warnf ( "exception running %s: %s" , k , e ) ; e . printStackTrace ( ) ; } } remaining . removeAll ( done ) ; } return out ; }
te	5	public String toString ( boolean printHeaderRow , String additionalColumnHeader , String additionalColumnValue ) { final List < Identifier > keys = new ArrayList < Identifier > ( variables . keySet ( ) ) ; Collections . sort ( keys , new Comparator < Identifier > ( ) { @ Override public int compare ( Identifier o1 , Identifier o2 ) { final int result = o1 . getValue ( ) . compareTo ( o2 . getValue ( ) ) ; if ( o1 . getValue ( ) . length ( ) < o2 . getValue ( ) . length ( ) ) { return - 1 ; } return result ; } } ) ; final List < String > columns = new ArrayList < > ( ) ; final List < String > values = new ArrayList < > ( ) ; final List < Integer > columnWidths = new ArrayList < > ( ) ; for ( Identifier id : keys ) { columns . add ( id . getValue ( ) ) ; values . add ( variables . get ( id ) != null ? variables . get ( id ) . toString ( true ) : null ) ; columnWidths . add ( width ( id . getValue ( ) ) ) ; } final boolean hasAdditionalColumn = StringUtils . isNotBlank ( additionalColumnHeader ) ; if ( hasAdditionalColumn ) { columns . add ( additionalColumnHeader ) ; values . add ( additionalColumnValue ) ; columnWidths . add ( width ( additionalColumnHeader ) ) ; } StringBuilder buffer = new StringBuilder ( ) ; if ( printHeaderRow ) { printHeaderLine ( buffer , columns , columnWidths , hasAdditionalColumn ) ; buffer . append ( "\n" ) ; } printSeparatorLine ( buffer , columns , columnWidths , hasAdditionalColumn ) ; buffer . append ( "\n" ) ; printValues ( buffer , values , columnWidths , hasAdditionalColumn ) ; return buffer . toString ( ) ; }
te	8	private void writeHeader ( ) throws IOException { row [ 0 ] = row [ 1 ] = row [ 2 ] = row [ 3 ] = "" ; int columnNumber = 4 ; for ( int i = 0 ; i < columns . get ( "" ) . size ( ) ; i ++ ) row [ columnNumber ++ ] = "" ; for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) if ( ! entry . getKey ( ) . equals ( "" ) ) for ( int i = 0 ; i < entry . getValue ( ) . size ( ) ; i ++ ) row [ columnNumber ++ ] = entry . getKey ( ) ; currentPointWriter . write ( ( String . join ( ";" , row ) + "\n" ) . getBytes ( ) ) ; row [ 0 ] = "Point#" ; row [ 1 ] = "Experiment#" ; row [ 2 ] = "Year#" ; row [ 3 ] = "After subiteration" ; columnNumber = 4 ; for ( Column column : columns . get ( "" ) ) row [ columnNumber ++ ] = column . dynamicValueName ; for ( Entry < String , List < Column >> entry : columns . entrySet ( ) ) if ( ! entry . getKey ( ) . equals ( "" ) ) for ( Column column : entry . getValue ( ) ) row [ columnNumber ++ ] = column . toString ( ) ; currentPointWriter . write ( ( String . join ( ";" , row ) + "\n" ) . getBytes ( ) ) ; }
te	4	public boolean remove ( Object x ) { outprint += "boolean remove Object x\n" ; int h = x . hashCode ( ) ; if ( h < 0 ) { h = - h ; } h = h % buckets . length ; Node current = buckets [ h ] ; Node previous = null ; while ( current != null ) { if ( current . data . equals ( x ) ) { if ( previous == null ) { buckets [ h ] = current . next ; } else { previous . next = current . next ; } currentSize -- ; return true ; } previous = current ; current = current . next ; } return false ; }
te	7	public long piece_can_reach ( int piece_index , int steps ) { long piece_bb = 1 << piece_index ; int piece_type = getPieceType ( piece_bb ) ; int piece_colour = piece_type & 01 ; long friend_bb = colour_bb [ piece_colour ] & ~ piece_bb ; int trap_num = trap_number [ piece_index ] ; if ( trap_num != - 1 ) { if ( ( TRAP [ trap_num ] & friend_bb ) != 0 ) { if ( ( TOUCH_TRAP [ trap_num ] & colour_bb [ piece_colour ] ) == piece_bb ) { friend_bb ^= TRAP [ trap_num ] ; } } } long unfrozen_sq_bb = ( touching_bb ( friend_bb ) | ( touching_bb ( colour_bb [ player ] ) & piece_bb ) | ~ touching_bb ( stronger_enemy_bb [ piece_type ] ) ) ; if ( ( unfrozen_sq_bb & piece_bb ) == 0 ) { return piece_bb ; } long bad_trap_bb = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( ( TOUCH_TRAP [ i ] & friend_bb ) == 0 ) { bad_trap_bb |= TRAP [ i ] ; } } long good_sq_bb = unfrozen_sq_bb & empty_bb & ~ bad_trap_bb ; long reached_bb = piece_bb ; for ( int i = 1 ; i < steps ; i ++ ) { reached_bb |= touching_bb ( reached_bb , piece_type ) & good_sq_bb ; } reached_bb |= touching_bb ( reached_bb , piece_type ) & empty_bb & ~ bad_trap_bb ; return reached_bb ; }
te	4	private Tag readTag ( ) { Tag retval = null ; String token = null ; try { readTo ( OPEN ) ; } catch ( final Exception e ) { return null ; } try { token = readTo ( CLOSE ) ; if ( token != null ) { token = token . trim ( ) ; if ( token . length ( ) > 0 ) { retval = new Tag ( token ) ; } } } catch ( final IOException e ) { throw error ( "Could not read a complete tag: IO error" ) ; } return retval ; }
te	8	private void runSpikingProblem ( Evolution evo ) { outputScreen . setText ( "" ) ; int populationSize = Integer . parseInt ( populationSizeField . getText ( ) ) ; int generations = Integer . parseInt ( generationsField . getText ( ) ) ; SpikingNeuronProblem sn = ( SpikingNeuronProblem ) problem ; List < Individual > individuals = problem . createPopulation ( populationSize ) ; try { long startTime = System . nanoTime ( ) ; for ( int i = 0 ; i < generations ; i ++ ) { individuals = evo . runGeneration ( individuals ) ; Individual best = individuals . get ( 0 ) ; for ( Individual ind : individuals ) { if ( ind . age ( ) > 0 ) { if ( ind . fitness ( ) > best . fitness ( ) ) { best = ind ; } } } String formattedString = outputScreen . getText ( ) ; formattedString += "Generation " + ( i + 1 ) + ": " + best . toString ( ) + "\n" ; outputScreen . setText ( formattedString ) ; Plot2DPanel plot = new Plot2DPanel ( ) ; BaseLabel title = new BaseLabel ( "Generation: " + ( i + 1 ) + "  " + problemBox . getSelectedItem ( ) . toString ( ) + "  " + adultBox . getSelectedItem ( ) . toString ( ) + "  " + parentBox . getSelectedItem ( ) . toString ( ) + "  mutation: " + mutationRateField . getText ( ) + "%  crossover: " + crossoverRateField . getText ( ) + "%" , Color . BLACK , 0.5 , 1.1 ) ; plot . addPlotable ( title ) ; plot . addLinePlot ( "Target" , Color . RED , sn . target ) ; SpikingNeuronPhenotype snPheno = ( SpikingNeuronPhenotype ) best . phenotype ( ) ; plot . addLinePlot ( "Best individual" , Color . BLUE , snPheno . spiketrain ) ; plot . addLegend ( "SOUTH" ) ; graphpanel . add ( plot ) ; CardLayout card = ( CardLayout ) graphpanel . getLayout ( ) ; card . last ( graphpanel ) ; if ( i % 10 == 0 ) System . out . println ( ( double ) ( System . nanoTime ( ) - startTime ) / 1000000000.0 ) ; } evo . drawBestFitnessPlot ( ) ; String teXLabel = "Generations: " + generations + "\\\\" + "\n" + "Population: " + populationSize + "\\\\" + "\n" + "Adult Selection: " + adultBox . getSelectedItem ( ) . toString ( ) ; if ( adultBox . getSelectedItem ( ) . toString ( ) . equals ( "Overproduction" ) ) { teXLabel += "( \\%)\\\\\n" ; } else teXLabel += "\\\\\n" ; if ( adultBox . getSelectedItem ( ) . toString ( ) . equals ( "Generational Mixing" ) ) { teXLabel += "( Adult spots: )\n" ; } else teXLabel += "\n" ; teXLabel += "Selection Method: " + parentBox . getSelectedItem ( ) . toString ( ) + "\\\\" + "\n" + "Mutation :" + mutationRateField . getText ( ) + "\\%" + "\\\\" + "\n" + "Crossover: " + crossoverRateField . getText ( ) + "\\% \\\\" + "\n" ; System . out . println ( teXLabel ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
te	7	@ Override public boolean nextKeyValue ( ) throws IOException , InterruptedException { if ( key == null ) { key = new LongWritable ( ) ; } key . set ( pos ) ; if ( value == null ) { value = new Text ( ) ; } value . clear ( ) ; final Text endline = new Text ( "\n" ) ; int newSize = 0 ; for ( int i = 0 ; i < NLINESTOPROCESS ; i ++ ) { Text v = new Text ( ) ; while ( pos < end ) { newSize = in . readLine ( v , maxLineLength , Math . max ( ( int ) Math . min ( Integer . MAX_VALUE , end - pos ) , maxLineLength ) ) ; value . append ( v . getBytes ( ) , 0 , v . getLength ( ) ) ; value . append ( endline . getBytes ( ) , 0 , endline . getLength ( ) ) ; if ( newSize == 0 ) { break ; } pos += newSize ; if ( newSize < maxLineLength ) { break ; } } } if ( newSize == 0 ) { key = null ; value = null ; return false ; } else { return true ; } }
te	6	@ Override public boolean equals ( Object o ) { return o instanceof RectData ? this . x == ( ( RectData ) o ) . x && this . y == ( ( RectData ) o ) . y && this . u == ( ( RectData ) o ) . u && this . v == ( ( RectData ) o ) . v && this . w == ( ( RectData ) o ) . w && this . h == ( ( RectData ) o ) . h : false ; }
te	8	public boolean isInitial ( int c ) { return Character . isLetter ( c ) || c == * || c == / || c == > || c == < || c == = || c == ? || c == ! || c == . ; }
te	7	public void xpShopSignLinks ( PlayerInteractEvent event , String [ ] line , Player p , Sign s ) { if ( plugin . config . debug ) { plugin . Logger ( " first line [xpShop] and leftklick!" , "Debug" ) ; } if ( ! plugin . Blacklistcode . startsWith ( "1" , 11 ) ) { plugin . Logger ( " not blacklisted!" , "Debug" ) ; if ( plugin . ListenerShop . blockIsValid ( line , "Interact" , p ) ) { plugin . Logger ( "Shop Links:: " , "Debug" ) ; plugin . Logger ( "Line 1: " + line [ 0 ] , "Debug" ) ; plugin . Logger ( "Line 2: " + line [ 1 ] , "Debug" ) ; plugin . Logger ( "Line 3: " + line [ 2 ] , "Debug" ) ; plugin . Logger ( "Line 4: " + line [ 3 ] , "Debug" ) ; plugin . Logger ( " Block is valid!" , "Debug" ) ; Player player = event . getPlayer ( ) ; if ( plugin . PermissionsHandler . checkpermissions ( p , "xpShop.use" ) ) { plugin . Logger ( "Player: " + p . getName ( ) + " has the permission: xpShop.use" , "Debug" ) ; if ( line [ 1 ] . equalsIgnoreCase ( "AdminShop" ) ) { signHandler . xpShopSignBuyAdmin ( player , line , s ) ; } else { Sign sign = plugin . ListenerShop . findSign ( event . getClickedBlock ( ) ) ; if ( sign != null ) { plugin . Logger ( "sign != null!" , "Debug" ) ; if ( sign . getLine ( 0 ) . equalsIgnoreCase ( "[xpShopSafe]" ) ) { plugin . Logger ( "Safe found!" , "Debug" ) ; signHandler . xpShopSignBuyCon ( player , line , s , sign ) ; } else { plugin . PlayerLogger ( p , plugin . config . safenoSafeonShop , "Error" ) ; } } else { signHandler . xpShopSignBuy ( player , line , s ) ; } } } } } else { plugin . blacklistLogger ( p ) ; event . setCancelled ( true ) ; } }
te	2	public void listen ( int port ) { try { server = new ServerSocket ( port ) ; listening = true ; while ( listening ) { new HTTPClient ( server . accept ( ) ) . start ( ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
te	0	public void setFPublic ( BigInteger value ) { this . fPublic = value ; }
te	5	public AList < Song > getTracksByGenre ( Genre g ) { AList < Song > tracksByGenre = new AList < Song > ( ) ; for ( SListIterator < Record > iterator = createIterator ( ) ; iterator . isValid ( ) ; iterator . moveNext ( ) ) { for ( int j = 0 ; j < 2 ; j ++ ) { for ( AListIterator < Song > iterator2 = iterator . getCurrentElem ( ) . getSide ( j ) . getSideTracklist ( ) . createIterator ( ) ; iterator2 . isValid ( ) ; iterator2 . moveNext ( ) ) { if ( iterator2 . getCurrentElem ( ) . getGenre ( ) . equals ( g ) ) { tracksByGenre . addLast ( iterator2 . getCurrentElem ( ) ) ; } } } } if ( tracksByGenre . isEmpty ( ) ) { return null ; } else { return tracksByGenre ; } }
te	4	public boolean isWalkable ( ) { return ( tileType . equals ( Empty ) || tileType . equals ( OpenedDoor ) || tileType . equals ( StairsUp ) || tileType . equals ( StairsDown ) ) && tileContent . stream ( ) . filter ( p -> p . isOccupiesWholeTile ( ) ) . count ( ) <= 0 ; }
te	1	@ Override public void commit ( ) { if ( currentTransaction != null ) currentTransaction . commit ( ) ; }
te	5	private static boolean KawigiEdit_RunTest ( int testNum , String p0 , int p1 , int p2 , boolean hasAnswer , int p3 ) { System . out . print ( "Test " + testNum + ": [" + "\"" + p0 + "\"" + " " + p1 + " " + p2 ) ; System . out . println ( "]" ) ; OneDimensionalRobotEasy obj ; int answer ; obj = new OneDimensionalRobotEasy ( ) ; long startTime = System . currentTimeMillis ( ) ; answer = obj . finalPosition ( p0 , p1 , p2 ) ; long endTime = System . currentTimeMillis ( ) ; boolean res ; res = true ; System . out . println ( "Time: " + ( endTime - startTime ) / 1000.0 + " seconds" ) ; if ( hasAnswer ) { System . out . println ( "Desired answer:" ) ; System . out . println ( "\t" + p3 ) ; } System . out . println ( "Your answer:" ) ; System . out . println ( "\t" + answer ) ; if ( hasAnswer ) { res = answer == p3 ; } if ( ! res ) { System . out . println ( "DOESN'T MATCH!!!!" ) ; } else if ( ( endTime - startTime ) / 1000.0 >= 2 ) { System . out . println ( "FAIL the timeout" ) ; res = false ; } else if ( hasAnswer ) { System . out . println ( "Match :-)" ) ; } else { System . out . println ( "OK  but is it right?" ) ; } System . out . println ( "" ) ; return res ; }
te	5	public Object nextEntity ( char ampersand ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == # ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ; ) { break ; } else { throw syntaxError ( "Missing ';' in XML entity: &" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + ";" ; }
te	8	private boolean r_postlude ( ) { int among_var ; int v_1 ; replab0 : while ( true ) { v_1 = cursor ; lab1 : do { bra = cursor ; among_var = find_among ( a_1 , 3 ) ; if ( among_var == 0 ) { break lab1 ; } ket = cursor ; switch ( among_var ) { case 0 : break lab1 ; case 1 : slice_from ( "i" ) ; break ; case 2 : slice_from ( "u" ) ; break ; case 3 : if ( cursor >= limit ) { break lab1 ; } cursor ++ ; break ; } continue replab0 ; } while ( false ) ; cursor = v_1 ; break replab0 ; } return true ; }
te	5	@ Override public void doPost ( HttpServletRequest request , HttpServletResponse response ) throws IOException { UserService userService = UserServiceFactory . getUserService ( ) ; User user = userService . getCurrentUser ( ) ; String guestbookName = request . getParameter ( "guestbookName" ) ; String emailDeclared = request . getParameter ( "email" ) ; String nameDeclared = request . getParameter ( "name" ) ; if ( guestbookName == null ) { guestbookName = "default" ; } if ( emailDeclared == null ) { emailDeclared = user . getEmail ( ) ; } if ( nameDeclared == null ) { nameDeclared = user . getNickname ( ) ; } Key guestbookKey = KeyFactory . createKey ( "Guestbook" , guestbookName ) ; String content = request . getParameter ( "message" ) ; if ( content == null ) { content = "Greetings!" ; } if ( user != null ) { Entity greeting = new Entity ( "Greeting" , guestbookKey ) ; Date date = new Date ( ) ; greeting . setProperty ( "user" , user ) ; greeting . setProperty ( "date" , date ) ; greeting . setProperty ( "userId" , user . getUserId ( ) ) ; greeting . setProperty ( "federatedId" , user . getFederatedIdentity ( ) ) ; greeting . setProperty ( "domain" , user . getAuthDomain ( ) ) ; greeting . setProperty ( "content" , content ) ; greeting . setProperty ( "nameDeclared" , nameDeclared ) ; greeting . setProperty ( "emailDeclared" , emailDeclared ) ; DatastoreService ds = DatastoreServiceFactory . getDatastoreService ( ) ; ds . put ( greeting ) ; } else { log . info ( "Anonymous: " + content ) ; } response . sendRedirect ( "/guest.jsp?guestbookName=" + guestbookName ) ; }
te	2	public static int [ ] idea_subkeys ( byte [ ] key ) { int [ ] encryptKeys = new int [ 52 ] ; int k1 ; for ( k1 = 0 ; k1 < 8 ; ++ k1 ) encryptKeys [ k1 ] = ( ( key [ 2 * k1 ] & ff ) << 8 ) | ( key [ 2 * k1 + 1 ] & ff ) ; for ( ; k1 < 52 ; ++ k1 ) encryptKeys [ k1 ] = ( ( encryptKeys [ k1 - 8 ] << 9 ) | ( encryptKeys [ k1 - 7 ] >>> 7 ) ) & ffff ; return encryptKeys ; }
te	4	public static Remote findObject ( String name , String host , int lowPort , int highPort ) throws NotBoundException { boolean aRegistryFound = false ; for ( int rport = lowPort ; rport <= highPort ; rport += 1 ) try { return LocateRegistry . getRegistry ( host , rport ) . lookup ( name ) ; } catch ( NotBoundException e ) { aRegistryFound = true ; } catch ( RemoteException e ) { } if ( aRegistryFound ) throw new NotBoundException ( "name not bound in any registry on " + host + ": " + name ) ; else throw new NotBoundException ( "no registries found on " + host + "  ports " + lowPort + ".." + highPort ) ; }
te	3	public static void main ( String [ ] args ) { double mass , height , BMI ; mass = double . parseDouble ( args [ 0 ] ) ; height = double . parseDouble ( args [ 1 ] ) ; BMI = mass / Math . pow ( height , 2 ) ; if ( BMI < 18.5 ) System . out . println ( "Underweight" ) ; else if ( BMI < 25 ) System . out . println ( "Normal weight" ) ; else if ( BMI < 30 ) System . out . println ( "Overweight" ) ; else System . out . println ( "Obses" ) ; }
te	2	@ Override public boolean readResponse ( String [ ] first_line , InputStream in ) throws BeanstalkcException , IOException { if ( first_line [ 0 ] . equals ( "BURIED" ) ) { return true ; } else if ( first_line [ 0 ] . equals ( "NOT_FOUND" ) ) { throw new JobNotFoundException ( String . format ( "Job %d not found  it may not exist or not be reserved by this client" , job_id ) ) ; } return false ; }
te	3	public void newDocument ( ) { try { final DocumentFrame doc = new DocumentFrame ( loadOrganizer , null ) ; loadOrganizer . openDocuments . add ( doc ) ; doc . addInternalFrameListener ( new InternalFrameAdapter ( ) { @ Override public void internalFrameClosed ( InternalFrameEvent e ) { loadOrganizer . openDocuments . remove ( doc ) ; } } ) ; loadOrganizer . desktop . add ( doc , LoadOrganizer . DOCLAYER ) ; if ( preferences . isGuiNewWindowMaximize ( ) ) { doc . setMaximum ( true ) ; } doc . setVisible ( true ) ; doc . setSelected ( true ) ; } catch ( DocumentClosedException e ) { } catch ( Throwable e ) { e . printStackTrace ( ) ; System . exit ( - 1 ) ; } }
te	0	public void clear ( ) { listModel . clear ( ) ; }
te	7	private boolean checkIntersects ( Point point ) { if ( foundSegment == null ) return false ; Segment segA = new Segment ( foundSegment . segment . getPointA ( ) , point ) ; Segment segB = new Segment ( foundSegment . segment . getPointB ( ) , point ) ; for ( Polygon p : getAllPolygons ( ) ) { for ( Segment s : p . getSegments ( ) ) { Point pt ; if ( ( pt = GeomUtils . intersectOnlyPoint ( segA , s ) ) != null ) { if ( ! foundSegment . segment . lies ( pt ) ) return false ; } if ( ( pt = GeomUtils . intersectOnlyPoint ( segB , s ) ) != null ) { if ( ! foundSegment . segment . lies ( pt ) ) return false ; } } } return true ; }
te	2	public OutcomingDocument createOutcomingDocument ( IncomingDocument initiatingDocument ) { if ( getEnvironment ( ) != null ) { if ( getDepartment ( ) != null ) { OutcomingDocument outcomingDocument = new OutcomingDocument ( getEnvironment ( ) . getOutcomingDocType ( ) , this , getDepartment ( ) . getPublicService ( ) ) ; outcomingDocument . setText ( this . getReplyToThank ( ) ) ; initiatingDocument . setReactionDocument ( outcomingDocument ) ; outcomingDocument . setInitiatingDocument ( initiatingDocument ) ; outcomingDocument . setDocumentName ( ExecutionDefaults . OUTCOMING_DOC_NAME ) ; return outcomingDocument ; } else throw new IllegalStateException ( ExecutionDefaults . DEPARTMENT_IS_NULL ) ; } else throw new IllegalStateException ( ExecutionDefaults . ENVIRONMENT_IS_NULL ) ; }
te	4	public void selectSort ( int [ ] data ) { if ( data == null ) { throw new NullPointerException ( "Input array is null." ) ; } for ( int i = 0 ; i < data . length ; i ++ ) { int small = i , tmp ; for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( data [ small ] > data [ j ] ) { small = j ; } } tmp = data [ i ] ; data [ i ] = data [ small ] ; data [ small ] = tmp ; } }
te	1	public Object1 method296 ( int i , int j , int k ) { Ground class30_sub3 = groundArray [ i ] [ j ] [ k ] ; if ( class30_sub3 == null ) return null ; else return class30_sub3 . obj1 ; }
te	1	@ Override public void setIsMondayFirstDayOfWeek ( boolean isMondayFirstDayOfWeek ) { if ( isMondayFirstDayOfWeek == true ) { weekDaysMap . put ( 0 , MONDAY ) ; weekDaysMap . put ( 1 , TUESDAY ) ; weekDaysMap . put ( 2 , WEDNESDAY ) ; weekDaysMap . put ( 3 , THURSDAY ) ; weekDaysMap . put ( 4 , FRIDAY ) ; weekDaysMap . put ( 5 , SATURDAY ) ; weekDaysMap . put ( 6 , SUNDAY ) ; } else { weekDaysMap . put ( 0 , SUNDAY ) ; weekDaysMap . put ( 1 , MONDAY ) ; weekDaysMap . put ( 2 , TUESDAY ) ; weekDaysMap . put ( 3 , WEDNESDAY ) ; weekDaysMap . put ( 4 , THURSDAY ) ; weekDaysMap . put ( 5 , FRIDAY ) ; weekDaysMap . put ( 6 , SATURDAY ) ; } super . setIsMondayFirstDayOfWeek ( isMondayFirstDayOfWeek ) ; }
te	3	public String look ( ) { StringBuffer names = new StringBuffer ( ) ; String items = currRoom . getItemNames ( ) ; String monsters = currRoom . getMonsterNames ( ) ; if ( ! items . equals ( "" ) ) { names . append ( "Items: " ) ; names . append ( items ) ; } if ( ! monsters . equals ( "" ) ) { if ( ! ( names . length ( ) == 0 ) ) { names . append ( "\n" ) ; } names . append ( "Monsters: " ) ; names . append ( monsters ) ; } return names . toString ( ) ; }
te	8	public static void main ( String [ ] args ) { int X , m ; int a1 , a2 , a3 ; int m1 , m2 , m3 ; int M1 , M2 , M3 ; int y1 , y2 , y3 ; y1 = y2 = y3 = 1 ; Scanner in = new Scanner ( System . in ) ; a1 = in . nextInt ( ) ; m1 = in . nextInt ( ) ; a2 = in . nextInt ( ) ; m2 = in . nextInt ( ) ; a3 = in . nextInt ( ) ; m3 = in . nextInt ( ) ; m = m1 * m2 * m3 ; M1 = m / m1 ; M2 = m / m2 ; M3 = m / m3 ; for ( int i = 1 ; i <= M1 ; i ++ ) { if ( congruent ( M1 * i , 1 , m1 ) ) { y1 = i ; break ; } } for ( int i = 1 ; i <= M2 ; i ++ ) { if ( congruent ( M2 * i , 1 , m2 ) ) { y2 = i ; break ; } } for ( int i = 1 ; i <= M3 ; i ++ ) { if ( congruent ( M3 * i , 1 , m3 ) ) { y3 = i ; break ; } } X = a1 * M1 * y1 + a2 * M2 * y2 + a3 * M3 * y3 ; int answer = 1 ; for ( int i = 1 ; i <= X ; i ++ ) { if ( congruent ( X , i , m ) ) { answer = i ; break ; } } System . out . println ( "A resposta \u00E9 " + answer ) ; System . out . println ( "Se a resposta dada n\u00E3o est\u00E1 num intervalo dado pelo problema  apenas adicione " + m + " \u00E0 resposta at\u00E9 que esteja" ) ; }
te	0	public TransformationScaleXY ( Node node ) { NamedNodeMap attr = node . getAttributes ( ) ; scaleX = float . parseFloat ( attr . getNamedItem ( "scaleX" ) . getNodeValue ( ) ) ; scaleY = float . parseFloat ( attr . getNamedItem ( "scaleY" ) . getNodeValue ( ) ) ; transform . setToScale ( scaleX , scaleY ) ; }
te	8	private void findCodelOnEdge ( CodelArea area ) { DirectionPointer directionPointer = mMachine . getDirectionPointer ( ) ; CodelChoser codelChoser = mMachine . getCodelChoser ( ) ; boolean isLeft = codelChoser . isLeft ( ) ; if ( directionPointer . isRight ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . maxXMinY ( ) ) ; } else { mEdgeCodel . set ( area . maxXMaxY ( ) ) ; } } else if ( directionPointer . isBottom ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . maxYMaxX ( ) ) ; } else { mEdgeCodel . set ( area . maxYMinX ( ) ) ; } } else if ( directionPointer . isLeft ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . minXMaxY ( ) ) ; } else { mEdgeCodel . set ( area . minXMinY ( ) ) ; } } else if ( directionPointer . isTop ( ) ) { if ( isLeft ) { mEdgeCodel . set ( area . minYMinX ( ) ) ; } else { mEdgeCodel . set ( area . minYMaxX ( ) ) ; } } }
te	7	private void searchUser ( ActionEvent e ) { String userName = this . userName . getText ( ) ; String userNo = this . userNO . getText ( ) ; if ( userName == null || Constants . STR_NULL . equals ( userName . trim ( ) ) ) { userName = Constants . STR_NULL ; } if ( userNo == null || Constants . STR_NULL . equals ( userNo . trim ( ) ) ) { userNo = Constants . STR_NULL ; } Map < String , Object > param = new HashMap < String , Object > ( ) ; param . put ( Constants . IN_USERNAME , userName ) ; param . put ( Constants . IN_USERNO , userNo ) ; System . out . println ( param ) ; List < Map < String , Object >> list = null ; try { list = userDao . searchUser ( param ) ; } finally { if ( null == list || Constants . NUM_ZERO == list . size ( ) ) { return ; } else { int size = list . size ( ) ; data = new String [ size ] [ 2 ] ; int i = 0 ; for ( Map < String , Object > item : list ) { data [ i ] [ 0 ] = item . get ( Constants . USER_NO ) ; data [ i ] [ 1 ] = item . get ( Constants . USER_NAME ) ; i ++ ; } refreshTable ( ) ; } } }
te	2	@ Override public final void setGeometry ( final Object geometry ) { if ( geometry instanceof String [ ] ) { final String [ ] geometryArray = ( String [ ] ) geometry ; if ( geometryArray . length != 4 ) { throw new IllegalArgumentException ( "geometry must be an array of four elements that contains racolName  decColName  timeColName and bandColName" ) ; } else { this . raCol = geometryArray [ 0 ] ; this . decCol = geometryArray [ 1 ] ; this . timeCol = geometryArray [ 2 ] ; this . bandCol = geometryArray [ 3 ] ; } } else { throw new IllegalArgumentException ( "geometry must be an array of four elements that contains racolName  decColName  timeColName and bandColName" ) ; } }
te	4	public static Monster createMonsterFromReader ( String monsterString ) { String [ ] values = monsterString . split ( " " ) ; Monster monster = new Monster ( ) ; try { monster . setName ( values [ 0 ] ) ; monster . setMaxHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setCurrentHP ( Integer . parseInt ( values [ 1 ] ) ) ; monster . setNaturalAC ( Integer . parseInt ( values [ 2 ] ) ) ; monster . setStrength ( Integer . parseInt ( values [ 3 ] ) ) ; monster . setDexterity ( Integer . parseInt ( values [ 4 ] ) ) ; monster . setSpeed ( Integer . parseInt ( values [ 5 ] ) ) ; monster . setAttackBonus ( Integer . parseInt ( values [ 6 ] ) ) ; monster . setBaseDamage ( Integer . parseInt ( values [ 7 ] ) ) ; monster . setBaseMeleeDescription ( values [ 8 ] ) ; monster . setSightRange ( Integer . parseInt ( values [ 9 ] ) ) ; monster . setDifficulty ( Integer . parseInt ( values [ 10 ] ) ) ; if ( values . length == 12 && values [ 11 ] != "" ) { String [ ] specials = values [ 11 ] . split ( " " ) ; monster = Monster . applySpecialTraits ( monster , specials ) ; } monster . setInSight ( false ) ; } catch ( Exception e ) { System . out . println ( "Error reading monster object" ) ; if ( monster . getName ( ) != null ) System . out . println ( monster . getName ( ) + " has some incorrect parameter." ) ; return null ; } return monster ; }
te	9X	@ Override public Set < String > keySet ( ) { return new Set < String > ( ) { @ Override public int size ( ) { return size ; } @ Override public boolean isEmpty ( ) { return size == 0 ; } @ Override public boolean contains ( Object o ) { return get ( ( String ) o ) != null ; } @ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : null ; @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean hasNext ( ) { return currentIterator != null ; } @ Override public String next ( ) { String toReturn ; toReturn = currentIterator . next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; } @ Override public Object [ ] toArray ( ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public < T > T [ ] toArray ( T [ ] a ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean add ( String e ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean containsAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Not yet" ) ; } @ Override public boolean addAll ( Collection < ? extends String > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } @ Override public void clear ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
te	9X	public static BufferedImage rotate ( BufferedImage src , Rotation rotation , BufferedImageOp ... ops ) throws IllegalArgumentException , ImagingOpException { long t = System . currentTimeMillis ( ) ; if ( src == null ) throw new IllegalArgumentException ( "src cannot be null" ) ; if ( rotation == null ) throw new IllegalArgumentException ( "rotation cannot be null" ) ; if ( DEBUG ) log ( 0 , "Rotating Image [%s]..." , rotation ) ; int newWidth = src . getWidth ( ) ; int newHeight = src . getHeight ( ) ; AffineTransform tx = new AffineTransform ( ) ; switch ( rotation ) { case CW_90 : newWidth = src . getHeight ( ) ; newHeight = src . getWidth ( ) ; tx . translate ( newWidth , 0 ) ; tx . rotate ( Math . toRadians ( 90 ) ) ; break ; case CW_270 : newWidth = src . getHeight ( ) ; newHeight = src . getWidth ( ) ; tx . translate ( 0 , newHeight ) ; tx . rotate ( Math . toRadians ( - 90 ) ) ; break ; case CW_180 : tx . translate ( newWidth , newHeight ) ; tx . rotate ( Math . toRadians ( 180 ) ) ; break ; case FLIP_HORZ : tx . translate ( newWidth , 0 ) ; tx . scale ( - 1.0 , 1.0 ) ; break ; case FLIP_VERT : tx . translate ( 0 , newHeight ) ; tx . scale ( 1.0 , - 1.0 ) ; break ; } BufferedImage result = createOptimalImage ( src , newWidth , newHeight ) ; Graphics2D g2d = ( Graphics2D ) result . createGraphics ( ) ; g2d . drawImage ( src , tx , null ) ; g2d . dispose ( ) ; if ( DEBUG ) log ( 0 , "Rotation Applied in %d ms  result [width=%d  height=%d]" , System . currentTimeMillis ( ) - t , result . getWidth ( ) , result . getHeight ( ) ) ; if ( ops != null && ops . length > 0 ) result = apply ( result , ops ) ; return result ; }
te	8	public int [ ] [ ] makeTileMap ( ArrayList < GameEntity > entities ) { int width = 1 ; int height = 1 ; startX = entities . get ( 0 ) . getStartX ( ) ; startY = entities . get ( 0 ) . getStartY ( ) ; int tileSize = GlobalSettings . tileSize ; for ( int i = 1 ; i < entities . size ( ) ; i ++ ) { int entX = entities . get ( i ) . getStartX ( ) ; int entY = entities . get ( i ) . getStartY ( ) ; if ( entX < startX ) { if ( ( startX - entX ) / tileSize == 0 ) System . out . println ( "Zero added" ) ; width += ( ( startX - entX ) / tileSize ) ; startX = entX ; } if ( entY < startY ) { height += ( ( startY - entY ) / tileSize ) ; startY = entY ; } if ( entX > startX + width * tileSize ) { width += ( ( entX - ( startX + width * tileSize ) ) / tileSize ) ; } if ( entY > startY + height * tileSize ) { height += ( ( entY - ( startY + height * tileSize ) ) / tileSize ) ; } } height ++ ; width ++ ; int [ ] [ ] tileMap = new int [ height ] [ width ] ; System . out . println ( "Width :: " + width + " Height :: " + height ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { boolean block = entities . get ( i ) . isBlock ( ) ; if ( block ) { int xpos = ( entities . get ( i ) . getStartX ( ) - startX ) / tileSize ; int ypos = ( entities . get ( i ) . getStartY ( ) - startY ) / tileSize ; tileMap [ ypos ] [ xpos ] = 1 ; } } return tileMap ; }
te	6	public int getAnswerIndex ( ) { if ( answer == null || options == null || isSurvey || style != CHOICE_QUESTION ) { return - 1 ; } for ( int i = 0 ; i < options . length ; i ++ ) { if ( answer . equals ( options [ i ] ) ) { return i ; } } return - 1 ; }
te	3	public String getResultDetail ( int index ) { if ( ! detail ) return null ; if ( index < 0 || index >= getResultCount ( ) ) throw new IllegalArgumentException ( class + ": illegal value for index" ) ; return details . get ( index ) ; }
te	6	public void sortBy ( String order ) { DefaultMutableTreeNode tmpNode = null ; DefaultMutableTreeNode curNodeCopy = null ; SortTreeModel treeModelTmp = null ; DefaultMutableTreeNode rootTmp = new DefaultMutableTreeNode ( rootNodeTxt ) ; if ( order . equals ( "name" ) ) { treeModelTmp = new SortTreeModel ( rootTmp , new TreeStringComparatorName ( ) ) ; sortedByName = true ; } else { treeModelTmp = new SortTreeModel ( rootTmp , new TreeStringComparatorDate ( ) ) ; sortedByName = false ; } sortByNameMenuItem . setEnabled ( ! sortedByName ) ; sortByDateMenuItem . setEnabled ( sortedByName ) ; for ( @ SuppressWarnings ( "rawtypes" ) Enumeration e = ( ( DefaultMutableTreeNode ) treeModel . getRoot ( ) ) . breadthFirstEnumeration ( ) ; e . hasMoreElements ( ) ; ) { DefaultMutableTreeNode curNode = ( DefaultMutableTreeNode ) e . nextElement ( ) ; Object obj = curNode . getUserObject ( ) ; if ( obj instanceof Item ) { Item currentItem = ( Item ) obj ; if ( currentItem . isDir ( ) ) curNodeCopy = new FolderNode ( currentItem ) ; else curNodeCopy = new LeafNode ( currentItem , ( ( LeafNode ) curNode ) . getDownPerc ( ) , ( ( LeafNode ) curNode ) . getStatus ( ) ) ; Object objPar = ( ( DefaultMutableTreeNode ) curNode . getParent ( ) ) . getUserObject ( ) ; if ( objPar instanceof Item ) { if ( ( tmpNode = getItemInTree ( ( Item ) objPar , treeModelTmp ) ) != null ) { treeModelTmp . insertNodeInto ( curNodeCopy , tmpNode ) ; } } else { treeModelTmp . insertNodeInto ( curNodeCopy , rootTmp ) ; } } } rootNode = rootTmp ; treeModel = treeModelTmp ; tree . setModel ( treeModel ) ; }
te	4	public void removeDeadTransitions ( ) { clearHashCode ( ) ; if ( isSingleton ( ) ) return ; Set < State > states = getStates ( ) ; Set < State > live = getLiveStates ( states ) ; for ( State s : states ) { Set < Transition > st = s . transitions ; s . resetTransitions ( ) ; for ( Transition t : st ) if ( live . contains ( t . to ) ) s . transitions . add ( t ) ; } reduce ( ) ; }
te	1	public void tradeElGamal ( boolean first ) { { p = new BigInteger ( "4988735951183711405443349413015910122453507015594895638933838601555750189585703700647655985269637551634513770201277370413860951650702374379627998821919409" ) ; BigInteger g = new BigInteger ( "4403105895869798297264918950735787070665047406714785361037216842427722734684061748868589917485012596281820467352001338223691996653533143166890875549812531" ) ; BigInteger y = new BigInteger ( "3670294064109445804998782973709772470002041046377612489028768098078250713079795031354099562309432613560558383306865142781216201315104971340333690591679721" ) ; BigInteger x = new BigInteger ( "4589946301809196862611751989088793376762175950291076147544077975213763218505486754450017554342955014202444667772016113058406939298289857995054770609176615" ) ; elGamalC_own = new ElGamalCipher ( p , g , y , x ) ; elGamalS_own = new ElGamalSignature ( p , g , y , x ) ; } if ( first ) { com . sendTo ( 1 , p . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 1 , elGamalC_own . y . toString ( 16 ) ) ; { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } } else { { BigInteger p = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger g = new BigInteger ( com . receive ( ) , 16 ) ; BigInteger y = new BigInteger ( com . receive ( ) , 16 ) ; elGamalC_other = new ElGamalCipher ( p , g , y ) ; elGamalS_other = new ElGamalSignature ( p , g , y ) ; } com . sendTo ( 0 , p . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . g . toString ( 16 ) ) ; com . sendTo ( 0 , elGamalC_own . y . toString ( 16 ) ) ; } }
te	5	public static Node addTwoNumbers ( Node num1 , Node num2 ) { Node num3 = null ; Node head = null ; int updigit = 0 ; while ( num1 != null && num2 != null ) { int digit1 = num1 . value ; int digit2 = num2 . value ; int newdigit = ( digit1 + digit2 + updigit ) % 10 ; updigit = ( digit1 + digit2 ) / 10 ; Node numNode = new Node ( null , newdigit ) ; if ( num3 == null ) { num3 = numNode ; head = num3 ; } else { num3 . next = numNode ; num3 = numNode ; } num1 = num1 . next ; num2 = num2 . next ; } if ( num1 != null ) { num3 . next = num1 ; } if ( num2 != null ) { num3 . next = num2 ; } return head ; }
te	8	public int characterAt ( int at ) throws JSONException { int c = get ( at ) ; if ( ( c & 80 ) == 0 ) { return c ; } int character ; int c1 = get ( at + 1 ) ; if ( ( c1 & 80 ) == 0 ) { character = ( ( c & 7F ) << 7 ) | c1 ; if ( character > 7F ) { return character ; } } else { int c2 = get ( at + 2 ) ; character = ( ( c & 7F ) << 14 ) | ( ( c1 & 7F ) << 7 ) | c2 ; if ( ( c2 & 80 ) == 0 && character > 3FFF && character <= 10FFFF && ( character < D800 || character > DFFF ) ) { return character ; } } throw new JSONException ( "Bad character at " + at ) ; }
te	8	public static void main ( String [ ] args ) { System . setOut ( new VOut ( System . out ) ) ; VEngineLogo vl = new VEngineLogo ( ) ; vl . setVisible ( true ) ; cfg = VFileReader . readCFG ( new File ( new File ( System . getProperty ( "user.home" ) + "/.vau/" ) . getAbsolutePath ( ) + "/configurations/game.cfg" ) ) ; cfg . s ( "home" , new File ( System . getProperty ( "user.home" ) + "/.vau/" ) . getAbsolutePath ( ) ) ; cfg . s ( "modhome" , new File ( System . getProperty ( "user.home" ) + "/.vau/mods/" + cfg . g ( "mod" ) + "/" ) . getAbsolutePath ( ) + "/" ) ; for ( String param : args ) { try { String [ ] pr = param . split ( "=" ) ; cfg . s ( pr [ 0 ] , pr [ 1 ] ) ; } catch ( Exception e ) { } } System . out . println ( cfg ) ; try { System . setProperty ( "java.library.path" , new File ( cfg . g ( "home" ) + "/native" ) . getAbsolutePath ( ) ) ; Field fieldSysPath = ClassLoader . class . getDeclaredField ( "sys_paths" ) ; fieldSysPath . setAccessible ( true ) ; try { fieldSysPath . set ( null , null ) ; } catch ( IllegalArgumentException ex ) { Logger . getLogger ( VEngine . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } catch ( IllegalAccessException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } } catch ( NoSuchFieldException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } catch ( SecurityException ex ) { JOptionPane . showMessageDialog ( null , "Error!\n" + ex . toString ( ) ) ; System . exit ( 1 ) ; } Music openingMenuMusic ; try { openingMenuMusic = new Music ( new File ( System . getProperty ( "user.home" ) + "/.vau/music/watchword.ogg" ) . getAbsolutePath ( ) ) ; if ( cfg . g ( "music" ) . equals ( "enabled" ) ) { openingMenuMusic . loop ( ) ; } } catch ( SlickException ex ) { Logger . getLogger ( VEngine . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } VGraphics . start ( ) ; VProcessor . add ( new vexamples . units . VPlayer ( ) ) ; VProcessor . add ( new vexamples . units . VUnit ( ) ) ; VProcessor . add ( new vexamples . units . VBullet ( ) ) ; VMenu vm = new VMenu ( ) ; vl . setVisible ( false ) ; }
te	1	@ Override public void enterRule ( ParseTreeListener listener ) { if ( listener instanceof DecafParserListener ) ( ( DecafParserListener ) listener ) . enterId1 ( this ) ; }
te	2	public static void main ( String args [ ] ) { String [ ] words = new String [ 2 ] ; String [ ] more = new String [ 2 ] ; ArrayList < String > str = new ArrayList < String > ( ) ; String strng ; for ( int i = 0 ; i < words . length ; i ++ ) words [ i ] = "words" + i ; for ( int i = 0 ; i < more . length ; i ++ ) more [ i ] = "more" + i ; str = merge ( words , more ) ; System . out . println ( str ) ; strng = makeSentence ( words ) ; System . out . println ( words ) ; }
te	0	public void setNeedsPass ( boolean needsPass ) { this . needsPass = needsPass ; }
te	2	public void convert ( Ticket ticket ) { for ( de . robert_heim . unfuddle2bitbucket . model . unfuddle . Comment unfuddleComment : ticket . getComments ( ) ) { String username = null ; Person p = provider . getPeopleConverter ( ) . findPersonById ( unfuddleComment . getAuthorId ( ) ) ; if ( null == p ) { System . out . println ( "Warning: the comment-author with id '" + unfuddleComment . getAuthorId ( ) + "' could not be found in the input file. Using 'null'." ) ; } else { username = p . getName ( ) ; } Comment comment = new Comment ( unfuddleComment . getBody ( ) , unfuddleComment . getCreatedAt ( ) . toGregorianCalendar ( ) . getTime ( ) , getUniqueCommentId ( ) , ticket . getId ( ) , ticket . getUpdatedAt ( ) . toGregorianCalendar ( ) . getTime ( ) , username ) ; comments . add ( comment ) ; } }
te	4	private void valider ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { boolean select = true ; int selectionCorrige = 0 ; int selection = tableau . getSelectedRow ( ) ; try { selectionCorrige = listeAchats . getTableau ( ) . getRowSorter ( ) . convertRowIndexToModel ( selection ) ; } catch ( Exception e ) { select = false ; JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "error_no_ticket_selected" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } if ( select ) { try { Achat achat = ( Achat ) listeAchats . getObjetByIndex ( selectionCorrige ) ; if ( ! achat . getPaye ( ) ) { achat . setPayer ( true ) ; } else { JOptionPane . showMessageDialog ( new JFrame ( ) , Langue . getTraduction ( "ticket_already_paid" ) , Langue . getTraduction ( "warning" ) , JOptionPane . INFORMATION_MESSAGE ) ; } } catch ( Exception e1 ) { Constantes . afficherException ( e1 ) ; } } } } ) ; }
te	8	public void run ( ) { ParallelWarteClass paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == 1 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; return ; } else { paraWait . interrupt ( ) ; } paraWait = new ParallelWarteClass ( 10000 ) ; paraWait . start ( ) ; while ( ! ( HWaccess . readInt ( Adressen . LaufbandDrehen . ordinal ( ) ) == 0 ) && paraWait . isAlive ( ) ) { try { Thread . sleep ( 150 ) ; } catch ( InterruptedException e ) { this . interrupt ( ) ; } } if ( ! paraWait . isAlive ( ) ) { interrupt ( ) ; } else { paraWait . interrupt ( ) ; } result = true ; }
te	1	public static void inorder ( BSTNode current ) { if ( current == null ) return ; inorder ( current . getLeft ( ) ) ; System . out . print ( current . getData ( ) + " " ) ; inorder ( current . getRight ( ) ) ; }
te	3	public boolean contains ( int val ) { System . out . printf ( "Looking for %d:%n" , val ) ; Node c = root ; while ( c != null ) if ( c . value == val ) { System . out . println ( " -> Requested value was found." ) ; return true ; } else if ( val < c . value ) { c = c . left ; System . out . printf ( " -> Requested value is smaller than %d : Going left." , c . value ) ; } else { c = c . right ; System . out . printf ( " -> Requested value is bigger than %d : Going right." , c . value ) ; } System . out . println ( " -> Requested value was not found." ) ; return false ; }
te	6	protected void recurseFields ( final DataFrame frame , final String token , final List < DataField > results ) { if ( frame != null ) { for ( int x = 0 ; x < frame . getFieldCount ( ) ; x ++ ) { final DataField field = frame . getField ( x ) ; String fname = field . getName ( ) ; if ( fname == null ) { fname = "field" + x ; } if ( token != null ) { fname = token + "." + fname ; } if ( field . isFrame ( ) ) { recurseFields ( ( DataFrame ) field . getObjectValue ( ) , fname , results ) ; } else { if ( filter . matches ( fname ) ) { results . add ( field ) ; } } } } }
te	1	@ Override public List < Score > getHighscore ( ) { List < Score > ret ; try { ret = fetchScores ( 10 ) ; } catch ( IOException e ) { ret = new ArrayList < Score > ( 0 ) ; e . printStackTrace ( ) ; } return ret ; }
te	0	public int numberOfPhotosBelongingTo ( ) { return this . photosInAlbum . size ( ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( Principal . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { getInstace ( null ) . setVisible ( true ) ; } } ) ; }
te	8	@ Override public void actionPerformed ( ActionEvent e ) { final JToggleButton sourceBtn = ( JToggleButton ) e . getSource ( ) ; if ( sourceBtn . isSelected ( ) ) { final String host = cbxCfgAddress . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; final String port = cbxCfgPort . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; final String name = cbxCfgName . getEditor ( ) . getItem ( ) . toString ( ) . trim ( ) ; ConfigHistory . addEntry ( host , port , name ) ; cbxCfgAddress . addItem ( host ) ; cbxCfgPort . addItem ( port ) ; cbxCfgName . addItem ( name ) ; try { final Registry reg = LocateRegistry . getRegistry ( host , Integer . parseInt ( port ) ) ; final ServerControl remoteControl = ( ServerControl ) reg . lookup ( BINDING_ID ) ; if ( name . equals ( "" ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Please enter your name!" , "Naming error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else if ( ! remoteControl . isJoinable ( ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "The selected server is busy!" , "Network error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else if ( ! remoteControl . register ( name ) ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Please choose another name!" , "Naming error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } else { cbxCfgAddress . setEnabled ( false ) ; cbxCfgName . setEnabled ( false ) ; cbxCfgPort . setEnabled ( false ) ; lblTitle . setText ( "Waiting for host..." ) ; target . setName ( name ) ; target . setController ( remoteControl ) ; registerThread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { try { while ( ! remoteControl . isRunning ( ) ) { Thread . sleep ( 500 ) ; } ConnectionDialog . this . dispose ( ) ; } catch ( InterruptedException | RemoteException e ) { try { remoteControl . unregister ( name ) ; } catch ( Exception e1 ) { } } } } ) ; registerThread . start ( ) ; } } catch ( RemoteException | NotBoundException ex ) { JOptionPane . showMessageDialog ( ConnectionDialog . this , "Host cannot be found!" , "Network error" , JOptionPane . ERROR_MESSAGE ) ; sourceBtn . setSelected ( false ) ; } } else { registerThread . interrupt ( ) ; cbxCfgAddress . setEnabled ( true ) ; cbxCfgName . setEnabled ( true ) ; cbxCfgPort . setEnabled ( true ) ; lblTitle . setText ( "Connect to host..." ) ; } }
te	1	private Particle createLandmineParticle ( double theta , Point2D . double pos ) { Particle p = new Particle ( theta , 0.0 , 0.0 , ( Landmine . PARTICLE_LIFE / ( int ) Globals . SLEEP_TIME ) , pos , new Dimension ( 24 , 24 ) , Images . LANDMINE_PARTICLE ) { @ Override public void update ( ) { if ( this . isAlive ( ) ) this . life -- ; } @ Override public void draw ( Graphics2D g2d ) { double x = this . pos . x - ( this . size . width / 2 ) ; double y = this . pos . y - ( this . size . height / 2 ) ; g2d . drawImage ( this . image , ( int ) x , ( int ) y , null ) ; } } ; return p ; }
te	3	public void update ( ByteBuffer data ) throws IOException { if ( data . position ( ) != 0 ) data . flip ( ) ; output . write ( data ) ; crc . update ( data . array ( ) , 0 , data . limit ( ) ) ; if ( output . size ( ) == udo . getLength ( ) ) { setFinished ( true ) ; udo . setChecksum ( crc . getValue ( ) ) ; output . close ( ) ; Main . localIndex . insert ( dataProcessor . storeData ( udo ) ) ; } else if ( output . size ( ) > udo . getLength ( ) ) { System . out . println ( "Huge error occured  too much data!" ) ; } }
te	9X	public static void main ( String [ ] args ) { boolean [ ] primes = new boolean [ 2000000 ] ; for ( int i = 2 ; i < primes . length ; i ++ ) primes [ i ] = true ; for ( int i = 2 ; i < primes . length ; i ++ ) if ( primes [ i ] ) for ( int j = 2 ; i * j < primes . length ; j ++ ) primes [ i * j ] = false ; ArrayList < Integer > primeList = new ArrayList < Integer > ( ) ; for ( int i = 5 ; i <= 1000000 ; i ++ ) if ( primes [ i ] ) primeList . add ( i ) ; int a = 1000000 ; while ( true ) { a ++ ; if ( primes [ a ] ) { primeList . add ( a ) ; break ; } } long sum = 0 ; for ( int i = 0 ; i < primeList . size ( ) - 1 ; i ++ ) sum += lowestMultiple ( primeList . get ( i ) , primeList . get ( i + 1 ) ) ; System . out . println ( sum ) ; }
te	7	private void clear ( ) { if ( zooKeeper != null ) { if ( leaderOffer != null && zooKeeper . getState ( ) . isAlive ( ) ) { try { zooKeeper . delete ( leaderOffer . getOffer ( ) , - 1 ) ; LOG . debug ( "Removed leader candidate {}" , leaderOffer ) ; } catch ( InterruptedException e ) { failed ( e ) ; } catch ( KeeperException e ) { failed ( e ) ; } if ( leaderElectionAware != null ) { leaderElectionAware . onClosed ( leaderOffer ) ; } leaderOffer = null ; } try { zooKeeper . close ( ) ; } catch ( InterruptedException e ) { failed ( e ) ; } finally { zooKeeper = null ; } } }
te	6	@ Override public void run ( ) { Player [ ] players = plugin . getServer ( ) . getOnlinePlayers ( ) ; Player player ; long configTime = plugin . getConfig ( ) . getInt ( "KICK_TIMER" ) * 60 * 1000 ; for ( int i = 0 ; ( players . length - 1 ) >= i ; i ++ ) { long lastMoved = 0 ; player = players [ i ] ; UserTable ut = plugin . getDatabase ( ) . find ( UserTable . class ) . where ( ) . ieq ( "userName" , player . getName ( ) ) . = ( "afk" , true ) . findUnique ( ) ; if ( ut == null ) { return ; } lastMoved = System . currentTimeMillis ( ) - ut . getAfkTime ( ) ; if ( player . isOp ( ) ) { if ( plugin . getConfig ( ) . getBoolean ( "KICK_OP" ) ) { if ( lastMoved > configTime ) { player . kickPlayer ( "Auto-Kick: You were afk too long..." ) ; } } } else { if ( lastMoved > configTime ) { player . kickPlayer ( "Auto-Kick: You were afk too long..." ) ; } } } }
te	1	@ Override public boolean equals ( Object obj ) { try { GitlabCommitStatus commitObj = ( GitlabCommitStatus ) obj ; return ( this . getId ( ) . compareTo ( commitObj . getId ( ) ) == 0 ) ; } catch ( ClassCastException e ) { return false ; } }
te	0	public PanelRenderer ( JTable table , TableCellRenderer renderer , TableCellEditor editor ) { this . table = table ; baseRenderer = renderer ; baseEditor = editor ; panel = new JPanel ( ) ; panel . setLayout ( new GridBagLayout ( ) ) ; }
te	4	public static double sigLevelByApproxRand ( int [ ] A , int [ ] B , int iterations ) { if ( A . length == 0 ) throw new IllegalArgumentException ( "Input arrays must not be empty!" ) ; if ( A . length != B . length ) throw new IllegalArgumentException ( "Input arrays must have equal length!" ) ; if ( iterations <= 0 ) throw new IllegalArgumentException ( "Number of iterations must be positive!" ) ; double [ ] X = new double [ A . length ] ; double [ ] Y = new double [ B . length ] ; for ( int i = 0 ; i < A . length ; i ++ ) { X [ i ] = A [ i ] ; Y [ i ] = B [ i ] ; } return sigLevelByApproxRand ( X , Y , iterations ) ; }
te	9X	public static void invert ( double src [ ] [ ] , double dst [ ] [ ] ) { gaussian ( src , a ) ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) b [ i ] [ i ] = i == j ? 1 : 0 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = i + 1 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 4 ; k ++ ) b [ index [ j ] ] [ k ] -= a [ index [ j ] ] [ i ] * b [ index [ i ] ] [ k ] ; for ( int i = 0 ; i < 4 ; i ++ ) { dst [ 4 - 1 ] [ i ] = b [ index [ 4 - 1 ] ] [ i ] / a [ index [ 4 - 1 ] ] [ 4 - 1 ] ; for ( int j = 2 ; j >= 0 ; j -- ) { dst [ j ] [ i ] = b [ index [ j ] ] [ i ] ; for ( int k = j + 1 ; k < 4 ; k ++ ) dst [ j ] [ i ] -= a [ index [ j ] ] [ k ] * dst [ k ] [ i ] ; dst [ j ] [ i ] /= a [ index [ j ] ] [ j ] ; } } }
te	7	public boolean mouseUp ( Event event , int x , int y ) { if ( menus . mouseUp ( x , y ) ) { damage ( ) ; return true ; } Renderer . setDragging ( false ) ; if ( x < 35 && y < 35 ) { } if ( x > W - 35 && y < 35 ) { } if ( x > W - 35 && y > H - 35 ) { } return true ; }
te	4	public static BitSet fromByteArray ( byte [ ] bytes ) { BitSet bits = new BitSet ( ) ; for ( int i = 0 ; i < bytes . length * 8 ; i ++ ) { if ( ( bytes [ bytes . length - i / 8 - 1 ] & ( 1 << ( i % 8 ) ) ) > 0 ) { bits . set ( i ) ; } } for ( int k = bits . size ( ) - 1 ; k >= 0 ; k -- ) { System . out . print ( ( bits . get ( k ) ) ? "1" : "0" ) ; } System . out . println ( ) ; return bits ; }
te	5	public void packTag ( byte [ ] bytes ) { Arrays . fill ( bytes , ( byte ) 0 ) ; try { BufferTools . stringIntoByteBuffer ( TAG , 0 , 3 , bytes , 0 ) ; } catch ( UnsupportedEncodingException e ) { } packField ( bytes , title , TITLE_LENGTH , TITLE_OFFSET ) ; packField ( bytes , artist , ARTIST_LENGTH , ARTIST_OFFSET ) ; packField ( bytes , album , ALBUM_LENGTH , ALBUM_OFFSET ) ; packField ( bytes , year , YEAR_LENGTH , YEAR_OFFSET ) ; if ( genre < 128 ) { bytes [ GENRE_OFFSET ] = ( byte ) genre ; } else { bytes [ GENRE_OFFSET ] = ( byte ) ( genre - 256 ) ; } if ( track == null ) { packField ( bytes , comment , COMMENT_LENGTH_V1_0 , COMMENT_OFFSET ) ; } else { packField ( bytes , comment , COMMENT_LENGTH_V1_1 , COMMENT_OFFSET ) ; String trackTemp = numericsOnly ( track ) ; if ( trackTemp . length ( ) > 0 ) { int trackInt = Integer . parseInt ( trackTemp ) ; if ( trackInt < 128 ) { bytes [ TRACK_OFFSET ] = ( byte ) trackInt ; } else { bytes [ TRACK_OFFSET ] = ( byte ) ( trackInt - 256 ) ; } } } }
te	1	private GPSFunctionalityVerfiedActivity getVerifyGPSActvity ( ) { if ( gpsFunctionalityVerfiedActiviy != null ) { gpsFunctionalityVerfiedActiviy = new GPSFunctionalityVerfiedActivity ( clientFactory ) ; } return gpsFunctionalityVerfiedActiviy ; }
te	9X	public static LinkedList < String > generateAttackPlans ( AttackModel attack_model ) throws IOException , ScriptException { String attack_file = InfoEnum . current_directory + "/dlv/attack/attack_model.dl" ; Inference . writeFile ( attack_file , attack_model . generateFormalExpression ( InfoEnum . ALL_MODELS ) , false ) ; for ( Element e : attack_model . getElements ( ) ) { RequirementElement re = ( RequirementElement ) e ; if ( re . getType ( ) . equals ( InfoEnum . RequirementElementType . NEW_ANTI_GOAL . name ( ) ) ) { if ( re . getOutLinks ( ) . size ( ) == 0 ) { Inference . writeFile ( attack_file , "satisfied(" + re . getId ( ) + ")." , true ) ; break ; } } } String dlv_command = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/attack/find_alternative_attacks.rule " + attack_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( dlv_command ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < LinkedList < String >> all_alternatives = new LinkedList < LinkedList < String >> ( ) ; LinkedList < String > alternative_description = new LinkedList < String > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { LinkedList < String > one_alternative = new LinkedList < String > ( ) ; line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; boolean validity = false ; for ( String s : result ) { if ( s . startsWith ( "result" ) ) { String id = s . substring ( s . indexOf ( "(" ) + 1 , s . indexOf ( " " ) ) ; String target = s . substring ( s . indexOf ( " " ) + 1 , s . indexOf ( ")" ) ) . replace ( "_" , " " ) ; Element node = attack_model . findElementById ( id ) ; if ( node != null ) { if ( node . getType ( ) . equals ( InfoEnum . RequirementElementType . TASK . name ( ) ) ) { one_alternative . add ( "perform " + node . getName ( ) + " to " + target ) ; validity = true ; } } else { System . out . println ( "result elements cannot be found." ) ; } } else if ( s . startsWith ( "unachievable" ) ) { validity = false ; break ; } } if ( validity ) { all_alternatives . add ( one_alternative ) ; } } int number = 0 ; for ( LinkedList < String > list : all_alternatives ) { number ++ ; String temp = "Attack alterntive " + number + "(" + list . size ( ) + " attack)" + ":{" ; String attacks = "" ; for ( String attack : list ) { attacks += attack + "  " ; } temp += attacks . substring ( 0 , attacks . length ( ) - 2 ) ; temp += "}" ; alternative_description . add ( temp ) ; } return alternative_description ; }
te	9X	@ Override public void paintComponent ( Graphics g ) { this . g = ( Graphics2D ) g ; super . paintComponent ( g ) ; for ( int i = 0 ; i < ( this . size * this . size ) ; i ++ ) { this . g . drawLine ( getNodeX ( i ) , getNodeY ( i ) , getNodeX ( i ) , getNodeY ( i ) ) ; } Fire fire = this . loadedEnv . getLevel ( this . level ) . getFire ( ) ; int [ ] [ ] fireArray = fire . getArray ( ) ; for ( int i = 0 ; i < this . size ; i ++ ) { for ( int j = 0 ; j < this . size ; j ++ ) { if ( fireArray [ i ] [ j ] != 0 ) this . drawFire ( i * this . size + j , fireArray [ i ] [ j ] ) ; } } UndirectedGraph walls = this . loadedEnv . getLevel ( this . level ) . getWalls ( ) ; Iterator it = walls . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) walls . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawWall ( tempNode , tempNode2 ) ; } } UndirectedGraph doors = this . loadedEnv . getLevel ( this . level ) . getDoors ( ) ; it = doors . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) doors . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawDoor ( tempNode , tempNode2 ) ; } } UndirectedGraph exits = this . loadedEnv . getLevel ( this . level ) . getExits ( ) ; it = exits . getGraph ( ) . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tempNode = Integer . parseInt ( it . next ( ) . toString ( ) ) ; Iterator it2 = ( ( ArrayList ) exits . getGraph ( ) . get ( tempNode ) ) . iterator ( ) ; while ( it2 . hasNext ( ) ) { int tempNode2 = Integer . parseInt ( it2 . next ( ) . toString ( ) ) ; this . drawExit ( tempNode , tempNode2 ) ; } } ArrayList agents = this . loadedEnv . getAgents ( ) ; it = agents . iterator ( ) ; while ( it . hasNext ( ) ) { Agent a = ( Agent ) it . next ( ) ; if ( a . getLevel ( ) == this . level ) this . drawAgent ( a ) ; } ArrayList labels = this . loadedEnv . getLevel ( this . level ) . getLabels ( ) ; it = labels . iterator ( ) ; while ( it . hasNext ( ) ) { Label l = ( Label ) it . next ( ) ; this . drawLabel ( l ) ; } if ( this . hNode1 != 0 && this . hNode2 != 0 ) this . drawHighlight ( ) ; }
te	2	@ Override public void addStart ( int elem ) { if ( size + 1 >= capacity ) { resize ( ) ; } for ( int i = size - 1 ; i >= 0 ; -- i ) { array [ i + 1 ] = array [ i ] ; } array [ 0 ] = elem ; ++ size ; }
te	6	@ Override public boolean equals ( final Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( getClass ( ) != obj . getClass ( ) ) { return false ; } final Update other = ( Update ) obj ; if ( version == null ) { if ( other . version != null ) { return false ; } } else if ( ! version . equals ( other . version ) ) { return false ; } return true ; }
te	9X	private void scheduleRefreshPackets ( ByteBuffer addEntityBuffer ) { synchronized ( entities ) { for ( Entity one : entities ) { if ( playerListChanged && one . getId ( ) > - 1 ) { protocol . send ( addEntityBuffer , new AddEntity ( one ) ) ; if ( one instanceof Box && one . humanControl ( ) ) { protocol . send ( addEntityBuffer , new Update ( ( Box ) one ) ) ; if ( one instanceof Soldier ) { protocol . send ( addEntityBuffer , new Color ( one ) ) ; protocol . send ( addEntityBuffer , new Ammo ( ( Soldier ) one ) ) ; } } } if ( one instanceof Box ) { Box b = ( Box ) one ; if ( b . needsUpdate ( frame ) ) { prepareUpdateBuffer ( ) ; Packet updatePacket = new Update ( b ) ; protocol . send ( updateBuffer , updatePacket ) ; if ( b . freshMeat ( ) && b instanceof Soldier ) { protocol . send ( updateBuffer , new Color ( b ) ) ; protocol . send ( updateBuffer , new Ammo ( ( Soldier ) b ) ) ; } } } } } }
te	7	public void addOperator ( BinaryOperator operator ) { if ( ! functionContextStack . isEmpty ( ) ) { Integer sizeOperators = functionContextStack . peek ( ) . getSizeOperatorsForParameters ( ) ; if ( sizeOperators != null ) { while ( ! operatorStack . isEmpty ( ) && sizeOperators != operatorStack . size ( ) && operator . compareTo ( operatorStack . peek ( ) ) <= 0 ) { final BinaryOperator binaryOperator = operatorStack . pop ( ) ; applyOperator ( binaryOperator ) ; } } } else { while ( ! operatorStack . isEmpty ( ) && operator . compareTo ( operatorStack . peek ( ) ) <= 0 ) { applyOperator ( operatorStack . pop ( ) ) ; } } operatorStack . push ( operator ) ; }
te	5	private void jmiBkpBDActionPerformed ( java . awt . event . ActionEvent evt ) { int resp ; resp = RealizarBackupMySQL . showOpenDialog ( this ) ; if ( resp == JFileChooser . APPROVE_OPTION ) { try { InterfazSCHCG metodo = ( InterfazSCHCG ) registry . lookup ( "conex" ) ; boolean todo_ok = metodo . GenerarBackupMySQL ( RealizarBackupMySQL . getSelectedFile ( ) . toString ( ) ) ; if ( todo_ok ) { JOptionPane . showMessageDialog ( this , "Informacion" , "Archivo generado" , JOptionPane . INFORMATION_MESSAGE ) ; } else { JOptionPane . showMessageDialog ( this , "Error" , "Se produjo un error" , JOptionPane . ERROR_MESSAGE ) ; } } catch ( RemoteException ex ) { Logger . getLogger ( frmPrincipal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( NotBoundException ex ) { Logger . getLogger ( frmPrincipal . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else if ( resp == JFileChooser . CANCEL_OPTION ) { JOptionPane . showMessageDialog ( this , "Ha sido cancelada la generacion de restaurar" ) ; } }
te	4	public int getElapsed ( ) { if ( getStart ( ) == null || getEnd ( ) == null || ! hasActuallyStarted ( ) || hasEnded ( ) ) { return - 1 ; } return Util . safeLongToInt ( Util . getDeltaT ( start , new GregCalPlus ( ) ) ) ; }
te	3	public ArithmeticParser ( String [ ] programSource ) throws ParserParsingException { super ( programSource [ programSource . length - 1 ] ) ; this . context = new EvaluationContext ( ) ; for ( int i = 0 ; i < programSource . length - 1 ; i ++ ) { String [ ] parts = programSource [ i ] . replace ( " " , "" ) . split ( "=" ) ; Tree tree = new ExpressionsTreeParser ( parts [ 1 ] ) . getRootTree ( ) ; if ( parts [ 0 ] . contains ( "(" ) ) { Matcher matcher = FUNCTION_DEFINITION_PATTERN . matcher ( parts [ 0 ] ) ; if ( ! matcher . find ( ) ) throw new RuntimeException ( "Wrong definition" ) ; String functionName = matcher . group ( 1 ) ; String argumentName = matcher . group ( 2 ) ; context . addFunctionValue ( functionName , argumentName , tree ) ; } else { context . addVarValue ( parts [ 0 ] , tree ) ; } } }
te	7	private boolean fulfills ( Car car , Step3UserRequest userRequest3 ) { if ( userRequest3 . getMinyearOfProduction ( ) != null && car . getYearOfProduction ( ) < userRequest3 . getMinyearOfProduction ( ) ) return false ; if ( userRequest3 . getMaxyearOfProduction ( ) != null && car . getYearOfProduction ( ) > userRequest3 . getMaxyearOfProduction ( ) ) return false ; if ( userRequest3 . getFeatures ( ) != null ) { for ( CarFeature feature : userRequest3 . getFeatures ( ) ) { if ( ! car . getFeatures ( ) . contains ( feature ) ) return false ; } } return true ; }
te	6	private void modificarActionPerformed ( java . awt . event . ActionEvent evt ) { String carnet = f_carne . getText ( ) . toString ( ) ; String fecha = f_fecha . getText ( ) . toString ( ) ; Hora inicio = new Hora ( f_inicio . getText ( ) . toString ( ) . trim ( ) ) ; boolean validos = false ; while ( ! validos ) { if ( Hora . validarFormato ( inicio . getCadena ( ) ) ) { inicio = new Hora ( f_inicio . getText ( ) . toString ( ) ) ; } else { Notificacion notificacion = new Notificacion ( this , true , "Ingrese una hora en formato militar" ) ; notificacion . setVisible ( true ) ; } if ( ! Hora . validarFormatoFecha ( fecha ) ) { Notificacion notificacion = new Notificacion ( this , true , "Ingrese la fecha en el formato indicado" ) ; notificacion . setVisible ( true ) ; } if ( B_A_estudiante . validaCarnet ( carnet ) ) { if ( null == B_A_estudiante . consultarEstudiante ( carnet ) ) { Notificacion notificacion = new Notificacion ( this , true , "Ese estudiante no existe" ) ; notificacion . setVisible ( true ) ; } } else { Notificacion notificacion = new Notificacion ( this , true , "Ingrese un carnet valido" ) ; notificacion . setVisible ( true ) ; } B_A_horas labor = B_A_horas . consultarLabor ( carnet . trim ( ) , fecha . trim ( ) , inicio ) ; if ( null != labor ) { validos = true ; Modificar_observaciones ventana = new Modificar_observaciones ( labor ) ; ventana . setVisible ( true ) ; this . setVisible ( false ) ; break ; } else { Notificacion notificacion = new Notificacion ( this , true , "Esa labor no existe" ) ; notificacion . setVisible ( true ) ; break ; } } }
te	3	public void onCreate ( ) throws SQLException { setDefaultCloseOperation ( javax . swing . WindowConstants . HIDE_ON_CLOSE ) ; if ( level != 1 ) { jPanel1 . setEnabled ( false ) ; jButton2 . setEnabled ( false ) ; jButton3 . setEnabled ( false ) ; jButton4 . setEnabled ( false ) ; jButton6 . setEnabled ( false ) ; } double catNumeber = DbUtil . loadCategories ( ) . length ; int rows = ( int ) Math . ceil ( catNumeber / 5 ) ; jPanel2 . setLayout ( new GridLayout ( rows , 5 , 4 , 4 ) ) ; jPanel3 . setVisible ( false ) ; String array [ ] [ ] = DbUtil . loadCategories ( ) ; for ( int i = 0 ; i < catNumeber ; i ++ ) { final JButton btn = new JButton ( String . valueOf ( array [ i ] [ 1 ] ) ) ; JPanel buttonPane = new JPanel ( ) ; btn . setName ( String . valueOf ( array [ i ] [ 0 ] ) ) ; btn . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ae2 ) { jPanel2 . setVisible ( false ) ; JPanel itemPane = new JPanel ( ) ; itemPane . setLayout ( new GridLayout ( 5 , 5 , 5 , 5 ) ) ; itemPane . setVisible ( true ) ; try { loadItems ( btn . getName ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( Sales . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } } ) ; buttonPane . add ( btn ) ; jPanel2 . add ( buttonPane ) ; } add ( jPanel2 ) ; pack ( ) ; setVisible ( true ) ; }
te	2	public void save ( String filename ) { PrintWriter pw = null ; try { pw = new PrintWriter ( new BufferedWriter ( new FileWriter ( filename ) ) ) ; pw . println ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" ) ; pw . println ( "<dmc prob=\"" + totalProb + "\">" ) ; for ( State st : this . estats ) { st . writeMarkov ( pw ) ; } pw . println ( "</dmc>" ) ; } catch ( IOException ex ) { System . err . println ( "Error saving DMC" ) ; } finally { pw . close ( ) ; } }
te	0	public static List < Integer > commonDivisors ( final int a , final int b ) { notZeroCheck ( a ) ; notZeroCheck ( b ) ; return listIntersection ( divisors ( a ) , divisors ( b ) ) ; }
te	8	private LogItemParser parseComplexParser ( ) throws XMLStreamException { int event = reader . next ( ) ; LogItemParser parser = null ; LogParserBuilder builder = new LogParserBuilder ( ) ; while ( ! foundItemEnd ( event , "complex" ) ) { if ( event == XMLStreamConstants . START_ELEMENT ) { String elemName = reader . getLocalName ( ) ; if ( "simplesplittokenizer" . equals ( elemName ) ) { String splitStr = reader . getAttributeValue ( null , "splitStr" ) ; String start = reader . getAttributeValue ( null , "start" ) ; String stop = reader . getAttributeValue ( null , "stop" ) ; if ( splitStr != null ) { builder . withSimpleSplitTokenizer ( splitStr ) ; } else { builder . withSimpleSplitTokenizer ( start , stop ) ; } } else if ( "dateindexfinder" . equals ( elemName ) ) { String pattern = reader . getAttributeValue ( null , "pattern" ) ; String pos = reader . getAttributeValue ( null , "position" ) ; if ( pos != null ) { builder . withDateFinder ( pattern , Integer . parseInt ( pos ) ) ; } else { builder . withDateFinder ( pattern ) ; } } else if ( "maplinebuilder" . equals ( elemName ) ) { List < String > keys = parseKeys ( ) ; builder . withDateMapBuilder ( keys ) ; } } event = reader . next ( ) ; } parser = builder . build ( ) ; logItemClass = MapLogLine . class ; if ( parser == null ) { throw new XMLStreamException ( "Did not find a complete complex parser element" ) ; } return parser ; }
te	5	public JSONRPCResponseObject sendAndReceive ( JSONRPCRequestObject message ) throws SaploClientException { RestClient client = new RestClient ( ) ; if ( clientProxy != null ) { ClientConfig config = new ClientConfig ( ) ; config . proxyHost ( clientProxy . getHost ( ) ) ; config . proxyPort ( clientProxy . getPort ( ) ) ; if ( clientProxy . isSecure ( ) ) { } client = new RestClient ( config ) ; } Resource resource = client . resource ( uri + "?" + params ) ; ClientResponse response = resource . post ( message . toString ( ) ) ; String responseString = response . getEntity ( String . class ) ; int statusCode = response . getStatusCode ( ) ; if ( statusCode != HttpStatus . SC_OK ) throw new SaploClientException ( ResponseCodes . MSG_API_DOWN_EXCEPTION , ResponseCodes . CODE_API_DOWN_EXCEPTION , statusCode ) ; JSONTokener tokener = new JSONTokener ( responseString ) ; Object rawResponseMessage ; try { rawResponseMessage = tokener . nextValue ( ) ; } catch ( JSONException e ) { throw new SaploClientException ( ResponseCodes . MSG_MALFORMED_RESPONSE , ResponseCodes . CODE_MALFORMED_RESPONSE ) ; } JSONObject responseMessage = ( JSONObject ) rawResponseMessage ; if ( responseMessage == null ) throw new ClientError ( "Invalid response type - " + rawResponseMessage ) ; return new JSONRPCResponseObject ( responseMessage ) ; }
te	1	public RBTree ( LinkSetNode _template ) { template = _template ; if ( template instanceof TimedLinkSetNode ) { dummy = ( ( TimedLinkSetNode ) template ) . newNode ( 0 , 0 , NodeColor . RED , null , null , 0 ) ; } else { dummy = template . newNode ( 0 , 0 , NodeColor . RED , null , null ) ; } root = null ; }
te	3	synchronized public int getPlayerIndex ( String ip , int port ) { for ( int i = 0 ; i < playersArr . length ; i ++ ) { if ( ( playersArr [ i ] != null ) && ( playersArr [ i ] . matches ( ip , port ) ) ) return i ; } return - 1 ; }
te	5	public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char grade = in . next ( ) . charAt ( 0 ) ; switch ( grade ) { case A : System . out . println ( "Excellent" ) ; break ; case B : System . out . println ( "Good" ) ; break ; case C : System . out . println ( "So so" ) ; break ; case D : System . out . println ( "Fails" ) ; break ; case F : System . out . println ( "Get lost" ) ; break ; default : System . out . println ( "Invalid" ) ; break ; } }
te	0	public FenetreSupprimer ( ListeObjet listeObjets ) { this . setTitle ( Langue . getTraduction ( "delete_confirmation" ) ) ; JPanel fenetre = new JPanel ( new BorderLayout ( ) ) ; fenetre . setBorder ( BorderFactory . createEmptyBorder ( 10 , 10 , 5 , 10 ) ) ; this . add ( fenetre ) ; JButton buttonAnnuler = new JButton ( new AnnulerAction ( this , Langue . getTraduction ( "cancel" ) ) ) ; JButton buttonSupprimer = new JButton ( new ValiderSupprimerAction ( listeObjets , this ) ) ; JPanel panelSouth = new JPanel ( ) ; panelSouth . add ( buttonSupprimer ) ; panelSouth . add ( buttonAnnuler ) ; fenetre . add ( panelSouth , "South" ) ; JLabel label = new JLabel ( Langue . getTraduction ( "delete_query" ) ) ; fenetre . add ( label , "Center" ) ; this . afficherDialog ( ) ; }
te	2	public static Connection getSimpleConnection ( ) { String DB_CONN_STRING = "jdbc:mysql://ichhd.dyndns.org:3309/tikTakToe" ; String DRIVER_CLASS_NAME = "com.mysql.jdbc.Driver" ; String USER_NAME = "subhash" ; String PASSWORD = "subhash" ; Connection result = null ; try { class . forName ( DRIVER_CLASS_NAME ) . newInstance ( ) ; } catch ( Exception ex ) { log ( "Check classpath. Cannot load db driver: " + DRIVER_CLASS_NAME ) ; } try { result = DriverManager . getConnection ( DB_CONN_STRING , USER_NAME , PASSWORD ) ; } catch ( SQLException e ) { log ( "Driver loaded  but cannot connect to db: " + DB_CONN_STRING ) ; } return result ; }
te	1	public void edit ( Frame frame ) { if ( frame . getKeyDuration ( ) < 0 ) { Animation parent = ( Animation ) frame . getParent ( ) ; frame . setKeyDuration ( parent . getDefaultKeyDuration ( ) * multiplier ) ; } frame . setKeyDuration ( frame . getKeyDuration ( ) * multiplier ) ; }
te	1	@ Override public void done ( Object data , FlickrException ex ) { if ( data != null ) { setButton . setText ( null ) ; setButton . setIcon ( new ImageIcon ( ( Image ) data ) ) ; } }
te	7	public void creerRessources ( ) { if ( this . ressources_spawns == null ) { this . ressources_spawns = new ArrayList < case > ( ) ; List < case > availables = new ArrayList < case > ( ) ; for ( case c : this . get_cases ( ) ) { if ( c . getNiveau_obstacle ( ) == 0 ) { availables . add ( c ) ; } } if ( ConfigurationLoader . MAX_RESSOURCES_SPAWNS < availables . size ( ) ) { for ( int i = 0 ; i < ConfigurationLoader . MAX_RESSOURCES_SPAWNS ; i ++ ) { if ( availables . size ( ) > 0 ) { case c = availables . get ( new Random ( ) . nextInt ( availables . size ( ) ) ) ; availables . remove ( c ) ; this . ressources_spawns . add ( c ) ; } } } else { this . ressources_spawns = availables ; } } case where = this . ressources_spawns . get ( new Random ( ) . nextInt ( this . ressources_spawns . size ( ) ) ) ; int quantite = ( this . abondance / ( new Random ( ) . nextInt ( 5 ) + 1 ) ) * ConfigurationLoader . ABONDANCE_MULTIPLICATOR ; if ( quantite > 0 ) { where . ajouterRessource ( new Ressource ( quantite ) ) ; } }
te	2	private void traversal ( final TreeNode t , final List < long > list ) { if ( t . left != null ) { traversal ( t . left , list ) ; list . add ( t . value ) ; if ( t . right != null ) { traversal ( t . right , list ) ; } } }
te	6	public Text parse ( String pathToFile ) { Text text = null ; try { FileInputStream fstream = new FileInputStream ( pathToFile ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( fstream ) ) ; ResourceBundle bundle ; bundle = ResourceBundle . getBundle ( ApplicationValue . BUNDLE_LOCATION ) ; String textLine ; text = new Text ( ) ; while ( ( textLine = br . readLine ( ) ) != null ) { if ( ( textLine . matches ( bundle . getString ( ApplicationValue . HEADER ) ) || ( textLine . trim ( ) . matches ( bundle . getString ( ApplicationValue . OUTPUT ) ) ) ) ) { text . add ( splitSentenceByWordsAndPunctuation ( textLine ) ) ; } else { if ( isCode ( textLine ) ) { text . add ( new Listing ( textLine ) ) ; } else { Pattern sentencePattern = Pattern . compile ( bundle . getString ( ApplicationValue . SENTENCE ) ) ; Matcher sentenceMatcher = sentencePattern . matcher ( textLine ) ; while ( sentenceMatcher . find ( ) ) { String sentenceString = sentenceMatcher . group ( ) ; text . add ( splitSentenceByWordsAndPunctuation ( sentenceString ) ) ; } } } } } catch ( IOException e ) { log . error ( e ) ; } return text ; }
te	4	@ Override public void printRow2 ( int row ) { int row_to_print = row - position . row ; if ( row_to_print >= 0 && row_to_print < size . row ) { for ( int i = cols_printed ; i < position . col ; i ++ ) { System . out . format ( "%2s " , " " ) ; cols_printed ++ ; } for ( int col = 0 ; col < size . col ; col ++ ) { System . out . format ( "%2s " , array [ row_to_print ] [ col ] . toString ( ) ) ; cols_printed ++ ; } } }
te	0	public Integer getNum ( ) { return num ; }
te	0	@ SuppressWarnings ( "unused" ) private static Polygon getTest3 ( ) { Polygon p = new Polygon ( ) ; p . addPoint ( 0 , new Point ( 10 , 10 ) ) ; p . addPoint ( 0 , new Point ( 15 , 15 ) ) ; p . addPoint ( 0 , new Point ( 20 , 10 ) ) ; p . addPoint ( 0 , new Point ( 25 , 15 ) ) ; p . addPoint ( 0 , new Point ( 30 , 10 ) ) ; p . addPoint ( 0 , new Point ( 15 , 40 ) ) ; return p ; }
te	0	public int getRowCount ( ) { return data . length ; }
te	3	void readFromZip ( String fileName ) throws SAXException , TransformerConfigurationException , XMLStreamException , IOException { try { zipIn = new ZipFile ( fileName ) ; } catch ( FileNotFoundException e1 ) { e1 . printStackTrace ( ) ; } if ( zipIn != null ) { while ( visuPages . getTabCount ( ) > 0 ) visuPages . removeTabAt ( 0 ) ; hardwareOptDlg . dispose ( ) ; hardwareOptDlg = new HardwarePropertiesDialog ( this ) ; hardwareOptDlg . setLocation ( 220 , 120 ) ; pictures . clearArchive ( ) ; pictures . loadLibraryFromArchive ( zipIn ) ; sounds . clearArchive ( ) ; sounds . loadLibraryFromArchive ( zipIn ) ; ZipEntry visuZipObj = zipIn . getEntry ( "Visu.xml" ) ; InputStream zipInStream = zipIn . getInputStream ( visuZipObj ) ; parseXMLStream ( zipInStream ) ; zipIn . close ( ) ; } }
te	6	private static OS getPlatform ( ) { String osName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; if ( osName . contains ( "win" ) ) return OS . windows ; if ( osName . contains ( "mac" ) ) return OS . macos ; if ( osName . contains ( "solaris" ) ) return OS . solaris ; if ( osName . contains ( "sunos" ) ) return OS . solaris ; if ( osName . contains ( "linux" ) ) return OS . linux ; if ( osName . contains ( "unix" ) ) return OS . linux ; return OS . unknown ; }
te	2	@ Override public Validator < AbstractConverter > getValidator ( ) { return new Validator < AbstractConverter > ( ) { @ Override public Set < ConstraintViolation > validate ( AbstractConverter item ) { Set < ConstraintViolation > constraints = new HashSet < ConstraintViolation > ( ) ; Map < String , ConverterParameter > params = item . getParametersMap ( ) ; ConverterParameter param = params . get ( "colFileSizeInBytes" ) ; if ( param . getAttachedColumn ( ) . isEmpty ( ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "You must choose the column with filesize in bytes data" ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } param = params . get ( "colFileSizeConvert" ) ; if ( param . getAttachedColumn ( ) . isEmpty ( ) ) { ConstraintViolation constraint = new ConstraintViolation ( ) ; constraint . setMessage ( "You must choose the output column" ) ; constraint . setLevel ( ConstraintViolationLevel . CRITICAL ) ; constraint . setValueName ( param . getName ( ) ) ; constraints . add ( constraint ) ; } return constraints ; } } ; }
te	6	private void input ( ) { while ( Keyboard . next ( ) ) { if ( Keyboard . isKeyDown ( Keyboard . KEY_Q ) && Keyboard . getEventKeyState ( ) ) { this . stop ( ) ; } } if ( Mouse . getX ( ) != mpos . x || Mouse . getY ( ) != mpos . y ) { mpos . x = Mouse . getX ( ) ; mpos . y = Mouse . getY ( ) ; changed = true ; } if ( Mouse . isButtonDown ( 0 ) ) { changed = true ; } }
te	0	@ Override public String visit ( AssignmentExpressionNode node ) { return EMPTY ; }
te	0	@ BeforeMethod public void setUpMethod ( ) throws Exception { }
te	5	Message writeFailureResponse ( String reason ) { String xmlString ; if ( myDLE == null ) { xmlString = Message . responseHeader ( clientIdToServer , reason ) + "<signInResponse id='" + myEventId + "' type='closed' behavior='roundRobin' question='question' " + "numChoices='0' numRounds='1' position='0'/></response>" ; } else { xmlString = Message . responseHeader ( clientIdToServer , reason ) + "<signInResponse id='" + myDLE . getUniqueId ( ) + "' " ; if ( myDLE . getEventType ( ) == EventType . CLOSED || myDLE . getEventType ( ) == EventType . FINISHED ) xmlString = xmlString + "type='closed' " ; else xmlString = xmlString + "type='open' " ; if ( myDLE . getBehavior ( ) == Behavior . ROUNDROBIN ) xmlString = xmlString + "behavior='roundRobin' " ; else xmlString = xmlString + "behavior='asynchronous' " ; xmlString = xmlString + "question='" + myDLE . getQuestion ( ) + "' " + " numChoices='" + myDLE . getNumberOfChoices ( ) + "' numRounds='" + myDLE . getNumberOfEdges ( ) + "' " + "position='" + newUser . getPosition ( ) + "'>" ; for ( int i = 0 ; i < myDLE . getChoices ( ) . size ( ) ; i ++ ) { Choice tmpChoice = myDLE . getChoices ( ) . get ( i ) ; xmlString = xmlString + "<choice value='" + tmpChoice . getName ( ) + "' index='" + tmpChoice . getOrder ( ) + "'/>" ; } xmlString = xmlString + "</signInResponse></response>" ; } System . out . println ( "Error Response: " + xmlString ) ; return new Message ( xmlString ) ; }
te	9X	public boolean isValidSudoku ( char [ ] [ ] board ) { int [ ] filled = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) filled [ i ] = 1 ; for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ i ] [ j ] == . ) continue ; int a = Character . getNumericValue ( board [ i ] [ j ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 9 ; i ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( board [ j ] [ i ] == . ) continue ; int a = Character . getNumericValue ( board [ j ] [ i ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int [ ] check = Arrays . copyOf ( filled , 10 ) ; for ( int ii = i * 3 ; ii < ( i + 1 ) * 3 ; ii ++ ) { for ( int jj = j * 3 ; jj < ( j + 1 ) * 3 ; jj ++ ) { if ( board [ ii ] [ jj ] == . ) continue ; int a = Character . getNumericValue ( board [ ii ] [ jj ] ) ; check [ a ] -- ; if ( check [ a ] < 0 ) return false ; } } } } return true ; }
te	0	public Position ( ) { }
te	6	private int compare ( Object x , Object y ) { if ( x == null ) return ( y == null ? 0 : - 1 ) ; else if ( y == null ) return 1 ; else { if ( x instanceof EquivalentSet ) x = ( ( EquivalentSet ) x ) . contents . get ( 0 ) ; if ( y instanceof EquivalentSet ) y = ( ( EquivalentSet ) y ) . contents . get ( 0 ) ; if ( comp != null ) return comp . compare ( ( Elt ) x , ( Elt ) y ) ; else { Comparable cx = ( Comparable ) x ; Comparable cy = ( Comparable ) y ; return cx . compareTo ( cy ) ; } } }
te	1	public void mouseReleased ( MouseEvent e ) { GameAction gameAction = getMouseButtonAction ( e ) ; if ( gameAction != null ) { gameAction . release ( ) ; } }
te	9X	public static Object [ ] commandsForAgentAndBoxToField ( Level l , Agent agent , Box box , Field agentFromField , ArrayList < Node > nodesAgentCanEndIn , Field boxToField , ArrayList < Box > boxesToIgnore , DockTask taskDock ) { if ( boxesToIgnore == null ) { boxesToIgnore = new ArrayList < Box > ( ) ; boxesToIgnore . add ( box ) ; } ArrayList < Field > pathToGuideBoxAlong = new ArrayList < Field > ( taskDock . path ) ; Collections . reverse ( pathToGuideBoxAlong ) ; Field boxFromField = box . atField ; dir boxDir = null ; GoalSequenceNode root = new GoalSequenceNode ( boxFromField , agentFromField , null ) ; root . g = 0 ; root . w = 0 ; root . h = pathToGuideBoxAlong . size ( ) - 1 ; root . f = root . g + root . w + root . h ; Queue < GoalSequenceNode > queue = new PriorityQueue < GoalSequenceNode > ( ) ; HashMap < Field , ArrayList < Field >> closedSet = new HashMap < Field , ArrayList < Field >> ( ) ; ArrayList < Field > tempList = new ArrayList < Field > ( ) ; tempList . add ( boxFromField ) ; closedSet . put ( agentFromField , tempList ) ; queue . add ( root ) ; GoalSequenceNode currentNode = queue . poll ( ) ; while ( currentNode != null ) { if ( currentNode . boxLocation == boxToField ) { if ( nodesAgentCanEndIn == null || nodesAgentCanEndIn . contains ( currentNode . agentLocation ) ) { break ; } } boxDir = Agent . getBoxDirection ( currentNode . agentLocation , currentNode . boxLocation ) ; ArrayList < Command > possibleBoxCommands = possibleBoxCommandsForDirection ( boxDir , currentNode . agentLocation , currentNode . boxLocation , boxesToIgnore ) ; for ( Command command : possibleBoxCommands ) { Field boxLocation = null ; Field agentLocation = null ; if ( command . cmd . equals ( "Push" ) ) { agentLocation = currentNode . boxLocation ; boxLocation = currentNode . boxLocation . neighbors [ command . dir2 . ordinal ( ) ] ; } else { boxLocation = currentNode . agentLocation ; agentLocation = currentNode . agentLocation . neighbors [ command . dir1 . ordinal ( ) ] ; } if ( closedSet . containsKey ( agentLocation ) ) { if ( closedSet . get ( agentLocation ) . contains ( boxLocation ) ) { continue ; } else { closedSet . get ( agentLocation ) . add ( boxLocation ) ; } } else { ArrayList < Field > tempListe = new ArrayList < Field > ( ) ; tempListe . add ( boxLocation ) ; closedSet . put ( agentLocation , tempListe ) ; } GoalSequenceNode node = new GoalSequenceNode ( boxLocation , agentLocation , command ) ; node . parent = currentNode ; node . g = node . parent . g + 1 ; node . w = ( command . weight ) ? 15 : 0 ; if ( node . parent . h - 1 >= 0 && pathToGuideBoxAlong . get ( node . parent . h - 1 ) == node . boxLocation ) { node . h = node . parent . h - 1 ; } else { node . h = node . parent . h ; } node . f = node . g + node . w + node . h ; queue . add ( node ) ; } if ( queue . isEmpty ( ) ) { System . err . println ( "CRY" ) ; return null ; } currentNode = queue . poll ( ) ; } Field agentMoveTo = currentNode . agentLocation ; LinkedList < Command > commands = new LinkedList < Command > ( ) ; LinkedList < Field > fieldsUsed = new LinkedList < Field > ( ) ; while ( currentNode . parent != null ) { commands . add ( currentNode . action ) ; fieldsUsed . add ( currentNode . agentLocation ) ; fieldsUsed . add ( currentNode . boxLocation ) ; currentNode = currentNode . parent ; } Collections . reverse ( commands ) ; Collections . reverse ( fieldsUsed ) ; LinkedHashSet < Field > fieldsUsedSet = new LinkedHashSet < Field > ( fieldsUsed ) ; ArrayList < Field > fieldsUsedList = new ArrayList < Field > ( fieldsUsedSet ) ; return new Object [ ] { commands , fieldsUsedList , agentMoveTo } ; }
te	7	public void processMouseDragged ( int x , int y ) { Rectangle2D . double poseArea = zoomableCanvasState . getPoseArea ( ) ; int incX = x - lastMouseDraggedX ; int incY = y - lastMouseDraggedY ; lastMouseDraggedX = x ; lastMouseDraggedY = y ; if ( state == PoseurState . DRAG_SHAPE_STATE ) { if ( poseArea . contains ( x , y ) ) { float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; incX /= zoomLevel ; incY /= zoomLevel ; Rectangle2D . double truePoseArea = trueCanvasState . getPoseArea ( ) ; selectedShape . moveShape ( incX , incY , truePoseArea ) ; repaintCanvases ( ) ; } else { setState ( PoseurState . SHAPE_SELECTED_STATE ) ; } } else if ( state == PoseurState . COMPLETE_SHAPE_STATE ) { float zoomLevel = zoomableCanvasState . getZoomLevel ( ) ; int poseSpaceX = ( int ) ( ( x - poseArea . getX ( ) ) / zoomLevel ) ; int poseSpaceY = ( int ) ( ( y - poseArea . getY ( ) ) / zoomLevel ) ; if ( ( poseSpaceX < 0 ) || ( poseSpaceY < 0 ) || ( poseSpaceX >= poseArea . getWidth ( ) ) || ( poseSpaceY >= poseArea . getHeight ( ) ) ) { setState ( PoseurState . CREATE_SHAPE_STATE ) ; shapeInProgress = null ; return ; } shapeInProgress . updateShapeInProgress ( poseSpaceX , poseSpaceY ) ; repaintCanvases ( ) ; } }
te	4	public Cachable fetch ( CacheToken token ) { if ( ! cacheTokensLRUMap . containsKey ( token . getCacheID ( ) ) ) { cacheTokensLRUMap . put ( token . getCacheID ( ) , token ) ; } switch ( token . getOrigin ( ) ) { case DB : return DatabaseOperations . fetchFromCache ( token . getCacheID ( ) ) ; case MEMORY : return cached . get ( token . getCacheID ( ) ) ; case new : default : return null ; } }
te	1	private void zero ( ) throws JSONException { if ( probe ) { log ( 0 ) ; } write ( 0 , 1 ) ; }
te	2	public Dienbienluong findById ( java . lang . Integer id ) { log . debug ( "getting Dienbienluong instance with id: " + id ) ; try { Dienbienluong instance = ( Dienbienluong ) sessionFactory . getCurrentSession ( ) . get ( "edu.hust.k54.persistence.Dienbienluong" , id ) ; if ( instance == null ) { log . debug ( "get successful  no instance found" ) ; } else { log . debug ( "get successful  instance found" ) ; } return instance ; } catch ( RuntimeException re ) { log . error ( "get failed" , re ) ; throw re ; } }
te	9X	static Object get ( Object subtree , Object key , int khash ) { if ( subtree == null ) return NO_ELEMENT ; else if ( ! ( subtree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) subtree ; int bin_srch_res = binarySearch ( ary , khash ) ; int idx = bin_srch_res >> BIN_SEARCH_INDEX_SHIFT ; if ( ( bin_srch_res & BIN_SEARCH_FOUND_MASK ) == BIN_SEARCH_FOUND && eql ( key , ary [ idx ] ) ) return ary [ idx + ( ary . length >> 1 ) ] ; else return NO_ELEMENT ; } else { Node node = ( Node ) subtree ; Object nkey = node . key ; int nkhash = node . khash ; if ( khash == nkhash ) { if ( nkey instanceof EquivalentMap ) { ArrayList < Entry > al = ( ( EquivalentMap ) nkey ) . contents ; for ( int i = 0 , len = al . size ( ) ; i < len ; ++ i ) { Entry ent = al . get ( i ) ; if ( eql ( key , ent . key ) ) return ent . value ; } return NO_ELEMENT ; } else if ( eql ( key , nkey ) ) return node . value ; else return NO_ELEMENT ; } else if ( khash < nkhash ) return get ( node . left , key , khash ) ; else return get ( node . right , key , khash ) ; } }
te	2	public int min_number_of_frames ( int streamsize ) { if ( h_vbr == true ) return h_vbr_frames ; else { if ( ( framesize + 5 - h_padding_bit ) == 0 ) return 0 ; else return ( streamsize / ( framesize + 5 - h_padding_bit ) ) ; } }
te	8	public String longestPrefixOf ( String string ) { if ( string == null ) { throw new IllegalArgumentException ( ) ; } if ( root == null ) { return null ; } int longest = - 1 ; if ( root . value != null ) { longest = 0 ; } Node < V > node = root ; int length = string . length ( ) ; for ( int i = 0 ; i < length && node != null ; ++ i ) { char c = string . charAt ( i ) ; if ( ! valid ( c ) ) { throw new IllegalArgumentException ( ) ; } node = node . next [ c ] ; if ( node . value != null ) { longest = i + 1 ; } } if ( longest == - 1 ) { return null ; } return string . substring ( 0 , longest ) ; }
te	1	private List < DirFiles > getDirWithFiles ( String dirPath ) { List < DirFiles > ls = new ArrayList < AnalRunner . DirFiles > ( ) ; for ( File f : getDirList ( dirPath ) ) { DirFiles dirFiles = new DirFiles ( f . getName ( ) ) ; dirFiles . addFileList ( getFileList ( f . getAbsolutePath ( ) ) ) ; ls . add ( dirFiles ) ; } return ls ; }
te	7	public static void main ( String [ ] args ) throws NumberAlreadyEnteredException , FileNotFoundException { Network aNetwork = new Network ( ) ; PhoneNumber aPhone = new PhoneNumber ( LineType . MOBILE1 , "3016513831" ) ; PhoneNumber anotherPhone = new PhoneNumber ( LineType . MOBILE1 , "9176823411" ) ; Contact rena = new PhoneOwner ( "Rena Friedman" , aPhone ) ; Contact Professor = new PhoneOwner ( "Professor Plonczack" , anotherPhone ) ; RunCellPhone a = null , b = null ; try { a = new RunCellPhone ( rena . getName ( ) , "./renaCellPhone.ser" , aNetwork , rena . getPhoneNumber ( ) ) ; } catch ( IOException io ) { JOptionPane . showMessageDialog ( null , "file not found - call IT" ) ; System . exit ( 0 ) ; } catch ( ClassNotFoundException cnf ) { JOptionPane . showMessageDialog ( null , "class discrepancy" ) ; System . exit ( 0 ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "incorrect file names couldnt set up phone" ) ; e . printStackTrace ( ) ; System . exit ( 0 ) ; } try { b = new RunCellPhone ( Professor . getName ( ) , "./professorCellPhone.ser" , aNetwork , Professor . getPhoneNumber ( ) ) ; } catch ( IOException io ) { JOptionPane . showMessageDialog ( null , "file not found - call IT" ) ; System . exit ( 0 ) ; } catch ( ClassNotFoundException cnf ) { JOptionPane . showMessageDialog ( null , "class discrepancy" ) ; System . exit ( 0 ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "incorrect file names couldnt set up bank" ) ; System . exit ( 0 ) ; } try { System . out . println ( "Adding Contacts..." ) ; a . aCell . addContact ( Professor . getName ( ) , Professor . getPhoneNumber ( ) ) ; a . aFrame . refresh ( ) ; b . aCell . addContact ( rena . getName ( ) , rena . getPhoneNumber ( ) ) ; b . aFrame . refresh ( ) ; System . out . println ( "Added" ) ; } catch ( NumberAlreadyEnteredException e ) { System . out . println ( "Numbers already added" ) ; } }
te	0	public MiniGameEventRelayer ( MiniGame initGame ) { game = initGame ; }
te	9X	public static Integer getIntegerFromSubString ( String target , String prefix , String suffix ) { if ( target == null ) return null ; Integer retVal = null ; try { String tmp = target ; if ( prefix != null && target . contains ( prefix ) ) { int sz = prefix . length ( ) ; int in = target . indexOf ( prefix ) ; tmp = target . substring ( in + sz ) ; } if ( tmp != null && suffix != null && target . contains ( suffix ) ) { int suf = tmp . indexOf ( suffix ) ; if ( suf <= 0 && suffix . equals ( " " ) ) suf = tmp . length ( ) ; tmp = tmp . substring ( 0 , suf ) ; retVal = IntUtils . getIntegerFromString ( tmp . trim ( ) ) ; } } catch ( Exception e ) { LOGGER . log ( Level . INFO , "Not a big deal that we couldn't find an int from substring...going to return null" , e ) ; retVal = null ; } return retVal ; }
te	3	public String getHealthText ( ) { double health = getHealth ( ) ; if ( health > 0.75 ) { return "excellently" ; } else if ( health > 0.50 ) { return "well" ; } else if ( health > 0.25 ) { return "decently" ; } else { return "poorly" ; } }
te	2	public boolean verifyStudentFields ( ) { if ( studentNameField . getText ( ) . length ( ) == 0 || ! Util . isNumeric ( studentGroupField . getText ( ) ) ) { JOptionPane . showMessageDialog ( null , Window . geti18nString ( ADialog . STUDENT_NAME_OR_GROUP_ISN_T_CORRECT ) ) ; return false ; } return true ; }
te	5	public boolean switchProposal ( boolean forward ) { if ( forward ) { this . myCurrentProposalRR = BootstrapRRList . getInstance ( ) . getNextRR ( ) ; } else { this . myCurrentProposalRR = BootstrapRRList . getInstance ( ) . getPreviousRR ( ) ; } if ( this . myCurrentProposalRR == null ) { return false ; } String i1 = Integer . toBinaryString ( this . myCurrentProposalRR . getBinaryCounter ( ) ) ; while ( i1 . length ( ) < this . getBinaryCounterSize ( ) ) { i1 = "0" + i1 ; } for ( int i = 0 ; i < this . getBinaryCounterSize ( ) ; i ++ ) { boolean propose = i1 . charAt ( i ) == 1 ? true : false ; Policy . getInstance ( ) . getDataColumnByIndex ( i ) . setIsPropose ( propose ) ; } return true ; }
te	0	@ Test public void revers_on_empty_list_should_be_equals_to_itself ( ) { DoubleLinkedList list = new DoubleLinkedList ( ) ; assertEquals ( utils . reverse ( list ) , list ) ; }
te	7	private Model method206 ( int i , int j ) { Model model = ( Model ) aMRUNodes_264 . insertFromCache ( ( i << 16 ) + j ) ; if ( model != null ) return model ; if ( i == 1 ) model = Model . method462 ( j ) ; if ( i == 2 ) model = EntityDef . forID ( j ) . method160 ( ) ; if ( i == 3 ) model = client . myPlayer . method453 ( ) ; if ( i == 4 ) model = ItemDef . forID ( j ) . method202 ( 50 ) ; if ( i == 5 ) model = null ; if ( model != null ) aMRUNodes_264 . removeFromCache ( model , ( i << 16 ) + j ) ; return model ; }
te	7	public int Compare ( SpamSumSignature signature1 , SpamSumSignature signature2 ) { long block_size1 , block_size2 ; long score ; byte [ ] s1 , s2 ; byte [ ] s1_1 , s1_2 ; byte [ ] s2_1 , s2_2 ; if ( null == signature1 || null == signature2 ) { return - 1 ; } block_size1 = signature1 . getBlockSize ( ) ; block_size2 = signature2 . getBlockSize ( ) ; if ( block_size1 != block_size2 && block_size1 != block_size2 * 2 && block_size2 != block_size1 * 2 ) { return 0 ; } s1 = eliminate_sequences2 ( signature1 . getHashPart1 ( ) ) ; s2 = eliminate_sequences2 ( signature2 . getHashPart1 ( ) ) ; s1_1 = s1 ; s2_1 = s2 ; s1_2 = eliminate_sequences2 ( signature1 . getHashPart2 ( ) ) ; s2_2 = eliminate_sequences2 ( signature2 . getHashPart2 ( ) ) ; if ( block_size1 == block_size2 ) { long score1 , score2 ; score1 = score_strings ( s1_1 , s2_1 , block_size1 ) ; score2 = score_strings ( s1_2 , s2_2 , block_size2 ) ; score = Math . max ( score1 , score2 ) ; } else if ( block_size1 == block_size2 * 2 ) { score = score_strings ( s1_1 , s2_2 , block_size1 ) ; } else { score = score_strings ( s1_2 , s2_1 , block_size2 ) ; } return ( int ) score ; }
te	6	public void convertItemToHtml ( XmlPullParser parser , XmlSerializer writer ) throws IOException , XmlPullParserException { writer . startTag ( null , "p" ) ; String title = null , link = null , description = null ; while ( parser . nextTag ( ) != XmlPullParser . END_TAG ) { if ( parser . getName ( ) . equals ( "title" ) ) { title = parser . nextText ( ) ; } else if ( parser . getName ( ) . equals ( "link" ) ) { link = parser . nextText ( ) ; } else if ( parser . getName ( ) . equals ( "description" ) ) { description = parser . nextText ( ) ; } } writer . startTag ( null , "a" ) ; writer . attribute ( null , "href" , link ) ; if ( title != null ) { writer . text ( title ) ; } else { writer . text ( link ) ; } writer . endTag ( null , "a" ) ; writer . startTag ( null , "br" ) . endTag ( null , "br" ) ; if ( description != null ) writer . text ( description ) ; writer . endTag ( null , "p" ) ; }
te	9X	@ SuppressWarnings ( "unchecked" ) public List < JZSequenceFile > partition ( List < String > inputFiles , int numPartitions , Comparator < K > comparator , String jobTaskTrackerID ) { final Comparator < K > tempComparator = comparator ; List < JZSequenceFile > inFiles = new ArrayList < JZSequenceFile > ( ) ; Comparator < Object [ ] > com = new Comparator < Object [ ] > ( ) { @ Override public int compare ( Object [ ] o1 , Object [ ] o2 ) { return tempComparator . compare ( ( K ) o1 [ 0 ] , ( K ) o2 [ 0 ] ) ; } } ; PriorityQueue < Object [ ] > keyQueue = new PriorityQueue < Object [ ] > ( 1 , com ) ; for ( int i = 0 ; i < inputFiles . size ( ) ; i ++ ) { JZSequenceFile file = new JZSequenceFile ( JZFile . LocalFileSystem , inputFiles . get ( i ) , 0 , 0 ) ; inFiles . add ( file ) ; JZSequenceFile . Reader < K , List < V >> reader = new JZSequenceFile . Reader < > ( file ) ; if ( reader . nextKeyValue ( ) ) { Object [ ] entry = new Object [ ] { reader . getCurrentKey ( ) , reader } ; keyQueue . offer ( entry ) ; } } List < JZSequenceFile > outFiles = new ArrayList < JZSequenceFile > ( ) ; List < JZSequenceFile . Writer < K , List < V >>> writers = new ArrayList < JZSequenceFile . Writer < K , List < V >>> ( ) ; for ( int i = 0 ; i < numPartitions ; i ++ ) { String fileName = createPartitionFileName ( jobTaskTrackerID , i ) ; JZSequenceFile file = new JZSequenceFile ( JZFile . JZFileSystem , fileName , 0 , 0 ) ; outFiles . add ( file ) ; writers . add ( new JZSequenceFile . Writer < K , List < V >> ( file ) ) ; } List < V > list = new ArrayList < V > ( ) ; Object [ ] firstEntry = keyQueue . peek ( ) ; K preKey = ( K ) firstEntry [ 0 ] ; JZSequenceFile . Reader < K , List < V >> reader = ( JZSequenceFile . Reader < K , List < V >> ) firstEntry [ 1 ] ; while ( ! keyQueue . isEmpty ( ) ) { Object [ ] entry = keyQueue . poll ( ) ; K key = ( K ) entry [ 0 ] ; reader = ( JZSequenceFile . Reader < K , List < V >> ) entry [ 1 ] ; List < V > value = ( List < V > ) reader . getCurrentValue ( ) ; if ( preKey . equals ( key ) ) { list . addAll ( value ) ; } else { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( "\n" + preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } preKey = key ; list = new ArrayList < V > ( value ) ; } if ( reader . nextKeyValue ( ) ) { K newKey = ( K ) reader . getCurrentKey ( ) ; entry [ 0 ] = newKey ; keyQueue . offer ( entry ) ; } else { reader . close ( ) ; } } if ( ! list . isEmpty ( ) ) { writers . get ( getPartition ( preKey , null , numPartitions ) ) . write ( preKey , list ) ; System . out . print ( preKey + ":" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . print ( " " + list . get ( i ) ) ; } System . out . println ( "\n" ) ; } for ( int i = 0 ; i < numPartitions ; i ++ ) { writers . get ( i ) . close ( ) ; } return outFiles ; }
te	4	public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String scomplete = scan . nextLine ( ) ; while ( ! scomplete . equals ( "#" ) ) { String [ ] scompleteArray = scomplete . split ( " " ) ; String s1 = scompleteArray [ 0 ] ; String s2 = scompleteArray [ 1 ] ; int [ ] [ ] m = new int [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; dir [ ] [ ] direcciones = new dir [ s2 . length ( ) + 1 ] [ s1 . length ( ) + 1 ] ; fill ( s2 , s1 , m , direcciones ) ; ArrayList < dir > res = trace ( m , direcciones , s2 , s1 ) ; int acarreo = 0 ; char last = a ; for ( int i = res . size ( ) - 1 ; i > - 1 ; i -- ) { if ( res . get ( i ) . pre . charAt ( 0 ) == I ) { acarreo ++ ; } res . get ( i ) . acarreo ( acarreo ) ; System . out . print ( res . get ( i ) . Stringify ( ) ) ; if ( res . get ( i ) . pre . charAt ( 0 ) == D ) { acarreo -- ; } } System . out . print ( "E\n" ) ; scomplete = scan . nextLine ( ) ; } }
te	3	private JSONWriter end ( char mode , char c ) throws JSONException { if ( this . mode != mode ) { throw new JSONException ( mode == a ? "Misplaced endArray." : "Misplaced endObject." ) ; } this . pop ( mode ) ; try { this . writer . write ( c ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } this . , = true ; return this ; }
te	8	private void handlePhysicalInteract ( PlayerInteractEvent event ) { if ( event . isCancelled ( ) ) return ; Location l = event . getClickedBlock ( ) . getLocation ( ) ; l . setY ( l . getY ( ) - 2 ) ; if ( l . getBlock ( ) . getState ( ) instanceof Sign ) { Sign s = ( Sign ) l . getBlock ( ) . getState ( ) ; String [ ] msg = s . getLines ( ) ; boolean oo = false ; String ms = "" ; for ( String m : msg ) { if ( ! m . isEmpty ( ) && m . substring ( 0 , 1 ) . equals ( "/" ) ) { Bukkit . dispatchCommand ( event . getPlayer ( ) , m . substring ( 1 ) ) ; } else { if ( oo ) { ms += m + " " ; } } if ( m . toLowerCase ( ) . equals ( "[tell]" ) ) { oo = true ; } } if ( ! ms . isEmpty ( ) ) event . getPlayer ( ) . sendMessage ( ChatColor . DARK_AQUA + ChatColor . translateAlternateColorCodes ( "&" . charAt ( 0 ) , ms ) ) ; } }
te	3	public void execute ( ) { Session session = null ; String _commandString ; String _output ; int _countCommands = 0 ; int _index = 0 ; this . result . append ( "*******************************************************\n" ) ; this . result . append ( "Started processing Unix Commands On Server :" ) ; this . result . append ( this . hostName ) ; this . result . append ( "\n" ) ; this . result . append ( "*******************************************************\n" ) ; _countCommands = this . commands . size ( ) ; while ( _countCommands > _index ) { _commandString = this . commands . get ( _index ) ; this . result . append ( "Executing :" ) ; this . result . append ( _commandString ) ; this . result . append ( "\n" ) ; this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; try { session = connectServer . openSession ( ) ; _output = executeCommand ( session , _commandString ) ; this . result . append ( _output ) ; } catch ( IOException e ) { AtomShellException _shellException = new AtomShellException ( e ) ; _shellException . setCustomMessage ( "Unable to Open a Session on Server IP :" + this . hostName ) ; } catch ( AtomShellException e ) { this . result . append ( e . getCustomMessage ( ) ) ; } this . result . append ( "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n" ) ; _index ++ ; } session . close ( ) ; connectServer . close ( ) ; }
te	9X	public Iterator < String > keysThatMatch ( String pattern ) { if ( pattern == null ) { throw new IllegalArgumentException ( ) ; } Queue < String > results = new ArrayList < String > ( size ) ; if ( root == null ) { return results . queued ( ) ; } Stack < Node < V >> nodes = new ArrayList < Node < V >> ( ) ; Stack < String > keys = new ArrayList < String > ( ) ; nodes . push ( root ) ; keys . push ( "" ) ; while ( ! nodes . empty ( ) ) { Node < V > node = nodes . pop ( ) ; String key = keys . pop ( ) ; if ( key . length ( ) == pattern . length ( ) ) { if ( node . value != null ) { results . enqueue ( key ) ; } continue ; } char c = pattern . charAt ( key . length ( ) ) ; if ( ! valid ( c ) ) { throw new IllegalArgumentException ( ) ; } if ( c == * ) { for ( char i = ALPHABET_SIZE - 1 ; i >= 0 ; -- i ) { if ( node . next [ i ] != null ) { nodes . push ( node . next [ i ] ) ; keys . push ( key + i ) ; } } } else if ( node . next [ c ] != null ) { nodes . push ( node . next [ c ] ) ; keys . push ( key + c ) ; } } return results . queued ( ) ; }
te	3	public void backPropagate ( double [ ] target , double learningSpeed ) { double [ ] oError = calculateError ( getOutput ( ) , target , learningSpeed ) ; for ( double n : oError ) if ( double . isNaN ( n ) ) throw new RuntimeException ( "calculateError resulted in NaN" ) ; for ( int l = layers . size ( ) - 2 ; l >= 0 ; -- l ) { double [ ] iError = backPropagateLayer ( layers . get ( l ) , layers . get ( l + 1 ) , weights . get ( l ) , oError , learningSpeed ) ; updateBias ( weights . get ( l ) , oError ) ; oError = iError ; } }
te	8	public GetDataBySubjectPanel ( JFrame frame , QueryDefinition query ) throws Exception { super ( frame , query , new GetDataBySubject ( query . getDocument ( ) ) ) ; JTabbedPane panel = new JTabbedPane ( ) ; ItemSet < SubjectID > subItems = new ItemSet < SubjectID > ( ) { @ Override public void add ( SubjectID item ) { GetDataBySubjectPanel . this . getRequest ( ) . addSubject ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( SubjectID item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeSubject ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getSubjectCount ( ) ; } @ Override public SubjectID get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getSubject ( index ) ; } @ Override public void set ( int index , String name , Object value ) { SubjectID id = this . get ( index ) ; if ( name . equals ( "Contributor" ) ) { id . setContributor ( ( Contributor ) value ) ; } else if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < SubjectID > subjectsPanel = new ItemTablePanel < SubjectID > ( SubjectID . class , subItems ) ; panel . add ( "Subject IDs" , subjectsPanel ) ; ItemSet < Parameter > paramItems = new ItemSet < Parameter > ( ) { @ Override public void add ( Parameter item ) { GetDataBySubjectPanel . this . getRequest ( ) . addParameter ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( Parameter item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeParameters ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getParameterCount ( ) ; } @ Override public Parameter get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getParameter ( index ) ; } @ Override public void set ( int index , String name , Object value ) { Parameter id = this . get ( index ) ; if ( name . equals ( "Name" ) ) { id . setName ( ( String ) value ) ; } else if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < Parameter > paramsPanel = new ItemTablePanel < Parameter > ( Parameter . class , paramItems ) ; panel . add ( "Parameters" , paramsPanel ) ; ItemSet < LogEntry > logItems = new ItemSet < LogEntry > ( ) { @ Override public void add ( LogEntry item ) { GetDataBySubjectPanel . this . getRequest ( ) . addLog ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public void remove ( LogEntry item ) { GetDataBySubjectPanel . this . getRequest ( ) . removeLog ( item ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } @ Override public int size ( ) { return GetDataBySubjectPanel . this . getRequest ( ) . getLogCount ( ) ; } @ Override public LogEntry get ( int index ) { return GetDataBySubjectPanel . this . getRequest ( ) . getLog ( index ) ; } @ Override public void set ( int index , String name , Object value ) { LogEntry id = this . get ( index ) ; if ( name . equals ( "Value" ) ) { id . setValue ( ( String ) value ) ; } GetDataBySubjectPanel . this . getRequest ( ) . notifyChange ( ) ; stateChanged ( new GetDatabySubjectPanelChangeEvent ( GetDataBySubjectPanel . this ) ) ; } } ; ItemTablePanel < LogEntry > logPanel = new ItemTablePanel < LogEntry > ( LogEntry . class , logItems ) ; panel . add ( "Logs" , logPanel ) ; JPanel otherPanel = new JPanel ( ) ; otherPanel . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints cMain = new GridBagConstraints ( ) ; cMain . fill = GridBagConstraints . HORIZONTAL ; cMain . anchor = GridBagConstraints . PAGE_START ; cMain . gridx = 0 ; cMain . gridy = 0 ; JPanel trxIdPanel = new JPanel ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; trxIdPanel . setLayout ( new GridBagLayout ( ) ) ; otherPanel . add ( trxIdPanel , cMain ) ; panel . add ( "Other" , otherPanel ) ; trxIdPanel . setBorder ( BorderFactory . createTitledBorder ( "Transaction ID" ) ) ; this . btnGroup = new ButtonGroup ( ) ; ActionListener btnActions = new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { if ( GetDataBySubjectPanel . this . rdoBtnStatic . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( true ) ; GetDataBySubjectPanel . this . trxIdTextField . grabFocus ( ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . static ) ; } else if ( GetDataBySubjectPanel . this . rdoBtnRandom . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( false ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . Random ) ; } else if ( GetDataBySubjectPanel . this . rdoBtnNone . isSelected ( ) ) { GetDataBySubjectPanel . this . trxIdTextField . setEditable ( false ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionIDMode ( TransactionMode . None ) ; } } } ; this . rdoBtnNone = new JRadioButton ( "None" , true ) ; this . rdoBtnNone . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnNone ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . anchor = GridBagConstraints . NORTHWEST ; c . gridx = 0 ; c . gridy = 0 ; trxIdPanel . add ( this . rdoBtnNone , c ) ; this . rdoBtnRandom = new JRadioButton ( "Random" ) ; this . rdoBtnRandom . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnRandom ) ; c . gridx = 0 ; c . gridy = 1 ; trxIdPanel . add ( this . rdoBtnRandom , c ) ; this . rdoBtnStatic = new JRadioButton ( "Static" ) ; this . rdoBtnStatic . addActionListener ( btnActions ) ; this . btnGroup . add ( this . rdoBtnStatic ) ; c . gridx = 0 ; c . gridy = 2 ; trxIdPanel . add ( this . rdoBtnStatic , c ) ; this . trxIdTextField = new JTextField ( ) ; this . trxIdTextField . addActionListener ( this ) ; this . trxIdTextField . setEditable ( false ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 0.5 ; c . gridx = 1 ; c . gridy = 2 ; trxIdPanel . add ( this . trxIdTextField , c ) ; JPanel bufferPanel = new JPanel ( ) ; cMain . gridx = 0 ; cMain . gridy = 1 ; cMain . weightx = 1 ; cMain . weighty = 1 ; otherPanel . add ( bufferPanel , cMain ) ; this . trxIdTextField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { @ Override public void changedUpdate ( DocumentEvent arg0 ) { String text = GetDataBySubjectPanel . this . trxIdTextField . getText ( ) ; GetDataBySubjectPanel . this . getRequest ( ) . setTransactionId ( text ) ; stateChanged ( null ) ; } @ Override public void insertUpdate ( DocumentEvent arg0 ) { this . changedUpdate ( arg0 ) ; } @ Override public void removeUpdate ( DocumentEvent arg0 ) { this . changedUpdate ( arg0 ) ; } } ) ; this . addFirstTab ( "Fields" , panel ) ; }
te	8	public static boolean hasAtLeastOneMethodWithName ( class < ? > clazz , String methodName ) { assert . notNull ( clazz , "Class must not be null" ) ; assert . notNull ( methodName , "Method name must not be null" ) ; Method [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; for ( Method method : declaredMethods ) { if ( method . getName ( ) . equals ( methodName ) ) { return true ; } } class < ? > [ ] ifcs = clazz . getInterfaces ( ) ; for ( class < ? > ifc : ifcs ) { if ( hasAtLeastOneMethodWithName ( ifc , methodName ) ) { return true ; } } return ( clazz . getSuperclass ( ) != null && hasAtLeastOneMethodWithName ( clazz . getSuperclass ( ) , methodName ) ) ; }
te	5	static int quadraticRoots ( final float a , final float b , final float c , float [ ] zeroes , final int off ) { int ret = off ; float t ; if ( a != 0f ) { final float dis = b * b - 4 * a * c ; if ( dis > 0f ) { final float sqrtDis = ( float ) Math . sqrt ( dis ) ; if ( b >= 0f ) { zeroes [ ret ++ ] = ( 2f * c ) / ( - b - sqrtDis ) ; zeroes [ ret ++ ] = ( - b - sqrtDis ) / ( 2f * a ) ; } else { zeroes [ ret ++ ] = ( - b + sqrtDis ) / ( 2f * a ) ; zeroes [ ret ++ ] = ( 2f * c ) / ( - b + sqrtDis ) ; } } else if ( dis == 0f ) { t = ( - b ) / ( 2f * a ) ; zeroes [ ret ++ ] = t ; } } else { if ( b != 0f ) { t = ( - c ) / b ; zeroes [ ret ++ ] = t ; } } return ret - off ; }
te	9X	@ Override public byte [ ] getByteData ( byte [ ] a , long startPos , long endPos , long step ) { if ( startPos < 0 || startPos >= length ) { throw new ArrayIndexOutOfBoundsException ( "startPos < 0 || startPos >= length" ) ; } if ( endPos < 0 || endPos > length || endPos < startPos ) { throw new ArrayIndexOutOfBoundsException ( "endPos < 0 || endPos > length || endPos < startPos" ) ; } if ( step < 1 ) { throw new IllegalArgumentException ( "step < 1" ) ; } long len = ( long ) Math . ceil ( ( endPos - startPos ) / ( double ) step ) ; if ( len > getMaxSizeOf32bitArray ( ) ) { return null ; } else { byte [ ] out ; if ( a != null && a . length >= len ) { out = a ; } else { out = new byte [ ( int ) len ] ; } int idx = 0 ; if ( ptr != 0 ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = Utilities . UNSAFE . getByte ( ptr + i ) ; } } else { if ( isConstant ( ) ) { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ 0 ] ; } } else { for ( long i = startPos ; i < endPos ; i += step ) { out [ idx ++ ] = data [ ( int ) i ] ; } } } return out ; } }
te	9X	@ SuppressWarnings ( "RedundantIfStatement" ) @ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; GitClone gitClone = ( GitClone ) o ; if ( localPath != null ? ! localPath . equals ( gitClone . localPath ) : gitClone . localPath != null ) return false ; if ( pathToGit != null ? ! pathToGit . equals ( gitClone . pathToGit ) : gitClone . pathToGit != null ) return false ; if ( repositoryUrl != null ? ! repositoryUrl . equals ( gitClone . repositoryUrl ) : gitClone . repositoryUrl != null ) return false ; return true ; }
te	9X	public void checkCollision ( JGEngineInterface eng , int srccid , int dstcid ) { if ( in_parallel_upd ) throw new JGameError ( "Recursive call" , true ) ; in_parallel_upd = true ; if ( objects . size > srcobj . length ) { srcobj = new JGObject [ objects . size + 50 ] ; dstobj = new JGObject [ objects . size + 50 ] ; } int srcsize = 0 ; int dstsize = 0 ; JGRectangle sr = tmprect1 ; JGRectangle dr = tmprect2 ; for ( int i = 0 ; i < objects . size ; i ++ ) { JGObject o = ( JGObject ) objects . values [ i ] ; if ( o . is_suspended ) continue ; if ( ! o . getBBox ( sr ) ) continue ; if ( ( o . colid & srccid ) != 0 ) { srcobj [ srcsize ++ ] = o ; } if ( ( o . colid & dstcid ) != 0 ) { dstobj [ dstsize ++ ] = o ; } } for ( int si = 0 ; si < srcsize ; si ++ ) { JGObject srco = srcobj [ si ] ; if ( ! srco . getBBox ( sr ) ) continue ; for ( int di = 0 ; di < dstsize ; di ++ ) { JGObject dsto = dstobj [ di ] ; if ( dsto == srco ) continue ; if ( ! dsto . getBBox ( dr ) ) continue ; if ( sr . intersects ( dr ) ) { try { dsto . hit ( srco ) ; } catch ( JGameError ex ) { eng . exitEngine ( eng . dbgExceptionToString ( ex ) ) ; } catch ( Exception ex ) { eng . dbgShowException ( dsto . getName ( ) , ex ) ; } } } } flushRemoveList ( ) ; in_parallel_upd = false ; }
te	6	public static void copyFilebyBufferedOutputStream ( File file ) throws IOException { FileInputStream fis = null ; BufferedInputStream bis = null ; FileOutputStream fos = null ; BufferedOutputStream bos = null ; try { fis = new FileInputStream ( file ) ; bis = new BufferedInputStream ( fis ) ; fos = new FileOutputStream ( file . getName ( ) + ".bak" ) ; bos = new BufferedOutputStream ( fos ) ; byte [ ] buffer = new byte [ 1024 ] ; int bytesRead = 0 ; while ( ( bytesRead = bis . read ( buffer , 0 , buffer . length ) ) != - 1 ) { bos . write ( buffer , 0 , bytesRead ) ; } bos . flush ( ) ; } catch ( Exception ex ) { System . out . println ( "Error occurs during copying " + file . getAbsoluteFile ( ) ) ; } finally { if ( fis != null ) fis . close ( ) ; if ( bis != null ) bis . close ( ) ; if ( fos != null ) fos . close ( ) ; if ( bos != null ) bos . close ( ) ; } }
te	3	public void set ( ProfesorBean oProfesorBean ) throws Exception { try { oMysql . conexion ( enumTipoConexion ) ; oMysql . initTrans ( ) ; if ( oProfesorBean . getId ( ) == 0 ) { oProfesorBean . setId ( oMysql . insertOne ( "profesor" ) ) ; } oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "id_usuario" , Integer . toString ( oProfesorBean . getId_usuario ( ) ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "dni" , oProfesorBean . getDni ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "nombre" , oProfesorBean . getNombre ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "ape1" , oProfesorBean . getApe1 ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "ape2" , oProfesorBean . getApe2 ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "sexo" , oProfesorBean . getSexo ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "telefono" , oProfesorBean . getTelefono ( ) ) ; oMysql . updateOne ( oProfesorBean . getId ( ) , "profesor" , "email" , oProfesorBean . getEmail ( ) ) ; if ( oProfesorBean . getId_usuario ( ) > 0 ) { oMysql . updateOne ( oProfesorBean . getId_usuario ( ) , "usuario" , "password" , oProfesorBean . getPassword ( ) ) ; oMysql . updateOne ( oProfesorBean . getId_usuario ( ) , "usuario" , "login" , oProfesorBean . getLogin ( ) ) ; } else { oMysql . setNull ( oProfesorBean . getId_usuario ( ) , "usuario" , "password" ) ; oMysql . setNull ( oProfesorBean . getId_usuario ( ) , "usuario" , "login" ) ; } oMysql . commitTrans ( ) ; } catch ( Exception e ) { oMysql . rollbackTrans ( ) ; throw new Exception ( "ProfesorDao.setProfesor: Error: " + e . getMessage ( ) ) ; } finally { oMysql . desconexion ( ) ; } }
te	7	@ Deprecated public < T > T toObject ( String input ) { final XmlPullParser xpp ; try { xpp = xmlPullParserFactory . newPullParser ( ) ; } catch ( XmlPullParserException e ) { throw new RuntimeException ( e . toString ( ) , e ) ; } final State state = stateFactory . get ( exceptionHandler ) ; try { xpp . setInput ( new StringReader ( input ) ) ; int eventType = xpp . getEventType ( ) ; do { if ( eventType == XmlPullParser . START_DOCUMENT ) { state . begin ( ) ; } else if ( eventType == XmlPullParser . START_TAG ) { state . processStartElement ( xpp , this ) ; } else if ( eventType == XmlPullParser . END_TAG ) { state . processEndElement ( ) ; } else if ( eventType == XmlPullParser . TEXT ) { state . processText ( xpp , this ) ; } eventType = xpp . next ( ) ; } while ( eventType != XmlPullParser . END_DOCUMENT ) ; state . end ( ) ; } catch ( Exception e ) { exceptionHandler . handle ( e ) ; } return ( T ) state . getObject ( ) ; }
te	7	public static Document deepCloneDocument ( Document doc , DOMImplementation impl ) { Element root = doc . getDocumentElement ( ) ; Document result = impl . createDocument ( root . getNamespaceURI ( ) , root . getNodeName ( ) , null ) ; Element rroot = result . getDocumentElement ( ) ; boolean before = true ; for ( Node n = doc . getFirstChild ( ) ; n != null ; n = n . getNextSibling ( ) ) { if ( n == root ) { before = false ; if ( root . hasAttributes ( ) ) { NamedNodeMap attr = root . getAttributes ( ) ; int len = attr . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { rroot . setAttributeNode ( ( Attr ) result . importNode ( attr . item ( i ) , true ) ) ; } } for ( Node c = root . getFirstChild ( ) ; c != null ; c = c . getNextSibling ( ) ) { rroot . appendChild ( result . importNode ( c , true ) ) ; } } else { if ( n . getNodeType ( ) != Node . DOCUMENT_TYPE_NODE ) { if ( before ) { result . insertBefore ( result . importNode ( n , true ) , rroot ) ; } else { result . appendChild ( result . importNode ( n , true ) ) ; } } } } return result ; }
te	3	public void setBean ( Object bean ) throws Exception { ReflectInfo info = MetaInfoMap . getReflectlInfo ( bean . getClass ( ) ) ; int size = query . sizeOfParameters ( ) ; int i = 0 ; int fieldIndex ; while ( i < size ) { String param = query . getParameter ( i ) ; fieldIndex = info . getIndexOfField ( param ) ; if ( fieldIndex == - 1 ) throw new Exception ( "In the bean  can't find " + param ) ; Object value = info . getFieldValue ( fieldIndex , bean ) ; int fieldType = info . getFieldType ( fieldIndex ) ; try { parameterMapper . setParameterValue ( ps , ++ i , value , fieldType ) ; } catch ( Exception e ) { throw new ParamerSettingException ( i , param , value , fieldType , e ) ; } } }
te	2	public String toString ( ) { String s = "{" ; for ( Location loc : getOccupiedLocations ( ) ) { if ( s . length ( ) > 1 ) s += "  " ; s += loc + "=" + get ( loc ) ; } return s + "}" ; }
te	8	@ Override public void itemStateChanged ( ItemEvent e ) { if ( e . getStateChange ( ) == ItemEvent . SELECTED ) { if ( value . getClass ( ) . getName ( ) . contains ( "PageNames" ) ) { ( ( PageNames ) value ) . setPageName ( ( String ) selectBox . getSelectedItem ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "PictureNames" ) ) { ( ( PictureNames ) value ) . setSelectedPictureIndex ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "SoundNames" ) ) { ( ( SoundNames ) value ) . setSelectedSoundIndex ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "ButtonFunctionType" ) ) { ( ( ButtonFunctionType ) value ) . setButtonFunction ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "ValueFormatType" ) ) { ( ( ValueFormatType ) value ) . setValueFormat ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "LedFunctionType" ) ) { ( ( LedFunctionType ) value ) . setLedFunction ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } if ( value . getClass ( ) . getName ( ) . contains ( "LedVisibleType" ) ) { ( ( LedVisibleType ) value ) . setLedVisible ( selectBox . getSelectedIndex ( ) ) ; fireEditingStopped ( ) ; } } }
te	0	public void setNbRows ( int nb ) { rows = nb ; }
te	9X	private boolean createHostel ( Element hostel ) { NodeList nameList = hostel . getElementsByTagName ( "name" ) ; NodeList addressList = hostel . getElementsByTagName ( "address" ) ; NodeList contactList = hostel . getElementsByTagName ( "contact" ) ; NodeList policyList = hostel . getElementsByTagName ( "restrictions" ) ; NodeList bedList = hostel . getElementsByTagName ( "availability" ) ; if ( nameList == null || nameList . getLength ( ) != 1 || addressList == null || addressList . getLength ( ) != 1 || contactList == null || contactList . getLength ( ) != 1 || policyList == null || policyList . getLength ( ) != 1 ) { return false ; } Node nameNode = nameList . item ( 0 ) ; Node addressNode = addressList . item ( 0 ) ; Node contactNode = contactList . item ( 0 ) ; Node policyNode = policyList . item ( 0 ) ; if ( nameNode . getNodeType ( ) != Node . ELEMENT_NODE || addressNode . getNodeType ( ) != Node . ELEMENT_NODE || contactNode . getNodeType ( ) != Node . ELEMENT_NODE || policyNode . getNodeType ( ) != Node . ELEMENT_NODE ) { return false ; } Address address = createAddress ( ( Element ) addressNode ) ; Contact contact = createContact ( ( Element ) contactNode ) ; Policy policy = createPolicy ( ( Element ) policyNode ) ; Identifier hostelId ; ArrayList < Identifier > bedIds = new ArrayList < Identifier > ( ) ; Hostel hostelInfo = new Hostel ( nameNode . getTextContent ( ) , address , contact , policy , bedIds ) ; try { hostelId = Hostels . getInstance ( ) . create ( hostelInfo ) ; } catch ( DataBaseReadWriteException | IdentifierAlreadyExistsException | InvalidParameterException e ) { e . printStackTrace ( ) ; return false ; } for ( int bedCount = 0 ; bedCount < bedList . getLength ( ) ; bedCount ++ ) { Node bedNode = bedList . item ( bedCount ) ; if ( bedNode . getNodeType ( ) == Node . ELEMENT_NODE ) { createBed ( ( Element ) bedNode , hostelId ) ; } } return true ; }
te	5	public static Set < Cliente > getClientesPedidosColores ( Set < Color > colores ) { Set < Cliente > l = new HashSet < > ( ) ; try { sql = "SELECT DISTINCT (CLIENTES_REMITOS.IDCLIENTE) AS IDCLIENTE " + "FROM CLIENTES_REMITOS INNER JOIN CLIENTES_DETALLE_REMITO ON " + "CLIENTES_REMITOS.IDREMITO = CLIENTES_DETALLE_REMITO.IDREMITO " + "WHERE (((CLIENTES_REMITOS.TIPODOC)=1 Or (CLIENTES_REMITOS.TIPODOC)=4) AND " + "((CLIENTES_REMITOS.ENTREGADO)=False) AND " + "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) AND ( " ; String tmp = "" ; for ( Color color : colores ) { tmp = tmp + Integer . toString ( color . getId ( ) ) + "  " ; } tmp = tmp . substring ( 0 , tmp . length ( ) - 2 ) ; sql = sql + " CLIENTES_DETALLE_REMITO.COLOR IN (" + tmp + ")" ; sql = sql + "));" ; try ( ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null ) { while ( rs . next ( ) ) { Cliente cliente = ClienteDP . getOne ( rs . getInt ( "IDCLIENTE" ) ) ; if ( cliente != null ) { l . add ( cliente ) ; } } } } } catch ( SQLException ex ) { Utils . showError ( "Error..." , "Error al buscar clientes con pedidos por colores.\nERROR: " + ex . getMessage ( ) + "\nSQL State: " + ex . getSQLState ( ) ) ; } return l ; }
te	6	public void paintComponent ( Graphics g2 ) { int w = getWidth ( ) ; int h = getHeight ( ) ; if ( ( img == null ) || ( img . getWidth ( null ) != w ) || ( img . getHeight ( null ) != h ) ) { img = createImage ( w , h ) ; Graphics g = img . getGraphics ( ) ; for ( int x = 0 ; x <= w / 524 ; x ++ ) { for ( int y = 0 ; y <= h / 524 ; y ++ ) g . drawImage ( bgImage , x * 524 , y * 524 , null ) ; } if ( ( g instanceof Graphics2D ) ) { Graphics2D gg = ( Graphics2D ) g ; } g . dispose ( ) ; } g2 . drawImage ( img , 0 , 0 , w , h , null ) ; }
te	9X	public final static byte [ ] encodeToByte ( byte [ ] sArr , boolean lineSep ) { if ( sArr == null || sArr . length == 0 ) return new byte [ 0 ] ; int sLen = sArr . length ; int eLen = ( sLen / 3 ) * 3 ; int cCnt = ( ( sLen - 1 ) / 3 + 1 ) << 2 ; int dLen = cCnt + ( lineSep ? ( cCnt - 1 ) / 76 << 1 : 0 ) ; byte [ ] dArr = new byte [ dLen ] ; for ( int s = 0 , d = 0 , cc = 0 ; s < eLen ; ) { int i = ( sArr [ s ++ ] & ff ) << 16 | ( sArr [ s ++ ] & ff ) << 8 | ( sArr [ s ++ ] & ff ) ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 18 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 12 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ ( i >>> 6 ) & 3f ] ; dArr [ d ++ ] = ( byte ) CA [ i & 3f ] ; if ( lineSep && ++ cc == 19 && d < dLen - 2 ) { dArr [ d ++ ] = '' ; dArr [ d ++ ] = '' ; cc = 0 ; } } int left = sLen - eLen ; if ( left > 0 ) { int i = ( ( sArr [ eLen ] & ff ) << 10 ) | ( left == 2 ? ( ( sArr [ sLen - 1 ] & ff ) << 2 ) : 0 ) ; dArr [ dLen - 4 ] = ( byte ) CA [ i >> 12 ] ; dArr [ dLen - 3 ] = ( byte ) CA [ ( i >>> 6 ) & 3f ] ; dArr [ dLen - 2 ] = left == 2 ? ( byte ) CA [ i & 3f ] : ( byte ) = ; dArr [ dLen - 1 ] = = ; } return dArr ; }
te	0	public void setY ( float y ) { this . y = y ; }
te	4	@ Override public void mouseClicked ( MouseEvent arg0 ) { if ( albumsScreen . editing ) { albumsScreen . editing = false ; albumsScreen . edit . setIcon ( new ImageIcon ( "resources/editUP.jpg" ) ) ; albumsScreen . edit . setPressedIcon ( new ImageIcon ( "resources/editDN.jpg" ) ) ; for ( AlbumInfo panel : albumsScreen . albumpanels ) { panel . changeName ( ) ; panel . showHideDeleteBtn ( ) ; panel . allowNameEditing ( ) ; } } try { photoScreen = new PhotosScreen ( this . album , this . albumsScreen . control , this . albumsScreen . backend , this , this . albumsScreen ) ; photoScreen . setVisible ( true ) ; photoScreen . setLocationRelativeTo ( null ) ; photoScreen . setResizable ( false ) ; this . albumsScreen . setVisible ( false ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( CadastroUsuarios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { getInstace ( ) . setVisible ( true ) ; } } ) ; }
te	7	public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { class c = class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; }
te	0	@ Override public void Lands ( Player P ) { }
te	8	public void start ( ) { if ( this . isRunning || this . simulationResult != null ) { return ; } this . latch = new CountDownLatch ( this . nrOfWorkers ) ; int roundsPerWorker = getNrOfRoundsPerWorker ( this . nrOfWorkers ) ; this . executor = Executors . newFixedThreadPool ( this . nrOfWorkers ) ; int workerUpdateInterval = getUpdateInterval ( this . nrOfWorkers ) ; for ( int i = 0 ; i < this . nrOfWorkers ; i ++ ) { SimulationWorker worker ; WorkerBuilder builder ; if ( this . gameType == PokerType . TEXAS_HOLDEM ) { builder = TexasHoldemWorker . builder ( ) ; } else if ( this . gameType == PokerType . OMAHA ) { builder = OmahaWorker . builder ( ) ; } else if ( this . gameType == PokerType . OMAHA_HILO ) { builder = OmahaHiLoWorker . builder ( ) ; } else if ( this . gameType == PokerType . FOMAHA ) { builder = FiveCardOmahaWorker . builder ( ) ; } else { builder = FiveCardOmahaHiLoWorker . builder ( ) ; } builder . setCommunityCards ( this . communityCards ) . setNotifier ( this ) . setRounds ( roundsPerWorker ) . setUpdateInterval ( workerUpdateInterval ) ; for ( PlayerProfile profile : this . profiles ) { builder . addPlayer ( profile ) ; } worker = builder . build ( ) ; this . executor . execute ( worker ) ; this . workers . add ( worker ) ; } this . startTime = System . currentTimeMillis ( ) ; this . isRunning = true ; Thread masterThread = new Thread ( new Supervisor ( ) ) ; masterThread . setDaemon ( true ) ; masterThread . start ( ) ; SimulationEvent event = new SimulationEvent ( SimulationEvent . EVENT_SIM_STARTED , this . nrOfWorkers ) ; this . notifiable . onSimulationStart ( event ) ; }
te	1	@ Override public MDDVariable getVariableForKey ( Object key ) { MDDVariable var = store . getVariableForKey ( key ) ; int idx = store2custom [ var . order ] ; if ( idx < 0 ) { return null ; } return var ; }
te	2	public void setStationData ( String call , String locator , String qrzUser , String qrzPass , double lat , double lon , String hamUser , String hamPass ) throws SQLException { Connection con = getDbConnection ( ) ; String query0 = "DELETE FROM SATION_DATA" ; con . prepareCall ( query0 ) . execute ( ) ; String query = "INSERT INTO SATION_DATA (CALL_ID LOCATOR LONGITUDE LATITUDE QRZ_USER QRZ_PASS HAM_USER HAM_PASS) VALUES (? ? ? ? ? ? ? ?)" ; java . sql . PreparedStatement stm = con . prepareStatement ( query ) ; int index = 1 ; stm . setString ( index ++ , call ) ; stm . setString ( index ++ , locator ) ; stm . setDouble ( index ++ , ( lon != null ) ? lon : 0d ) ; stm . setDouble ( index ++ , ( lat != null ) ? lat : 0d ) ; stm . setString ( index ++ , qrzUser ) ; stm . setString ( index ++ , qrzPass ) ; stm . setString ( index ++ , hamUser ) ; stm . setString ( index ++ , hamPass ) ; stm . execute ( ) ; }
te	6	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( album == null ) ? 0 : album . hashCode ( ) ) ; result = prime * result + ( ( artist == null ) ? 0 : artist . hashCode ( ) ) ; result = prime * result + ( ( comment == null ) ? 0 : comment . hashCode ( ) ) ; result = prime * result + genre ; result = prime * result + ( ( title == null ) ? 0 : title . hashCode ( ) ) ; result = prime * result + ( ( track == null ) ? 0 : track . hashCode ( ) ) ; result = prime * result + ( ( year == null ) ? 0 : year . hashCode ( ) ) ; return result ; }
te	5	@ Override public float [ ] getFloatData ( ) { if ( ptr != 0 ) { return null ; } else { if ( isConstant ( ) ) { if ( length > getMaxSizeOf32bitArray ( ) ) return null ; float [ ] out = new float [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = data [ 0 ] ; } return out ; } else { float [ ] out = new float [ ( int ) length ] ; for ( int i = 0 ; i < length ; i ++ ) { out [ i ] = ( float ) data [ i ] ; } return out ; } } }
te	8	private Line generateLine ( Scanner inFile ) { Point s = null , e = null ; int thickness = 0 ; Color c = null ; String current = inFile . next ( ) ; while ( inFile . hasNext ( ) && ! ( isCloseTag ( current ) && parseTag ( current ) == LegalTag . Line ) ) { if ( isOpenTag ( current ) ) { switch ( parseTag ( current ) ) { case Start : s = new Point ( inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case End : e = new Point ( inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case Color : c = new Color ( inFile . nextInt ( ) , inFile . nextInt ( ) , inFile . nextInt ( ) ) ; break ; case Thickness : thickness = inFile . nextInt ( ) ; break ; default : break ; } } current = inFile . next ( ) ; } Line l = new Line ( s , e , thickness , c ) ; return l ; }
te	7	public SplitSample < T > contains ( Set < Integer > ids , boolean negate ) { ListSample < T > result = new ListSample < T > ( ) ; for ( T item : this ) { Integer id = membership . get ( item . identifier ( ) ) ; if ( id == null ) { if ( ids . contains ( SplitSample . undefined ) ) result . add ( item ) ; } else if ( ( ! negate && ids . contains ( id ) ) || ( negate && ! ids . contains ( id ) ) ) result . add ( item ) ; } return result ; }
te	6	public static void openFile ( File file ) { Debug . println ( "Opening file: " + file . getAbsolutePath ( ) ) ; if ( ( OSDetector . isWindows ( ) ) && ( file . isFile ( ) ) ) { int exitCode = runWindows ( file ) ; if ( exitCode == 0 ) { return ; } else { Debug . println ( "Opening file: " + file . getAbsolutePath ( ) + " failed with windows method. (fall back to default action)" ) ; } } if ( ! Desktop . isDesktopSupported ( ) ) { throw new UnsupportedOperationException ( "Desktop is not supported (fatal)" ) ; } Desktop desktop = Desktop . getDesktop ( ) ; if ( ! desktop . isSupported ( Desktop . Action . OPEN ) ) { throw new UnsupportedOperationException ( "Desktop doesn't support the OPEN action (fatal)" ) ; } try { URI uri = file . getCanonicalFile ( ) . toURI ( ) ; desktop . open ( new File ( uri ) ) ; } catch ( IOException e ) { Debug . printException ( e ) ; } }
te	2	protected MemoryEfficientString subSequence ( int start , int end ) { if ( start < 0 || end > ( data . length ) ) { throw new IllegalArgumentException ( "Illegal range " + start + "-" + end + " for sequence of length " + data . length ) ; } byte [ ] newdata = new byte [ end - start ] ; System . arraycopy ( data , start , newdata , 0 , end - start ) ; return new MemoryEfficientString ( newdata ) ; }
te	9X	public boolean isValid ( String s ) { Stack < Character > stack = new Stack < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char curChar = s . charAt ( i ) ; switch ( curChar ) { case ) : if ( stack . isEmpty ( ) || stack . pop ( ) != ( ) { return false ; } break ; case ] : if ( stack . isEmpty ( ) || stack . pop ( ) != [ ) { return false ; } break ; case } : if ( stack . isEmpty ( ) || stack . pop ( ) != { ) { return false ; } break ; default : stack . push ( curChar ) ; } } return stack . isEmpty ( ) ; }
te	0	public final void set ( double xl , double yl , double xh , double yh ) { boundaryLowX = xl ; boundaryLowY = yl ; boundaryHiX = xh ; boundaryHiY = yh ; }
te	3	public List < double > toOrderedList ( ) { List < double > distr = new ArrayList < double > ( ) ; for ( int i = 0 ; i < this . getRows ( ) ; i ++ ) { for ( int j = 0 ; j < this . getColumns ( ) ; j ++ ) { if ( ! this . isSparse ( i , j ) ) distr . add ( this . getSimilarity ( i , j ) ) ; } } Collections . sort ( distr ) ; return distr ; }
te	4	public String hash ( ) { if ( this . lshCode != null ) { return this . lshCode ; } if ( ! this . lshCodeValid ) { return null ; } LshBinStruct tmp = new LshBinStruct ( ) ; for ( int k = 0 ; k < TLSH_CHECKSUM_LEN ; k ++ ) { tmp . checksum [ k ] = swapByte ( this . lshBin . checksum [ k ] ) ; } tmp . lValue = swapByte ( this . lshBin . lValue ) ; tmp . Q = swapByte ( this . lshBin . Q ) ; for ( int i = 0 ; i < CODE_SIZE ; i ++ ) { tmp . tmpCode [ i ] = this . lshBin . tmpCode [ CODE_SIZE - 1 - i ] ; } this . lshCode = toHex ( tmp . checksum ) ; this . lshCode += toHex ( new int [ ] { tmp . lValue } ) ; this . lshCode += toHex ( new int [ ] { tmp . Q } ) ; this . lshCode += toHex ( tmp . tmpCode ) ; return this . lshCode ; }
te	7	public static String readSeatNumbers ( ) { boolean tryAgain ; do { tryAgain = false ; str = scan . nextLine ( ) ; for ( String s : str . split ( " " ) ) { if ( s . length ( ) < 2 ) { tryAgain = true ; } else if ( s . charAt ( 0 ) < A && s . charAt ( 0 ) > Z ) { tryAgain = true ; } else { try { Integer . parseInt ( s . substring ( 1 , s . length ( ) ) ) ; } catch ( NumberFormatException exception ) { tryAgain = true ; } } if ( tryAgain ) { System . out . print ( "Seats No input is invalid! Try again: " ) ; break ; } } } while ( tryAgain ) ; return str ; }
te	2	public static void runReports ( boolean full , boolean printall , Object ... objs ) { Tester t = new Tester ( ) ; if ( objs != null ) { for ( Object obj : objs ) { t . runAnyTests ( obj , full , printall ) ; } } }
te	1	public void serverCutText ( String str ) { if ( viewer . acceptClipboard . getValue ( ) ) clipboardDialog . serverCutText ( str ) ; }
te	2	@ Override public String toString ( ) { String s = "Vertices: " + V + " Edges: " + E + "\n" ; for ( int i = 0 ; i < V ; i ++ ) { s += i + ": " ; for ( int w : adj ( i ) ) s += w + " " ; s += "\n" ; } return s ; }
te	4	public Descriptor compile ( SymbolTable table ) { Descriptor d = null ; if ( type instanceof IdentNode ) { String s = ( ( IdentNode ) type ) . getIdentName ( ) ; if ( s . equals ( "integer" ) ) { d = new SimpleTypeDescriptor ( Type . INTEGER ) ; } else if ( s . equals ( "boolean" ) ) { d = new SimpleTypeDescriptor ( Type . boolean ) ; } else if ( s . equals ( "string" ) ) { d = new SimpleTypeDescriptor ( Type . STRING ) ; } else { d = table . descriptorFor ( s ) ; } } else { d = type . compile ( table ) ; } IdentListNode n = ( IdentListNode ) node ; n . compileParams ( table , d ) ; typeOfSection = d ; return null ; }
te	7	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; ProcDescriptor other = ( ProcDescriptor ) obj ; if ( labelInAssembler != other . labelInAssembler ) return false ; if ( lokal == null ) { if ( other . lokal != null ) return false ; } else if ( ! lokal . equals ( other . lokal ) ) return false ; return true ; }
te	8	private void runButtonActionPerformed ( java . awt . event . ActionEvent evt ) throws IOException { if ( runButton . getText ( ) . equals ( "Run" ) ) { threadSwitch . setEnabled ( false ) ; debugSwitch . setEnabled ( false ) ; simRunSwitch . setEnabled ( false ) ; ignoreSwitch . setEnabled ( false ) ; forceSwitch . setEnabled ( false ) ; writeToDBSwitch . setEnabled ( false ) ; threadComboBox . setEnabled ( false ) ; debugComboBox . setEnabled ( false ) ; runButton . setText ( "Interrupt" ) ; boolean debugEnabled = debugSwitch . isSelected ( ) ; boolean simRunEnabled = simRunSwitch . isSelected ( ) ; boolean ignoreEnabled = ignoreSwitch . isSelected ( ) ; boolean forceEnabled = forceSwitch . isSelected ( ) ; int threadComboVal = threadComboBox . getSelectedIndex ( ) + 1 ; int debugComboVal = debugComboBox . getSelectedIndex ( ) + 1 ; config . setDebug ( debugEnabled ) ; if ( debugEnabled ) { config . setVerbosity ( debugComboVal ) ; } else { config . setVerbosity ( 1 ) ; } config . setRunTerminal ( false ) ; config . setPastOnly ( false ) ; config . setForceRun ( forceEnabled ) ; config . setSimRun ( simRunEnabled ) ; if ( simRunEnabled ) { config . setLOG_NAME ( "log_alt.txt" ) ; } config . setIgnoreLog ( ignoreEnabled ) ; config . setNumThreads ( threadComboVal ) ; try { if ( config . finishedToday ( ) && ! config . isIgnoreLog ( ) ) { mainOutMessage ( "Already finished today" , 1 ) ; } } catch ( IOException e ) { Util . exceptionHandler ( e , 1 , "WT.run> Unknown error  probably a problem reading logfile" , config , this ) ; } config . outputConfig ( this ) ; wr = new WeatherRecorder ( this , config ) ; wr . run ( ) ; } else if ( runButton . getText ( ) . equals ( "Interrupt" ) ) { runButton . setText ( "Press button again to interrupt" ) ; } else if ( runButton . getText ( ) . equals ( "Press button again to interrupt" ) ) { runButton . setText ( "Forcing quit..." ) ; stopProgram ( ) ; } }
te	4	private Map fitnessCalculations ( List < Individual > individuals ) { Map statistics = new HashMap ( ) ; double countFitness = 0 ; double maxFitness = 0.0 ; double minFitness = 10.0 ; for ( Individual i : individuals ) { try { countFitness += i . fitness ( ) ; if ( i . fitness ( ) > maxFitness ) { maxFitness = i . fitness ( ) ; statistics . put ( "maxFitness" , maxFitness ) ; statistics . put ( "bestIndividual" , i ) ; } if ( i . fitness ( ) < minFitness ) { minFitness = i . fitness ( ) ; statistics . put ( "minFitness" , minFitness ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } statistics . put ( "avgFitness" , countFitness / individuals . size ( ) ) ; return statistics ; }
te	1	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { editNameLabel = new javax . swing . JLabel ( ) ; editNameField = new javax . swing . JTextField ( ) ; editTypeLabel = new javax . swing . JLabel ( ) ; editTypeDropdown = new javax . swing . JComboBox ( ) ; editValueLabel = new javax . swing . JLabel ( ) ; editCancelButton = new javax . swing . JButton ( ) ; editSaveButton = new javax . swing . JButton ( ) ; editValueField = new javax . swing . JTextField ( ) ; editValueValidationLabel = new javax . swing . JLabel ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ; setTitle ( "Editing key " + key ) ; editNameLabel . setText ( "Key:" ) ; editNameField . setText ( this . key ) ; editTypeLabel . setText ( "Type:" ) ; editTypeDropdown . setModel ( new javax . swing . DefaultComboBoxModel ( ValueTypes . values ( ) ) ) ; editTypeDropdown . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editTypeDropdownActionPerformed ( evt ) ; } } ) ; editValueLabel . setText ( "Value:" ) ; editCancelButton . setText ( "Cancel" ) ; editCancelButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editCancelButtonActionPerformed ( evt ) ; } } ) ; editSaveButton . setText ( "Save" ) ; editSaveButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { editSaveButtonActionPerformed ( evt ) ; } } ) ; editValueField . setText ( this . value != null ? this . value . toString ( ) : "" ) ; editValueField . setInputVerifier ( new EditValueFieldInputVerifier ( ) ) ; editValueField . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyTyped ( java . awt . event . KeyEvent evt ) { editValueFieldKeyTyped ( evt ) ; } } ) ; editValueValidationLabel . setIcon ( UIManager . getIcon ( "OptionPane.warningIcon" ) ) ; editValueValidationLabel . setText ( "jLabel1" ) ; editValueValidationLabel . setVisible ( false ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( editNameLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editNameField ) . addComponent ( editTypeLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editTypeDropdown , 0 , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( editValueLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addGroup ( javax . swing . GroupLayout . Alignment . TRAILING , layout . createSequentialGroup ( ) . addGap ( 0 , 244 , short . MAX_VALUE ) . addComponent ( editSaveButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editCancelButton ) ) . addComponent ( editValueField ) . addComponent ( editValueValidationLabel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) . addContainerGap ( ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( editNameLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editNameField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editTypeLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editTypeDropdown , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . UNRELATED ) . addComponent ( editValueLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( editValueField , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addComponent ( editValueValidationLabel ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , 79 , short . MAX_VALUE ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( editCancelButton ) . addComponent ( editSaveButton ) ) . addContainerGap ( ) ) ) ; pack ( ) ; }
te	3	private String getDifficultyName ( ) { if ( numHints < ( boardSegs * boardSegs ) + boardSegs ) return "diablolical" ; if ( numHints < boardWidth * 2 ) return "tough" ; if ( numHints < boardWidth * boardSegs ) return "moderate" ; return "gentle" ; }
te	5	private Point chooseRandomLocation ( ) { Point randomLocation ; ArrayList < Point > listOfEmptyLocations = new ArrayList < > ( ) ; Location [ ] [ ] locations = this . board . getBoardLocations ( ) ; for ( int row = 0 ; row < locations . length ; row ++ ) { Location [ ] rowLocations = locations [ row ] ; for ( int col = 0 ; col < rowLocations . length ; col ++ ) { Player playerAtLocation = rowLocations [ col ] . getPlayer ( ) ; if ( playerAtLocation == null ) { listOfEmptyLocations . add ( new Point ( row , col ) ) ; } } } int noOfEmptyLocations = listOfEmptyLocations . size ( ) ; if ( noOfEmptyLocations == 0 ) { return null ; } else if ( listOfEmptyLocations . size ( ) == 1 ) { randomLocation = listOfEmptyLocations . get ( 0 ) ; return randomLocation ; } else { int randomNumber = new Random ( ) . nextInt ( noOfEmptyLocations ) ; randomLocation = listOfEmptyLocations . get ( randomNumber ) ; return randomLocation ; } }
te	4	@ Override public int compareTo ( Card o ) { if ( rank . getValue ( ) < o . rank . getValue ( ) ) { return - 1 ; } else if ( rank . getValue ( ) > o . rank . getValue ( ) ) { return 1 ; } return suit . getValue ( ) < o . suit . getValue ( ) ? - 1 : suit . getValue ( ) == o . suit . getValue ( ) ? 0 : 1 ; }
te	8	public BinaryStrings ( double mutationRate , double recombinationRate , int recombinationSplit , int maxMutations ) { try { if ( recombinationRate > 1.0 || recombinationRate < 0.0 ) { throw new Exception ( "Crossover rate outside range 0.0-1.0" ) ; } this . recombinationRate = recombinationRate ; if ( recombinationSplit > 2 || recombinationSplit < 1 ) { throw new Exception ( "Crossover split is outside range  accepted values are 1 and 2  got " + recombinationSplit ) ; } this . recombinationSplit = recombinationSplit ; if ( mutationRate > 1.0 || mutationRate < 0.0 ) { throw new Exception ( "Mutation rate outside range 0.0-1.0" ) ; } this . mutationRate = mutationRate ; if ( maxMutations < 1 ) throw new Exception ( "Can't have 0 or negative mutations!" ) ; this . maxMutations = maxMutations ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
te	7	protected final short get_action ( int state , int sym ) { short tag ; int first , last , probe ; short [ ] row = action_tab [ state ] ; if ( row . length < 20 ) for ( probe = 0 ; probe < row . length ; probe ++ ) { tag = row [ probe ++ ] ; if ( tag == sym || tag == - 1 ) { return row [ probe ] ; } } else { first = 0 ; last = ( row . length - 1 ) / 2 - 1 ; while ( first <= last ) { probe = ( first + last ) / 2 ; if ( sym == row [ probe * 2 ] ) return row [ probe * 2 + 1 ] ; else if ( sym > row [ probe * 2 ] ) first = probe + 1 ; else last = probe - 1 ; } return row [ row . length - 1 ] ; } return 0 ; }
te	5	public static Object evaluate ( String expression , Object root , boolean trimRootToken ) throws Exception { if ( trimRootToken ) { expression = expression . substring ( expression . indexOf ( . ) + 1 ) ; } Object value = root ; StringTokenizer parser = new StringTokenizer ( expression , "." ) ; while ( parser . hasMoreTokens ( ) ) { String token = parser . nextToken ( ) ; if ( value == null ) { return null ; } ClassMap classMap = getClassMap ( value . getClass ( ) ) ; String methodBase = StringUtils . capitalizeFirstLetter ( token ) ; String methodName = "get" + methodBase ; Method method = classMap . findMethod ( methodName , CLASS_ARGS ) ; if ( method == null ) { methodName = "is" + methodBase ; method = classMap . findMethod ( methodName , CLASS_ARGS ) ; } if ( method == null ) { return null ; } value = method . invoke ( value , OBJECT_ARGS ) ; } return value ; }
te	1	@ Override public void visit ( VariableDeclaration node ) { Type symbolType = node . symbol ( ) . getType ( ) ; if ( ! symbolType . isPrimitive ( ) ) reportError ( node . lineNumber ( ) , node . charPosition ( ) , "Variable " + node . symbol ( ) . getName ( ) + " has invalid type " + symbolType + "." ) ; }
te	4	private void refilter ( ) { filteredList . clear ( ) ; for ( PasswordEntry entry : group . getListEntry ( ) ) { if ( compare ( entry . getURL ( ) ) || compare ( entry . getTitle ( ) ) || compare ( entry . getNotes ( ) ) ) { filteredList . add ( entry ) ; } } }
te	2	@ Override public BSTNode < T > search ( T element ) { BSTNode < T > node = search ( element , root ) ; if ( ! node . isEmpty ( ) ) { splay ( node ) ; } else { if ( ! node . equals ( root ) ) { splay ( ( BSTNode < T > ) node . getParent ( ) ) ; } } return node ; }
te	5	public int [ ] getIntArrayFileArgument ( String name , int start , int stop , boolean required ) { if ( M . containsKey ( name ) ) { String [ ] content = readFileContents ( M . get ( name ) ) ; if ( stop > content . length - 1 ) { if ( stop != Integer . MAX_VALUE ) { System . err . println ( "Warning requested array position does not exist" ) ; } stop = content . length - 1 ; } int [ ] res = new int [ ( stop - start ) + 1 ] ; for ( int i = start ; i <= stop ; i ++ ) { res [ i - start ] = Integer . parseInt ( content [ i ] ) ; } return res ; } else { if ( required ) { argumentMissing ( name ) ; } } return null ; }
te	7	private void setupLinks ( ) { final int rawlinksnum = this . links . size ( ) ; int [ ] rawlinks = new int [ rawlinksnum * Link . LINK_SIZE ] ; int idx = 0 ; for ( int i = 0 ; i < rawlinksnum ; i ++ ) { final int [ ] link = this . links . get ( i ) ; final int src = link [ 0 ] ; final int dst = link [ 1 ] ; final int widx = link [ 2 ] ; rawlinks [ idx ] = src ; idx ++ ; rawlinks [ idx ] = dst ; idx ++ ; rawlinks [ idx ] = widx ; idx ++ ; } Link . sortDstMaj ( rawlinks , Link . ORDER_ASC ) ; int [ ] links = Link . eliminateRedundantLinks ( rawlinks ) ; if ( links . length % Link . LINK_SIZE != 0 ) { throw new LinkArrayCorrupt ( ) ; } this . structure . links = links ; final int linksnum = links . length / Link . LINK_SIZE ; this . structure . linksnum = linksnum ; int woff = 1 ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = links [ idx + Link . IDX_SRC ] ; final int dst = links [ idx + Link . IDX_DST ] ; final int widx = links [ idx + Link . IDX_WEIGHT ] ; this . indeg [ dst ] ++ ; this . outdeg [ src ] ++ ; final int lsrc = this . layermap [ src ] ; final int ldst = this . layermap [ dst ] ; if ( lsrc >= ldst ) { this . structure . recurrent = true ; } if ( widx == WEIGHT_NEEDED ) { links [ idx + Link . IDX_WEIGHT ] = woff ; woff ++ ; } else if ( widx == Link . NOWEIGHT ) { links [ idx + Link . IDX_WEIGHT ] = 0 ; } idx += Link . LINK_SIZE ; } this . structure . weightsnum = ( woff - 1 ) ; int [ ] linksrev = links . clone ( ) ; Link . sortSrcMaj ( linksrev , Link . ORDER_ASC ) ; idx = 0 ; for ( int i = 0 ; i < linksnum ; i ++ ) { final int src = linksrev [ idx + Link . IDX_SRC ] ; final int dst = linksrev [ idx + Link . IDX_DST ] ; linksrev [ idx + Link . IDX_DST ] = src ; linksrev [ idx + Link . IDX_SRC ] = dst ; idx += Link . LINK_SIZE ; } this . structure . linksrev = linksrev ; }
te	1	class < ? > [ ] groups ( ) default { } ;
te	5	public boolean equals ( Object _other ) { if ( _other == null ) { return false ; } if ( _other == this ) { return true ; } if ( ! ( _other instanceof InviteRes ) ) { return false ; } final InviteRes _cast = ( InviteRes ) _other ; if ( inviteRes == null ? _cast . inviteRes != inviteRes : ! inviteRes . equals ( _cast . inviteRes ) ) { return false ; } return true ; }
te	1	public CashOffice registerCashOffice ( CashOffice cashOffice ) { int index = cashOffices . indexOf ( cashOffice ) ; if ( index == - 1 ) { addCashOffice ( cashOffice ) ; return cashOffice ; } else { CashOffice foundedCashOffice = cashOffices . get ( index ) ; return foundedCashOffice ; } }
te	6	public ScenarioTreeStepTwoOptions ( String name , ScenarioTreeStep first , String firstText , ScenarioTreeStep second , String secondText , String help ) { super ( name , help ) ; if ( first == null || second == null ) { throw new IllegalArgumentException ( "ScenarioTreeStepTwoOptions: Beide Schritte m\u00FCssen gesetzt sein!" ) ; } if ( firstText == null || firstText . trim ( ) . isEmpty ( ) || secondText == null || secondText == null ) { throw new IllegalArgumentException ( "ScenarioTreeStepTwoOptions: Beide Texte m\u00FCssen gesetzt und nicht leer sein!" ) ; } this . addFollowUpStep ( first , firstText ) ; this . addFollowUpStep ( second , secondText ) ; }
te	6	public int largestRectangleArea2 ( int [ ] height ) { if ( height == null || height . length == 0 ) return 0 ; int max = 0 ; int i = 0 ; while ( i < height . length ) { int k = i ; while ( k < height . length - 1 ) { if ( height [ k ] > height [ k + 1 ] ) { break ; } k ++ ; } i = k ; int lowest = height [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { lowest = Math . min ( lowest , height [ j ] ) ; int val = ( i - j + 1 ) * lowest ; max = Math . max ( max , val ) ; } i ++ ; } return max ; }
te	6	private void initButtons ( ) { buttons = new JPanel ( ) ; buttons . setMinimumSize ( new Dimension ( 70 , 75 + design . getHeight ( ) ) ) ; buttons . setBackground ( Color . black ) ; noTerrain = new JButton ( ) ; noTerrain . setText ( "Canyon" ) ; noTerrain . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; noTerrain . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; noTerrain . setForeground ( Color . LIGHT_GRAY ) ; noTerrain . setBackground ( Color . black ) ; noTerrain . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; noTerrain . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = - 1 ; } } ) ; terrain0 = new JButton ( ) ; terrain0 . setText ( "Road" ) ; terrain0 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain0 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain0 . setForeground ( Color . BLACK ) ; terrain0 . setBackground ( Color . LIGHT_GRAY ) ; terrain0 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain0 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 0 ; unitButtons . deselect ( ) ; } } ) ; terrain1 = new JButton ( ) ; terrain1 . setText ( "Grass" ) ; terrain1 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain1 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain1 . setForeground ( Color . BLACK ) ; terrain1 . setBackground ( new Color ( 100 , 150 , 0 ) ) ; terrain1 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain1 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 1 ; unitButtons . deselect ( ) ; } } ) ; terrain2 = new JButton ( ) ; terrain2 . setText ( "Hills" ) ; terrain2 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain2 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain2 . setForeground ( Color . BLACK ) ; terrain2 . setBackground ( new Color ( 100 , 100 , 0 ) ) ; terrain2 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain2 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 2 ; unitButtons . deselect ( ) ; } } ) ; terrain3 = new JButton ( ) ; terrain3 . setText ( "Forest" ) ; terrain3 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain3 . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; terrain3 . setForeground ( Color . BLACK ) ; terrain3 . setBackground ( new Color ( 0 , 125 , 0 ) ) ; terrain3 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain3 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 3 ; unitButtons . deselect ( ) ; } } ) ; terrain4 = new JButton ( ) ; terrain4 . setText ( "Mountain" ) ; terrain4 . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; terrain4 . setFont ( new Font ( "Consolas" , 0 , 8 ) ) ; terrain4 . setForeground ( Color . lightGray ) ; terrain4 . setBackground ( new Color ( 0 , 65 , 0 ) ) ; terrain4 . setMinimumSize ( new Dimension ( 40 , 40 ) ) ; terrain4 . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 4 ; unitButtons . deselect ( ) ; } } ) ; blueBase = new JButton ( ) ; blueBase . setIcon ( new ImageIcon ( ModelManager . getModel ( "BlueBase" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; blueBase . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; blueBase . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; blueBase . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 5 ; unitButtons . deselect ( ) ; } } ) ; redBase = new JButton ( ) ; redBase . setIcon ( new ImageIcon ( ModelManager . getModel ( "RedBase" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; redBase . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; redBase . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; redBase . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 6 ; unitButtons . deselect ( ) ; } } ) ; factory = new JButton ( ) ; factory . setIcon ( new ImageIcon ( ModelManager . getModel ( "Factory" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; factory . setBackground ( Color . LIGHT_GRAY ) ; factory . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; factory . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; factory . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = 7 ; unitButtons . deselect ( ) ; } } ) ; teamFactory = new JButton ( ) ; teamFactory . setIcon ( new ImageIcon ( ModelManager . getModel ( "Factory" ) . getImage ( ) . getScaledInstance ( 32 , 22 , java . awt . Image . SCALE_SMOOTH ) ) ) ; teamFactory . setBackground ( Color . BLUE ) ; teamFactory . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; teamFactory . setMaximumSize ( new Dimension ( 40 , 40 ) ) ; teamFactory . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { type = team ? 8 : 9 ; unitButtons . deselect ( ) ; } } ) ; blueTeam = new JRadioButton ( ) ; blueTeam . setText ( "Blue" ) ; blueTeam . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; blueTeam . setBackground ( Color . BLACK ) ; blueTeam . setForeground ( Color . LIGHT_GRAY ) ; blueTeam . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { team = true ; unitButtons . changeTeam ( true ) ; teamFactory . setBackground ( Color . BLUE ) ; redTeam . setSelected ( false ) ; } } ) ; redTeam = new JRadioButton ( ) ; redTeam . setText ( "Red" ) ; redTeam . setFont ( new Font ( "Consolas" , 0 , 9 ) ) ; redTeam . setBackground ( Color . BLACK ) ; redTeam . setForeground ( Color . LIGHT_GRAY ) ; redTeam . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { team = false ; unitButtons . changeTeam ( false ) ; teamFactory . setBackground ( Color . red ) ; blueTeam . setSelected ( false ) ; } } ) ; unitButtons = new UnitButtonsPanel ( ) ; unitButtons . setMaximumSize ( new Dimension ( 100 , 0 ) ) ; save = new JButton ( ) ; save . setText ( "Save" ) ; save . setBackground ( Color . BLACK ) ; save . setForeground ( Color . LIGHT_GRAY ) ; save . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; save . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { if ( LocationManager . getBase ( true ) == null || LocationManager . getBase ( false ) == null ) { JOptionPane . showMessageDialog ( design , "Base Missing" ) ; return ; } String mapName = JOptionPane . showInputDialog ( "Map Name?" ) ; if ( mapName == null || mapName . equals ( "" ) ) { JOptionPane . showMessageDialog ( design , "Invalid Name" ) ; return ; } try { LocationManager . saveMap ( mapName ) ; JOptionPane . showMessageDialog ( design , "Map " + mapName + " saved." ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( design , "Error occurred: " + e . toString ( ) ) ; } } } ) ; random = new JButton ( ) ; random = new JButton ( ) ; random . setText ( "Random" ) ; random . setBackground ( Color . BLACK ) ; random . setForeground ( Color . LIGHT_GRAY ) ; random . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; random . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { LocationManager . generateMap ( LocationManager . getSize ( ) . x , LocationManager . getSize ( ) . y ) ; render ( ) ; } } ) ; }
te	7	public Dimension preferredLayoutSize ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { if ( lastParentSize == null || ! parent . getSize ( ) . equals ( lastParentSize ) ) { for ( ComponentWrapper wrapper : ccMap . keySet ( ) ) { Component c = ( Component ) wrapper . getComponent ( ) ; if ( c instanceof JTextArea || c instanceof JEditorPane || ( c instanceof JComponent && boolean . true . equals ( ( ( JComponent ) c ) . getClientProperty ( "migLayout.dynamicAspectRatio" ) ) ) ) { layoutContainer ( parent ) ; break ; } } } lastParentSize = parent . getSize ( ) ; return getSizeImpl ( parent , LayoutUtil . PREF ) ; } }
te	4	public void move ( ) { m_x += m_velocityX ; m_y += m_velocityY ; if ( m_x < 0 ) { m_x = 0 ; m_velocityX = - m_velocityX ; } else if ( m_x > m_rightBound ) { m_x = m_rightBound ; m_velocityX = - m_velocityX ; } if ( m_y < 0 ) { m_y = 0 ; m_velocityY = - m_velocityY ; } else if ( m_y > m_bottomBound ) { m_y = m_bottomBound ; m_velocityY = - m_velocityY ; } }
te	1	private void fixUpCase1 ( RBNode < T > node ) { if ( node . equals ( root ) ) { node . setColour ( Colour . BLACK ) ; } else { fixUpCase2 ( node ) ; } }
te	2	public String getHeader ( String key ) { for ( Header h : headers ) { if ( h . getName ( ) . equals ( key ) ) { return h . getValue ( ) ; } } return null ; }
te	3	public static void resetVersion ( ) { DataOutputStream dos = null ; try { File dir = new File ( getWorkingDirectory ( ) + File . separator + "bin" + File . separator ) ; File versionFile = new File ( dir , "version" ) ; dos = new DataOutputStream ( new FileOutputStream ( versionFile ) ) ; dos . writeUTF ( "0" ) ; dos . close ( ) ; } catch ( FileNotFoundException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IOException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } finally { try { dos . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( Util . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
te	2	public static void initPreferences ( Preferences preferences ) { if ( pdfLaTeXFile == null ) preferences . put ( "pathToPDFLaTeXFile" , default ) ; else preferences . put ( "pathToPDFLaTeXFile" , pdfLaTeXFile . getAbsolutePath ( ) ) ; if ( pdfExportFolder == null ) preferences . put ( "pathToPDFExportFolder" , default ) ; else preferences . put ( "pathToPDFExportFolder" , pdfExportFolder . getAbsolutePath ( ) ) ; }
te	4	private ArrayList < String > RemoveStopWords ( ArrayList < String > textSnippets ) { String regex = "" , regexCaps = "" ; ArrayList < String > rem ; String path = System . getProperty ( "user.dir" ) ; File f = new File ( path , Settings . get ( "STOPWORD_LIST_PATH_SEARCH" ) ) ; try { BufferedReader br = new BufferedReader ( new FileReader ( f ) ) ; String line = "" ; line = br . readLine ( ) ; while ( line != null ) { regexCaps = line . substring ( 0 , 1 ) . toUpperCase ( ) + line . substring ( 1 ) ; regex = " " + line + " | " + regexCaps + " " ; rem = new ArrayList < String > ( ) ; for ( String temp : textSnippets ) { temp = " " + temp + " " ; temp = temp . replaceAll ( regex , " " ) ; rem . add ( temp . trim ( ) ) ; } textSnippets = rem ; line = br . readLine ( ) ; } br . close ( ) ; } catch ( FileNotFoundException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } catch ( IOException e ) { ApplicationHelper . printError ( STOP_WORDS_FILE_ERROR ) ; } return textSnippets ; }
te	0	public void setType ( String type ) { this . type = type ; }
te	2	public void add ( E e ) { Node u = new Node ( e ) ; if ( tail != null ) tail . setNext ( u ) ; tail = u ; if ( isEmpty ( ) ) { head = tail ; current = head ; } size ++ ; }
te	9X	private boolean applyDistributiveLaw ( IExpressionContext context , ASTNode result ) { final TreeMatcher matcher = new TreeMatcher ( ) . ignoreChildOrder ( true ) . requireNodeToHaveParent ( true ) . unwrapAll ( ) . matchParent ( ) . matchAND ( ) . matchOR ( ) . buildOR ( ) . matchRightChild ( ) . addMatcher ( new INodeMatcher ( ) { @ Override public boolean matches ( TreeMatcher matcher , ASTNode n ) { final ASTNode unwrapped = unwrap ( matcher . parentMatch ( ) ) ; if ( unwrapped . isOR ( ) ) { return n . isAND ( ) ; } if ( unwrapped . isAND ( ) ) { return n . isOR ( ) ; } throw new RuntimeException ( "Unreachable code reached" ) ; } } ) . buildOR ( ) . matchExtra ( ) . addMatcher ( new INodeMatcher ( ) { @ Override public boolean matches ( TreeMatcher matcher , ASTNode n ) { return matcher . leftMatch ( ) . getNodeCount ( ) != matcher . rightMatch ( ) . getNodeCount ( ) ; } } ) . buildOR ( ) ; final MutatingNodeVisitor visitor = new MutatingNodeVisitor ( context ) { @ Override public void visit ( ASTNode node , IExpressionContext context , IIterationContext it ) { if ( ! matcher . matches ( matcher , node ) ) { return ; } final ASTNode matchedParent = matcher . parentMatch ( ) ; final ASTNode leftChild = matcher . leftMatch ( ) ; final ASTNode rightChild = matcher . rightMatch ( ) ; final ASTNode leftTerm ; final ASTNode rightTerm ; final ASTNode replacementTerm ; ASTNode unwrappedRight = unwrap ( rightChild ) ; if ( unwrap ( matchedParent ) . isAND ( ) && unwrappedRight . isOR ( ) ) { leftTerm = maybeWrapInTerm ( OperatorNode . and ( leftChild , unwrappedRight . child ( 0 ) ) ) ; rightTerm = maybeWrapInTerm ( OperatorNode . and ( leftChild , unwrappedRight . child ( 1 ) ) ) ; replacementTerm = OperatorNode . or ( leftTerm , rightTerm ) ; } else if ( unwrap ( matchedParent ) . isOR ( ) && unwrappedRight . isAND ( ) ) { leftTerm = maybeWrapInTerm ( OperatorNode . or ( leftChild , unwrappedRight . child ( 0 ) ) ) ; rightTerm = maybeWrapInTerm ( OperatorNode . or ( leftChild , unwrappedRight . child ( 1 ) ) ) ; replacementTerm = OperatorNode . and ( leftTerm , rightTerm ) ; } else { throw new RuntimeException ( "Unreachable code reached => " + matcher ) ; } ASTNode toReplace = matchedParent ; if ( ! toReplace . hasParent ( ) ) { if ( unwrap ( toReplace ) != toReplace ) { toReplace = unwrap ( toReplace ) ; } else { throw new RuntimeException ( "Unreachable code reached" ) ; } } debugPrintln ( "DISTRIBUTIVE LAW: Replacing " + matchedParent . toString ( false ) + " -> " + replacementTerm ) ; toReplace . replaceWith ( replacementTerm ) ; it . astMutated ( ) ; } } ; return applyInOrder ( result , visitor ) ; }
te	4	public boolean boundaryCheck ( Point point ) { if ( ( point . x > 0 ) && point . x < width ) { if ( ( point . y > 0 ) && point . y < height ) { return true ; } } return false ; }
te	7	public ClassificationCodeType codeType ( ) { if ( "Flg" . equals ( name ( ) ) ) { return ClassificationCodeType . Number ; } if ( "MemberStatus" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ServiceRank" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "Region" . equals ( name ( ) ) ) { return ClassificationCodeType . Number ; } if ( "WithdrawalReason" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ProductCategory" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } if ( "ProductStatus" . equals ( name ( ) ) ) { return ClassificationCodeType . String ; } return ClassificationCodeType . String ; }
te	0	public boolean jogador1EhVencedor ( ) { return jogador1 . ehVencedor ( ) ; }
te	7	public void removeKey ( String var ) { boolean changed = false ; if ( this . props . containsKey ( var ) ) { this . props . remove ( var ) ; changed = true ; } Iterator < String > it = this . lines . listIterator ( ) ; while ( it . hasNext ( ) ) { String line = it . next ( ) ; if ( line . trim ( ) . length ( ) == 0 ) { continue ; } if ( line . charAt ( 0 ) == # ) { continue ; } if ( line . contains ( "=" ) ) { int delimPosition = line . indexOf ( = ) ; String key = line . substring ( 0 , delimPosition ) . trim ( ) ; if ( key . equals ( var ) ) { it . remove ( ) ; changed = true ; } } else { continue ; } } if ( changed ) { save ( ) ; } }
te	8	public static void main ( String [ ] args ) { final Random rnd = new Random ( System . currentTimeMillis ( ) ) ; final int input = 2 ; final int hidden = 8 ; final int trainset_size = 5000 ; final int testset_size = 100 ; final int epochs = 4000 ; final double learningrate = 0.004 ; final double momentum = 0.9 ; final MLPGenerator gen = new MLPGenerator ( ) ; gen . inputLayer ( input ) ; gen . hiddenLayer ( hidden , CellType . SIGMOID , true , - 1.0 ) ; gen . outputLayer ( 1 , CellType . SIGMOID ) ; final Net mlp = gen . generate ( ) ; mlp . initializeWeights ( rnd ) ; final SampleSet trainset = generateData ( trainset_size + testset_size , 0.5f , rnd ) ; final SampleSet testset = trainset . split ( testset_size , rnd ) ; GradientDescent trainer = new GradientDescent ( ) ; trainer . setEpochs ( epochs ) ; trainer . setLearningRate ( learningrate ) ; trainer . setMomentum ( momentum ) ; trainer . setPermute ( true ) ; trainer . setRnd ( rnd ) ; trainer . setTargetError ( 10E-5 ) ; trainer . setNet ( mlp ) ; trainer . setTrainingSet ( trainset ) ; trainer . addListener ( new NetTrainerListener ( ) { @ Override public void started ( NetTrainer trainer ) { } @ Override public void finished ( NetTrainer trainer ) { } @ Override public void epoch ( NetTrainer trainer ) { final int ep = trainer . getEpoch ( ) + 1 ; if ( ( ep ) % ( epochs / 16 ) != 0 && ep != 1 ) return ; final BufferedImage img = new BufferedImage ( 800 , 800 , BufferedImage . TYPE_INT_RGB ) ; double [ ] p = new double [ 2 ] ; double [ ] o = new double [ 2 ] ; for ( int y = 0 ; y < img . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < img . getWidth ( ) ; x ++ ) { p [ 0 ] = ( ( double ) x ) / ( ( double ) ( img . getWidth ( ) ) ) ; p [ 1 ] = ( ( double ) y ) / ( ( double ) ( img . getHeight ( ) ) ) ; mlp . reset ( ) ; mlp . input ( p , 0 ) ; mlp . compute ( ) ; mlp . output ( o , 0 ) ; int v = ( ( int ) ( o [ 0 ] * 255 ) ) ; img . setRGB ( x , y , ( ( v >> 1 ) << 8 ) | v ) ; } } final Graphics2D g = ( Graphics2D ) img . getGraphics ( ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; for ( Sample s : trainset ) { int x = ( int ) ( ( double ) ( img . getWidth ( ) - 1 ) * s . getInput ( ) [ 0 ] ) ; int y = ( int ) ( ( double ) ( img . getHeight ( ) - 1 ) * s . getInput ( ) [ 1 ] ) ; if ( s . getTarget ( ) [ 0 ] > 0.5 ) { g . setColor ( CLASS_1 ) ; } else { g . setColor ( CLASS_2 ) ; } g . fillOval ( x - 2 , y - 2 , 5 , 5 ) ; } JFrame frame = new JFrame ( "Geometry Learning - Epoch: " + ep ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; JPanel panel = new JPanel ( ) { private static final long serialVersionUID = - 4307908552010057652 ; @ Override protected void paintComponent ( Graphics gfx ) { super . paintComponent ( gfx ) ; gfx . drawImage ( img , 0 , 0 , img . getWidth ( ) , img . getHeight ( ) , null ) ; } } ; panel . setPreferredSize ( new Dimension ( img . getWidth ( ) , img . getHeight ( ) ) ) ; frame . add ( panel ) ; frame . setResizable ( false ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } } ) ; trainer . train ( ) ; System . out . println ( ) ; ClassificationValidator val = new ClassificationValidator ( mlp ) ; for ( Sample s : trainset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on trainset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; val . reset ( ) ; for ( Sample s : testset ) { val . apply ( s ) ; } System . out . println ( "recognition accuracy on testset: " + ( val . ratio ( ) * 100.0 ) + "%" ) ; }
te	5	@ Override public boolean equals ( Object object ) { if ( ! ( object instanceof Users ) ) { return false ; } Users other = ( Users ) object ; if ( ( this . iduser == null && other . iduser != null ) || ( this . iduser != null && ! this . iduser . equals ( other . iduser ) ) ) { return false ; } return true ; }
te	3	public static Polynomial createFromBytes ( byte [ ] bytes ) { TreeSet < BigInteger > dgrs = createDegreesCollection ( ) ; int degree = 0 ; for ( int i = bytes . length - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < 8 ; j ++ ) { if ( ( ( ( bytes [ i ] >> j ) & 1 ) == 1 ) ) { dgrs . add ( BigInteger . valueOf ( degree ) ) ; } degree ++ ; } } return new Polynomial ( dgrs ) ; }
te	9X	private int [ ] getMinPrefMaxSumSize ( boolean isHor ) { int [ ] [ ] sizes = isHor ? colFlowSpecs . sizes : rowFlowSpecs . sizes ; int [ ] retSizes = new int [ 3 ] ; BoundSize sz = isHor ? lc . getWidth ( ) : lc . getHeight ( ) ; for ( int i = 0 ; i < sizes . length ; i ++ ) { if ( sizes [ i ] != null ) { int [ ] size = sizes [ i ] ; for ( int sType = LayoutUtil . MIN ; sType <= LayoutUtil . MAX ; sType ++ ) { if ( sz . getSize ( sType ) != null ) { if ( i == 0 ) retSizes [ sType ] = sz . getSize ( sType ) . getPixels ( getParentSize ( container , isHor ) , container , null ) ; } else { int s = size [ sType ] ; if ( s != LayoutUtil . NOT_SET ) { if ( sType == LayoutUtil . PREF ) { int bnd = size [ LayoutUtil . MAX ] ; if ( bnd != LayoutUtil . NOT_SET && bnd < s ) s = bnd ; bnd = size [ LayoutUtil . MIN ] ; if ( bnd > s ) s = bnd ; } retSizes [ sType ] += s ; } if ( size [ LayoutUtil . MAX ] == LayoutUtil . NOT_SET || retSizes [ LayoutUtil . MAX ] > LayoutUtil . INF ) retSizes [ LayoutUtil . MAX ] = LayoutUtil . INF ; } } } } correctMinMax ( retSizes ) ; return retSizes ; }
te	5	public ArrayList < ClosedTransaction > closeLong ( TransactionHistory th ) { int closeAmount = th . getAmount ( ) * - 1 ; if ( this . openAmount <= 0 || closeAmount <= 0 ) { throw new InvalidCloseAction ( ) ; } double closePrice = th . getPrice ( ) ; Date closeTime = th . getTime ( ) ; if ( closeAmount > this . openAmount ) { throw new NotEnoughAmountToClose ( closeAmount ) ; } this . openAmount -= closeAmount ; ArrayList < ClosedTransaction > closed = new ArrayList < ClosedTransaction > ( ) ; int remainToClose = closeAmount ; while ( remainToClose > 0 ) { OpenTransaction node = this . openList . getFirst ( ) ; int nodeAmount = node . getOpenAmount ( ) ; if ( remainToClose >= nodeAmount ) { ClosedTransaction ct = node . close ( closeTime , closePrice , nodeAmount ) ; closed . add ( ct ) ; this . openList . removeFirst ( ) ; remainToClose -= nodeAmount ; } else { ClosedTransaction ct = node . close ( closeTime , closePrice , remainToClose ) ; closed . add ( ct ) ; node . setOpenAmount ( nodeAmount - remainToClose ) ; remainToClose = 0 ; } } return closed ; }
te	9X	private static void begin ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNextLine ( ) ) { StringTokenizer st = new StringTokenizer ( sc . nextLine ( ) ) ; int nbrInts = Integer . parseInt ( st . nextToken ( ) ) ; if ( nbrInts <= 0 ) { System . out . println ( "Not jolly" ) ; continue ; } else if ( nbrInts == 1 ) { System . out . println ( "Jolly" ) ; continue ; } boolean [ ] data = new boolean [ nbrInts - 1 ] ; int prev = Integer . parseInt ( st . nextToken ( ) ) ; while ( st . hasMoreTokens ( ) ) { int curr = Integer . parseInt ( st . nextToken ( ) ) ; int absDiff = Math . abs ( prev - curr ) ; if ( absDiff > 0 && absDiff <= nbrInts - 1 ) { data [ absDiff - 1 ] = true ; } prev = curr ; } boolean isJolly = true ; for ( boolean b : data ) { if ( ! b ) { isJolly = false ; break ; } } if ( isJolly ) { System . out . println ( "Jolly" ) ; } else { System . out . println ( "Not jolly" ) ; } } }
te	3	@ Override public void update ( Observable o , Object o1 ) { if ( o . getClass ( ) == FachadaInterfaz . class && o1 . equals ( "Convenio" ) ) { try { setTableConvenios ( ) ; } catch ( ParseException ex ) { Logger . getLogger ( MantenimientoConvenio . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } }
te	3	public boolean hasSlot ( String name ) { if ( slots . containsKey ( name ) ) return true ; for ( MinObject proto : protos ) { if ( proto . hasSlot ( name ) ) return true ; } return false ; }
te	6	public void update ( ) { Board board = Board . getInstance ( ) ; int x = board . getIntX ( ) + ( board . getIntWidth ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; int y = board . getIntY ( ) + ( board . getIntHeight ( ) - 11 * BoardEntity . FIELD_SIZE ) / 2 ; switch ( getType ( ) ) { case RED_PLAYER : y += BoardEntity . FIELD_SIZE ; break ; case BLUE_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE ; break ; case GREEN_PLAYER : x += BoardEntity . FIELD_SIZE * 7 ; y += BoardEntity . FIELD_SIZE * 9 ; break ; case YELLOW_PLAYER : y += BoardEntity . FIELD_SIZE * 9 ; break ; } nameLabel . verticalAlignCenter ( x , x + 4 * BoardEntity . FIELD_SIZE ) ; nameLabel . setY ( y ) ; nameLabel . update ( ) ; if ( position != 0 ) { nameLabel . setText ( scoreLabelStr ( ) ) ; } else if ( isActive ( ) ) { nameLabel . setText ( String . format ( "%s (%d)" , this . name , this . rollCount ) ) ; } else { nameLabel . setText ( this . name ) ; } }
te	3	@ Override public String execute ( ) throws Exception { try { Map session = ActionContext . getContext ( ) . getSession ( ) ; User user = ( User ) session . get ( "User" ) ; Campaign camp ; lc = ( long ) long . parseLong ( campaid ) ; System . out . println ( "campaignlong id is" + getLc ( ) ) ; camp = ( Campaign ) myDao . getDbsession ( ) . get ( Campaign . class , lc ) ; camp . setCampaignId ( long . parseLong ( campaid ) ) ; camp . setCampaignName ( campaignname ) ; camp . setStartDate ( startdate ) ; camp . setEndDate ( enddate ) ; camp . setDialyBudget ( dailybdgt ) ; camp . setDeliveryMethod ( deliverytype ) ; camp . setNote ( note ) ; getMyDao ( ) . getDbsession ( ) . update ( camp ) ; setCamplist ( ( List < Campaign > ) myDao . getDbsession ( ) . createQuery ( "from Campaign" ) . list ( ) ) ; Criteria crit = myDao . getDbsession ( ) . createCriteria ( Campaign . class ) ; crit . add ( Restrictions . like ( "user" , user ) ) ; crit . setMaxResults ( 20 ) ; setCamplist ( ( List < Campaign > ) crit . list ( ) ) ; addActionMessage ( "Campaign " + camp . getCampaignName ( ) + " Successfully Updated" ) ; return "success" ; } catch ( HibernateException e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } catch ( NullPointerException ne ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; ne . printStackTrace ( ) ; return "error" ; } catch ( Exception e ) { addActionError ( "Server  Error Please Recheck All Fields " ) ; e . printStackTrace ( ) ; return "error" ; } }
te	0	public void incrementNodeQuantity ( int increment ) { nodeQuantity += increment ; }
te	7	private JSONWriter append ( String string ) throws JSONException { if ( string == null ) { throw new JSONException ( "Null pointer" ) ; } if ( this . mode == o || this . mode == a ) { try { if ( this . , && this . mode == a ) { this . writer . write (   ) ; } this . writer . write ( string ) ; } catch ( IOException e ) { throw new JSONException ( e ) ; } if ( this . mode == o ) { this . mode = k ; } this . , = true ; return this ; } throw new JSONException ( "Value out of sequence." ) ; }
te	2	public void setFieldValue ( _Fields field , Object value ) { switch ( field ) { case SUCCESS : if ( value == null ) { unset_success ( ) ; } else { set_success ( ( Integer ) value ) ; } break ; } }
te	7	private void writeFile ( String data , boolean isAppend ) { if ( ! exists ( ) ) { try { createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } BufferedWriter bfWriter = null ; try { FileWriter flWriter = null ; if ( isAppend ) { flWriter = new FileWriter ( this , true ) ; } else { flWriter = new FileWriter ( this ) ; } bfWriter = new BufferedWriter ( flWriter ) ; if ( isAppend ) { bfWriter . newLine ( ) ; } bfWriter . write ( data ) ; bfWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( bfWriter != null ) bfWriter . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } }
te	5	JavaExporter ( Component parent , List < FontHandle > fonts , JFileChooser chooser ) { if ( chooser != null ) { mChooser = chooser ; } else { String path = System . getProperty ( "user.home" ) ; if ( path != null ) { File file = new File ( path , "Desktop" ) ; if ( ! file . exists ( ) ) { file = new File ( path ) ; } mChooser = new JFileChooser ( file ) ; } else { mChooser = new JFileChooser ( ) ; } } while ( parent . getParent ( ) != null ) { parent = parent . getParent ( ) ; } mFonts = fonts ; mNoExampleButton = new JButton ( "Export Fonts" ) ; mExampleButton = new JButton ( "Export Fonts + Example Code" ) ; mCancelButton = new JButton ( "Cancel" ) ; mNoExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( false ) ; } } ) ; mExampleButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doExport ( true ) ; } } ) ; mCancelButton . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { doCancel ( ) ; } } ) ; Font font = new Font ( "Verdana" , Font . BOLD , 18 ) ; for ( JButton b : new JButton [ ] { mNoExampleButton , mExampleButton , mCancelButton } ) { b . setFont ( font ) ; add ( b ) ; } setLayout ( new Layout ( ) ) ; mDialog = new JDialog ( ( Window ) parent , "Export Options" , ModalityType . APPLICATION_MODAL ) ; mDialog . setContentPane ( this ) ; mDialog . setSize ( 450 , 280 ) ; mDialog . setResizable ( false ) ; mDialog . setLocationRelativeTo ( parent ) ; mDialog . setVisible ( true ) ; }
te	2	public Object unserialize ( String s ) throws IOException { return ( s == null || s . length ( ) == 0 ) ? null : new Integer ( s ) ; }
te	7	HubNode ( Device dev , TreeNode parent ) throws IOException { super ( dev , parent ) ; hub = new Hub ( dev ) ; addr = dev . getAddress ( ) ; if ( isFlatTree ) { if ( hub . isRootHub ( ) ) { Bus bus = dev . getBus ( ) ; children = new USBNode [ 127 ] ; last = 0 ; for ( int i = 1 ; i <= 127 ; i ++ ) { Device d = bus . getDevice ( i ) ; if ( d != null && d != dev ) deviceAdded ( d , null ) ; } } else children = null ; } else { children = new USBNode [ hub . getNumPorts ( ) ] ; last = 0 ; for ( int i = 1 ; i <= children . length ; i ++ ) { Device d = dev . getChild ( i ) ; if ( d != null ) deviceAdded ( d , null ) ; } } }
te	3	public static List < FavoritesTag > constructTag ( Response res ) throws WeiboException { try { JSONArray list = res . asJSONObject ( ) . getJSONArray ( "tags" ) ; int size = list . length ( ) ; List < FavoritesTag > tags = new ArrayList < FavoritesTag > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { tags . add ( new FavoritesTag ( list . getJSONObject ( i ) ) ) ; } return tags ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone ) ; } catch ( WeiboException te ) { throw te ; } }
te	8	@ Transactional public void allocateSeats ( Event event ) { if ( event . isSeatAllocated ( ) ) { return ; } List < EventRegistration > allUnallocatedForeignRegistrations = participantDAO . allUnallocatedRegistrations ( event , false , false ) ; List < EventRegistration > allUnallocatedIndianRegistrations = participantDAO . allUnallocatedRegistrations ( event , false , true ) ; List < EventRegistration > allUnallocatedRegistrations = new ArrayList < EventRegistration > ( ) ; allUnallocatedRegistrations . addAll ( allUnallocatedForeignRegistrations ) ; allUnallocatedRegistrations . addAll ( allUnallocatedIndianRegistrations ) ; List < RowMeta > rowMetas = eventDAO . getAllEmptyRowMetas ( event ) ; int regsCount = 0 ; int regsSize = allUnallocatedRegistrations . size ( ) ; for ( RowMeta rowMeta : rowMetas ) { if ( regsCount >= regsSize ) { break ; } int seatCounter = 0 ; boolean [ ] seatFlags = markAllocatedSeats ( event , rowMeta ) ; boolean isRowFull = false ; for ( int i = 0 ; i < seatFlags . length ; i ++ ) { if ( regsCount >= regsSize ) { break ; } seatCounter = seatCounter + 1 ; if ( ! seatFlags [ i ] ) { EventRegistration registration = allUnallocatedRegistrations . get ( regsCount ) ; ParticipantSeat seat = createSeat ( registration , rowMeta . getRowName ( ) , seatCounter ) ; participantDAO . saveOrUpdate ( seat ) ; seatFlags [ i ] = true ; regsCount ++ ; } if ( seatFlags . length == seatCounter ) { isRowFull = true ; } } if ( isRowFull ) { rowMeta . setRowFull ( true ) ; eventDAO . saveOrUpdate ( rowMeta ) ; } } event . setSeatAllocated ( true ) ; eventDAO . saveOrUpdate ( event ) ; }
te	3	public String [ ] adjudicate ( final int lineNumber , final String orig , final String [ ] hdr , final String [ ] flds ) { final int n = hdr . length ; String [ ] res = new String [ n ] ; for ( int i = 0 ; ( i < flds . length ) && ( i < n ) ; ++ i ) { res [ i ] = flds [ i ] ; } for ( int i = flds . length ; i < n ; ++ i ) { res [ i ] = "" ; } return res ; }
te	6	public static void SetBusqueda ( String dir ) { if ( dir . contains ( "http" ) == true || dir . contains ( "www" ) == true || dir . contains ( ".com" ) == true || dir . contains ( ".es" ) == true ) { dir = dir . replace ( "http://" , "" ) ; dir = dir . replace ( "https://" , "" ) ; try { web . getEngine ( ) . load ( "http://" + dir ) ; } catch ( Exception e ) { web . getEngine ( ) . load ( "https://" + dir ) ; } } else { String search = getStaticWords ( dir ) ; try { web . getEngine ( ) . load ( search ) ; } catch ( Exception e ) { } } }
te	0	public NoSuchColumnException ( String message , Throwable cause ) { super ( message , cause ) ; }
te	4	public void construct2DMatrixFromStringSet ( int currentRow , int startIndex , int numRows , int numColumns , List < String > rawData ) { String sCurrentLine = "" ; String _convertedPattern = "" ; int trackNumberOfRows = 0 ; int sIndex = 0 ; _pattern = new String [ numRows ] ; while ( true ) { sCurrentLine = rawData . get ( currentRow ) . substring ( startIndex , startIndex + numColumns ) ; sIndex = 0 ; if ( trackNumberOfRows == numRows ) break ; _convertedPattern = "" ; while ( sIndex < sCurrentLine . length ( ) ) { _convertedPattern += ( sCurrentLine . charAt ( sIndex ) == + ? 1 : 0 ) ; sIndex ++ ; } _pattern [ trackNumberOfRows ] = String . valueOf ( binaryToDecimal ( _convertedPattern ) ) ; trackNumberOfRows ++ ; } }
te	4	public int numCoreArgs ( ) { int cnt = 0 ; for ( int i = 0 , n = arglbids . length ; i < n ; ++ i ) if ( arglbids [ i ] >= 0 && arglbs [ i ] . length ( ) < 3 && arglbs [ i ] . startsWith ( "A" ) ) ++ cnt ; return cnt ; }
te	6	public static void display ( MapInfo mapInfo ) { StdDraw . setXscale ( 0 , mapInfo . getMapSize ( ) ) ; StdDraw . setYscale ( 0 , mapInfo . getMapSize ( ) ) ; StdDraw . setPenColor ( StdDraw . RED ) ; StdDraw . setPenColor ( StdDraw . BLACK ) ; for ( int row = 1 ; row < mapInfo . getMapSize ( ) - 1 ; row ++ ) { for ( int column = 1 ; column < mapInfo . getMapSize ( ) - 1 ; column ++ ) { if ( mapInfo . getCell ( row , column ) . isSouth ( ) ) StdDraw . line ( row + 1 , column , row + 1 , column + 1 ) ; if ( mapInfo . getCell ( row , column ) . isNorth ( ) ) StdDraw . line ( row , column , row , column + 1 ) ; if ( mapInfo . getCell ( row , column ) . isWest ( ) ) StdDraw . line ( row , column , row + 1 , column ) ; if ( mapInfo . getCell ( row , column ) . isEast ( ) ) StdDraw . line ( row , column + 1 , row + 1 , column + 1 ) ; } } StdDraw . show ( 1000 ) ; }
te	2	public static void writeAttack ( Pokemon poke , int moveChoice , int damage , int teamId ) { if ( ! isSearchMode ) { String statement = "%s" ; if ( teamId == Game . OMNIDEXTER ) { statement = String . format ( statement , "OmniDexter's" ) ; } else { statement = String . format ( statement , "Opponent" ) ; } statement = statement . concat ( " %s uses %s  dealing %d damage!" ) ; String moveName = poke . getMove ( moveChoice ) . getMove ( ) . getName ( ) ; statement = String . format ( statement , poke , moveName , damage ) ; System . out . println ( statement ) ; } }
te	2	void setProgressBar ( double pos ) { progress_bar = pos ; if ( ! is_initialised && initpainter != null ) repaint ( 100 ) ; }
te	5	public static boolean isValidWeekInMonthCode ( final int code ) { switch ( code ) { case FIRST_WEEK_IN_MONTH : case SECOND_WEEK_IN_MONTH : case THIRD_WEEK_IN_MONTH : case FOURTH_WEEK_IN_MONTH : case LAST_WEEK_IN_MONTH : return true ; default : return false ; } }
te	1	public static JSONObject toJSONObject ( String string ) throws JSONException { JSONObject jo = new JSONObject ( ) ; JSONTokener x = new JSONTokener ( string ) ; while ( x . more ( ) ) { String name = Cookie . unescape ( x . nextTo ( = ) ) ; x . next ( = ) ; jo . put ( name , Cookie . unescape ( x . nextTo ( ; ) ) ) ; x . next ( ) ; } return jo ; }
te	8	private void buildMenu ( ) { jmbMenu = new JMenuBar ( ) ; JMenu jmFile = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.file" , "File" ) ) ; JMenuItem jmiConnect = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.connect" , "Connect" ) ) ; JMenuItem jmiDisconnect = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.disconnect" , "Disconnect" ) ) ; JMenuItem jmiOpen = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.openExisting" , "Open Existing" ) ) ; JMenuItem jmiRemove = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.remove" , "Remove Existing" ) ) ; JMenuItem jmiPrint = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.print" , "Print" ) ) ; JMenuItem jmiSave = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.save" , "Save As CSV" ) ) ; JMenuItem jmiExit = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.file.exit" , "Exit" ) ) ; jmFile . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.file.acc" , "f" ) ) . charAt ( 0 ) ) ; jmiConnect . addActionListener ( new File_New ( ) ) ; jmiDisconnect . addActionListener ( new File_Disconnect ( ) ) ; jmiOpen . addActionListener ( new File_Open ( this ) ) ; jmiRemove . addActionListener ( new File_Remove ( ) ) ; jmiPrint . addActionListener ( new File_Print ( ) ) ; jmiSave . addActionListener ( new File_Save ( ) ) ; jmiExit . addActionListener ( new File_Exit ( ) ) ; jmFile . add ( jmiConnect ) ; jmFile . add ( jmiDisconnect ) ; jmFile . add ( jmiOpen ) ; jmFile . add ( jmiRemove ) ; jmFile . addSeparator ( ) ; jmFile . add ( jmiPrint ) ; jmFile . add ( jmiSave ) ; jmFile . addSeparator ( ) ; jmFile . add ( jmiExit ) ; JMenu jmView = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.view" , "View" ) ) ; JMenuItem jmiConnections = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu." , "Connections" ) ) ; JMenuItem jmiClients = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu." , "Connected Clients" ) ) ; jmView . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.view.acc" , "v" ) ) . charAt ( 0 ) ) ; jmiConnections . addActionListener ( new View_Connections ( ) ) ; jmiClients . addActionListener ( new View_Clients ( ) ) ; jmView . add ( jmiConnections ) ; jmView . add ( jmiClients ) ; JMenu jmPrefs = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.preferences" , "Preferences" ) ) ; JMenu jmLnF = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.lnf" , "Look and Feel" ) ) ; JMenu jmLocale = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.locale" , "Locale" ) ) ; JMenu jmLogging = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.logging" , "Logging" ) ) ; JMenuItem jmiXSDDir = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.XSDDir" , "Set Schema Location" ) ) ; JMenuItem jmiLogDir = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.prefs.LogsDir" , "Set Log Directory" ) ) ; jmPrefs . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.preferences.acc" , "p" ) ) . charAt ( 0 ) ) ; UIManager . LookAndFeelInfo [ ] lafThisSystem = UIManager . getInstalledLookAndFeels ( ) ; ButtonGroup bgLnF = new ButtonGroup ( ) ; for ( int i = 0 ; i < lafThisSystem . length ; i ++ ) { JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( lafThisSystem [ i ] . getName ( ) ) ; jrbMI . addActionListener ( new Prefs_LnF ( lafThisSystem [ i ] . getClassName ( ) , this , mrbGui . getRBLocale ( ) ) ) ; if ( lafThisSystem [ i ] . getClassName ( ) . equals ( pGui . get ( "mars.lnf" , "javax.swing.plaf.metal.MetalLookAndFeel" ) ) ) { jrbMI . setSelected ( true ) ; } bgLnF . add ( jrbMI ) ; jmLnF . add ( jrbMI ) ; } String strNumOfLangs = mrbGui . getRBString ( "mars.locales.numberOfLocales" , "Unknown" ) ; Vector vecLangs = new Vector ( ) ; if ( strNumOfLangs . equals ( "Unknown" ) ) { vecLangs . add ( new String [ ] { "US English" , "en_US" } ) ; } else { Integer intLangAmount = new Integer ( strNumOfLangs ) ; for ( int i = 1 ; i <= intLangAmount . intValue ( ) ; i ++ ) { vecLangs . add ( new String [ ] { mrbGui . getRBString ( "mars.locales." + i , "US English" ) , mrbGui . getRBString ( "mars.locales.code." + i , "en_US" ) } ) ; } } String savedLocale = new String ( pGui . get ( "mars.locale.lang" , "en" ) + "_" + pGui . get ( "mars.locale.country" , "US" ) ) ; ButtonGroup bgLocale = new ButtonGroup ( ) ; for ( int i = 0 ; i < vecLangs . size ( ) ; i ++ ) { String [ ] lang = ( String [ ] ) vecLangs . get ( i ) ; JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( lang [ 0 ] , new ImageIcon ( "images/" + lang [ 1 ] + ".png" ) ) ; jrbMI . addActionListener ( new Prefs_Locale ( lang [ 1 ] ) ) ; if ( lang [ 1 ] . equals ( savedLocale ) ) { jrbMI . setSelected ( true ) ; } bgLocale . add ( jrbMI ) ; jmLocale . add ( jrbMI ) ; } String [ ] strLog = new String [ ] { "Severe" , "Warning" , "Info" , "Config" , "Fine" , "Finer" , "Finest" , "All" , "Off" } ; ButtonGroup bgLogs = new ButtonGroup ( ) ; for ( int i = 0 ; i < strLog . length ; i ++ ) { JRadioButtonMenuItem jrbMI = new JRadioButtonMenuItem ( strLog [ i ] ) ; jrbMI . addActionListener ( new Prefs_Logging ( strLog [ i ] ) ) ; if ( pGui . get ( "mars.logLevel" , "All" ) . equals ( strLog [ i ] ) ) { jrbMI . setSelected ( true ) ; } bgLogs . add ( jrbMI ) ; jmLogging . add ( jrbMI ) ; } jmiXSDDir . addActionListener ( new Prefs_SetDir ( "XSD" , this ) ) ; jmiLogDir . addActionListener ( new Prefs_SetDir ( "Log" , this ) ) ; jmPrefs . add ( jmLnF ) ; jmPrefs . add ( jmLocale ) ; jmPrefs . add ( jmLogging ) ; jmPrefs . add ( jmiXSDDir ) ; jmPrefs . add ( jmiLogDir ) ; JMenu jmWindow = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.window" , "Window" ) ) ; JMenuItem jmiTile = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.tile" , "Tile All" ) ) ; JMenuItem jmiCascade = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.cascade" , "Cascade" ) ) ; JMenuItem jmiMinimise = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.window.minimise" , "Minimise" ) ) ; jmWindow . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.window.acc" , "w" ) ) . charAt ( 0 ) ) ; jmiTile . addActionListener ( new Window_Tile ( ) ) ; jmiCascade . addActionListener ( new Window_Cascade ( ) ) ; jmiMinimise . addActionListener ( new Window_Minimise ( ) ) ; jmWindow . add ( jmiTile ) ; jmWindow . add ( jmiCascade ) ; jmWindow . add ( jmiMinimise ) ; JMenu jmHelp = new JMenu ( mrbGui . getRBString ( "mars.gui.client.menu.help" , "Help" ) ) ; JMenuItem jmiAbout = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.help.about" , "About" ) ) ; JMenuItem jmiLicense = new JMenuItem ( mrbGui . getRBString ( "mars.gui.client.menu.help.license" , "License" ) ) ; jmHelp . setMnemonic ( ( mrbGui . getRBString ( "mars.gui.client.menu.help.acc" , "h" ) ) . charAt ( 0 ) ) ; jmiAbout . addActionListener ( new Help_About ( ) ) ; jmiLicense . addActionListener ( new Help_License ( ) ) ; jmHelp . add ( jmiAbout ) ; jmHelp . add ( jmiLicense ) ; jmbMenu . add ( jmFile ) ; jmbMenu . add ( jmView ) ; jmbMenu . add ( jmPrefs ) ; jmbMenu . add ( jmWindow ) ; jmbMenu . add ( jmHelp ) ; }
te	6	public Geometry makePath ( double [ ] [ ] Pn , int nP ) { if ( nP == this . nP && same ( Pn , this . Pn ) ) return this ; if ( this . Pn == null || this . Pn . length != Pn . length ) this . Pn = new double [ Pn . length ] [ 3 ] ; for ( int n = 0 ; n < Pn . length ; n ++ ) for ( int k = 0 ; k < Pn [ n ] . length ; k ++ ) this . Pn [ n ] [ k ] = Pn [ n ] [ k ] ; return makePath ( resample ( Pn , nP ) ) ; }
te	3	static private final int jjMoveStringLiteralDfa14_0 ( long old0 , long active0 ) { if ( ( ( active0 &= old0 ) ) == 0 ) return jjStartNfa_0 ( 12 , old0 ) ; try { curChar = input_stream . readChar ( ) ; } catch ( java . io . IOException e ) { jjStopStringLiteralDfa_0 ( 13 , active0 ) ; return 14 ; } switch ( curChar ) { case 79 : return jjMoveStringLiteralDfa15_0 ( active0 , 10 ) ; default : break ; } return jjStartNfa_0 ( 13 , active0 ) ; }
te	1	public static float distanceBetween ( Creature t , Creature o2 ) { float x1 , x2 , y1 , y2 ; x1 = t . getX ( ) ; y1 = t . getY ( ) ; if ( o2 instanceof Ship ) { Ship s = ( Ship ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } else { Sprite s = ( Sprite ) o2 ; x2 = s . getX ( ) ; y2 = s . getY ( ) ; } return distanceBetween ( x1 , y1 , x2 , y2 ) ; }
te	8	public static Pair < Integer > traverse_spiral ( int cur_row , int cur_col , int square_len ) { int midpoint = ( square_len - 1 ) / 2 ; int next_col = cur_col ; int next_row = cur_row ; if ( cur_row == square_len / 2 && cur_col == midpoint ) { next_col = - 1 ; next_row = - 1 ; } else if ( cur_row <= midpoint ) { if ( cur_col < cur_row - 1 ) { next_row -- ; } else if ( cur_col < square_len - 1 - cur_row ) { next_col ++ ; } else if ( next_col != midpoint ) { next_row ++ ; } } else { if ( cur_col > cur_row ) { next_row ++ ; } else if ( cur_col > square_len - 1 - cur_row ) { next_col -- ; } else { next_row -- ; } } Pair < Integer > p = new Pair < Integer > ( next_row , next_col ) ; return p ; }
te	3	private void doPrint ( String s ) { for ( int newline = s . indexOf ( '' ) ; newline >= 0 ; newline = s . indexOf ( '' ) ) { if ( newline > 0 ) { indent ( ) ; writer . println ( protect ( s . substring ( 0 , newline ) ) ) ; } else { writer . println ( ) ; } begin_line = true ; s = s . substring ( newline + 1 ) ; } if ( s . length ( ) > 0 ) { indent ( ) ; writer . print ( protect ( s ) ) ; } }
te	4	private void findNextCodel ( Codel codel ) { int x = codel . x ; int y = codel . y ; DirectionPointer directionPointer = mMachine . getDirectionPointer ( ) ; if ( directionPointer . isRight ( ) ) { x += 1 ; } else if ( directionPointer . isBottom ( ) ) { y += 1 ; } else if ( directionPointer . isLeft ( ) ) { x -= 1 ; } else if ( directionPointer . isTop ( ) ) { y -= 1 ; } mNextCodel . set ( x , y ) ; }
te	7	public void connect2 ( TreeLinkNode root ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) return ; TreeLinkNode cur = root ; TreeLinkNode sibling ; TreeLinkNode next = null ; while ( cur != null && cur . left != null ) { next = cur . left ; while ( cur != null ) { if ( cur . next != null ) sibling = cur . next . left ; else sibling = null ; cur . left . next = cur . right ; cur . right . next = sibling ; cur = cur . next ; } cur = next ; } }
te	9X	private void handlePacket ( Command command ) throws ProtocolException { if ( command . getCommand ( ) . equals ( ClientProtocol . GAME ) ) { String arg0 = command . getArgument ( 0 ) ; int arg1 = Integer . parseInt ( command . getArgument ( 1 ) ) ; int arg2 = Integer . parseInt ( command . getArgument ( 2 ) ) ; if ( games . containsKey ( arg0 ) ) { games . remove ( arg0 ) ; } System . out . println ( arg0 + arg1 + arg2 ) ; games . put ( arg0 , new int [ ] { arg1 , arg2 } ) ; LobbyGUI . lobbyGUI . paintList ( ) ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . JOIN_GAME ) ) { if ( command . getArgument ( 0 ) . equals ( currentGame . getCreator ( ) . getUsername ( ) ) ) { currentGame . addPlayer ( user ) ; } } else if ( command . getCommand ( ) . equals ( ClientProtocol . START ) ) { currentGame = new ServerGame ( new HumanPlayer ( command . getArgument ( 0 ) ) ) ; if ( command . getArgumentCount ( ) >= 2 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 1 ) ) ) ; } if ( command . getArgumentCount ( ) >= 3 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 2 ) ) ) ; } if ( command . getArgumentCount ( ) == 4 ) { currentGame . addPlayer ( new HumanPlayer ( command . getArgument ( 3 ) ) ) ; } currentGame . start ( ) ; LobbyGUI . lobbyGUI . startGame ( ) ; currentGame . online = true ; currentGame . playerType = LobbyGUI . lobbyGUI . playerType ; int timeLimit ; try { timeLimit = Integer . parseInt ( LobbyGUI . lobbyGUI . textField . getText ( ) ) ; } catch ( NumberFormatException e ) { timeLimit = 0 ; } currentGame . timeLimit = timeLimit ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . MOVE_DONE ) ) { currentGame . turn = false ; int x = Integer . parseInt ( command . getArgument ( 1 ) ) , y = Integer . parseInt ( command . getArgument ( 2 ) ) ; currentGame . doMove ( x , y ) ; } else if ( command . getCommand ( ) . equals ( ClientProtocol . MOVE ) ) { synchronized ( currentGame ) { if ( currentGame . playerType . equals ( "Human" ) ) { currentGame . turn = true ; currentGame . gameGameGUI . paintComponents ( currentGame . board , true ) ; } else { currentGame . turnOnlineAI ( ) ; } } } }
te	1	public void buyGem ( Gem gem ) { if ( MagicPower . decrease ( gem ) ) { map . setGem ( gem ) ; } else listener . onError ( TDActionListener . NO_MP ) ; }
te	9X	public static String toString ( JSONArray ja ) throws JSONException { int i ; JSONObject jo ; String key ; Iterator keys ; int length ; Object object ; StringBuffer sb = new StringBuffer ( ) ; String tagName ; String value ; tagName = ja . getString ( 0 ) ; XML . noSpace ( tagName ) ; tagName = XML . escape ( tagName ) ; sb . append ( < ) ; sb . append ( tagName ) ; object = ja . opt ( 1 ) ; if ( object instanceof JSONObject ) { i = 2 ; jo = ( JSONObject ) object ; keys = jo . keys ( ) ; while ( keys . hasNext ( ) ) { key = keys . next ( ) . toString ( ) ; XML . noSpace ( key ) ; value = jo . optString ( key ) ; if ( value != null ) { sb . append (   ) ; sb . append ( XML . escape ( key ) ) ; sb . append ( = ) ; sb . append ( " ) ; sb . append ( XML . escape ( value ) ) ; sb . append ( " ) ; } } } else { i = 1 ; } length = ja . length ( ) ; if ( i >= length ) { sb . append ( / ) ; sb . append ( > ) ; } else { sb . append ( > ) ; do { object = ja . get ( i ) ; i += 1 ; if ( object != null ) { if ( object instanceof String ) { sb . append ( XML . escape ( object . toString ( ) ) ) ; } else if ( object instanceof JSONObject ) { sb . append ( toString ( ( JSONObject ) object ) ) ; } else if ( object instanceof JSONArray ) { sb . append ( toString ( ( JSONArray ) object ) ) ; } } } while ( i < length ) ; sb . append ( < ) ; sb . append ( / ) ; sb . append ( tagName ) ; sb . append ( > ) ; } return sb . toString ( ) ; }
te	0	@ Override public String getGrammarFileName ( ) { return "Enquanto.g4" ; }
te	8	@ Override public void marshal ( Element amdSec , Document doc ) { super . marshal ( amdSec , doc ) ; String metsNs = NS . METS . ns ( ) ; if ( this . techMD != null ) { for ( MdSec mds : this . techMD ) { Element techMD = doc . createElementNS ( metsNs , "mets:techMD" ) ; mds . marshal ( techMD , doc ) ; amdSec . appendChild ( techMD ) ; } } if ( this . rightsMD != null ) { for ( MdSec mds : this . rightsMD ) { Element rightsMD = doc . createElementNS ( metsNs , "mets:rightsMD" ) ; mds . marshal ( rightsMD , doc ) ; amdSec . appendChild ( rightsMD ) ; } } if ( this . sourceMD != null ) { for ( MdSec mds : this . sourceMD ) { Element sourceMD = doc . createElementNS ( metsNs , "mets:sourceMD" ) ; mds . marshal ( sourceMD , doc ) ; amdSec . appendChild ( sourceMD ) ; } } if ( this . digiprovMD != null ) { for ( MdSec mds : this . digiprovMD ) { Element digiprovMD = doc . createElementNS ( metsNs , "mets:digiprovMD" ) ; mds . marshal ( digiprovMD , doc ) ; amdSec . appendChild ( digiprovMD ) ; } } }
te	5	public void move ( ) { super . move ( ) ; if ( this . clock % 10 == 0 ) { if ( this . clock % 50 == 0 ) { this . angle = Math . PI * 3 / 2 ; } PlayerShip p = game . getPlayer ( ) ; double dFromPlayer = Math . sqrt ( Math . pow ( p . x - x , 2 ) + Math . pow ( p . y - y , 2 ) ) ; if ( dFromPlayer < 128 ) { this . angle = Math . PI * 3 / 2 ; this . velocity += 1.2 ; } } if ( game . t % 10 == 0 && game . random ( 0 , 1 , 1 ) == 1 ) { shoot ( Math . PI * 3 / 2 ) ; } }
te	3	@ Override public void process ( ) { String [ ] s = curDir . list ( stringS . getStringFilter ( ) . getFilenameFilter ( ) ) ; int cs = 0 , cf = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { String x = stringS . substitute ( s [ i ] ) ; String t = s [ i ] + " => " + x ; if ( ! isPreview ) t += new File ( curDir , s [ i ] ) . renameTo ( new File ( curDir , x ) ) ? " ok " + ++ cs : " fail " + ++ cf ; Print . ln ( t ) ; } Print . ln ( "Total " + s . length + " files  " + cs + " success  " + cf + " fail" ) ; }
te	8	private static boolean longestWordFromOtherWords2 ( HashMap < String , boolean > wordMap , boolean isOriginal , String word ) { String substring1 ; String substring2 ; if ( word == null || word . length ( ) == 0 ) { return false ; } else if ( wordMap . containsKey ( word ) && ! isOriginal ) { return wordMap . get ( word ) ; } else { int i ; for ( i = 1 ; i < word . length ( ) ; i ++ ) { substring1 = word . substring ( 0 , i ) ; substring2 = word . substring ( i ) ; if ( wordMap . containsKey ( substring1 ) && wordMap . get ( substring1 ) == true && longestWordFromOtherWords2 ( wordMap , false , substring2 ) ) { return true ; } } wordMap . put ( word , false ) ; return false ; } }
te	1	private void checkLevel ( ) { if ( Console . getDebugMode ( ) ) setLevel ( Level . ALL ) ; else setLevel ( Level . INFO ) ; }
te	0	public TasquesPendents ( String any , IClient client ) { this . client = client ; this . any = any ; initialize ( ) ; }
te	4	@ Override public Node compile ( ) { boolean fc = first instanceof Comment ; boolean sc = second instanceof Comment ; if ( fc && sc ) return new Comment ( "Cannot compile this." ) ; if ( fc ) return second . compile ( ) ; if ( sc ) return first . compile ( ) ; return new Block ( first . compile ( ) , second . compile ( ) ) ; }
te	4	private static Node < Integer > partitionList2 ( Node < Integer > node , int x ) { Node < Integer > before = null ; Node < Integer > after = null ; while ( node != null ) { Node < Integer > next = node . getNext ( ) ; if ( node . getData ( ) < x ) { node . setNext ( before ) ; before = node ; } else { node . setNext ( after ) ; after = node ; } node = next ; } if ( before == null ) { return after ; } Node < Integer > head = before ; while ( before . getNext ( ) != null ) { before = before . getNext ( ) ; } before . setNext ( after ) ; return head ; }
te	0	private byte [ ] toBytes ( String s ) { return s . getBytes ( ) ; }
te	7	private void reflectClassWrapper ( Map < Type , Set < GeneTrait >> genePool , String className , int parameterCount , List < String > parameterTypes , int parametersSet ) throws ClassNotFoundException { if ( parametersSet < parameterCount ) { for ( BreedingClassSetup classSetup : Settings . getSettings ( ) . getClasses ( ) ) { if ( ! rawTypesClassMap . containsKey ( classSetup . className ) ) { if ( parameterTypes . size ( ) >= parametersSet + 1 ) { parameterTypes . remove ( parametersSet ) ; } parameterTypes . add ( parametersSet , classSetup . className ) ; reflectClassWrapper ( genePool , className , parameterCount , parameterTypes , parametersSet + 1 ) ; } } } else { class < ? > clazz = rawTypesClassMap . get ( className ) ; if ( clazz == null ) { clazz = class . forName ( className ) ; } Type classType = Type . getType ( className + ( ( parameterCount == 0 ) ? "" : ( "<" + Tools . implode ( parameterTypes , " " ) + ">" ) ) ) ; reflectClass ( genePool , clazz , className , classType , parameterTypes ) ; } }
te	3	private static < T > void removeDuplicatesBuffer ( Node < T > list ) { if ( list == null ) { throw new IllegalArgumentException ( ) ; } Set < T > unique = new HashSet < T > ( ) ; unique . add ( list . getData ( ) ) ; while ( list . getNext ( ) != null ) { Node < T > current = list ; while ( unique . contains ( current . getNext ( ) . getData ( ) ) ) { current = current . getNext ( ) ; } unique . add ( current . getNext ( ) . getData ( ) ) ; list . setNext ( current . getNext ( ) ) ; list = list . getNext ( ) ; } }
te	0	public static void sort ( Comparable [ ] array ) { }
te	3	public void updateUser ( User user ) { Session session = null ; try { session = HibernateUtil . getSessionFactory ( ) . openSession ( ) ; session . beginTransaction ( ) ; session . update ( user ) ; session . getTransaction ( ) . commit ( ) ; } catch ( Exception e ) { System . err . println ( "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0432\u0441\u0442\u0430\u0432\u043A\u0435" + e . getMessage ( ) ) ; } finally { if ( session != null && session . isOpen ( ) ) { session . close ( ) ; } } }
te	7	private boolean isRowEmpty ( int rowIndex ) { if ( rowIndex < getRowCount ( ) - 1 ) { return ( ( participantList . get ( rowIndex ) . getFirstName ( ) == null || participantList . get ( rowIndex ) . getFirstName ( ) . trim ( ) . equals ( "" ) ) && ( participantList . get ( rowIndex ) . getLastName ( ) == null || participantList . get ( rowIndex ) . getLastName ( ) . trim ( ) . equals ( "" ) ) ) ; } else { return ( ( lastRow . getFirstName ( ) == null || lastRow . getFirstName ( ) . trim ( ) . equals ( "" ) ) && ( lastRow . getLastName ( ) == null || lastRow . getLastName ( ) . trim ( ) . equals ( "" ) ) ) ; } }
te	5	private static int decode ( String rgb , int start , int end ) { try { final int len = rgb . length ( ) ; if ( start >= len ) return 0 ; if ( end >= len ) end = len ; final int v = Integer . parseInt ( rgb . substring ( start , end ) , 16 ) ; return v > 255 ? 255 : v < 0 ? 0 : v ; } catch ( NumberFormatException ex ) { return 0 ; } }
te	8	public static String query ( int table_id , String str , int start_index , int max_fetch ) throws Exception { JSONObject result = new JSONObject ( ) ; JSONArray entry_list = new JSONArray ( ) ; Map temp = new LinkedHashMap ( ) ; int max_count , count ; int maxCount [ ] = new int [ 6 ] ; Connection Con = global . getConnection ( ) ; switch ( table_id ) { case 0 : { entry_list . clear ( ) ; start_index /= 6 ; max_fetch /= 6 ; maxCount [ 0 ] = Course . getResultCount ( Con , str ) ; maxCount [ 1 ] = Student . getResultCount ( Con , str ) ; maxCount [ 2 ] = Instructor . getResultCount ( Con , str ) ; maxCount [ 3 ] = Work . getResultCount ( Con , str ) ; maxCount [ 4 ] = Project . getResultCount ( Con , str ) ; maxCount [ 5 ] = Post . getResultCount ( Con , str ) ; max_count = 0 ; SortedSet < Pair > set = new TreeSet < Pair > ( ) ; for ( int ii = 0 ; ii < 6 ; ii ++ ) { set . add ( new Pair ( ii , maxCount [ ii ] ) ) ; max_count += maxCount [ ii ] ; } addResults ( entry_list , set , Con , str , start_index , max_fetch ) ; break ; } case 1 : { entry_list = Course . Query ( Con , str , start_index , max_fetch ) ; max_count = Course . getResultCount ( Con , str ) ; break ; } case 2 : { entry_list = Student . Query ( Con , str , start_index , max_fetch ) ; max_count = Student . getResultCount ( Con , str ) ; break ; } case 3 : { entry_list = Instructor . Query ( Con , str , start_index , max_fetch ) ; max_count = Instructor . getResultCount ( Con , str ) ; break ; } case 4 : { entry_list = Project . Query ( Con , str , start_index , max_fetch ) ; max_count = Project . getResultCount ( Con , str ) ; break ; } case 5 : { entry_list = Work . Query ( Con , str , start_index , max_fetch ) ; max_count = Work . getResultCount ( Con , str ) ; break ; } case 6 : { entry_list = Post . Query ( Con , str , start_index , max_fetch ) ; max_count = Post . getResultCount ( Con , str ) ; break ; } default : { max_count = 0 ; break ; } } count = entry_list . size ( ) ; temp . put ( "max_count" , max_count ) ; temp . put ( "count" , count ) ; temp . put ( "entries" , entry_list ) ; result . put ( "results" , temp ) ; Con . close ( ) ; return result . toJSONString ( ) ; }
te	3	private boolean r_reflexive ( ) { int among_var ; ket = cursor ; among_var = find_among_b ( a_3 , 2 ) ; if ( among_var == 0 ) { return false ; } bra = cursor ; switch ( among_var ) { case 0 : return false ; case 1 : slice_del ( ) ; break ; } return true ; }
te	0	public void serviceRemoved ( ServiceEvent event ) { synchronized ( infos ) { infos . remove ( event . getName ( ) ) ; } }
te	0	public int getCodigo ( ) { return codigo ; }
te	7	boolean testAndSet ( Obstacle obs ) { if ( isDirty ) return false ; if ( excludedObstacles . contains ( obs ) ) return false ; Segment seg1 = new Segment ( obs . topLeft , obs . bottomRight ) ; Segment seg2 = new Segment ( obs . topRight , obs . bottomLeft ) ; for ( int s = 0 ; s < points . size ( ) - 1 ; s ++ ) { points . getPoint ( CURRENT , s ) ; points . getPoint ( NEXT , s + 1 ) ; if ( seg1 . intersects ( CURRENT , NEXT ) || seg2 . intersects ( CURRENT , NEXT ) || obs . contains ( CURRENT ) || obs . contains ( NEXT ) ) { isDirty = true ; return true ; } } return false ; }
te	7	public ArrayList < UserProfile > fetchAllProfiles ( ) throws SQLConnectionException , SQLQueryException { ArrayList < UserProfile > profiles = new ArrayList < UserProfile > ( ) ; Statement st ; try { st = dbCon . createStatement ( ) ; } catch ( SQLException e ) { if ( dbCon != null ) try { dbCon . close ( ) ; } catch ( SQLException e2 ) { e2 . printStackTrace ( ) ; } throw new SQLConnectionException ( e ) ; } finally { } ResultSet rs ; try { rs = st . executeQuery ( "SELECT rowid  name FROM userprofile" ) ; } catch ( SQLException e ) { throw new SQLQueryException ( e ) ; } try { while ( rs . next ( ) ) { UserProfile up = new UserProfile ( rs . getInt ( "rowid" ) , rs . getString ( "name" ) ) ; profiles . add ( up ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } try { st . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return profiles ; }
te	0	@ Override public boolean setPacketFields ( Map < String , Object > in ) { return true ; }
te	4	public Type parse ( int i ) { switch ( i ) { case 1 : return HASHTAG ; case 2 : return USER ; case 3 : return EMOTICON ; case 4 : return URL ; } return OTHER ; }
te	1	protected ASTNode maybeWrapInTerm ( ASTNode node ) { if ( node . getNodeCount ( ) == 1 ) { return node ; } return new TermNode ( node ) ; }
te	9X	public void renderTile ( int plane , int x , int y , int clippingPath , int clippingPathRotation , int textureId , int vertexHeightSW , int vertexHeightSE , int vertexHeightNE , int vertexHeightNW , int k2 , int l2 , int i3 , int j3 , int k3 , int l3 , int i4 , int j4 , int k4 , int l4 ) { if ( clippingPath == 0 ) { PlainTile tile = new PlainTile ( k2 , l2 , j3 , i3 , k4 , - 1 , false ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } if ( clippingPath == 1 ) { PlainTile tile = new PlainTile ( k3 , l3 , j4 , i4 , l4 , textureId , vertexHeightSW == vertexHeightSE && vertexHeightSW == vertexHeightNE && vertexHeightSW == vertexHeightNW ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . plainTile = tile ; return ; } ShapedTile tile = new ShapedTile ( x , vertexHeightSW , vertexHeightSE , vertexHeightNW , vertexHeightNE , y , clippingPathRotation , textureId , clippingPath , k2 , k3 , l2 , l3 , j3 , j4 , i3 , i4 , l4 , k4 ) ; for ( int _z = plane ; _z >= 0 ; _z -- ) if ( groundArray [ _z ] [ x ] [ y ] == null ) groundArray [ _z ] [ x ] [ y ] = new Ground ( _z , x , y ) ; groundArray [ plane ] [ x ] [ y ] . shapedTile = tile ; }
te	7	public Response multPartURL ( String url , PostParameter [ ] params , ImageItem item , boolean authenticated ) throws WeiboException { PostMethod post = new PostMethod ( url ) ; try { org . apache . commons . httpclient . HttpClient client = getHttpClient ( ) ; long t = System . currentTimeMillis ( ) ; Part [ ] parts = null ; if ( params == null ) { parts = new Part [ 1 ] ; } else { parts = new Part [ params . length + 1 ] ; } if ( params != null ) { int i = 0 ; for ( PostParameter entry : params ) { parts [ i ++ ] = new StringPart ( entry . getName ( ) , ( String ) entry . getValue ( ) ) ; } parts [ parts . length - 1 ] = new ByteArrayPart ( item . getContent ( ) , item . getName ( ) , item . getContentType ( ) ) ; } post . setRequestEntity ( new MultipartRequestEntity ( parts , post . getParams ( ) ) ) ; List < Header > headers = new ArrayList < Header > ( ) ; if ( authenticated ) { if ( oauth == null ) { } String authorization = null ; if ( null != oauth ) { authorization = oauth . generateAuthorizationHeader ( "POST" , url , params , oauthToken ) ; } else { throw new IllegalStateException ( "Neither user ID/password combination nor OAuth consumer key/secret combination supplied" ) ; } headers . add ( new Header ( "Authorization" , authorization ) ) ; log ( "Authorization: " + authorization ) ; } client . getHostConfiguration ( ) . getParams ( ) . setParameter ( "http.default-headers" , headers ) ; client . executeMethod ( post ) ; Response response = new Response ( ) ; response . setResponseAsString ( post . getResponseBodyAsString ( ) ) ; response . setStatusCode ( post . getStatusCode ( ) ) ; log ( "multPartURL URL:" + url + "  result:" + response + "  time:" + ( System . currentTimeMillis ( ) - t ) ) ; return response ; } catch ( Exception ex ) { throw new WeiboException ( ex . getMessage ( ) , ex , - 1 ) ; } finally { post . releaseConnection ( ) ; } }
te	9X	public Subscription ( Socket in_sock , iKPIC_subscribeHandler2 hand ) { final iKPIC_subscribeHandler2 f_eh = hand ; final Socket ft_kpSocket = in_sock ; InputStream reader = null ; try { reader = in_sock . getInputStream ( ) ; } catch ( IOException e2 ) { e2 . printStackTrace ( ) ; } final BufferedReader ft_in = new BufferedReader ( new InputStreamReader ( reader ) ) ; System . out . println ( "Subscription: going to start thread" ) ; Thread eventThread = new Thread ( ) { public void run ( ) { SSAP_XMLTools xmlTools = new SSAP_XMLTools ( null , null , null ) ; String msg_event = "" ; String restOfTheMessage = "" ; int buffsize = 4 * 1024 ; StringBuilder builder = new StringBuilder ( ) ; char [ ] buffer = new char [ buffsize ] ; int charRead = 0 ; try { while ( ( ( charRead = ft_in . read ( buffer , 0 , buffer . length ) ) != ( - 1 ) ) || ( ! restOfTheMessage . isEmpty ( ) ) ) { if ( ! restOfTheMessage . equals ( "" ) ) { builder . append ( restOfTheMessage ) ; restOfTheMessage = "" ; } if ( charRead != - 1 ) { builder . append ( buffer , 0 , charRead ) ; } msg_event = builder . toString ( ) ; if ( msg_event . contains ( "<SSAP_message>" ) && msg_event . contains ( "</SSAP_message>" ) ) { int index = msg_event . indexOf ( "</SSAP_message>" ) + 15 ; restOfTheMessage = msg_event . substring ( index ) ; msg_event = msg_event . substring ( 0 , index ) ; String subID = xmlTools . getSubscriptionID ( msg_event ) ; if ( xmlTools . isUnSubscriptionConfirmed ( msg_event ) ) { f_eh . kpic_UnsubscribeEventHandler ( subID ) ; return ; } else { String indSequence = xmlTools . getSSAPmsgIndicationSequence ( msg_event ) ; if ( xmlTools . isRDFNotification ( msg_event ) ) { Vector < Vector < String >> triples_n = new Vector < Vector < String >> ( ) ; triples_n = xmlTools . getNewResultEventTriple ( msg_event ) ; Vector < Vector < String >> triples_o = new Vector < Vector < String >> ( ) ; triples_o = xmlTools . getObsoleteResultEventTriple ( msg_event ) ; f_eh . kpic_RDFEventHandler ( triples_n , triples_o , indSequence , subID ) ; } else { SSAP_sparql_response resp_new = xmlTools . get_SPARQL_indication_new_results ( msg_event ) ; SSAP_sparql_response resp_old = xmlTools . get_SPARQL_indication_obsolete_results ( msg_event ) ; f_eh . kpic_SPARQLEventHandler ( resp_new , resp_old , indSequence , subID ) ; } if ( restOfTheMessage . contains ( "<SSAP_message>" ) && restOfTheMessage . contains ( "</SSAP_message>" ) ) { String test = restOfTheMessage . substring ( 0 , restOfTheMessage . indexOf ( "</SSAP_message>" ) + 15 ) ; if ( xmlTools . isUnSubscriptionConfirmed ( test ) ) { System . out . println ( "I should never print this please check" ) ; return ; } } buffer = new char [ buffsize ] ; charRead = 0 ; msg_event = "" ; builder = new StringBuilder ( ) ; } } } try { System . out . println ( "I should not go here untili unsubscribe" ) ; ft_in . close ( ) ; ft_kpSocket . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; f_eh . kpic_ExceptionEventHandler ( e ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; f_eh . kpic_ExceptionEventHandler ( e ) ; } } } ; eventThread . start ( ) ; }
te	0	public String getImage0 ( ) { return image0 ; }
te	9X	public String getString ( int id , int language ) throws IOException { if ( id == 0 ) return null ; if ( id < 0 || id > ff ) throw new IllegalArgumentException ( ) ; if ( ! checkedStrings ) getLanguages ( ) ; if ( languages == null || languages . length == 0 ) return null ; byte key = new byte ( ( byte ) id ) ; String retval = null ; if ( stringCache == null ) { synchronized ( lock ) { if ( stringCache == null ) { cachedLanguage = language ; stringCache = new Hashtable ( 7 ) ; } } } else if ( stringCache . containsKey ( key ) ) { Object value = stringCache . get ( key ) ; if ( value instanceof String ) return ( String ) value ; else return null ; } retval = ControlMessage . getString ( this , ( byte ) id , language ) ; if ( retval == null ) stringCache . put ( key , boolean . false ) ; else stringCache . put ( key , retval ) ; return retval ; }
te	8	public boolean execute ( CommandSender sender , String [ ] args ) { String groupName = args [ 0 ] ; GroupManager groupManager = Citadel . getGroupManager ( ) ; Faction group = groupManager . getGroup ( groupName ) ; if ( group == null ) { sendMessage ( sender , ChatColor . RED , "Group doesn't exist" ) ; return true ; } String senderName = sender . getName ( ) ; if ( ! group . isFounder ( senderName ) && ! group . isModerator ( senderName ) && ! group . isMember ( senderName ) ) { sendMessage ( sender , ChatColor . RED , "Invalid permission to access this group" ) ; return true ; } sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cGroup Name:\u00A7e " ) . append ( groupName ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cOwner:\u00A7e " ) . append ( group . getFounder ( ) ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cModerators:\u00A7e " ) . append ( groupManager . getModeratorsOfGroup ( groupName ) . size ( ) ) . toString ( ) ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cMembers:\u00A7e " ) . append ( groupManager . getMembersOfGroup ( groupName ) . size ( ) ) . toString ( ) ) ; if ( group . isFounder ( senderName ) || group . isModerator ( senderName ) ) { String password = group . getPassword ( ) ; sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cPassword:\u00A7e " ) . append ( password ) . toString ( ) ) ; String joinable = "" ; if ( password != null && ! password . equalsIgnoreCase ( "null" ) ) { joinable = "Yes" ; } else { joinable = "No" ; } sender . sendMessage ( new StringBuilder ( ) . append ( "\u00A7cJoinable:\u00A7e " ) . append ( joinable ) . toString ( ) ) ; } return true ; }
te	4	@ Override public void input ( float delta ) { float movAmt = speed * delta ; if ( Input . getKey ( leftKey ) ) move ( getTransform ( ) . getRot ( ) . getLeft ( ) , movAmt ) ; if ( Input . getKey ( rightKey ) ) move ( getTransform ( ) . getRot ( ) . getRight ( ) , movAmt ) ; if ( Input . getKey ( downKey ) ) move ( getTransform ( ) . getRot ( ) . getUp ( ) , - movAmt ) ; else if ( Input . getKey ( upKey ) ) move ( getTransform ( ) . getRot ( ) . getUp ( ) , movAmt ) ; }
te	4	public CombIterator ( final Map < ? extends K , ? extends Iterable < ? extends V >> origin ) throws NullPointerException , IllegalArgumentException { this . iterators = new HashMap < > ( origin . size ( ) ) ; this . template = new LinkedHashMap < > ( origin . size ( ) ) ; for ( final K key : origin . keySet ( ) ) { resume ( key , origin . get ( key ) . iterator ( ) ) ; } this . origin = origin ; }
te	4	public Builder touPricing ( String [ ] froms , String [ ] tos , double [ ] prices ) { if ( ! type . equals ( "TOUPricing" ) ) { System . err . println ( "PricingPolicy type mismatch: method only applicable to the TOUPricing scheme" ) ; return this ; } if ( ! ( froms . length == tos . length && tos . length == prices . length ) ) { System . err . println ( "PricingPolicy initialization error: all input tables must have the same length" ) ; return this ; } for ( int i = 0 ; i < froms . length ; i ++ ) { String from = froms [ i ] ; String to = tos [ i ] ; double price = prices [ i ] ; Period p = new Period ( from , to , price ) ; periods . add ( p ) ; } return this ; }
te	6	@ Override public void done ( ) { try { try { socket = get ( ) ; parent . updateStatus ( "Connected!" ) ; parent . parentFrame . addTab ( socket , parent . getNickname ( ) ) ; parent . dispose ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } catch ( java . util . concurrent . CancellationException e ) { closeSocket ( ) ; parent . updateStatus ( "Cancelled." ) ; } catch ( java . util . concurrent . ExecutionException e ) { closeSocket ( ) ; String why = null ; Throwable cause = e . getCause ( ) ; if ( cause != null ) { why = cause . getMessage ( ) ; if ( cause instanceof UnknownHostException ) { why = "Unknown host " + why ; } else if ( cause instanceof SocketTimeoutException ) { why = "Connection timed out" ; } } else { why = e . getMessage ( ) ; } parent . updateStatus ( why ) ; } finally { connectButton . setEnabled ( true ) ; } }
te	5	@ Override public boolean equals ( Object o ) { return o != null && o . getClass ( ) . equals ( this . getClass ( ) ) && ( ( ( ( EduAVLTree ) o ) . root == null && this . root == null ) || ( this . root != null && this . root . equals ( ( ( EduAVLTree ) o ) . root ) ) ) ; }
te	1	@ Override protected void put ( Message request , Message response ) { request . put ( Document . ID , request . get ( Vote . ID ) ) ; Message origVote = new Message ( request . getContext ( ) ) ; new PersistentDocumentService ( ) . doGet ( request , origVote ) ; Message updateReq = new Message ( request . getContext ( ) ) ; updateReq . putAllFields ( origVote . getFields ( ) ) ; updateReq . putAllReferences ( origVote . getReferences ( ) ) ; updateReq . put ( Vote . VOTE , request . get ( Vote . VOTE ) ) ; new PersistentDocumentService ( ) . doPut ( updateReq , response ) ; new AnswerService ( ) . doPut ( request , response ) ; if ( request . get ( Vote . VOTE ) . equals ( Vote . VOTE_UP ) ) { Message answerResponse = new Message ( request . getContext ( ) ) ; new AnswerService ( ) . doGet ( request , answerResponse ) ; request . put ( Profile . ID , answerResponse . get ( Document . AUTHOR ) ) ; request . put ( Profile . POINTS , "" + Vote . POINTS_FOR_VOTE_UP ) ; new ProfileService ( ) . doPut ( request , response ) ; } }
te	1	public void print ( Node node ) { if ( node != null ) { System . out . print ( node . value + " " ) ; print ( node . next ) ; } else { System . out . println ( ) ; } }
te	5	@ Override public Point getTarget ( GameState state ) { float [ ] [ ] candidates = new float [ 3 ] [ 5 ] ; Point target = null ; int i = 0 ; for ( TargetingStrategy strategy : strategies ) { target = strategy . getTarget ( state ) ; if ( target != null ) { candidates [ target . x ] [ target . y ] += weights [ i ] ; } ++ i ; } float greatest = 0f ; target = null ; for ( int x = 0 ; x < 3 ; x ++ ) { for ( int y = 0 ; y < 5 ; y ++ ) { if ( candidates [ x ] [ y ] > greatest ) { target = new Point ( x , y ) ; greatest = candidates [ x ] [ y ] ; } } } return target ; }
te	7	public synchronized void nextGeneration ( ) { generation ++ ; Arrays . fill ( tmp , 0 ) ; for ( int x = 0 ; x < maxx ; ++ x ) { int xminor = ( x + maxx - 1 ) % maxx ; int xmajor = ( x + 1 ) % maxx ; for ( int y = 0 ; y < maxy ; ++ y ) { int yminor = ( y + maxy - 1 ) % maxy ; int ymajor = ( y + 1 ) % maxy ; int here = maxx * y + x ; int neighbors = f ( grid [ maxx * yminor + xminor ] ) + f ( grid [ maxx * yminor + x ] ) + f ( grid [ maxx * yminor + xmajor ] ) + f ( grid [ maxx * y + xminor ] ) + f ( grid [ maxx * y + xmajor ] ) + f ( grid [ maxx * ymajor + xminor ] ) + f ( grid [ maxx * ymajor + x ] ) + f ( grid [ maxx * ymajor + xmajor ] ) ; if ( grid [ here ] > 0 ) { if ( neighbors < 2 ) { tmp [ here ] = 0 ; } else if ( neighbors == 2 || neighbors == 3 ) { tmp [ here ] = grid [ here ] + 1 ; } else { tmp [ here ] = 0 ; } } else { if ( neighbors == 3 ) { tmp [ here ] = 1 ; } } } } int [ ] t = grid ; grid = tmp ; tmp = t ; }
te	8	public static ArrayList < Player > getEnemies ( Player player ) { ArrayList < Player > emenies = new ArrayList < Player > ( ) ; if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( BLUE ) ) && Teams . getPlayersOfTeam ( BLUE ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( BLUE ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( GREEN ) ) && Teams . getPlayersOfTeam ( GREEN ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( GREEN ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( ORANGE ) ) && Teams . getPlayersOfTeam ( ORANGE ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( ORANGE ) ) ; } if ( ! getTeamFriends ( Teams . getTeamOfPlayer ( player ) ) . contains ( Teams . getPlayersOfTeam ( RED ) ) && Teams . getPlayersOfTeam ( RED ) != null ) { emenies . add ( Teams . getPlayersOfTeam ( RED ) ) ; } return emenies ; }
te	5	static private Vector < double [ ] > sampleResults ( Vector < Future < Vector < double [ ] >>> results , int bins ) throws Exception { int nDescriptors = results . get ( 0 ) . get ( ) . get ( 0 ) . length ; System . out . println ( "Printing for " + nDescriptors + " descriptors" ) ; Vector < double [ ] > descriptors = new Vector < double [ ] > ( nDescriptors ) ; for ( int d = 0 ; d < nDescriptors ; ++ d ) { double [ ] averages = new double [ bins ] ; for ( Future < Vector < double [ ] >> result : results ) { Vector < double [ ] > samples = result . get ( ) ; int samplesPerBin = samples . size ( ) / bins ; for ( int b = 0 ; b < bins ; ++ b ) { double sum = 0 ; int counted = 0 ; for ( int s = 0 ; s < samplesPerBin && b * samplesPerBin + s < samples . size ( ) ; ++ s ) { sum += samples . get ( b * samplesPerBin + s ) [ d ] ; counted += 1 ; } averages [ b ] = sum / counted ; } } descriptors . add ( averages ) ; } return descriptors ; }
te	6	private String getIndexText ( int index , int colour ) { assert ( colour == PL_WHITE || colour == PL_BLACK ) ; assert ( index >= 0 && index <= 15 ) ; String result = "" ; result += col_text [ index % 8 ] ; if ( colour == PL_WHITE ) { result += ( index <= 7 ) ? "2" : "1" ; } if ( colour == PL_BLACK ) { result += ( index <= 7 ) ? "7" : "8" ; } return result ; }
te	2	private Viability initiateViability ( File habitatFolder ) throws IOException , InterruptedException { File viabilityCSV = new File ( habitatFolder . getPath ( ) + File . separatorChar + VIABILITY ) ; if ( ! viabilityCSV . exists ( ) || ! viabilityCSV . isFile ( ) ) throw new FileDoesntExist ( habitatFolder . getPath ( ) + File . separatorChar + VIABILITY , "but file with parameters of viability is strongly required" ) ; String fileContent = getFullFileContent ( viabilityCSV ) ; String preparedContent = preparer . getPreparedContent ( fileContent , ViabilityReader . INPUT_AREA ) ; saver . saveForCurrentPoint ( habitatFolder . getName ( ) , VIABILITY , preparedContent ) ; return new ViabilityReader ( preparedContent ) . getViability ( ) ; }
te	0	public String getName ( ) { return getClass ( ) . getName ( ) ; }
te	6	private static int computeLongestCycle ( String string ) { final int length = string . length ( ) ; int maxcycle = 0 ; int i = 0 ; char [ ] chars = string . toCharArray ( ) ; for ( i = 0 ; i < length ; i ++ ) { boolean same = true ; char first = chars [ i ] ; int cycle = 0 ; for ( int j = i + 1 ; j < string . length ( ) ; j ++ ) { if ( chars [ j ] != first ) { same = false ; } else { final int l = ( j - i ) ; final boolean ok = equals ( chars , i , i + l , l ) ; if ( ok ) { cycle = l ; break ; } } } if ( same ) { cycle = 1 ; } if ( cycle > maxcycle ) { maxcycle = cycle ; } } return maxcycle ; }
te	9X	private Objective loadObjective ( TagCompound tag ) { try { TagBase tbname = tag . getTag ( "name" ) ; if ( ! ( tbname instanceof TagString ) ) return null ; TagBase tbtarget = tag . getTag ( "target" ) ; if ( ! ( tbtarget instanceof TagString ) ) return null ; TagBase tbtypes = tag . getTag ( "type" ) ; if ( ! ( tbtypes instanceof TagString ) ) return null ; ObjectiveType t = QuestManager . getInstance ( ) . getRegisteredObjectiveType ( ( ( TagString ) tbtypes ) . data ) ; if ( t == null ) return null ; Objective o = new Objective ( tag . getName ( ) , ( ( TagString ) tbname ) . data , t , ( ( TagString ) tbtarget ) . data ) ; TagBase tbicoid = tag . getTag ( "iconid" ) ; if ( tbicoid instanceof TagInt ) o . setItemIconId ( ( ( TagInt ) tbicoid ) . data ) ; TagBase tbopt = tag . getTag ( "optional" ) ; if ( tbopt instanceof TagByte ) o . setOptional ( ( ( TagByte ) tbopt ) . data == 1 ) ; TagBase tbvis = tag . getTag ( "visible" ) ; if ( tbvis instanceof TagByte ) o . setVisible ( ( ( TagByte ) tbvis ) . data == 1 ) ; TagBase rewards = tag . getTag ( "rewards" ) ; if ( rewards instanceof TagList ) { for ( TagBase b : ( ( TagList ) rewards ) . get ( ) ) { if ( b instanceof TagCompound ) { QuestAction a = loadAction ( ( TagCompound ) b ) ; if ( a != null ) o . addReward ( a ) ; } } } TagBase desc = tag . getTag ( "description" ) ; ArrayList < String > dsc = new ArrayList < String > ( ) ; if ( desc instanceof TagList ) { for ( TagBase b : ( ( TagList ) desc ) . get ( ) ) { if ( b instanceof TagString ) { dsc . add ( ( ( TagString ) b ) . data ) ; } } } o . setDescription ( dsc ) ; return o ; } catch ( IllegalArgumentException iae ) { return null ; } }
te	2	@ Override public void put ( Point point , double value ) { if ( value != 0.5 ) cells . put ( point , value ) ; else if ( cells . containsKey ( point ) ) { cells . remove ( point ) ; } }
te	1	public static synchronized SondageDao getInstance ( ) { if ( instance == null ) instance = new SondageDao ( ) ; return instance ; }
te	1	public void restoreDecks ( ) { int k = OPEN_DECK_SIZE - open_deck . size ( ) ; if ( deck . size ( ) < k ) { deck . addAll ( discarded ) ; discardeds . push ( discarded ) ; discarded = new CardBag ( ) ; } else { discardeds . push ( null ) ; } CardBag cs = deck . draw ( k , random ) ; deck_restorations . push ( cs ) ; open_deck . addAll ( cs ) ; }
te	1	public static String translate ( String fieldname ) { if ( fieldname == null ) fieldname = "" ; String key = String . format ( "Field.%s" , fieldname . toLowerCase ( ) ) ; String name = properties . getProperty ( key , fieldname ) ; return name ; }
te	9X	public static int heading ( double longFrom , double latFrom , double longTo , double latTo ) { double latDiff = latTo - latFrom ; double longDiff = longTo - longFrom ; latDiff *= 110828.28 ; longDiff *= 97862.52 ; double angle ; int quadrant ; if ( longDiff == 0 ) angle = 0 ; else { if ( latDiff < 0 && longDiff < 0 ) quadrant = 3 ; else if ( latDiff < 0 && longDiff > 0 ) quadrant = 2 ; else if ( latDiff >= 0 && longDiff < 0 ) quadrant = 4 ; else quadrant = 1 ; latDiff = Math . abs ( latDiff ) ; longDiff = Math . abs ( longDiff ) ; angle = Math . atan ( latDiff / longDiff ) ; angle *= 180 / ( Math . PI ) ; switch ( quadrant ) { case 1 : angle = 90 - angle ; break ; case 2 : angle = 90 + angle ; break ; case 3 : angle = 270 - angle ; break ; case 4 : angle = 270 + angle ; break ; } } return ( int ) angle ; }
te	4	@ Override Pizza createPizza ( String type ) { Pizza pizza = null ; ChicagoPizzaIngredientFactory ingredientFactory = new ChicagoPizzaIngredientFactory ( ) ; if ( type . equals ( "cheese" ) ) { pizza = new ChicagoStyleCheesePizza ( ingredientFactory ) ; } else if ( type . equals ( "pepperoni" ) ) { pizza = new ChicagoStylePepperoniPizza ( ingredientFactory ) ; } else if ( type . equals ( "clam" ) ) { pizza = new ChicagoStyleClamPizza ( ingredientFactory ) ; } else if ( type . equals ( "veggie" ) ) { pizza = new ChicagoStyleVegglePizza ( ingredientFactory ) ; } return pizza ; }
te	0	public Response delete ( String url , boolean authenticated ) throws WeiboException { return httpRequest ( url , null , authenticated , "DELETE" ) ; }
te	1	@ Override public void paint ( Graphics g ) { Graphics2D g2d = ( Graphics2D ) g ; if ( image != null ) { synchronized ( image ) { g2d . setRenderingHint ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_SPEED ) ; g2d . drawImage ( image , 0 , 0 , null ) ; } } else { super . paint ( g2d ) ; } }
te	4	private void reHeapify ( ArrayList < Step > steps ) { int size = heapValues . length - 1 ; int child = 2 ; while ( child <= size ) { if ( ( child < size ) && ( heapValues [ child ] < heapValues [ child + 1 ] ) ) child ++ ; steps . ensureCapacity ( steps . size ( ) + 1 ) ; steps . add ( new ArrayHeapCompareStep ( arrayValues . clone ( ) , heapValues . clone ( ) , orderedCount , child , child / 2 ) ) ; if ( heapValues [ child / 2 ] > heapValues [ child ] ) break ; byte temp = heapValues [ child / 2 ] ; heapValues [ child / 2 ] = heapValues [ child ] ; heapValues [ child ] = temp ; arrayValues [ child / 2 ] = heapValues [ child / 2 ] ; arrayValues [ child ] = heapValues [ child ] ; steps . ensureCapacity ( steps . size ( ) + 1 ) ; steps . add ( new ArrayHeapSwapStep ( arrayValues . clone ( ) , heapValues . clone ( ) , orderedCount , child , child / 2 ) ) ; child *= 2 ; } }
te	6	@ Override public byte [ ] post ( HttpExchange he ) { if ( ! this . getContext ( ) . getSessionManager ( ) . isAuthorised ( he ) ) { return new byte [ 0 ] ; } WebUser wu = this . getContext ( ) . getSessionManager ( ) . getWebUser ( he . getRemoteAddress ( ) . getAddress ( ) ) ; OfflinePlayer offlinePlayer = this . getContext ( ) . getPlugin ( ) . getServer ( ) . getOfflinePlayer ( wu . getUsername ( ) ) ; if ( offlinePlayer == null || ( ! ( offlinePlayer . isOp ( ) ) ) ) { return new byte [ 0 ] ; } String postParams ; try ( InputStreamReader inStream = new InputStreamReader ( he . getRequestBody ( ) ) ) { try ( BufferedReader bufferedReader = new BufferedReader ( inStream ) ) { postParams = bufferedReader . readLine ( ) ; } } catch ( IOException ex ) { Logger . getLogger ( RequestHandler . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; return new byte [ 0 ] ; } Map < String , String > vars = parsePostResponse ( postParams ) ; String add = vars . get ( "addPlayers" ) ; String rem = vars . get ( "removePlayers" ) ; if ( add != null ) { return addToWhitelist ( add ) ; } if ( rem != null ) { return removeFromWhitelist ( rem ) ; } return new byte [ 0 ] ; }
te	8	public int applyBonatoTest ( double [ ] variances ) { int i = signals . get ( 0 ) . size ( ) / 2 ; int onset = Integer . MAX_VALUE ; for ( int k = 0 ; k < sensorSize ; k ++ ) { bonatoSigns . get ( k ) . clear ( ) ; cumulativeSignsCounter [ k ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) { int j_k1 = signals . get ( k ) . get ( j * 2 ) ; int j_k2 = signals . get ( k ) . get ( ( j * 2 ) + 1 ) ; double g_j = Math . pow ( ( j_k1 + j_k2 ) , 2 ) / variances [ k ] ; if ( g_j > this . threshold_h ) { bonatoSigns . get ( k ) . add ( true ) ; cumulativeSignsCounter [ k ] ++ ; } else { bonatoSigns . get ( k ) . add ( false ) ; cumulativeSignsCounter [ k ] = 0 ; } } for ( int j = 0 ; j < sensorSize ; j ++ ) { if ( cumulativeSignsCounter [ j ] > threshold_m ) { System . out . println ( "onset" ) ; for ( int j2 = 0 ; j2 < i ; j2 ++ ) { if ( bonatoSigns . get ( k ) . get ( j2 ) ) { if ( j2 * 2 < onset ) { onset = j2 * 2 ; System . out . println ( "onset" ) ; } break ; } } } } } return onset ; }
te	4	public static void registerToRmi ( ) { try { NameNodeSlaveImpl slave = new NameNodeSlaveImpl ( ) ; String local_Ipaddress = InetAddress . getLocalHost ( ) . getHostAddress ( ) ; String slaveName = SystemConstants . getConfig ( SystemConstants . NAMENODE_SLAVE_SERVICE ) ; String name = slaveName + "_" + getIdentifier ( ) ; String bindName = "rmi://" + local_Ipaddress + ":" + portNumber + "/" + name ; System . out . println ( "Registering NameNodeSlave as : " + bindName ) ; Naming . rebind ( bindName , slave ) ; System . out . println ( "NameNodeSlaveImpl: Ready..." ) ; } catch ( RemoteException e ) { System . out . println ( "Error while accessing the remote object check on the RMI." ) ; System . exit ( 0 ) ; } catch ( UnknownHostException e ) { System . out . println ( "Error while accessing the RMI  please retry" ) ; System . exit ( 0 ) ; } catch ( MalformedURLException e ) { System . out . println ( "Error while binding the slave  please retry." ) ; System . exit ( 0 ) ; } catch ( AccessControlException e ) { System . out . println ( "Error with the Access control  check the policy." ) ; System . exit ( 0 ) ; } }
te	6	public void render ( VPoint cm , VGame vg , VGraphics g ) { if ( l > 0 ) { l -- ; } if ( l <= 0 ) { return ; } VPoint v = new VPoint ( s . x - cm . x , s . y - cm . y , s . z ) ; VPoint osv = VConvert . to2DPoint ( v . x , v . y , v . z ) ; switch ( i ) { case 1 : g . setTexture ( "eft/smoke.png" ) ; g . setColor ( new Color ( 255 , 255 , 255 , l * 2 ) ) ; g . drawRect ( ( int ) osv . x , ( int ) osv . y , 32 , 32 , a ) ; s . x += ( r . nextInt ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 2 : g . setTexture ( "eft/smoke.png" ) ; g . setColor ( new Color ( 255 , 255 , 255 , l * 8 ) ) ; g . drawRect ( ( int ) osv . x , ( int ) osv . y , 16 , 16 , a ) ; s . x += ( r . nextInt ( 6 ) - 2 ) ; s . y -= 1 ; s . z += ( l ) / 34 ; break ; case 3 : g . setColor ( new Color ( 255 , 255 , 255 , 255 ) ) ; Sprite . render ( "bullet" , g , 7 - l , v ) ; break ; case 4 : g . setColor ( new Color ( 255 , 255 , 255 , 255 ) ) ; Sprite . render ( "gauss_bullet" , g , 5 - l , v ) ; break ; default : } }
te	3	private static void splitReciprocal ( final double in [ ] , final double result [ ] ) { final double b = 1.0 / 4194304.0 ; final double a = 1.0 - b ; if ( in [ 0 ] == 0.0 ) { in [ 0 ] = in [ 1 ] ; in [ 1 ] = 0.0 ; } result [ 0 ] = a / in [ 0 ] ; result [ 1 ] = ( b * in [ 0 ] - a * in [ 1 ] ) / ( in [ 0 ] * in [ 0 ] + in [ 0 ] * in [ 1 ] ) ; if ( result [ 1 ] != result [ 1 ] ) { result [ 1 ] = 0.0 ; } resplit ( result ) ; for ( int i = 0 ; i < 2 ; i ++ ) { double err = 1.0 - result [ 0 ] * in [ 0 ] - result [ 0 ] * in [ 1 ] - result [ 1 ] * in [ 0 ] - result [ 1 ] * in [ 1 ] ; err = err * ( result [ 0 ] + result [ 1 ] ) ; result [ 1 ] += err ; } }
te	9X	private Description deserialise ( SingleDescriptionTriples buffer , List < Description > additional ) throws DeserialisationException { if ( buffer . hasBeenDeserialised ( ) ) { return buffer . getDeserialisation ( ) ; } URI type = getSpecificType ( buffer ) ; Description description ; if ( type == null ) { type = getImpliedType ( buffer . getSubject ( ) ) ; if ( type == null ) { return null ; } } description = ProvConstructer . create ( type , buffer . getIdentifier ( ) ) ; buffer . setDeserialisation ( description ) ; for ( URI predicate : buffer . getPredicates ( ) ) { if ( ! predicate . equals ( RDF . typeURI ( ) ) ) { if ( Term . isProvTerm ( predicate ) ) { deserialise ( predicate , buffer , description , additional ) ; } else { if ( description instanceof AttributeHolder ) { for ( Literal object : buffer . getLiteralObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object . _value ) ; } for ( URI object : buffer . getURIObjects ( predicate ) ) { ( ( AttributeHolder ) description ) . addAttribute ( predicate , object ) ; } } } } } return description ; }
te	2	private Set < Strategy > buildStrategies ( Strategy strategy , int breakpointNumber , int [ ] breakpoints , int [ ] [ ] actionPercentages ) { Set < Strategy > strategies = new HashSet < Strategy > ( ) ; for ( int [ ] actionPercentageSet : actionPercentages ) { Strategy s = new Strategy ( strategy ) ; Tactic nextTactic = new Tactic ( actionPercentageSet ) ; s . putNewTactic ( nextTactic ) ; if ( breakpointNumber < AISettings . DEFAULT_BREAKPOINTS . length - 1 ) { strategies . addAll ( buildStrategies ( s , breakpointNumber + 1 , breakpoints , actionPercentages ) ) ; } else { strategies . add ( s ) ; } } return strategies ; }
te	4	public static void solve ( int k , int ct ) { int i , j ; if ( k < ct && k >= 0 ) { i = blan [ k ] / 9 ; j = blan [ k ] % 9 ; for ( int fill = 1 ; fill <= 9 ; fill ++ ) { if ( checkitnow ( i , j , fill ) ) { sudoku [ i ] [ j ] = fill ; solve ( ++ k , ct ) ; k -- ; } } sudoku [ i ] [ j ] = 0 ; } else { answer ++ ; printsudoku ( ) ; } }
te	8	static public void msDur ( StringBuilder sb , int ms ) { if ( ms < 0 ) { sb . append ( "-" ) ; msDur ( sb , - ms ) ; } else if ( ms < 1000 ) { sb . append ( ms ) ; sb . append ( "ms" ) ; } else if ( ms < 10000 ) { tenths ( sb , ms , 1000 ) ; sb . append ( s ) ; } else if ( ms < 60000 ) { sb . append ( ms / 1000 ) ; sb . append ( s ) ; } else if ( ms < 600000 ) { tenths ( sb , ms , 60000 ) ; sb . append ( m ) ; } else if ( ms < 3600000 ) { sb . append ( ms / 60000 ) ; sb . append ( m ) ; } else if ( ms < 36000000 ) { tenths ( sb , ms , 3600000 ) ; sb . append ( h ) ; } else if ( ms < 86400000 ) { sb . append ( ms / 3600000 ) ; sb . append ( h ) ; } else { tenths ( sb , ms , 86400000 ) ; sb . append ( d ) ; } }
te	0	public void setI ( float i ) { this . i = i ; }
te	9X	protected void defineCommands ( ) { commands . put ( "quit" , new Command ( ) { public void run ( String [ ] args ) throws Exception { close ( ) ; } } ) ; commands . put ( "create" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( args . length < 2 ) { gui . addNotice ( "create <pokoj> <haslo>" ) ; return ; } String roomName = args [ 0 ] ; String password = args [ 1 ] ; if ( client != null ) client . createRoom ( roomName , password ) ; } } ) ; commands . put ( "join" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( args . length < 3 ) { gui . addNotice ( "join <nick> <pokoj> <haslo>" ) ; return ; } String nickname = args [ 0 ] ; String roomName = args [ 1 ] ; String password = args [ 2 ] ; if ( client != null ) { if ( currentRoom != null ) { handleCommand ( "leave" ) ; } client . joinRoom ( roomName , password , nickname ) ; currentRoom = new CurrentRoom ( roomName , nickname ) ; } } } ) ; commands . put ( "leave" , new Command ( ) { public void run ( String [ ] args ) throws Exception { if ( currentRoom == null ) { gui . addError ( "Nie jeste\u015B obecnie w \u017Cadnym pokoju" ) ; return ; } if ( client != null ) { String currentRoomName = currentRoom . roomName ; String currentRoomNickname = currentRoom . nickname ; client . leaveRoom ( currentRoom . roomName , currentRoom . nickname ) ; currentRoom = null ; gui . addNotice ( String . format ( "%s opu\u015Bci\u0142(a) pok\u00F3j %s" , currentRoomNickname , currentRoomName ) ) ; gui . setStatus ( "" ) ; } } } ) ; commands . put ( "msgs" , new Command ( ) { private final String SENT_FORMAT = "dd.MM.yyyy" ; public void run ( String [ ] args ) throws Exception { if ( currentRoom == null ) { gui . addError ( "Nie jeste\u015B obecnie w \u017Cadnym pokoju" ) ; return ; } if ( client != null ) { String sentArg = args . length > 0 ? args [ 0 ] : null ; Date sent = null ; if ( sentArg != null ) { SimpleDateFormat df = new SimpleDateFormat ( SENT_FORMAT ) ; try { sent = df . parse ( sentArg ) ; } catch ( ParseException e ) { gui . addNotice ( String . format ( "msgs: Data powinna byc w formacie `%s'" , SENT_FORMAT ) ) ; return ; } } client . showMessages ( currentRoom . roomName , sent ) ; } } } ) ; }
te	2	public void add_bits ( int bitstring , int length ) { int bitmask = 1 << ( length - 1 ) ; do if ( ( ( crc & 8000 ) == 0 ) ^ ( ( bitstring & bitmask ) == 0 ) ) { crc <<= 1 ; crc ^= polynomial ; } else crc <<= 1 ; while ( ( bitmask >>>= 1 ) != 0 ) ; }
te	6	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( SettingsFrame . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new SettingsFrame ( ) . setVisible ( true ) ; } } ) ; }
te	7	public void setSelectedOC ( OutputConnector selectedOC , Component comp ) { if ( this . selectedOC != null ) this . selectedOC . setSelected ( true ) ; this . selectedOC = selectedOC ; this . selectedOC . setSelected ( true ) ; connectables = new ArrayList < InputConnector > ( ) ; for ( Component e : getElements ( ) ) { if ( e == comp ) continue ; if ( e instanceof InputStub ) continue ; for ( Connector c : e . getConnectors ( ) ) { if ( c instanceof InputConnector ) if ( ! ( ( InputConnector ) c ) . isConnected ( ) ) connectables . add ( ( InputConnector ) c ) ; } } }
te	6	private RequirementElement parseAttackElementInfo ( List < String > factors ) { RequirementElement new_elem = new RequirementElement ( ) ; if ( factors . get ( 2 ) . equals ( "Circle" ) && ! factors . get ( 3 ) . equals ( "empty" ) ) { new_elem = new NewAntiGoal ( ) ; new_elem . setId ( factors . get ( 1 ) ) ; new_elem . setType ( InfoEnum . RequirementElementType . NEW_ANTI_GOAL . name ( ) ) ; String sg_name = factors . get ( 3 ) ; new_elem . setName ( sg_name . trim ( ) ) ; ( ( NewAntiGoal ) new_elem ) . extractInfoFromName ( ) ; } else if ( checkCircle ( factors . get ( 7 ) ) ) { } else { new_elem = new RequirementElement ( ) ; new_elem . setId ( factors . get ( 1 ) ) ; if ( factors . get ( 2 ) . equals ( "Hexagon" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . TASK . name ( ) ) ; } else if ( factors . get ( 2 ) . equals ( "Rectangle" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . DOMAIN_ASSUMPTION . name ( ) ) ; } else if ( factors . get ( 3 ) . equals ( "empty" ) & factors . get ( 2 ) . equals ( "Circle" ) & factors . get ( 10 ) . equals ( "0" ) ) { new_elem . setType ( InfoEnum . RequirementElementType . MIDDLE_POINT . name ( ) ) ; } else { } new_elem . setName ( factors . get ( 3 ) ) ; } String [ ] temp2 = factors . get ( 11 ) . split ( " " ) ; new_elem . origin_x = double . parseDouble ( temp2 [ 0 ] . replace ( " " , "." ) ) ; new_elem . origin_y = double . parseDouble ( temp2 [ 1 ] . replace ( " " , "." ) ) ; return new_elem ; }
te	6	private boolean skipComment ( ) throws IOException { char cc = _next ( ) ; if ( cc != * ) { putback ( cc ) ; return false ; } int lineno = getLine ( ) ; while ( ( cc = _next ( ) ) != EOF ) { if ( cc == * ) { cc = _next ( ) ; if ( cc == / ) return true ; if ( cc == * ) putback ( cc ) ; if ( cc == EOF ) break ; } } throw error ( "unclosed comment" , _lineno ) ; }
te	3	@ SuppressWarnings ( "unchecked" ) private void initprocedureArray ( ) { procedureArray = ( Action < TerminalEnum , ProductionEnum , VersionEnum > [ ] ) new Action < ? , ? , ? > [ ] { reduceitem_star_0_empty , branch0 , branch0 , shift4 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , reduceblock , reduceinstr_end , reduceinstr_break , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , branch0 , reducefuncall , branch0 , branch0 , branch0 , branch0 , branch0 , reduceinstr_if , branch0 , reduceinstr_if_else , branch0 , branch0 , branch0 , branch0 , branch0 , reduceinstr_repeat , branch0 , branch0 , branch0 , branch0 , reduceinstr_repeat_while , branch0 , reduceinstr_funcall , branch0 , reduceproc , reduceitem_proc , reduceitem_instr , reduceitem_star_0_rec } ; }
te	4	public FrizzleFeatherGene ( String genotype ) { this . genotype = genotype ; switch ( genotype ) { case "FF" : phenotype = "Normal" ; break ; case "Ff" : case "fF" : phenotype = "Frizzle" ; break ; case "ff" : phenotype = "Curly" ; break ; default : } }
te	8	public static void main ( String [ ] args ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; ArrayList < Integer > datos = new ArrayList < Integer > ( 100 ) ; int mayor = 0 ; System . out . println ( "Introduzca hasta 100 n\u00FAmeros ('q' para salir):" ) ; boolean fin = false ; while ( datos . size ( ) < 100 && ! fin ) { System . out . print ( ( datos . size ( ) + 1 ) + ": " ) ; String entrada = null ; try { entrada = reader . readLine ( ) ; } catch ( IOException ex ) { entrada = "q" ; } if ( entrada . equals ( "q" ) ) { fin = true ; } else { try { int num = Integer . parseInt ( entrada ) ; datos . add ( num ) ; if ( datos . size ( ) == 1 || num > mayor ) mayor = num ; } catch ( NumberFormatException ex ) { } } } System . out . println ( ) ; if ( datos . size ( ) == 0 ) System . out . println ( "\u00A1No ha introducido ning\u00FAn n\u00FAmero!" ) ; else System . out . println ( "El n\u00FAmero mayor es: " + mayor ) ; }
te	3	public int checkHorizontalLinePieces ( int row , Symbol sym ) { int flag = 0 ; int column = 0 ; while ( column < board . length ) { if ( board [ row ] [ column ] != null && board [ row ] [ column ] . getSym ( ) == sym ) column += 1 ; else { flag = - 1 ; break ; } } return flag ; }
te	9X	public void draw ( Graphics gPanel , float cellHeight , MapPanel panel ) { String drawImageName = "" ; Color color = null ; boolean draw = false ; if ( getBuilding ( ) != null ) { drawImageName = getBuilding ( ) . getImageLocation ( ) ; } else if ( getUnit ( ) != null ) { drawImageName = getUnit ( ) . getImageLocation ( ) ; } if ( getBuilding ( ) instanceof Base ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getBuilding ( ) instanceof Factory ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getBuilding ( ) instanceof Barracks ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getBuilding ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getUnit ( ) instanceof Marine ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getUnit ( ) . getOwner ( ) ) ) ; draw = true ; } else if ( getUnit ( ) instanceof Tank ) { color = Teams . getTeamColor ( Teams . getTeamOfPlayer ( getUnit ( ) . getOwner ( ) ) ) ; draw = true ; } if ( draw ) { BufferedImage originalImage = new BufferedImage ( 90 , 90 , BufferedImage . TYPE_INT_RGB ) ; try { BufferedImage rawImage = new BufferedImage ( 90 , 90 , BufferedImage . TYPE_INT_RGB ) ; rawImage = ImageIO . read ( getClass ( ) . getResource ( drawImageName ) ) ; BufferedImage mask = generateMask ( rawImage , color , 0.3f ) ; originalImage = tint ( rawImage , mask ) ; } catch ( IOException e1 ) { System . out . println ( "Error getting map image!" ) ; } if ( getUnit ( ) != null && drawHealthBars ) { float healthScale = getUnit ( ) . getCurrentHealth ( ) / ( float ) getUnit ( ) . getBaseHealth ( ) ; Graphics g = originalImage . getGraphics ( ) ; int offset = 10 ; g . drawRect ( offset , 5 , ( int ) ( ( 90 - 2 * offset ) ) , 10 ) ; g . setColor ( Color . green ) ; g . fillRect ( offset + 1 , 5 + 1 , ( int ) ( ( 90 - 2 * offset ) * healthScale ) - 1 , 10 - 1 ) ; } else if ( getBuilding ( ) != null && drawHealthBars ) { float healthScale = getBuilding ( ) . getCurrentHealth ( ) / ( float ) getBuilding ( ) . getBaseHealth ( ) ; Graphics g = originalImage . getGraphics ( ) ; int offset = 10 ; g . drawRect ( offset , 5 , ( int ) ( ( 90 - 2 * offset ) ) , 10 ) ; g . setColor ( Color . green ) ; g . fillRect ( offset + 1 , 5 + 1 , ( int ) ( ( 90 - 2 * offset ) * healthScale ) - 1 , 10 - 1 ) ; } int newH = ( int ) ( 90 * panel . getZoom ( ) ) ; gPanel . drawImage ( originalImage , ( int ) ( this . getCellPosX ( ) * cellHeight ) , ( int ) ( this . getCellPosY ( ) * cellHeight ) , newH , newH , null ) ; } }
te	6	private ID3v2CommentFrameData extractCommentFrameData ( String id , boolean itunes ) { ID3v2FrameSet frameSet = frameSets . get ( id ) ; if ( frameSet != null ) { Iterator < ID3v2Frame > iterator = frameSet . getFrames ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) iterator . next ( ) ; ID3v2CommentFrameData frameData ; try { frameData = new ID3v2CommentFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; if ( itunes && ITUNES_COMMENT_DESCRIPTION . equals ( frameData . getDescription ( ) . toString ( ) ) ) { return frameData ; } else if ( ! itunes ) { return frameData ; } } catch ( InvalidDataException e ) { } } } return null ; }
te	5	public static void main ( String [ ] args ) { init ( ) ; if ( args . length < 2 ) { System . err . println ( "Expected args: <cmd> <config_file> ....\n" + "\t cmd = create  compare" ) ; System . exit ( 1 ) ; } cmd = args [ 0 ] . toLowerCase ( ) ; String configFile = args [ 1 ] ; try { initVSL ( configFile ) ; } catch ( Exception e ) { System . err . println ( "Caught exception: " + e . toString ( ) ) ; e . printStackTrace ( ) ; System . exit ( 1 ) ; } Integer cmdint = ( Integer ) cmds . get ( cmd ) ; if ( cmdint == null ) { System . err . println ( "Expected args: <cmd> <dbfile> ....\n" + "\t cmd = create  compare  list  read" ) ; System . exit ( 1 ) ; } switch ( cmdint ) { case 1 : create ( args ) ; break ; case 3 : compare ( args ) ; break ; } System . exit ( 0 ) ; }
te	6	public static String encodeParameters ( List < PostParameter > postParams , String splitter , boolean quot ) { StringBuffer buf = new StringBuffer ( ) ; for ( PostParameter param : postParams ) { if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } buf . append ( splitter ) ; } buf . append ( encode ( param . name ) ) . append ( "=" ) ; if ( quot ) { buf . append ( "\"" ) ; } buf . append ( encode ( param . value ) ) ; } if ( buf . length ( ) != 0 ) { if ( quot ) { buf . append ( "\"" ) ; } } return buf . toString ( ) ; }
te	4	public void minHeapify ( int index ) { for ( int left = leftChild ( index ) ; left < heap . size ( ) ; index = left ) { if ( left + 1 < heap . size ( ) && heap . get ( left + 1 ) . key < heap . get ( left ) . key ) { left ++ ; } if ( heap . get ( left ) . key < heap . get ( index ) . key ) { swap ( left , index ) ; } else { break ; } } }
te	9X	public int divide ( int dividend , int divisor ) { if ( divisor == 0 || ( dividend == Integer . MIN_VALUE && divisor == - 1 ) ) { return Integer . MAX_VALUE ; } boolean negative = false ; if ( dividend < 0 ) { negative = ! negative ; } else { dividend = - dividend ; } if ( divisor < 0 ) { negative = ! negative ; } else { divisor = - divisor ; } int ret = 0 ; int bits = - 1 ; for ( int i = divisor ; i > dividend >> 1 ; i <<= 1 ) { bits ++ ; } if ( bits == - 1 && dividend <= divisor ) { bits = 0 ; } while ( bits >= 0 ) { int subtractor = divisor << bits ; while ( dividend <= subtractor ) { dividend -= subtractor ; ret += 1 << bits ; } bits -- ; } return negative ? - ret : ret ; }
te	5	public synchronized boolean findSDSLInstances ( ) { knownSDSLInstances = new ArrayList < SDSL > ( ) ; boolean found = false ; ListIterator < Line > it = gct . getCodeLines ( ) . listIterator ( ) ; while ( it . hasNext ( ) ) { Line l = it . next ( ) ; if ( l . startsWith ( "28708ceb 000000" ) ) { Line [ ] code = new Line [ 4 ] ; code [ 0 ] = l ; code [ 1 ] = it . next ( ) ; if ( code [ 1 ] . startsWith ( "4A000000 90180F06" ) ) { code [ 2 ] = it . next ( ) ; if ( code [ 2 ] . startsWith ( "14000076 FF00" ) ) { code [ 3 ] = it . next ( ) ; if ( code [ 3 ] . startsWith ( "E0000000 80008000" ) ) { found = true ; SDSL sdsl = new SDSL ( code ) ; knownSDSLInstances . add ( sdsl ) ; gct . recordDynamicCode ( sdsl ) ; } } } } } return found ; }
te	4	public CalculatorFrame ( ) { setBounds ( 250 , 150 , 500 , 200 ) ; setLayout ( null ) ; setTitle ( "Super Calculator" ) ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setResizable ( false ) ; calcPanel = new CalculatorPanel ( this ) ; add ( calcPanel ) ; setVisible ( true ) ; addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { if ( calcPanel != null && Settings . AUTOSAVE . get ( ) . equals ( "true" ) ) { calcPanel . getCalcMenuBar ( ) . autoSave ( ) ; } } @ Override public void windowOpened ( WindowEvent e ) { if ( calcPanel != null && Settings . AUTOSAVE . get ( ) . equals ( "true" ) ) { calcPanel . getCalcMenuBar ( ) . autoOpen ( ) ; } } } ) ; System . out . println ( "Auto round: " + Settings . AUTOROUND . get ( ) ) ; }
te	2	public AccountPermissions read ( String id ) { log . debug ( "reading " + entitySimpleName + " instance with id: " + id ) ; AccountPermissions instance = null ; try { instance = ( AccountPermissions ) super . read ( entityFullName , id ) ; log . debug ( entitySimpleName + " read successful  instance found" ) ; } catch ( EntityNotFoundException ex ) { log . error ( entitySimpleName + " read successful  no instance found" , ex ) ; } catch ( RuntimeException re ) { log . error ( entitySimpleName + " read failed" , re ) ; throw re ; } return instance ; }
te	2	private Player getWinner ( ) { for ( Player player : playerList . getPlayers ( ) ) { if ( ! player . isBankrupt ( ) ) { return player ; } } return null ; }
te	3	public static Node reverseK ( Node head , int k ) { Node current = head ; Node next = null ; Node prev = null ; int count = 0 ; while ( current != null && count < k ) { next = current . getNext ( ) ; current . setNext ( prev ) ; prev = current ; current = next ; count ++ ; } if ( next != null ) { head . setNext ( reverseK ( next , k ) ) ; } return prev ; }
te	3	public FHashMap < Key , Val > less ( Key key ) { Object t = less ( tree , key , hashCode ( key ) ) ; if ( t == tree ) return this ; else if ( t == null && dflt == null ) return emptyMap ( ) ; else return new FHashMap < Key , Val > ( t , dflt ) ; }
te	5	protected static void validateCertificateChain ( Certificate [ ] ownCerts , Certificate [ ] native_certs ) throws Exception { if ( ownCerts == null ) return ; if ( native_certs == null ) throw new Exception ( "Unable to validate certificate chain. Native entry did not have a certificate chain at all" ) ; if ( ownCerts . length != native_certs . length ) throw new Exception ( "Unable to validate certificate chain. Chain differs in length [" + ownCerts . length + " vs " + native_certs . length + "]" ) ; for ( int i = 0 ; i < ownCerts . length ; i ++ ) if ( ! ownCerts [ i ] . equals ( native_certs [ i ] ) ) throw new Exception ( "Certificate mismatch: " + ownCerts [ i ] + " != " + native_certs [ i ] ) ; }
te	9X	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; T2 < ? , ? > other = ( T2 < ? , ? > ) obj ; if ( _first == null ) { if ( other . _first != null ) return false ; } else if ( ! _first . equals ( other . _first ) ) return false ; if ( _second == null ) { if ( other . _second != null ) return false ; } else if ( ! _second . equals ( other . _second ) ) return false ; return true ; }
te	2	public static void assert_are_of_type ( class expected_type , Object ... objects ) { for ( Object object : objects ) { if ( ! object . getClass ( ) . isInstance ( expected_type ) ) { assert . fail ( String . format ( "Expecting type [%s] GOT [%s]" , expected_type , object . getClass ( ) ) ) ; } } }
te	4	public void immune ( Type primary , Type secondary ) { if ( immuneTypes . length == 0 ) { return ; } for ( int i = 0 ; i < resistantTypes . length ; i ++ ) { if ( immuneTypes [ i ] . equalsTo ( primary . showType ( ) ) || immuneTypes [ i ] . equalsTo ( secondary . showType ( ) ) ) { typeModifier = 0.0 ; } } }
te	8	public void connect ( TreeLinkNode root ) { TreeLinkNode cur = root ; while ( cur != null ) { TreeLinkNode next = null ; TreeLinkNode prev = null ; while ( cur != null ) { if ( next == null ) { if ( cur . left != null ) next = cur . left ; else next = cur . right ; } if ( cur . left != null ) { if ( prev != null ) prev . next = cur . left ; prev = cur . left ; } if ( cur . right != null ) { if ( prev != null ) prev . next = cur . right ; prev = cur . right ; } cur = cur . next ; } cur = next ; } }
te	5	public void resetBoard ( ) { for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { m_Pieces [ i ] [ j ] = NONE_PIECE ; } } m_Pieces [ 3 ] [ 3 ] = WHITE_PIECE ; m_Pieces [ 4 ] [ 4 ] = WHITE_PIECE ; m_Pieces [ 3 ] [ 4 ] = BLACK_PIECE ; m_Pieces [ 4 ] [ 3 ] = BLACK_PIECE ; for ( int x = 0 ; x < WIDTH ; x ++ ) { for ( int y = 0 ; y < HEIGHT ; y ++ ) { if ( m_Pieces [ x ] [ y ] == null ) { m_Pieces [ x ] [ y ] = NONE_PIECE ; } } } }
te	5	public void transform ( String originalFile , String thumbnailFile , int thumbWidth , int thumbHeight , int quality ) throws Exception { Image image = javax . imageio . ImageIO . read ( new File ( originalFile ) ) ; double thumbRatio = ( double ) thumbWidth / ( double ) thumbHeight ; int imageWidth = image . getWidth ( null ) ; int imageHeight = image . getHeight ( null ) ; double imageRatio = ( double ) imageWidth / ( double ) imageHeight ; if ( thumbRatio < imageRatio ) { thumbHeight = ( int ) ( thumbWidth / imageRatio ) ; } else { thumbWidth = ( int ) ( thumbHeight * imageRatio ) ; } if ( imageWidth < thumbWidth && imageHeight < thumbHeight ) { thumbWidth = imageWidth ; thumbHeight = imageHeight ; } else if ( imageWidth < thumbWidth ) thumbWidth = imageWidth ; else if ( imageHeight < thumbHeight ) thumbHeight = imageHeight ; BufferedImage thumbImage = new BufferedImage ( thumbWidth , thumbHeight , BufferedImage . TYPE_INT_RGB ) ; Graphics2D graphics2D = thumbImage . createGraphics ( ) ; graphics2D . setBackground ( Color . WHITE ) ; graphics2D . setPaint ( Color . WHITE ) ; graphics2D . fillRect ( 0 , 0 , thumbWidth , thumbHeight ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BILINEAR ) ; graphics2D . drawImage ( image , 0 , 0 , thumbWidth , thumbHeight , null ) ; javax . imageio . ImageIO . write ( thumbImage , "JPG" , new File ( thumbnailFile ) ) ; }
te	2	public < K , V > ListenableAtomicMap < K , V > removeListenableAtomicMapNamed ( String name ) { return atomic ( ( ) -> { ListenableAtomicMap < ? , ? > map = ListenableAtomicMapsByName . remove ( name ) ; return ( ListenableAtomicMap < K , V > ) map ; } ) ; }
te	8	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getActionCommand ( ) . equals ( "tower" ) ) clickState = ClickState . tower ; else if ( arg0 . getActionCommand ( ) . equals ( "swamp" ) ) clickState = ClickState . swamp ; else if ( arg0 . getActionCommand ( ) . equals ( "elfrune" ) ) clickState = ClickState . elf ; else if ( arg0 . getActionCommand ( ) . equals ( "manrune" ) ) { clickState = ClickState . man ; } else if ( arg0 . getActionCommand ( ) . equals ( "dwarfrune" ) ) clickState = ClickState . dwarf ; else if ( arg0 . getActionCommand ( ) . equals ( "hobbitrune" ) ) clickState = ClickState . hobbit ; else if ( arg0 . getActionCommand ( ) . equals ( "reloadrune" ) ) clickState = ClickState . reload ; else if ( arg0 . getActionCommand ( ) . equals ( "rangerune" ) ) clickState = ClickState . range ; }
te	9X	public boolean onCommand ( CommandSender sender , Command cmd , String label , String [ ] args ) { Player player = null ; if ( sender instanceof Player ) { player = ( Player ) sender ; } if ( args . length == 0 ) { if ( player == null ) { sender . sendMessage ( "This command can only be run by a player" ) ; } else { player . setLevel ( 150 ) ; player . sendMessage ( ChatColor . WHITE + "You've made yourself " + ChatColor . DARK_GREEN + "Level 150!" ) ; return true ; } } if ( args . length == 1 ) { if ( Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; target . setLevel ( 150 ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " Has been made " + ChatColor . DARK_GREEN + "Level 150!" ) ; target . sendMessage ( ChatColor . WHITE + "You've been made " + ChatColor . DARK_GREEN + "Level 150 " + ChatColor . WHITE + "by " + ChatColor . DARK_GREEN + sender . getName ( ) ) ; return true ; } else if ( Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + "'" + args [ 0 ] + "'" + ChatColor . WHITE + " is not online." ) ; return true ; } } if ( args . length == 2 ) { if ( Bukkit . getPlayer ( args [ 0 ] ) != null ) { Player target = Bukkit . getPlayer ( args [ 0 ] ) ; int lvlset = Integer . parseInt ( args [ 1 ] ) ; target . setLevel ( lvlset ) ; sender . sendMessage ( ChatColor . DARK_GREEN + target . getDisplayName ( ) + ChatColor . WHITE + " Has been made " + ChatColor . DARK_GREEN + "Level " + lvlset ) ; target . sendMessage ( ChatColor . WHITE + "You've been made " + ChatColor . DARK_GREEN + "Level " + lvlset + ChatColor . WHITE + " by " + ChatColor . DARK_GREEN + sender . getName ( ) ) ; return true ; } else if ( Bukkit . getPlayer ( args [ 0 ] ) == null ) { sender . sendMessage ( ChatColor . DARK_GREEN + "'" + args [ 0 ] + "'" + ChatColor . WHITE + " is not online." ) ; return true ; } } return true ; }
te	0	public void setProjectId ( int projectId ) { this . projectId = projectId ; }
te	3	private static void player1DoSwapPieces ( OthelloPiece piecesToSwap [ ] [ ] ) { for ( int i = 0 ; i < TOTALWIDTH ; i ++ ) { for ( int j = 0 ; j < TOTALHEIGHT ; j ++ ) { if ( piecesToSwap [ i ] [ j ] == null ) { } else { player1SwapPieces ( i , j ) ; } } } }
te	9X	public boolean isPunch ( ) { switch ( this ) { case BULLET_PUNCH : case COMET_PUNCH : case DIZZY_PUNCH : case DRAIN_PUNCH : case DYNAMICPUNCH : case FIRE_PUNCH : case FOCUS_PUNCH : case HAMMER_ARM : case ICE_PUNCH : case MACH_PUNCH : case MEGA_PUNCH : case METEOR_MASH : case SHADOW_PUNCH : case SKY_UPPERCUT : case THUNDERPUNCH : return true ; default : return false ; } }
te	7	private void updatePermissions ( ) { bukkitPermissions = new LinkedHashMap < String , Permission > ( ) ; if ( subgroups == null ) { subgroups = new ArrayList < String > ( ) ; } if ( ! permissions . containsKey ( Config . getDefaultWorld ( ) ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + Config . getDefaultWorld ( ) , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; Permission permission = new Permission ( "droxperms.meta.group." + name + "." + Config . getDefaultWorld ( ) , "Group-Permissions for group " + name + " on world " + Config . getDefaultWorld ( ) , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( Config . getDefaultWorld ( ) , permission ) ; } for ( String world : Config . getWorlds ( ) ) { Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup + "." + world , true ) ; } children . put ( "droxperms.meta.group." + name , true ) ; if ( permissions . get ( world ) != null ) { children . putAll ( permissions . get ( world ) ) ; } Permission permission = new Permission ( "droxperms.meta.group." + name + "." + world , "Group-Permissions for group " + name + " on world " + world , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; bukkitPermissions . put ( world , permission ) ; } Map < String , boolean > children = new LinkedHashMap < String , boolean > ( ) ; for ( String subgroup : subgroups ) { children . put ( "droxperms.meta.group." + subgroup , true ) ; } children . putAll ( globalPermissions ) ; Permission permission = new Permission ( "droxperms.meta.group." + name , "Group-Permissions for group " + name , PermissionDefault . false , children ) ; Bukkit . getPluginManager ( ) . removePermission ( permission ) ; Bukkit . getPluginManager ( ) . addPermission ( permission ) ; }
te	5	public void abrir ( ) throws Exception { if ( id . length ( ) > 0 && ! id . equals ( "0" ) ) { long cod = long . parseLong ( id ) ; if ( venda == null || ( venda != null && venda . getId ( ) != cod ) ) setVenda ( ejb . Open ( cod ) ) ; } }
te	9X	public IPv4 ( String symbolicIP , String netmask ) throws NumberFormatException { String [ ] st = symbolicIP . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; int i = 24 ; baseIPnumeric = 0 ; for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid IP address: " + symbolicIP ) ; } baseIPnumeric += value << i ; i -= 8 ; } st = netmask . split ( "\\." ) ; if ( st . length != 4 ) throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; i = 24 ; netmaskNumeric = 0 ; if ( Integer . parseInt ( st [ 0 ] ) < 255 ) { throw new NumberFormatException ( "The first byte of netmask can not be less than 255" ) ; } for ( int n = 0 ; n < st . length ; n ++ ) { int value = Integer . parseInt ( st [ n ] ) ; if ( value != ( value & ff ) ) { throw new NumberFormatException ( "Invalid netmask address: " + netmask ) ; } netmaskNumeric += value << i ; i -= 8 ; } boolean encounteredOne = false ; int ourMaskBitPattern = 1 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( netmaskNumeric & ourMaskBitPattern ) != 0 ) { encounteredOne = true ; } else { if ( encounteredOne == true ) throw new NumberFormatException ( "Invalid netmask: " + netmask + " (bit " + ( i + 1 ) + ")" ) ; } ourMaskBitPattern = ourMaskBitPattern << 1 ; } }
te	6	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; RecordTypeNode other = ( RecordTypeNode ) obj ; if ( fieldLists == null ) { if ( other . fieldLists != null ) return false ; } else if ( ! fieldLists . equals ( other . fieldLists ) ) return false ; return true ; }
te	0	@ Override protected void drawComponentBody ( Graphics2D g ) { int [ ] xx = { x , x + width / 6 , x + width - width / 6 , x + width , x + width , x + width - width / 6 , x + width / 6 , x } ; int [ ] yy = { y + height / 6 , y , y , y + height / 6 , y + height - height / 6 , y + height , y + height , y + height - height / 6 } ; g . drawPolygon ( xx , yy , xx . length ) ; Stroke strokeSave = g . getStroke ( ) ; g . setStroke ( new BasicStroke ( 0.5f ) ) ; g . drawPolygon ( new int [ ] { x , x + width , x + width , x } , new int [ ] { y , y , y + height , y + height } , 4 ) ; g . setStroke ( strokeSave ) ; }
te	2	public static BookSection fromJson ( JsonElement elem ) { JsonObject obj = elem . getAsJsonObject ( ) ; String header = obj . has ( HEADER ) ? obj . getAsJsonPrimitive ( HEADER ) . getAsString ( ) : null ; LinkedList < String > names = new LinkedList < String > ( ) ; for ( JsonElement probElem : obj . get ( PROBLEMS ) . getAsJsonArray ( ) ) { names . add ( probElem . getAsString ( ) ) ; } return new BookSection ( header , names ) ; }
te	6	public List < double > classifyInstance ( Datum attributesDatum ) { List < double > attributesList = attributesDatum . getAttributes ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Input ) ; i ++ ) { neuralMap . get ( NetworkLevel . Input ) . get ( i ) . setNodeValue ( attributesList . get ( i ) ) ; } for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; i ++ ) { double totalHiddenInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Input ) ; j ++ ) { double inputNodeValue = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getNodeValue ( ) ; double inputNodeWeight = neuralMap . get ( NetworkLevel . Input ) . get ( j ) . getOutputWeightAt ( i ) ; totalHiddenInput += inputNodeValue * inputNodeWeight ; } totalHiddenInput += biasNode . getOutputWeightAt ( i ) * biasNode . getNodeValue ( ) ; double hiddenNodeValue = 1.0 / ( 1 + Math . pow ( Math . E , - totalHiddenInput ) ) ; neuralMap . get ( NetworkLevel . Hidden ) . get ( i ) . setNodeValue ( hiddenNodeValue ) ; } ArrayList < double > intermediateValues = new ArrayList < double > ( ) ; double simpleTotal = 0 ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double totalOutputInput = 0 ; for ( int j = 0 ; j < nodeLevelNumber . get ( NetworkLevel . Hidden ) ; j ++ ) { double hiddenNodeValue = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getNodeValue ( ) ; double hiddenNodeWeight = neuralMap . get ( NetworkLevel . Hidden ) . get ( j ) . getOutputWeightAt ( i ) ; totalOutputInput += hiddenNodeValue * hiddenNodeWeight ; } totalOutputInput += biasNode . getOutputWeightAt ( i + nodeLevelNumber . get ( NetworkLevel . Hidden ) ) * biasNode . getNodeValue ( ) ; intermediateValues . add ( totalOutputInput ) ; simpleTotal += Math . pow ( Math . E , totalOutputInput ) ; } ArrayList < double > finalValues = new ArrayList < double > ( ) ; for ( int i = 0 ; i < nodeLevelNumber . get ( NetworkLevel . Output ) ; i ++ ) { double trueOutputValue ; trueOutputValue = Math . pow ( Math . E , intermediateValues . get ( i ) ) / simpleTotal ; neuralMap . get ( NetworkLevel . Output ) . get ( i ) . setNodeValue ( trueOutputValue ) ; finalValues . add ( trueOutputValue ) ; } return finalValues ; }
te	2	private void program ( BlockNode root ) { Token t = in . next ( ) ; while ( t != null ) { if ( t . type == TokenType . END ) throw new ParserException ( "extra ']' without matching '['" ) ; else operation ( root , t ) ; t = in . next ( ) ; } }
te	8	@ Override public void beginContact ( Contact c ) { Fixture a = c . m_fixtureA ; Fixture b = c . m_fixtureB ; if ( a . getUserData ( ) != null && a . getUserData ( ) . equals ( FOOT_SENSOR ) ) { } if ( a . m_isSensor && a . m_userData != null && a . getUserData ( ) . equals ( FOOT_SENSOR ) ) { LivingEntity e = ( LivingEntity ) a . getBody ( ) . getUserData ( ) ; e . setFootContacts ( e . getFootContacts ( ) + 1 ) ; } if ( b . m_isSensor && b . m_userData != null && b . m_userData . equals ( FOOT_SENSOR ) ) { LivingEntity e = ( LivingEntity ) b . getBody ( ) . getUserData ( ) ; e . setFootContacts ( e . getFootContacts ( ) + 1 ) ; } }
te	5	private Stmt stmt ( ) throws SyntaxException { Stmt toBeReturned = null ; if ( isKind ( currentToken , IDENT ) ) { toBeReturned = assignStmt ( ) ; } else if ( isKind ( currentToken , pause ) ) { toBeReturned = pauseStmt ( ) ; } else if ( isKind ( currentToken , _while ) ) { toBeReturned = iterationStmt ( ) ; } else if ( isKind ( currentToken , _if ) ) { toBeReturned = alternativeStmt ( ) ; } else if ( isKind ( currentToken , ; ) ) { consume ( ) ; } else { throw new SyntaxException ( currentToken , "Either of " + Arrays . asList ( ; , IDENT , pause , _while , _if ) + " was expected here." ) ; } return toBeReturned ; }
te	1	public void run ( ) { boolean autoFlushStream = true ; try { in = new BufferedReader ( new InputStreamReader ( clientSocket . getInputStream ( ) ) ) ; out = new PrintWriter ( clientSocket . getOutputStream ( ) , autoFlushStream ) ; out . println ( "sWait" ) ; processPlayer ( ) ; } catch ( IOException ioe ) { System . out . println ( "Some I/O error occured..." + ioe . getMessage ( ) ) ; } }
te	1	void removeWindow ( ) { if ( viewport != null ) viewport . dispose ( ) ; viewport = null ; }
te	8	public JPanel addNumberButtons ( JTextField DispField ) { final JTextField Field = DispField ; JPanel ButtonPanel = new JPanel ( ) ; ButtonPanel . setLayout ( new GridLayout ( 4 , 3 ) ) ; ButtonPanel . setPreferredSize ( new Dimension ( 500 , 320 ) ) ; ButtonPanel . setMaximumSize ( new Dimension ( 500 , 500 ) ) ; JButton [ ] NumButtons = new JButton [ 10 ] ; JButton StarButtons = new JButton ( "*" ) ; StarButtons . setFont ( NumButtonsFont ) ; StarButtons . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; StarButtons . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + "*" ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; JButton latticeButtons = new JButton ( "#" ) ; latticeButtons . setFont ( NumButtonsFont ) ; latticeButtons . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; latticeButtons . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + "#" ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; for ( int i = 0 ; i < 10 ; i ++ ) { final String name = "" + i ; NumButtons [ i ] = new JButton ( "" + i ) ; NumButtons [ i ] . setFont ( NumButtonsFont ) ; NumButtons [ i ] . setPreferredSize ( new Dimension ( 100 , 75 ) ) ; NumButtons [ i ] . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent ev ) { if ( Field . getText ( ) . length ( ) < MaxChars ) Field . setText ( Field . getText ( ) + name ) ; if ( ! MainFrame . RedirectPanel . isVisible ( ) ) CallButton . setEnabled ( true ) ; } } ) ; } for ( int i = 1 ; i <= 9 ; i ++ ) { ButtonPanel . add ( NumButtons [ i ] ) ; } ButtonPanel . add ( StarButtons ) ; ButtonPanel . add ( NumButtons [ 0 ] ) ; ButtonPanel . add ( latticeButtons ) ; return ButtonPanel ; }
te	1	public double timesRestart ( Character c ) { if ( restart . containsKey ( c ) ) { return restart . getValue ( c ) ; } else { return 0 ; } }
te	5	public void setup ( ) { setup = true ; if ( recordReplay ) replay = new GameReplay ( players , board ) ; playersAliveCount = players . length ; Player [ ] starters = players . clone ( ) ; int [ ] startPositions = board . getStartPositions ( starters . length ) ; if ( scrambleStartPositions ) { for ( int i = 0 ; i < startPositions . length ; i ++ ) { int randomIndex = random . nextInt ( startPositions . length ) ; int tmp = startPositions [ i ] ; startPositions [ i ] = startPositions [ randomIndex ] ; startPositions [ randomIndex ] = tmp ; } } for ( int i = 0 ; i < players . length ; i ++ ) { players [ i ] . setAlive ( true ) ; players [ i ] . setNumber ( i ) ; players [ i ] . reset ( ) ; int start = startPositions [ i ] ; board . placePlayerWall ( Board . posToX ( start ) , Board . posToY ( start ) , players [ i ] ) ; } if ( recordReplay ) replay . setStartPositions ( startPositions ) ; thread = new Thread ( ) { @ Override public void run ( ) { runGame ( ) ; } } ; }
te	7	@ Override public void itemStateChanged ( ItemEvent e ) { Object source = e . getSource ( ) ; if ( source == m_add ) { m_tensorPanel . setTypeChangeEnabled ( true ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_INITIAL_PICK ) ; System . out . println ( "click into the display to add a feature" ) ; } else if ( source == m_remove ) { m_tensorPanel . setTypeChangeEnabled ( false ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_PICK ) ; System . out . println ( "click near a feature to remove it" ) ; } else if ( source == m_select ) { m_tensorPanel . setTypeChangeEnabled ( false ) ; m_disp . setMajorMode ( PvDisplayIf . MODE_PICK ) ; System . out . println ( "click near a feature to select it" ) ; } else if ( source == m_flowReflect ) { updateVectorField ( ) ; } else if ( source == m_showSeparatrices ) { if ( m_showSeparatrices . getState ( ) ) { m_disp . addGeometry ( m_separatrices ) ; } else { m_disp . removeGeometry ( m_separatrices ) ; } m_disp . update ( m_separatrices ) ; } else if ( source == m_direction ) { updateVectorField ( ) ; } else { assert false : "Unhandled item changed: " + source ; } }
