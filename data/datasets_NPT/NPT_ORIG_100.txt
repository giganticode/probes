tr	B	public Integer getValue ( DraughtsState ds ) { return evaluate ( ds ) ; }
tr	C	private static void saveMapToTextFile ( String fileToSaveTo ) { FileWriter writeto = null ; try { writeto = new FileWriter ( fileToSaveTo , true ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( writeto == null ) { System . out . println ( "file not initialized" ) ; return ; } for ( Map . Entry < String , String > entry : rawMap . entrySet ( ) ) { String textadd = entry . getKey ( ) + SPLITTER + entry . getValue ( ) + "\n" ; char [ ] buffer = new char [ textadd . length ( ) ] ; textadd . getChars ( 0 , textadd . length ( ) , buffer , 0 ) ; try { writeto . write ( buffer ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { writeto . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	H	void button_save_clicked ( String args ) { FileDialog dialog = new FileDialog ( new Frame ( ) , "Save" , FileDialog . SAVE ) ; dialog . setVisible ( true ) ; String filename = dialog . getDirectory ( ) + dialog . getFile ( ) ; if ( filename == null ) return ; try { DataOutputStream fp = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( filename ) ) ) ; int svm_type = svm_parameter . C_SVC ; int svm_type_idx = args . indexOf ( "-s " ) ; if ( svm_type_idx != - 1 ) { StringTokenizer svm_str_st = new StringTokenizer ( args . substring ( svm_type_idx + 2 ) . trim ( ) ) ; svm_type = atoi ( svm_str_st . nextToken ( ) ) ; } int n = point_list . size ( ) ; if ( svm_type == svm_parameter . EPSILON_SVR || svm_type == svm_parameter . NU_SVR ) { for ( int i = 0 ; i < n ; i ++ ) { point p = point_list . elementAt ( i ) ; fp . writeBytes ( p . y + " 1:" + p . x + "\n" ) ; } } else { for ( int i = 0 ; i < n ; i ++ ) { point p = point_list . elementAt ( i ) ; fp . writeBytes ( p . value + " 1:" + p . x + " 2:" + p . y + "\n" ) ; } } fp . close ( ) ; } catch ( IOException e ) { System . err . print ( e ) ; } }
tr	A	public NodeLVL2 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL2 . ds = ds . clone ( ) ; }
tr	E	public List < Data > select ( byte [ ] ... keys ) throws DRUMSException { List < Data > result = new ArrayList < Data > ( ) ; IntObjectOpenHashMap < ArrayList < byte [ ] >> bucketKeyMapping = getBucketKeyMapping ( keys ) ; String filename ; for ( IntObjectCursor < ArrayList < byte [ ] >> entry : bucketKeyMapping ) { filename = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) ; HeaderIndexFile < Data > indexFile = null ; try { indexFile = new HeaderIndexFile < Data > ( filename , HeaderIndexFile . AccessMode . READ_ONLY , gp . HEADER_FILE_LOCK_RETRY , gp ) ; ArrayList < byte [ ] > keyList = entry . value ; result . addAll ( searchForData ( indexFile , keyList . toArray ( new byte [ keyList . size ( ) ] [ ] ) ) ) ; } catch ( FileLockException ex ) { logger . error ( "Could not access the file {} within {} retries. The file seems to be locked." , filename , gp . HEADER_FILE_LOCK_RETRY ) ; throw new DRUMSException ( ex ) ; } catch ( IOException ex ) { logger . error ( "An exception occurred while trying to get objects from the file {}." , filename , ex ) ; throw new DRUMSException ( ex ) ; } finally { if ( indexFile != null ) { indexFile . close ( ) ; } } } return result ; }
tr	D	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	H	private void initConstsPanel ( Composite mainPanel ) { constsPanel = new Composite ( mainPanel , SWT . NONE ) ; constsPanel . setLayout ( new MigLayout ( "nogrid" ) ) ; Label label = new Label ( constsPanel , SWT . NONE ) ; label . setText ( "Possible values: " ) ; constsTxt = new Text ( constsPanel , SWT . BORDER ) ; constsTxt . setLayoutData ( "wrap" ) ; if ( fieldDef . getContentDef ( ) instanceof ConstContentDef ) { ConstContentDef cd = ( ConstContentDef ) fieldDef . getContentDef ( ) ; StringBuffer allowedValsStr = new StringBuffer ( ) ; Vector < String > allowedVals = cd . getAllowedVals ( ) ; for ( Iterator < String > it = allowedVals . iterator ( ) ; it . hasNext ( ) ; ) { allowedValsStr . append ( it . next ( ) ) . append ( " " ) ; } allowedValsStr . deleteCharAt ( allowedValsStr . length ( ) - 1 ) ; constsTxt . setText ( allowedValsStr . toString ( ) ) ; constsPanel . setVisible ( true ) ; } else constsPanel . setVisible ( false ) ; label = new Label ( constsPanel , SWT . NONE ) ; label . setText ( "(comma separated)" ) ; }
tr	J	public void join ( ) throws InterruptedException { syncManager . join ( ) ; }
tr	I	public int findElementInReadBuffer ( ByteBuffer workingBuffer , byte [ ] key , int indexInChunk ) { workingBuffer . position ( indexInChunk ) ; int minElement = indexInChunk / gp . getElementSize ( ) ; int numberOfEntries = workingBuffer . limit ( ) / gp . getElementSize ( ) ; int maxElement = numberOfEntries - 1 ; int midElement ; int comp ; byte [ ] tempKey = new byte [ gp . getKeySize ( ) ] ; while ( minElement <= maxElement ) { midElement = minElement + ( maxElement - minElement ) / 2 ; indexInChunk = midElement * gp . getElementSize ( ) ; workingBuffer . position ( indexInChunk ) ; workingBuffer . get ( tempKey ) ; comp = KeyUtils . compareKey ( key , tempKey , gp . getKeySize ( ) ) ; if ( comp == 0 ) { return indexInChunk ; } else if ( comp < 0 ) { maxElement = midElement - 1 ; } else { minElement = midElement + 1 ; } } return - 1 ; }
tr	F	public String format ( double number ) { int sign = 1 ; if ( number < 0 ) { sign = - 1 ; } number = Math . abs ( number ) ; String fractionalPart = ":" ; int integerPart ; integerPart = ( ( int ) Math . floor ( number ) ) ; double fractional = Math . abs ( number - integerPart ) ; if ( fractionLength < 6 ) { double minutes = fractional * 60 ; String form = "%02.0f" ; if ( fractionLength == 5 ) { form = "%04.1f" ; } Formatter formatter = new Formatter ( Locale . US ) ; String newMinutes = formatter . format ( form , minutes ) . toString ( ) ; if ( double . parseDouble ( newMinutes ) >= 60.0 ) { minutes = 0.0 ; integerPart ++ ; } formatter = new Formatter ( Locale . US ) ; fractionalPart += formatter . format ( form , minutes ) ; } else { double minutes = Math . floor ( fractional * 60 ) ; double rest = fractional - ( ( double ) minutes / 60.0 ) ; double seconds = rest * 3600 ; String form = "%02.0f" ; if ( fractionLength == 8 ) { form = "%04.1f" ; } else if ( fractionLength == 9 ) { form = "%05.2f" ; } Formatter formatter = new Formatter ( Locale . US ) ; String newSeconds = formatter . format ( form , seconds ) . toString ( ) ; if ( double . parseDouble ( newSeconds ) >= 60.0 ) { seconds = 0.0 ; minutes ++ ; } formatter = new Formatter ( Locale . US ) ; String newMinutes = formatter . format ( "%02.0f" , minutes ) . toString ( ) ; if ( double . parseDouble ( newMinutes ) >= 60.0 ) { minutes = 0.0 ; integerPart ++ ; } formatter = new Formatter ( Locale . US ) ; fractionalPart += formatter . format ( "%02.0f:" + form , minutes , seconds ) ; } String res = integerPart + fractionalPart ; if ( sign < 0 ) { res = "-" + res ; } res = padLeft ( res , length ) ; return res ; }
tr	I	void button_load_clicked ( ) { FileDialog dialog = new FileDialog ( new Frame ( ) , "Load" , FileDialog . LOAD ) ; dialog . setVisible ( true ) ; String filename = dialog . getDirectory ( ) + dialog . getFile ( ) ; if ( filename == null ) return ; clear_all ( ) ; try { BufferedReader fp = new BufferedReader ( new FileReader ( filename ) ) ; String line ; while ( ( line = fp . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line , " \t\n\r\f:" ) ; if ( st . countTokens ( ) == 5 ) { byte value = ( byte ) atoi ( st . nextToken ( ) ) ; st . nextToken ( ) ; double x = atof ( st . nextToken ( ) ) ; st . nextToken ( ) ; double y = atof ( st . nextToken ( ) ) ; point_list . addElement ( new point ( x , y , value ) ) ; } else if ( st . countTokens ( ) == 3 ) { double y = atof ( st . nextToken ( ) ) ; st . nextToken ( ) ; double x = atof ( st . nextToken ( ) ) ; point_list . addElement ( new point ( x , y , current_value ) ) ; } else break ; } fp . close ( ) ; } catch ( IOException e ) { System . err . print ( e ) ; } draw_all_points ( ) ; }
tr	G	public static String optionsCount ( String stock ) { String httpdata = getHtml ( yahoobase + "/op?s=" + stock ) ; if ( httpdata . contains ( ">There is no" ) || httpdata . contains ( "Check your spelling" ) || httpdata . indexOf ( "View By Expiration" ) < 0 ) return "0" ; try { httpdata = httpdata . substring ( httpdata . indexOf ( "View By Expiration" ) ) ; httpdata = httpdata . substring ( 0 , httpdata . indexOf ( "table" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return "" + ( httpdata . toLowerCase ( ) . split ( "a href" ) . length - 1 ) ; }
tr	H	boolean validateSignature ( final Document doc , KeySelector keySelector , InputStream payloadStream ) { ManifestSigner signer = new ManifestSigner ( ) ; if ( signer . hasSignature ( doc ) ) { if ( keySelector != null ) { if ( ! signer . validateSignature ( doc , keySelector , payloadStream ) ) { errorHandler . reportError ( INVALID_SIGNATURE , "Invalid digital signature" , null ) ; return false ; } } else { errorHandler . reportError ( UNABLE_TO_VERIFY_SIGNATURE , "No key provided to verify digital signature" , null ) ; return false ; } } return true ; }
tr	C	public void setSynchronizerFactory ( ISynchronizerFactory < Data > factory ) { this . synchronizerFactory = factory ; this . syncManager . setSynchronizer ( factory ) ; }
tr	H	void button_clear_clicked ( ) { clear_all ( ) ; }
tr	F	public static boolean printQuickCount ( StringBuilder saveAsText ) { String [ ] sections = saveAsText . toString ( ) . replaceAll ( "@" , " " ) . split ( " " ) ; StringBuilder build = new StringBuilder ( ) ; for ( String s : sections ) { build . append ( " " + s . split ( "_" ) . length ) ; } return build . toString ( ) . equals ( " 2 36 44 9 9 9 9 9 9 9 9 9 9 1 1 1" ) ; }
tr	E	private void sendHello ( ) { send ( new FppsResponse ( getClass ( ) . getSimpleName ( ) . concat ( "()" ) ) ) ; }
tr	E	@ Override public Draft copyInstance ( ) { return new Draft_76 ( ) ; }
tr	G	protected IntObjectOpenHashMap < ArrayList < byte [ ] >> getBucketKeyMapping ( byte [ ] ... keys ) { IntObjectOpenHashMap < ArrayList < byte [ ] >> bucketKeyMapping = new IntObjectOpenHashMap < ArrayList < byte [ ] >> ( ) ; int bucketId ; for ( byte [ ] key : keys ) { bucketId = hashFunction . getBucketId ( key ) ; if ( ! bucketKeyMapping . containsKey ( bucketId ) ) { bucketKeyMapping . put ( bucketId , new ArrayList < byte [ ] > ( ) ) ; } bucketKeyMapping . get ( bucketId ) . add ( key ) ; } return bucketKeyMapping ; }
tr	G	private String padLeft ( String s , int n ) { if ( s . length ( ) >= n ) { return s ; } String spaces = "" ; for ( int i = 0 ; i < n - s . length ( ) ; i ++ ) { spaces += " " ; } return spaces + s ; }
tr	J	public void close ( ) throws InterruptedException { if ( reader_instance != null ) { reader_instance . closeFiles ( ) ; } reader_instance = null ; if ( syncManager != null ) { syncManager . shutdown ( ) ; syncManager . join ( ) ; } }
tr	I	public static String pastPrices ( String stock ) { String httpdata = getHtml ( yahoobase + "/hp?s=" + stock ) ; if ( ! httpdata . contains ( "Adj Close" ) ) return "HISTORIC" ; httpdata = removeHtml ( reformat ( httpdata . substring ( httpdata . indexOf ( "Adj Close" ) ) ) , false ) ; httpdata = httpdata . substring ( 0 , httpdata . lastIndexOf ( "@" ) ) ; if ( httpdata . indexOf ( "@" ) < 2 ) httpdata = httpdata . substring ( httpdata . indexOf ( "@" ) + 1 ) ; if ( httpdata . lastIndexOf ( "@" ) > 1 ) httpdata = ( httpdata . substring ( 0 , httpdata . lastIndexOf ( "@" ) ) . replaceAll ( " " , "" ) ) ; return httpdata ; }
tr	C	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
tr	I	public DRUMSIterator < Data > getIterator ( ) { return new DRUMSIterator < Data > ( hashFunction , gp ) ; }
tr	E	@ Override public ByteBuffer createBinaryFrame ( Framedata framedata ) { if ( framedata . getOpcode ( ) == Opcode . CLOSING ) return ByteBuffer . wrap ( closehandshake ) ; return super . createBinaryFrame ( framedata ) ; }
tr	D	public BucketContainer < Data > getBucketContainer ( ) { return this . bucketContainer ; }
tr	G	static double [ ] dataLightSubprocessor ( String datain ) { String [ ] dataInSplit = datain . replaceAll ( "@" , " " ) . replaceAll ( "_" , " " ) . split ( " " ) ; if ( dataInSplit . length != 175 ) System . out . println ( dataInSplit . length ) ; double [ ] processed = new double [ dataInSplit . length ] ; for ( int i = 0 ; i < dataInSplit . length ; i ++ ) { double factor = 1 ; String data = dataInSplit [ i ] . replace ( "$" , "" ) ; data = data . replace ( "%" , "" ) ; data = data . replaceAll ( "--" , "" ) ; data = data . replaceAll ( "\\(" , "-" ) ; data = data . replaceAll ( "\\)" , "" ) ; data = data . replaceAll ( "NM" , "" ) ; data = data . replaceAll ( "Dividend" , "" ) ; for ( int j = 0 ; j < months . length ; j ++ ) { if ( data . equals ( months [ j ] ) ) { data = "" + j ; } } if ( data . equals ( "#" ) ) processed [ i ] = - 0.0000001 ; if ( data . contains ( "B" ) ) { factor = 1000000000 ; data = data . replaceAll ( "B" , "" ) ; } if ( data . contains ( "M" ) ) { factor = 1000000 ; data = data . replaceAll ( "M" , "" ) ; } if ( data . contains ( "K" ) ) { factor = 1000 ; data = data . replaceAll ( "K" , "" ) ; } if ( data != null ) { String dat = data . replaceAll ( " " , "" ) ; double dub = doDouble ( dat ) ; processed [ i ] = dub * factor ; } else { processed [ i ] = - 0.0000001 ; } } return processed ; }
tr	C	protected DRUMS ( AbstractHashFunction hashFunction , AccessMode accessMode , DRUMSParameterSet < Data > gp ) throws IOException { this . prototype = gp . getPrototype ( ) ; this . hashFunction = hashFunction ; this . gp = gp ; DynamicMemoryAllocater . instantiate ( gp ) ; gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC = ( int ) ( ( gp . BUCKET_MEMORY - gp . BUCKET_MEMORY % gp . MEMORY_CHUNK ) / hashFunction . getNumberOfBuckets ( ) / prototype . getSize ( ) / 2 ) ; logger . info ( "Setted MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC to {}" , gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC ) ; if ( accessMode == AccessMode . READ_WRITE ) { @ SuppressWarnings ( "unchecked" ) Bucket < Data > [ ] tmp = new Bucket [ hashFunction . getNumberOfBuckets ( ) ] ; buckets = tmp ; for ( int i = 0 ; i < hashFunction . getNumberOfBuckets ( ) ; i ++ ) { buckets [ i ] = new Bucket < Data > ( i , gp ) ; String tmpFileName = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( i ) ; if ( ! new File ( tmpFileName ) . exists ( ) ) { HeaderIndexFile < Data > tmpFile ; try { tmpFile = new HeaderIndexFile < Data > ( tmpFileName , HeaderIndexFile . AccessMode . READ_WRITE , 1 , gp ) ; tmpFile . close ( ) ; } catch ( FileLockException e ) { logger . error ( "Can't create file {}  because file is locked by another process." , tmpFileName ) ; } catch ( IOException e ) { logger . error ( "Can't create file {}. {}" , tmpFileName , e ) ; throw e ; } } } bucketContainer = new BucketContainer < Data > ( buckets , hashFunction ) ; synchronizerFactory = new SynchronizerFactory < Data > ( ) ; syncManager = new SyncManager < Data > ( bucketContainer , synchronizerFactory , gp ) ; syncManager . start ( ) ; } }
tr	H	private int calcPages ( int width , int height ) { int w = width ; int h = height - topBox ; int boxW = ( int ) ( boxWInches * anInch ) ; int boxH = ( int ) ( boxHInches * anInch ) ; double boxesAcross = w / boxW ; double boxesDown = h / boxH ; int recordCount = CharApp . getInstance ( ) . getRecord ( ) . getRecords ( randomOrder ) . size ( ) ; int pages = 0 ; if ( printMode . getStyle ( ) == PrintMode . STYLE_CRAM ) { pages = ( int ) Math . ceil ( recordCount / ( boxesDown * ( boxesAcross - ( boxesAcross % 2 ) ) / 2 ) ) ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ONE_PER_LINE ) { pages = ( int ) Math . ceil ( recordCount / boxesDown ) ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ALTERNATING_LINES ) { pages = ( int ) Math . ceil ( recordCount / ( boxesDown / 2 ) ) ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_READING ) { pages = ( int ) Math . ceil ( recordCount / ( boxesDown * boxesAcross ) ) ; } return pages ; }
tr	A	public int getBestMove ( ) { return 0 ; }
tr	F	public List < Data > read ( int bucketId , int elementOffset , int numberToRead ) throws FileLockException , IOException { String filename = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( bucketId ) ; HeaderIndexFile < Data > indexFile = new HeaderIndexFile < Data > ( filename , HeaderIndexFile . AccessMode . READ_ONLY , gp . HEADER_FILE_LOCK_RETRY , gp ) ; List < Data > result = new ArrayList < Data > ( ) ; long actualOffset = elementOffset * gp . getElementSize ( ) ; ByteBuffer dataBuffer = ByteBuffer . allocate ( numberToRead * gp . getElementSize ( ) ) ; indexFile . read ( actualOffset , dataBuffer ) ; dataBuffer . flip ( ) ; byte [ ] dataArray = new byte [ gp . getElementSize ( ) ] ; while ( dataBuffer . position ( ) < dataBuffer . limit ( ) ) { dataBuffer . get ( dataArray ) ; @ SuppressWarnings ( "unchecked" ) Data copy = ( Data ) prototype . fromByteBuffer ( ByteBuffer . wrap ( dataArray ) ) ; result . add ( copy ) ; } indexFile . close ( ) ; return result ; }
tr	C	@ Deprecated public double parseSexagesimal2 ( String number ) throws IllegalArgumentException { number = number . replace (   , : ) ; number = number . replace ( ; , : ) ; if ( number . indexOf ( ":" ) == - 1 ) { try { double n = double . parseDouble ( number ) ; return n ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Sexagesimal number format not correct (not even single number)" ) ; } } StringTokenizer st = new StringTokenizer ( number , ":" , false ) ; double degrees = 0 ; double minutes = 0 ; double seconds = 0 ; try { String aux = st . nextToken ( ) . trim ( ) ; if ( aux . length ( ) > 0 ) { degrees = double . parseDouble ( aux ) ; } aux = st . nextToken ( ) . trim ( ) ; if ( aux . length ( ) > 0 ) { minutes = double . parseDouble ( aux ) ; } if ( fractionLength > 5 ) { aux = st . nextToken ( ) . trim ( ) ; if ( aux . length ( ) > 0 ) { seconds = double . parseDouble ( aux ) ; } } } catch ( NoSuchElementException e ) { throw new IllegalArgumentException ( "Sexagesimal number format not correct" ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Sexagesimal number component not correct" ) ; } double res = degrees ; if ( degrees > 0 ) { res += ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } else { res -= ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } return res ; }
tr	F	public static String limitToTen ( String pastPrices ) { if ( pastPrices . contains ( "Split" ) ) System . out . println ( "**S-->" + pastPrices ) ; if ( pastPrices . equals ( "HISTORIC" ) ) return "#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#" + " #" + " #" ; split = 1 ; dividends = 0 ; String [ ] days = pastPrices . split ( "@" ) ; StringBuilder reconstruct = new StringBuilder ( ) ; int counter = 0 ; for ( int i = 0 ; i < days . length ; i ++ ) { String [ ] data = days [ i ] . split ( "_" ) ; if ( data . length < 9 ) { System . out . println ( pastPrices ) ; String [ ] determine = days [ i ] . split ( ":" ) ; try { if ( determine . length < 2 ) dividends += doDouble ( days [ i ] . split ( "_" ) [ 3 ] ) ; else if ( counter < 5 ) { split = doDouble ( determine [ 0 ] . split ( "_" ) [ 3 ] ) / doDouble ( determine [ 1 ] . toLowerCase ( ) . replace ( "stock_split" , "" ) . replaceAll ( "_" , "" ) ) ; System . out . println ( "SPLIT: " + split + "\nFrom: " + pastPrices ) ; } } catch ( Exception e ) { System . out . println ( days [ i ] ) ; e . printStackTrace ( ) ; } } else { reconstruct . append ( days [ i ] + "@" ) ; counter ++ ; if ( counter == 10 ) break ; } } for ( int j = counter - 1 ; j < 9 ; j ++ ) reconstruct . append ( "#_#_#_#_#_#_#_#_#@" ) ; return reconstruct . append ( " " + dividends + " " + split ) . deleteCharAt ( reconstruct . lastIndexOf ( "@" ) ) . toString ( ) ; }
tr	A	public DraughtsState getState ( ) { return NodeLVL2 . ds ; }
tr	J	@ Override protected void processMouseEvent ( MouseEvent e ) { if ( e . getID ( ) == MouseEvent . MOUSE_PRESSED ) { if ( e . getX ( ) >= XLEN || e . getY ( ) >= YLEN ) return ; point p = new point ( ( double ) e . getX ( ) / XLEN , ( double ) e . getY ( ) / YLEN , current_value ) ; point_list . addElement ( p ) ; draw_point ( p ) ; } }
tr	D	public static String analystEstimates ( String stock ) { int counting = 0 ; String httpdata = getHtml ( yahoobase + "/ae?s=" + stock ) ; String chop = "" ; if ( httpdata . contains ( "Earnings Est" ) && httpdata . contains ( "Currency in USD" ) ) { chop = httpdata . substring ( httpdata . indexOf ( "Earnings Est" ) , httpdata . indexOf ( "Currency in USD" ) ) . replaceAll ( "d><t" , "d> <t" ) . replaceAll ( "d></t" , "d>@</t" ) ; } String rval = "" ; chop = removeHtml ( ( chop ) , true ) . replaceAll ( "_" , " " ) ; for ( String k : estimatekeys ) { counting ++ ; if ( chop . contains ( k ) ) { if ( counting == 6 && chop . contains ( "Earnings Hist" ) ) chop = chop . substring ( chop . indexOf ( "Earnings Hist" ) ) ; String datapart = chop . substring ( chop . indexOf ( k ) + k . length ( ) ) ; if ( datapart . contains ( "@" ) ) datapart = datapart . substring ( 0 , datapart . indexOf ( "@" ) ) . trim ( ) ; for ( int i = 0 ; i < 4 - datapart . split ( " " ) . length ; i ++ ) datapart += "_#" ; rval += datapart + " " ; } else rval += "# # # # " ; } String backAt = ( rval . replaceAll ( "_" , " " ) . trim ( ) . replaceAll ( " " , "_" ) ) ; return backAt ; }
tr	F	protected void setSendHello ( boolean sendHello ) { this . sendHello = sendHello ; }
tr	A	public static String fileTitle ( String nasOrNy ) { double time = System . currentTimeMillis ( ) ; time /= 1000 ; time /= 3600 ; time /= 24 ; time = ( double ) ( ( int ) ( time * 10 ) / 10.0 ) ; return nasOrNy + "_" + time + ".txt" ; }
tr	B	private void mapRawData ( String [ ] tickers ) { System . out . println ( "total number of tickers: " + tickers . length ) ; int counter = 0 ; for ( String tk : tickers ) { StringBuilder saveAsText = new StringBuilder ( ) ; saveAsText . append ( cnnForecast ( tk ) . trim ( ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( analystEstimates ( tk ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( keyBasedData ( yahoobase + "/ks?s=" + tk , keykeys ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( limitToTen ( pastPrices ( tk ) ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( optionsCount ( tk ) ) ; if ( ! printQuickCount ( saveAsText ) ) System . out . println ( "\n--> " + saveAsText ) ; rawMap . put ( tk , saveAsText . toString ( ) ) ; } }
tr	B	private static void makeSureFilesExist ( String makeFileWithName ) { File newFile = new File ( makeFileWithName ) ; try { newFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	F	private void waitLines ( ) throws IOException { do { String s = bufferedreader . readLine ( ) ; if ( s == null ) break ; logReceived ( s ) ; try { Calendar start = Calendar . getInstance ( ) ; processStringRequest ( s ) ; Calendar end = Calendar . getInstance ( ) ; if ( end . getTimeInMillis ( ) - start . getTimeInMillis ( ) > 1000 ) Logger . getLogger ( getClass ( ) ) . info ( String . format ( "%s accept runned for %dms" , s , Calendar . getInstance ( ) . getTimeInMillis ( ) - start . getTimeInMillis ( ) ) ) ; } catch ( Exception e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } } while ( Thread . currentThread ( ) . isAlive ( ) ) ; }
tr	A	public INDISexagesimalFormatter ( String format ) throws IllegalArgumentException { this . format = format ; checkFormat ( ) ; }
tr	B	static void loadTickerSet ( String fileName , ArrayList < String > tickers ) { Scanner inFile = null ; try { inFile = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } if ( inFile == null ) { System . out . println ( "invalid file no symbols loaded" ) ; return ; } boolean firstLine = true ; while ( inFile . hasNextLine ( ) ) { String ticker = inFile . nextLine ( ) ; if ( firstLine ) { firstLine = false ; continue ; } String [ ] getTicker = ticker . split ( " " ) ; tickers . add ( getTicker [ 0 ] . replaceAll ( "\"" , "" ) ) ; } }
tr	G	private float calculateDifferenceBetweenAngles ( float firstAngle , float secondAngle ) { float difference = secondAngle - firstAngle ; while ( difference < - 180 ) difference += 360 ; while ( difference > 180 ) difference -= 360 ; return difference ; }
tr	C	public static void loadDataFromFile ( String fileName ) { Scanner previoustickers = null ; try { previoustickers = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String key = "" ; String value = "" ; while ( previoustickers . hasNextLine ( ) ) { String filedata = previoustickers . nextLine ( ) ; if ( filedata . equals ( "" ) ) continue ; String [ ] linedata = filedata . split ( "\\^" ) ; if ( linedata . length > 1 ) { key = linedata [ 0 ] ; value = linedata [ 1 ] ; lightMap . put ( key , dataLightSubprocessor ( value ) ) ; } } }
tr	D	public double parseSexagesimal ( String number ) throws IllegalArgumentException { number = number . trim ( ) ; if ( number . length ( ) == 0 ) { throw new IllegalArgumentException ( "Empty number" ) ; } number = number . replace (   , : ) ; number = number . replace ( ; , : ) ; int charCount = number . length ( ) - number . replaceAll ( ":" , "" ) . length ( ) ; if ( charCount > 2 ) { throw new IllegalArgumentException ( "Too many components for the sexagesimal formatter" ) ; } double degrees = 0 ; double minutes = 0 ; double seconds = 0 ; StringTokenizer st = new StringTokenizer ( number , ":" , false ) ; String d = st . nextToken ( ) . trim ( ) ; try { degrees = double . parseDouble ( d ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Number format incorrect" ) ; } if ( st . hasMoreTokens ( ) ) { String m = st . nextToken ( ) . trim ( ) ; try { minutes = double . parseDouble ( m ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Minutes format incorrect" ) ; } if ( minutes < 0 ) { throw new IllegalArgumentException ( "Minutes cannot be negative" ) ; } if ( st . hasMoreTokens ( ) ) { String s = st . nextToken ( ) . trim ( ) ; try { seconds = double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Seconds format incorrect" ) ; } if ( seconds < 0 ) { throw new IllegalArgumentException ( "Seconds cannot be negative" ) ; } } } double res = degrees ; if ( double . valueOf ( degrees ) . compareTo ( - 0. ) > 0 ) { res += ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } else { res -= ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } return res ; }
tr	B	public static int evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
tr	H	public long size ( ) throws FileLockException , IOException { long size = 0 ; for ( int bucketId = 0 ; bucketId < hashFunction . getNumberOfBuckets ( ) ; bucketId ++ ) { HeaderIndexFile < Data > headerIndexFile = new HeaderIndexFile < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( bucketId ) , gp . HEADER_FILE_LOCK_RETRY , gp ) ; size += headerIndexFile . getFilledUpFromContentStart ( ) / gp . getElementSize ( ) ; headerIndexFile . close ( ) ; } return size ; }
tr	J	static protected String getHtml ( String suf ) { URL url ; InputStream is ; InputStreamReader isr ; BufferedReader r ; String str = "" ; String nl = "" ; try { url = new URL ( suf ) ; is = url . openStream ( ) ; isr = new InputStreamReader ( is ) ; r = new BufferedReader ( isr ) ; do { nl = r . readLine ( ) ; if ( nl != null ) { nl = nl . trim ( ) + " " ; } str += nl ; } while ( nl != null ) ; } catch ( MalformedURLException e ) { System . out . println ( "Must enter a valid URL" ) ; } catch ( IOException e ) { } return str ; }
tr	G	public List < Data > searchForData ( HeaderIndexFile < Data > indexFile , byte [ ] ... keys ) throws IOException { Arrays . sort ( keys , new ByteArrayComparator ( ) ) ; List < Data > result = new ArrayList < Data > ( ) ; IndexForHeaderIndexFile index = indexFile . getIndex ( ) ; int actualChunkIdx = 0 , lastChunkIdx = - 1 ; long actualChunkOffset = 0 , oldChunkOffset = - 1 ; int indexInChunk = 0 ; ByteBuffer workingBuffer = ByteBuffer . allocate ( ( int ) indexFile . getChunkSize ( ) ) ; byte [ ] tmpB = new byte [ gp . getElementSize ( ) ] ; for ( byte [ ] key : keys ) { actualChunkIdx = index . getChunkId ( key ) ; actualChunkOffset = index . getStartOffsetOfChunk ( actualChunkIdx ) ; if ( actualChunkIdx != lastChunkIdx ) { if ( oldChunkOffset > - 1 ) { indexFile . read ( oldChunkOffset , workingBuffer ) ; indexInChunk = 0 ; } indexFile . read ( actualChunkOffset , workingBuffer ) ; } indexInChunk = findElementInReadBuffer ( workingBuffer , key , indexInChunk ) ; if ( indexInChunk == - 1 ) { indexInChunk = 0 ; continue ; } workingBuffer . position ( indexInChunk ) ; workingBuffer . get ( tmpB ) ; @ SuppressWarnings ( "unchecked" ) Data copy = ( Data ) prototype . fromByteBuffer ( ByteBuffer . wrap ( tmpB ) ) ; result . add ( copy ) ; if ( indexInChunk == - 1 ) { logger . warn ( "Element with key {} was not found." , key ) ; indexInChunk = 0 ; } lastChunkIdx = actualChunkIdx ; oldChunkOffset = actualChunkOffset ; } return result ; }
tr	B	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
tr	I	public static String reformat ( String input ) { String output = input . replaceAll ( "@" , "_" ) . replaceAll ( "^" , "_" ) . replaceAll ( "\\*" , "_" ) ; if ( input . contains ( "</table>" ) ) output = output . substring ( 0 , output . indexOf ( "</table>" ) ) ; output = output . replaceAll ( "d><t" , "d> <t" ) . replaceAll ( "h><t" , "h> <t" ) . replaceAll ( "d></t" , "d>@</t" ) . replaceAll ( "&nbsp;" , "-" ) . replaceAll ( "--" , "" ) ; return output ; }
tr	A	public void setBestMove ( int move ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
tr	I	private static double doDouble ( String value ) { try { double val = double . parseDouble ( value ) ; if ( val == val ) return val ; else return - 0.0000001 ; } catch ( Exception e ) { return - 0.0000001 ; } }
tr	J	public static String keyBasedData ( String addy , String [ ] keys ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( i > 0 ) System . out . println ( "\nConnection Failure. Trying again: " + i ) ; String httpdata = getHtml ( addy ) ; String yhdata = "" ; String str = httpdata ; if ( str . contains ( "was not found" ) ) return "#_#_#" ; if ( str . contains ( "Recommendation Trends" ) ) { str = ( str . substring ( str . indexOf ( "Recommendation Trends" ) ) ) ; str = str . replaceAll ( "d><t" , "d> <t" ) ; } for ( String key : keys ) { if ( str . contains ( ">" + key ) ) { String strx = str . substring ( str . indexOf ( ">" + key ) + 1 ) ; if ( ! strx . contains ( "</tr>" ) ) return "#_#_#" ; strx = strx . substring ( 0 , strx . indexOf ( "</tr>" ) ) ; if ( key . equals ( "Sector" ) ) strx = strx . replaceAll ( " " , "|" ) ; strx = removeHtml ( strx , true ) . replaceAll ( "@" , " " ) ; if ( strx . length ( ) == 0 ) strx = "#" ; yhdata += strx + "_" ; } else { yhdata += "#_" ; } } return ( yhdata . replaceAll ( "--" , "#" ) . replaceAll ( "_" , " " ) . trim ( ) . replaceAll ( " " , "_" ) ) ; } return "#_#" ; }
tr	D	public void insertOrMerge ( Data ... toPersist ) throws DRUMSException , InterruptedException { try { bucketContainer . addToCache ( toPersist ) ; } catch ( BucketContainerException ex ) { throw new DRUMSException ( ex ) ; } }
tr	D	public SyncManager < Data > getSyncManager ( ) { return this . syncManager ; }
tr	J	public DRUMSReader < Data > getReader ( ) throws FileLockException , IOException { if ( reader_instance != null && ! reader_instance . filesAreOpened ) { reader_instance . openFiles ( ) ; } else { reader_instance = new DRUMSReader < Data > ( this ) ; } return reader_instance ; }
tr	E	public static String cnnForecast ( String stock ) { for ( int i = 0 ; i < 4 ; i ++ ) { String httpdata = getHtml ( fcstbase + stock ) ; if ( httpdata == null ) System . out . println ( "null forecast" ) ; if ( httpdata . contains ( ">There is no" ) || httpdata . contains ( "was not found" ) ) { return "#_#" ; } String chop = "#_#" ; if ( httpdata . contains ( ">Stock Price Forecast" ) ) { if ( i > 0 ) System . out . print ( "\n*" + i + "*" ) ; chop = httpdata . substring ( httpdata . indexOf ( ">Stock Price Forecast" ) ) ; if ( chop . contains ( "Earnings and Sales Forecasts" ) && chop . contains ( "The" ) ) chop = chop . substring ( chop . indexOf ( "The" ) + 3 ) ; String analysts = "#" ; String forecast = "#" ; try { if ( chop . contains ( "analyst" ) ) analysts = chop . substring ( 0 , chop . indexOf ( "analyst" ) ) . trim ( ) ; if ( chop . contains ( "represents a" ) ) forecast = chop . substring ( chop . indexOf ( "represents a" ) + 12 , chop . indexOf ( "%" ) ) . replaceAll ( "_" , "" ) ; if ( forecast . contains ( ">" ) ) forecast = forecast . substring ( forecast . indexOf ( ">" ) + 1 ) . trim ( ) ; } catch ( Exception e ) { } chop = analysts + "_" + forecast ; } return ( chop ) ; } return "#_#_#" ; }
tr	E	@ Override public CloseHandshakeType getCloseHandshakeType ( ) { return CloseHandshakeType . ONEWAY ; }
va	A	@ Override public String getName ( ) { return "human" ; }
va	H	private void initNumRangePanel ( Composite mainPanel ) { numRangePanel = new Composite ( mainPanel , SWT . NONE ) ; numRangePanel . setLayout ( new MigLayout ( ) ) ; Label label = new Label ( numRangePanel , SWT . NONE ) ; label . setText ( "Minimum Value: " ) ; numMinValSp = new Spinner ( numRangePanel , SWT . BORDER ) ; numMinValSp . setLayoutData ( "width 50  wrap" ) ; numMinValSp . setMinimum ( - 9999999 ) ; numMinValSp . setMaximum ( 9999999 ) ; label = new Label ( numRangePanel , SWT . NONE ) ; label . setText ( "Maximum Value: " ) ; numMaxValSp = new Spinner ( numRangePanel , SWT . BORDER ) ; numMaxValSp . setLayoutData ( "width 50  wrap" ) ; numMaxValSp . setMinimum ( - 9999999 ) ; numMaxValSp . setMaximum ( 9999999 ) ; paddedBtn = new Button ( numRangePanel , SWT . CHECK ) ; paddedBtn . setText ( "Pad number with zeros" ) ; if ( fieldDef . getContentDef ( ) instanceof NumericRangeContentDef ) { NumericRangeContentDef cd = ( NumericRangeContentDef ) fieldDef . getContentDef ( ) ; numMinValSp . setSelection ( ( int ) cd . getMinVal ( ) ) ; numMaxValSp . setSelection ( ( int ) cd . getMaxVal ( ) ) ; paddedBtn . setSelection ( false ) ; numRangePanel . setVisible ( true ) ; } else if ( fieldDef . getContentDef ( ) instanceof PaddedIntContentDef ) { PaddedIntContentDef cd = ( PaddedIntContentDef ) fieldDef . getContentDef ( ) ; numMinValSp . setSelection ( cd . getMinVal ( ) ) ; numMaxValSp . setSelection ( cd . getMaxVal ( ) ) ; paddedBtn . setSelection ( true ) ; numRangePanel . setVisible ( true ) ; } else numRangePanel . setVisible ( false ) ; }
va	F	private void CheckLabActionPerformed ( java . awt . event . ActionEvent evt ) { if ( CheckLab . isSelected ( ) ) { CheckNombre . setEnabled ( false ) ; CheckTelefono . setEnabled ( false ) ; textBuscar . setEnabled ( true ) ; } else { CheckNombre . setEnabled ( true ) ; CheckTelefono . setEnabled ( true ) ; textBuscar . setEnabled ( false ) ; } }
va	D	void button_change_clicked ( ) { ++ current_value ; if ( current_value > 3 ) current_value = 1 ; }
va	F	protected void setDelimitadorEnvio ( String delimitadorEnvio ) { this . delimitadorEnvio = delimitadorEnvio ; }
va	I	public static String getShortNameAsProperty ( class < ? > clazz ) { String shortName = ClassUtils . getShortName ( clazz ) ; int dotIndex = shortName . lastIndexOf ( . ) ; shortName = ( dotIndex != - 1 ? shortName . substring ( dotIndex + 1 ) : shortName ) ; return Introspector . decapitalize ( shortName ) ; }
va	J	@ Override public void paint ( Graphics g ) { if ( buffer == null ) { buffer = this . createImage ( XLEN , YLEN ) ; buffer_gc = buffer . getGraphics ( ) ; buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . fillRect ( 0 , 0 , XLEN , YLEN ) ; } g . drawImage ( buffer , 0 , 0 , this ) ; }
va	E	public void setOutputFilter ( TcpMessageFilter outputFilter ) { this . outputFilter = outputFilter ; }
va	H	void putDirtyIntArray ( final int [ ] array ) { final int length = array . length ; if ( ( ( length & 1 ) == 0 ) && ( length <= MAX_ARRAY_SIZE ) ) { getDirtyIntArrayCache ( length ) . putDirtyArray ( array , length ) ; } }
va	B	private void checkFormat ( ) throws IllegalArgumentException { if ( ! format . startsWith ( "%" ) ) { throw new IllegalArgumentException ( "Number format not starting with %" ) ; } if ( ! format . endsWith ( "m" ) ) { throw new IllegalArgumentException ( "Sexagesimal format not recognized (not ending m)" ) ; } String remaining = format . substring ( 1 , format . length ( ) - 1 ) ; int dotPos = remaining . indexOf ( "." ) ; if ( dotPos == - 1 ) { throw new IllegalArgumentException ( "Sexagesimal format not correct (no dot)" ) ; } String l = remaining . substring ( 0 , dotPos ) ; String frLength = remaining . substring ( dotPos + 1 ) ; try { length = Integer . parseInt ( l ) ; fractionLength = Integer . parseInt ( frLength ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Illegal sexagesimal length or fraction length" ) ; } if ( ( fractionLength != 3 ) && ( fractionLength != 5 ) && ( fractionLength != 6 ) && ( fractionLength != 8 ) && ( fractionLength != 9 ) ) { throw new IllegalArgumentException ( "Illegal sexagesimal fraction length" ) ; } }
va	G	private static boolean shouldInLineType ( class < ? > clazz , Map < String , Object > options ) { if ( clazz . equals ( String . class ) ) { boolean inlineString = BuilderOptions . DEFAULT_INLINE_STRINGS ; if ( options . containsKey ( BuilderOptions . INLINE_STRINGS ) ) { inlineString = ( boolean ) options . get ( BuilderOptions . INLINE_STRINGS ) ; } return inlineString ; } if ( clazz . isPrimitive ( ) ) return true ; if ( isNumberObject ( clazz , options ) ) { boolean inlineNumbers = BuilderOptions . DEFAULT_INLINE_NUMBERS ; if ( options . containsKey ( BuilderOptions . INLINE_NUMBERS ) ) { inlineNumbers = ( boolean ) options . get ( BuilderOptions . INLINE_NUMBERS ) ; } return inlineNumbers ; } return false ; }
va	B	public String getFormat ( ) { return format ; }
va	C	void clear_all ( ) { point_list . removeAllElements ( ) ; if ( buffer != null ) { buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . fillRect ( 0 , 0 , XLEN , YLEN ) ; } repaint ( ) ; }
va	I	private void limpiarButtonActionPerformed ( java . awt . event . ActionEvent evt ) { limpiarTabla ( jTable1 ) ; buscarButton . setEnabled ( true ) ; CheckLab . setSelected ( false ) ; CheckNombre . setSelected ( false ) ; CheckTelefono . setSelected ( false ) ; CheckLab . setEnabled ( true ) ; CheckNombre . setEnabled ( true ) ; CheckTelefono . setEnabled ( true ) ; }
va	G	public FeatureVector createArcFeatures ( DependencyInstance inst , int h , int c ) { int attDist = getBinnedDistance ( h - c ) ; FeatureVector fv = new FeatureVector ( numArcFeats ) ; addBasic1OFeatures ( fv , inst , h , c , attDist ) ; addCore1OPosFeatures ( fv , inst , h , c , attDist ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . postagids [ h ] , inst . formids [ c ] , inst . postagids [ c ] , attDist ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . postagids [ h ] , inst . lemmaids [ c ] , inst . postagids [ c ] , attDist ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . cpostagids [ h ] , inst . formids [ c ] , inst . cpostagids [ c ] , attDist ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . cpostagids [ h ] , inst . lemmaids [ c ] , inst . cpostagids [ c ] , attDist ) ; if ( inst . featids [ h ] != null && inst . featids [ c ] != null ) { for ( int i = 0 , N = inst . featids [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = inst . featids [ c ] . length ; j < M ; ++ j ) { addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . featids [ h ] [ i ] , inst . formids [ c ] , inst . featids [ c ] [ j ] , attDist ) ; if ( inst . lemmas != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . featids [ h ] [ i ] , inst . lemmaids [ c ] , inst . featids [ c ] [ j ] , attDist ) ; } } return fv ; }
va	J	@ Override public Dimension getPreferredSize ( ) { return new Dimension ( XLEN , YLEN + 50 ) ; }
va	D	private static double atof ( String s ) { return double . valueOf ( s ) . doubleValue ( ) ; }
va	C	void draw_point ( point p ) { Color c = colors [ p . value + 3 ] ; Graphics window_gc = getGraphics ( ) ; buffer_gc . setColor ( c ) ; buffer_gc . fillRect ( ( int ) ( p . x * XLEN ) , ( int ) ( p . y * YLEN ) , 4 , 4 ) ; window_gc . setColor ( c ) ; window_gc . fillRect ( ( int ) ( p . x * XLEN ) , ( int ) ( p . y * YLEN ) , 4 , 4 ) ; }
va	E	public void setInputFilter ( TcpMessageFilter inputFilter ) { this . inputFilter = inputFilter ; }
va	A	@ Override public Move getMove ( DraughtsState s ) { throw new UnsupportedOperationException ( "should never be called!!!" ) ; }
te	C	void draw_all_points ( ) { int n = point_list . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) draw_point ( point_list . elementAt ( i ) ) ; }
te	D	private static int atoi ( String s ) { return Integer . parseInt ( s ) ; }
te	C	@ Override public HandshakeState acceptHandshakeAsClient ( ClientHandshake request , ServerHandshake response ) { if ( failed ) { return HandshakeState . NOT_MATCHED ; } try { if ( ! response . getFieldValue ( "Sec-WebSocket-Origin" ) . equals ( request . getFieldValue ( "Origin" ) ) || ! basicAccept ( response ) ) { return HandshakeState . NOT_MATCHED ; } byte [ ] content = response . getContent ( ) ; if ( content == null || content . length == 0 ) { throw new IncompleteHandshakeException ( ) ; } if ( Arrays . equals ( content , createChallenge ( request . getFieldValue ( "Sec-WebSocket-Key1" ) , request . getFieldValue ( "Sec-WebSocket-Key2" ) , request . getContent ( ) ) ) ) { return HandshakeState . MATCHED ; } else { return HandshakeState . NOT_MATCHED ; } } catch ( InvalidHandshakeException e ) { throw new RuntimeException ( "bad handshakerequest" , e ) ; } }
te	E	private void setRawSocket ( java . net . Socket rawSocket ) { this . rawSocket = rawSocket ; }
te	J	public static void main ( String [ ] argv ) { new AppletFrame ( "svm_toy" , new svm_toy ( ) , 500 , 500 + 50 ) ; }
te	A	@ Override public boolean isHuman ( ) { return true ; }
te	F	private static int getArrayLength ( Object ar ) throws BuildException { try { return Array . getLength ( ar ) ; } catch ( Exception e ) { throw new BuildException ( "Error getting length on " + ar . toString ( ) , e ) ; } }
te	F	private void buscarButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( textBuscar . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Escriba lo que desee buscar." , "Campo de busqueda vacio" , WIDTH ) ; } else { if ( CheckNombre . isSelected ( ) ) { try { result = stmt . executeQuery ( "Select proyectofarmacia.proveedores.Id_proveedores  proyectofarmacia.proveedores.Nombre_proveedores  proyectofarmacia.proveedores.Telefono_proveedores  proyectofarmacia.proveedores.Laboratorio_pertenece from proveedores where Nombre_proveedores= '" + textBuscar . getText ( ) + "'" ) ; if ( result . next ( ) ) { DefaultTableModel modelo = ( DefaultTableModel ) jTable1 . getModel ( ) ; Object [ ] nuevo = { modelo . getRowCount ( ) , "" , "" } ; modelo . addRow ( nuevo ) ; int id = result . getInt ( "Id_proveedores" ) ; jTable1 . setValueAt ( id , 0 , 0 ) ; String nombre = result . getString ( "Nombre_proveedores" ) ; jTable1 . setValueAt ( nombre , 0 , 1 ) ; String telefono = result . getString ( "Telefono_proveedores" ) ; jTable1 . setValueAt ( telefono , 0 , 2 ) ; String lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , 0 , 3 ) ; for ( int i = 1 ; result . next ( ) ; i ++ ) { modelo . addRow ( nuevo ) ; id = result . getInt ( "Id_" ) ; jTable1 . setValueAt ( id , i , 0 ) ; nombre = result . getString ( "Nombre_medicamentos" ) ; jTable1 . setValueAt ( nombre , i , 1 ) ; telefono = result . getString ( "Telefono_medicamentos" ) ; jTable1 . setValueAt ( telefono , i , 2 ) ; lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , i , 3 ) ; } textBuscar . setText ( "" ) ; buscarButton . setEnabled ( false ) ; } else { int aviso = JOptionPane . showConfirmDialog ( this , "No existe proveedor con ese nombre. \n Desea agregarlo?" , "Busqueda sin exito" , JOptionPane . YES_NO_OPTION ) ; if ( aviso == JOptionPane . YES_OPTION ) { RegistroProveedores prov = new RegistroProveedores ( ) ; prov . mostrar ( ) ; } textBuscar . setText ( "" ) ; textBuscar . setText ( "" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( this , "Error al tratar de conectar la base  verifica tus datos de conexion" ) ; } } if ( CheckLab . isSelected ( ) ) { try { result = stmt . executeQuery ( "Select proyectofarmacia.proveedores.Id_proveedores  proyectofarmacia.proveedores.Nombre_proveedores  proyectofarmacia.proveedores.Telefono_proveedores  proyectofarmacia.proveedores.Laboratorio_pertenece from proveedores where Laboratorio_pertenece= '" + textBuscar . getText ( ) + "'" ) ; if ( result . next ( ) ) { DefaultTableModel modelo = ( DefaultTableModel ) jTable1 . getModel ( ) ; Object [ ] nuevo = { modelo . getRowCount ( ) , "" , "" } ; modelo . addRow ( nuevo ) ; int id = result . getInt ( "Id_proveedores" ) ; jTable1 . setValueAt ( id , 0 , 0 ) ; String nombre = result . getString ( "Nombre_proveedores" ) ; jTable1 . setValueAt ( nombre , 0 , 1 ) ; String telefono = result . getString ( "Telefono_proveedores" ) ; jTable1 . setValueAt ( telefono , 0 , 2 ) ; String lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , 0 , 3 ) ; for ( int i = 1 ; result . next ( ) ; i ++ ) { modelo . addRow ( nuevo ) ; id = result . getInt ( "Id_" ) ; jTable1 . setValueAt ( id , i , 0 ) ; nombre = result . getString ( "Nombre_medicamentos" ) ; jTable1 . setValueAt ( nombre , i , 1 ) ; telefono = result . getString ( "Telefono_medicamentos" ) ; jTable1 . setValueAt ( telefono , i , 2 ) ; lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , i , 3 ) ; } textBuscar . setText ( "" ) ; buscarButton . setEnabled ( false ) ; } else { int aviso = JOptionPane . showConfirmDialog ( this , "No existe proveedor perteneciente a ese laboratorio. \n Desea agregarlo?" , "Busqueda sin exito" , JOptionPane . YES_NO_OPTION ) ; if ( aviso == JOptionPane . YES_OPTION ) { RegistroProveedores prov = new RegistroProveedores ( ) ; prov . mostrar ( ) ; } textBuscar . setText ( "" ) ; textBuscar . setText ( "" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( this , "Error al tratar de conectar la base  verifica tus datos de conexion" ) ; } } if ( CheckTelefono . isSelected ( ) ) { try { result = stmt . executeQuery ( "Select proyectofarmacia.proveedores.Id_proveedores  proyectofarmacia.proveedores.Nombre_proveedores  proyectofarmacia.proveedores.Telefono_proveedores  proyectofarmacia.proveedores.Laboratorio_pertenece from proveedores where Telefono_proveedores= '" + textBuscar . getText ( ) + "'" ) ; if ( result . next ( ) ) { DefaultTableModel modelo = ( DefaultTableModel ) jTable1 . getModel ( ) ; Object [ ] nuevo = { modelo . getRowCount ( ) , "" , "" } ; modelo . addRow ( nuevo ) ; int id = result . getInt ( "Id_proveedores" ) ; jTable1 . setValueAt ( id , 0 , 0 ) ; String nombre = result . getString ( "Nombre_proveedores" ) ; jTable1 . setValueAt ( nombre , 0 , 1 ) ; String telefono = result . getString ( "Telefono_proveedores" ) ; jTable1 . setValueAt ( telefono , 0 , 2 ) ; String lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , 0 , 3 ) ; for ( int i = 1 ; result . next ( ) ; i ++ ) { modelo . addRow ( nuevo ) ; id = result . getInt ( "Id_" ) ; jTable1 . setValueAt ( id , i , 0 ) ; nombre = result . getString ( "Nombre_medicamentos" ) ; jTable1 . setValueAt ( nombre , i , 1 ) ; telefono = result . getString ( "Telefono_medicamentos" ) ; jTable1 . setValueAt ( telefono , i , 2 ) ; lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , i , 3 ) ; } textBuscar . setText ( "" ) ; buscarButton . setEnabled ( false ) ; } else { int aviso = JOptionPane . showConfirmDialog ( this , "No exsite proveedor con ese telefono. \n Desea agregarlo?" , "Busqueda sin exito" , JOptionPane . YES_NO_OPTION ) ; if ( aviso == JOptionPane . YES_OPTION ) { RegistroProveedores prov = new RegistroProveedores ( ) ; prov . mostrar ( ) ; } textBuscar . setText ( "" ) ; textBuscar . setText ( "" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( this , "Error al tratar de conectar la base  verifica tus datos de conexion" ) ; } } } }
te	B	@ Override public void putEnd ( ) throws ParsingException { close ( ) ; }
te	D	void button_run_clicked ( String args ) { if ( point_list . isEmpty ( ) ) return ; svm_parameter param = new svm_parameter ( ) ; param . svm_type = svm_parameter . C_SVC ; param . kernel_type = svm_parameter . RBF ; param . degree = 3 ; param . gamma = 0 ; param . coef0 = 0 ; param . nu = 0.5 ; param . cache_size = 40 ; param . C = 1 ; param . eps = 1e-3 ; param . p = 0.1 ; param . shrinking = 1 ; param . probability = 0 ; param . nr_weight = 0 ; param . weight_label = new int [ 0 ] ; param . weight = new double [ 0 ] ; StringTokenizer st = new StringTokenizer ( args ) ; String [ ] argv = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i < argv . length ; i ++ ) argv [ i ] = st . nextToken ( ) ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( argv [ i ] . charAt ( 0 ) != - ) break ; if ( ++ i >= argv . length ) { System . err . print ( "unknown option\n" ) ; break ; } switch ( argv [ i - 1 ] . charAt ( 1 ) ) { case s : param . svm_type = atoi ( argv [ i ] ) ; break ; case t : param . kernel_type = atoi ( argv [ i ] ) ; break ; case d : param . degree = atoi ( argv [ i ] ) ; break ; case g : param . gamma = atof ( argv [ i ] ) ; break ; case r : param . coef0 = atof ( argv [ i ] ) ; break ; case n : param . nu = atof ( argv [ i ] ) ; break ; case m : param . cache_size = atof ( argv [ i ] ) ; break ; case c : param . C = atof ( argv [ i ] ) ; break ; case e : param . eps = atof ( argv [ i ] ) ; break ; case p : param . p = atof ( argv [ i ] ) ; break ; case h : param . shrinking = atoi ( argv [ i ] ) ; break ; case b : param . probability = atoi ( argv [ i ] ) ; break ; case w : ++ param . nr_weight ; { int [ ] old = param . weight_label ; param . weight_label = new int [ param . nr_weight ] ; System . arraycopy ( old , 0 , param . weight_label , 0 , param . nr_weight - 1 ) ; } { double [ ] old = param . weight ; param . weight = new double [ param . nr_weight ] ; System . arraycopy ( old , 0 , param . weight , 0 , param . nr_weight - 1 ) ; } param . weight_label [ param . nr_weight - 1 ] = atoi ( argv [ i - 1 ] . substring ( 2 ) ) ; param . weight [ param . nr_weight - 1 ] = atof ( argv [ i ] ) ; break ; default : System . err . print ( "unknown option\n" ) ; } } svm_problem prob = new svm_problem ( ) ; prob . l = point_list . size ( ) ; prob . y = new double [ prob . l ] ; if ( param . kernel_type == svm_parameter . PRECOMPUTED ) { } else if ( param . svm_type == svm_parameter . EPSILON_SVR || param . svm_type == svm_parameter . NU_SVR ) { if ( param . gamma == 0 ) param . gamma = 1 ; prob . x = new svm_node [ prob . l ] [ 1 ] ; for ( int i = 0 ; i < prob . l ; i ++ ) { point p = point_list . elementAt ( i ) ; prob . x [ i ] [ 0 ] = new svm_node ( ) ; prob . x [ i ] [ 0 ] . index = 1 ; prob . x [ i ] [ 0 ] . value = p . x ; prob . y [ i ] = p . y ; } svm_model model = svm . svm_train ( prob , param ) ; svm_node [ ] x = new svm_node [ 1 ] ; x [ 0 ] = new svm_node ( ) ; x [ 0 ] . index = 1 ; int [ ] j = new int [ XLEN ] ; Graphics window_gc = getGraphics ( ) ; for ( int i = 0 ; i < XLEN ; i ++ ) { x [ 0 ] . value = ( double ) i / XLEN ; j [ i ] = ( int ) ( YLEN * svm . svm_predict ( model , x ) ) ; } buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . drawLine ( 0 , 0 , 0 , YLEN - 1 ) ; window_gc . setColor ( colors [ 0 ] ) ; window_gc . drawLine ( 0 , 0 , 0 , YLEN - 1 ) ; int p = ( int ) ( param . p * YLEN ) ; for ( int i = 1 ; i < XLEN ; i ++ ) { buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . drawLine ( i , 0 , i , YLEN - 1 ) ; window_gc . setColor ( colors [ 0 ] ) ; window_gc . drawLine ( i , 0 , i , YLEN - 1 ) ; buffer_gc . setColor ( colors [ 5 ] ) ; window_gc . setColor ( colors [ 5 ] ) ; buffer_gc . drawLine ( i - 1 , j [ i - 1 ] , i , j [ i ] ) ; window_gc . drawLine ( i - 1 , j [ i - 1 ] , i , j [ i ] ) ; if ( param . svm_type == svm_parameter . EPSILON_SVR ) { buffer_gc . setColor ( colors [ 2 ] ) ; window_gc . setColor ( colors [ 2 ] ) ; buffer_gc . drawLine ( i - 1 , j [ i - 1 ] + p , i , j [ i ] + p ) ; window_gc . drawLine ( i - 1 , j [ i - 1 ] + p , i , j [ i ] + p ) ; buffer_gc . setColor ( colors [ 2 ] ) ; window_gc . setColor ( colors [ 2 ] ) ; buffer_gc . drawLine ( i - 1 , j [ i - 1 ] - p , i , j [ i ] - p ) ; window_gc . drawLine ( i - 1 , j [ i - 1 ] - p , i , j [ i ] - p ) ; } } } else { if ( param . gamma == 0 ) param . gamma = 0.5 ; prob . x = new svm_node [ prob . l ] [ 2 ] ; for ( int i = 0 ; i < prob . l ; i ++ ) { point p = point_list . elementAt ( i ) ; prob . x [ i ] [ 0 ] = new svm_node ( ) ; prob . x [ i ] [ 0 ] . index = 1 ; prob . x [ i ] [ 0 ] . value = p . x ; prob . x [ i ] [ 1 ] = new svm_node ( ) ; prob . x [ i ] [ 1 ] . index = 2 ; prob . x [ i ] [ 1 ] . value = p . y ; prob . y [ i ] = p . value ; } svm_model model = svm . svm_train ( prob , param ) ; svm_node [ ] x = new svm_node [ 2 ] ; x [ 0 ] = new svm_node ( ) ; x [ 1 ] = new svm_node ( ) ; x [ 0 ] . index = 1 ; x [ 1 ] . index = 2 ; Graphics window_gc = getGraphics ( ) ; for ( int i = 0 ; i < XLEN ; i ++ ) for ( int j = 0 ; j < YLEN ; j ++ ) { x [ 0 ] . value = ( double ) i / XLEN ; x [ 1 ] . value = ( double ) j / YLEN ; double d = svm . svm_predict ( model , x ) ; if ( param . svm_type == svm_parameter . ONE_CLASS && d < 0 ) d = 2 ; buffer_gc . setColor ( colors [ ( int ) d ] ) ; window_gc . setColor ( colors [ ( int ) d ] ) ; buffer_gc . drawLine ( i , j , i , j ) ; window_gc . drawLine ( i , j , i , j ) ; } } draw_all_points ( ) ; }
te	I	public int print ( Graphics graphics , PageFormat pageFormat , int pageIndex ) throws PrinterException { if ( pageIndex < calcPages ( ( int ) pageFormat . getImageableWidth ( ) - padding * 2 , ( int ) pageFormat . getImageableHeight ( ) - padding * 2 ) ) { paintGrid ( graphics , pageFormat , pageIndex , 1.0 ) ; return Printable . PAGE_EXISTS ; } else { return Printable . NO_SUCH_PAGE ; } }
te	H	float [ ] getDirtyFloatArray ( final int length ) { if ( length <= MAX_ARRAY_SIZE ) { return getDirtyFloatArrayCache ( length ) . getArray ( ) ; } if ( DO_STATS ) { incOversize ( ) ; } if ( DO_LOG_OVER_SIZE ) { logInfo ( "getDirtyFloatArray[oversize]: length=\t" + length + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return new float [ length ] ; }
te	E	private void socketLifeCycle ( ) { notifyConnection ( ) ; if ( isSendHello ( ) ) sendHello ( ) ; try { waitLines ( ) ; Logger . getLogger ( getClass ( ) ) . info ( "Disconnected!" ) ; } catch ( SocketException e ) { Logger . getLogger ( getClass ( ) ) . warn ( e . getMessage ( ) ) ; } catch ( SocketTimeoutException e ) { Logger . getLogger ( getClass ( ) ) . warn ( e . getMessage ( ) ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } finally { if ( getRawSocket ( ) != null ) Logger . getLogger ( getClass ( ) ) . info ( new StringBuffer ( "Disconnect from " ) . append ( getRawSocket ( ) . getInetAddress ( ) . getHostName ( ) ) ) ; try { disconnect ( ) ; notifyDisconnection ( ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } } }
te	B	@ Override public void putNewLine ( ) throws ParsingException { if ( token . isStarted ( ) ) putChar ( Characters . NEWLINE ) ; else token . start ( ) ; }
te	I	public static String getClassFileName ( class < ? > clazz ) { assert . notNull ( clazz , "Class must not be null" ) ; String className = clazz . getName ( ) ; int lastDotIndex = className . lastIndexOf ( PACKAGE_SEPARATOR ) ; return className . substring ( lastDotIndex + 1 ) + CLASS_FILE_SUFFIX ; }
te	A	public TextHandler ( TokenContext context ) { super ( context ) ; this . token = new Token ( ) ; }
te	J	private void btnNuevoActionPerformed ( java . awt . event . ActionEvent evt ) { desbloquear ( ) ; txtCedula . requestFocus ( ) ; }
te	G	private static boolean isNumberObject ( class < ? > clazz , Map < String , Object > options ) { if ( clazz . equals ( byte . class ) ) return true ; if ( clazz . equals ( short . class ) ) return true ; if ( clazz . equals ( Integer . class ) ) return true ; if ( clazz . equals ( long . class ) ) return true ; if ( clazz . equals ( float . class ) ) return true ; if ( clazz . equals ( double . class ) ) return true ; return false ; }
te	H	FloatArrayCache getDirtyFloatArrayCache ( final int length ) { final int bucket = ArrayCache . getBucket ( length ) ; return getArrayCachesHolder ( ) . dirtyFloatArrayCaches [ bucket ] ; }
te	G	private static String getClassName ( Object o ) { return o . getClass ( ) . getSimpleName ( ) ; }
