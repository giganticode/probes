tr	D	public double parseSexagesimal ( String number ) throws IllegalArgumentException { number = number . trim ( ) ; if ( number . length ( ) == 0 ) { throw new IllegalArgumentException ( "Empty number" ) ; } number = number . replace (   , : ) ; number = number . replace ( ; , : ) ; int charCount = number . length ( ) - number . replaceAll ( ":" , "" ) . length ( ) ; if ( charCount > 2 ) { throw new IllegalArgumentException ( "Too many components for the sexagesimal formatter" ) ; } double degrees = 0 ; double minutes = 0 ; double seconds = 0 ; StringTokenizer st = new StringTokenizer ( number , ":" , false ) ; String d = st . nextToken ( ) . trim ( ) ; try { degrees = double . parseDouble ( d ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Number format incorrect" ) ; } if ( st . hasMoreTokens ( ) ) { String m = st . nextToken ( ) . trim ( ) ; try { minutes = double . parseDouble ( m ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Minutes format incorrect" ) ; } if ( minutes < 0 ) { throw new IllegalArgumentException ( "Minutes cannot be negative" ) ; } if ( st . hasMoreTokens ( ) ) { String s = st . nextToken ( ) . trim ( ) ; try { seconds = double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Seconds format incorrect" ) ; } if ( seconds < 0 ) { throw new IllegalArgumentException ( "Seconds cannot be negative" ) ; } } } double res = degrees ; if ( double . valueOf ( degrees ) . compareTo ( - 0. ) > 0 ) { res += ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } else { res -= ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } return res ; }
tr	D	public float getVelocityY ( ) { return ( float ) velocity . y ; }
tr	D	private Connection createNewConnection ( ) { Connection myconn = null ; try { try { class < ? > myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CDbError . logError ( errfile , false , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myconn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myconn == null ) { CDbError . logError ( errfile , false , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } if ( ! testConnection ( myconn ) ) { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; CDbError . logError ( errfile , false , "New connection failed test" , null ) ; return ( null ) ; } } catch ( Exception e ) { CDbError . logError ( errfile , false , "Error making connection: " , e ) ; return ( null ) ; } return ( myconn ) ; }
tr	A	protected DOMNodeListByTagNameImpl ( Node first , String tagName ) { this . first = first ; this . tagName = tagName ; }
tr	B	private void mapRawData ( String [ ] tickers ) { System . out . println ( "total number of tickers: " + tickers . length ) ; int counter = 0 ; for ( String tk : tickers ) { StringBuilder saveAsText = new StringBuilder ( ) ; saveAsText . append ( cnnForecast ( tk ) . trim ( ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( analystEstimates ( tk ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( keyBasedData ( yahoobase + "/ks?s=" + tk , keykeys ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( limitToTen ( pastPrices ( tk ) ) ) ; saveAsText . append ( " " ) ; saveAsText . append ( optionsCount ( tk ) ) ; if ( ! printQuickCount ( saveAsText ) ) System . out . println ( "\n--> " + saveAsText ) ; rawMap . put ( tk , saveAsText . toString ( ) ) ; } }
tr	I	public void setValue ( Object arg0 ) { int year = Integer . parseInt ( ( String ) arg0 ) ; setCalendar ( Calendar . YEAR , year ) ; }
tr	F	private Query < M > parseSelectQuery ( String query ) { if ( query == null ) { return new Query < > ( allFields ( ) , null ) ; } Matcher matcher = RegexUtil . matcher ( "^(?i)(?:SELECT (.+?) *)?(?:FROM .+? *)?((?:WHERE .+)?(?:ORDER BY .+)?)$" , query ) ; if ( ! matcher . matches ( ) ) { throw new RuntimeException ( "Can not parse this query: " + query ) ; } return new Query < > ( parseFields ( matcher . group ( 1 ) ) , matcher . group ( 2 ) ) ; }
tr	G	public void initFonts ( ) { int boxH = ( int ) ( boxHInches * anInch ) ; int boxW = ( int ) ( boxWInches * anInch ) ; int fontSize = 60 ; FontMetrics metrics ; do { chineseFont = new Font ( chineseFont . getFontName ( ) , Font . PLAIN , fontSize -= 1 ) ; metrics = getFontMetrics ( chineseFont ) ; } while ( metrics . getHeight ( ) > boxH * 3f / 4f ) ; fontSize = 20 ; do { pinyinFont = new Font ( pinyinFont . getFontName ( ) , Font . PLAIN , fontSize -= 1 ) ; metrics = getFontMetrics ( pinyinFont ) ; } while ( getFontWidth ( pinyinFont ) * 8 > boxW ) ; fontSize = 10 ; do { otherFont = new Font ( otherFont . getFontName ( ) , Font . PLAIN , fontSize -= 1 ) ; metrics = getFontMetrics ( otherFont ) ; } while ( getFontWidth ( otherFont ) * 8 > boxW ) ; CharProps . getProperties ( ) . setProperty ( "font.ch.face" , chineseFont . getFontName ( ) ) ; CharProps . getProperties ( ) . setProperty ( "font.ch.size" , chineseFont . getSize ( ) + "" ) ; CharProps . getProperties ( ) . setProperty ( "font.ch.style" , chineseFont . getStyle ( ) + "" ) ; CharProps . getProperties ( ) . setProperty ( "font.pinyin.face" , pinyinFont . getFontName ( ) ) ; CharProps . getProperties ( ) . setProperty ( "font.pinyin.size" , pinyinFont . getSize ( ) + "" ) ; CharProps . getProperties ( ) . setProperty ( "font.pinyin.style" , pinyinFont . getStyle ( ) + "" ) ; CharProps . getProperties ( ) . setProperty ( "font.other.face" , otherFont . getFontName ( ) ) ; CharProps . getProperties ( ) . setProperty ( "font.other.size" , otherFont . getSize ( ) + "" ) ; CharProps . getProperties ( ) . setProperty ( "font.other.style" , otherFont . getStyle ( ) + "" ) ; }
tr	J	private int compute_qr ( double [ ] s , double [ ] e , double [ ] u , double [ ] v ) { int k ; boolean converged ; double shift , r ; double utemp , vtemp ; double f , g ; final int MAX_INTERATIONS = 10 ; final double CONVERGE_TOL = 4.89E-15 ; double c_b48 = 1. ; int first ; converged = false ; first = 1 ; if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL || Math . abs ( e [ 0 ] ) < CONVERGE_TOL ) converged = true ; for ( k = 0 ; k < MAX_INTERATIONS && ! converged ; k ++ ) { shift = compute_shift ( s [ 1 ] , e [ 1 ] , s [ 2 ] ) ; f = ( Math . abs ( s [ 0 ] ) - shift ) * ( d_sign ( c_b48 , s [ 0 ] ) + shift / s [ 0 ] ) ; g = e [ 0 ] ; r = compute_rot ( f , g , sinr , cosr , 0 , first ) ; f = cosr [ 0 ] * s [ 0 ] + sinr [ 0 ] * e [ 0 ] ; e [ 0 ] = cosr [ 0 ] * e [ 0 ] - sinr [ 0 ] * s [ 0 ] ; g = sinr [ 0 ] * s [ 1 ] ; s [ 1 ] = cosr [ 0 ] * s [ 1 ] ; r = compute_rot ( f , g , sinl , cosl , 0 , first ) ; first = 0 ; s [ 0 ] = r ; f = cosl [ 0 ] * e [ 0 ] + sinl [ 0 ] * s [ 1 ] ; s [ 1 ] = cosl [ 0 ] * s [ 1 ] - sinl [ 0 ] * e [ 0 ] ; g = sinl [ 0 ] * e [ 1 ] ; e [ 1 ] = cosl [ 0 ] * e [ 1 ] ; r = compute_rot ( f , g , sinr , cosr , 1 , first ) ; e [ 0 ] = r ; f = cosr [ 1 ] * s [ 1 ] + sinr [ 1 ] * e [ 1 ] ; e [ 1 ] = cosr [ 1 ] * e [ 1 ] - sinr [ 1 ] * s [ 1 ] ; g = sinr [ 1 ] * s [ 2 ] ; s [ 2 ] = cosr [ 1 ] * s [ 2 ] ; r = compute_rot ( f , g , sinl , cosl , 1 , first ) ; s [ 1 ] = r ; f = cosl [ 1 ] * e [ 1 ] + sinl [ 1 ] * s [ 2 ] ; s [ 2 ] = cosl [ 1 ] * s [ 2 ] - sinl [ 1 ] * e [ 1 ] ; e [ 1 ] = f ; utemp = u [ 0 ] ; u [ 0 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 3 ] ; u [ 3 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 3 ] ; utemp = u [ 1 ] ; u [ 1 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 4 ] ; u [ 4 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 4 ] ; utemp = u [ 2 ] ; u [ 2 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 5 ] ; u [ 5 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 5 ] ; utemp = u [ 3 ] ; u [ 3 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 6 ] ; u [ 6 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 6 ] ; utemp = u [ 4 ] ; u [ 4 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 7 ] ; u [ 7 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 7 ] ; utemp = u [ 5 ] ; u [ 5 ] = cosl [ 1 ] * utemp + sinl [ 1 ] * u [ 8 ] ; u [ 8 ] = - sinl [ 1 ] * utemp + cosl [ 1 ] * u [ 8 ] ; vtemp = v [ 0 ] ; v [ 0 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 1 ] ; v [ 1 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 1 ] ; vtemp = v [ 3 ] ; v [ 3 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 4 ] ; v [ 4 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 4 ] ; vtemp = v [ 6 ] ; v [ 6 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 7 ] ; v [ 7 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 7 ] ; vtemp = v [ 1 ] ; v [ 1 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 2 ] ; v [ 2 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 2 ] ; vtemp = v [ 4 ] ; v [ 4 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 5 ] ; v [ 5 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 5 ] ; vtemp = v [ 7 ] ; v [ 7 ] = cosr [ 1 ] * vtemp + sinr [ 1 ] * v [ 8 ] ; v [ 8 ] = - sinr [ 1 ] * vtemp + cosr [ 1 ] * v [ 8 ] ; m [ 0 ] = s [ 0 ] ; m [ 1 ] = e [ 0 ] ; m [ 2 ] = 0.0 ; m [ 3 ] = 0.0 ; m [ 4 ] = s [ 1 ] ; m [ 5 ] = e [ 1 ] ; m [ 6 ] = 0.0 ; m [ 7 ] = 0.0 ; m [ 8 ] = s [ 2 ] ; if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL || Math . abs ( e [ 0 ] ) < CONVERGE_TOL ) converged = true ; } if ( Math . abs ( e [ 1 ] ) < CONVERGE_TOL ) { compute_2X2 ( s [ 0 ] , e [ 0 ] , s [ 1 ] , s , sinl , cosl , sinr , cosr , 0 ) ; utemp = u [ 0 ] ; u [ 0 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 3 ] ; u [ 3 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 3 ] ; utemp = u [ 1 ] ; u [ 1 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 4 ] ; u [ 4 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 4 ] ; utemp = u [ 2 ] ; u [ 2 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 5 ] ; u [ 5 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 5 ] ; vtemp = v [ 0 ] ; v [ 0 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 1 ] ; v [ 1 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 1 ] ; vtemp = v [ 3 ] ; v [ 3 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 4 ] ; v [ 4 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 4 ] ; vtemp = v [ 6 ] ; v [ 6 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 7 ] ; v [ 7 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 7 ] ; } else { compute_2X2 ( s [ 1 ] , e [ 1 ] , s [ 2 ] , s , sinl , cosl , sinr , cosr , 1 ) ; utemp = u [ 3 ] ; u [ 3 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 6 ] ; u [ 6 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 6 ] ; utemp = u [ 4 ] ; u [ 4 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 7 ] ; u [ 7 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 7 ] ; utemp = u [ 5 ] ; u [ 5 ] = cosl [ 0 ] * utemp + sinl [ 0 ] * u [ 8 ] ; u [ 8 ] = - sinl [ 0 ] * utemp + cosl [ 0 ] * u [ 8 ] ; vtemp = v [ 1 ] ; v [ 1 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 2 ] ; v [ 2 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 2 ] ; vtemp = v [ 4 ] ; v [ 4 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 5 ] ; v [ 5 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 5 ] ; vtemp = v [ 7 ] ; v [ 7 ] = cosr [ 0 ] * vtemp + sinr [ 0 ] * v [ 8 ] ; v [ 8 ] = - sinr [ 0 ] * vtemp + cosr [ 0 ] * v [ 8 ] ; } return ( 0 ) ; }
tr	J	private static String getQualifiedNameForArray ( class < ? > clazz ) { StringBuilder result = new StringBuilder ( ) ; while ( clazz . isArray ( ) ) { clazz = clazz . getComponentType ( ) ; result . append ( ClassUtils . ARRAY_SUFFIX ) ; } result . insert ( 0 , clazz . getName ( ) ) ; return result . toString ( ) ; }
tr	H	public Collection < Val > values ( ) { return new AbstractCollection < Val > ( ) { public Iterator < Val > iterator ( ) { return new FTMValueIterator < Val > ( tree ) ; } public int size ( ) { return FTreeMap . this . size ( ) ; } } ; }
tr	A	public Cliente ( ) { initComponents ( ) ; limpiar ( ) ; bloquear ( ) ; cargar ( "" ) ; }
tr	D	public static String analystEstimates ( String stock ) { int counting = 0 ; String httpdata = getHtml ( yahoobase + "/ae?s=" + stock ) ; String chop = "" ; if ( httpdata . contains ( "Earnings Est" ) && httpdata . contains ( "Currency in USD" ) ) { chop = httpdata . substring ( httpdata . indexOf ( "Earnings Est" ) , httpdata . indexOf ( "Currency in USD" ) ) . replaceAll ( "d><t" , "d> <t" ) . replaceAll ( "d></t" , "d>@</t" ) ; } String rval = "" ; chop = removeHtml ( ( chop ) , true ) . replaceAll ( "_" , " " ) ; for ( String k : estimatekeys ) { counting ++ ; if ( chop . contains ( k ) ) { if ( counting == 6 && chop . contains ( "Earnings Hist" ) ) chop = chop . substring ( chop . indexOf ( "Earnings Hist" ) ) ; String datapart = chop . substring ( chop . indexOf ( k ) + k . length ( ) ) ; if ( datapart . contains ( "@" ) ) datapart = datapart . substring ( 0 , datapart . indexOf ( "@" ) ) . trim ( ) ; for ( int i = 0 ; i < 4 - datapart . split ( " " ) . length ; i ++ ) datapart += "_#" ; rval += datapart + " " ; } else rval += "# # # # " ; } String backAt = ( rval . replaceAll ( "_" , " " ) . trim ( ) . replaceAll ( " " , "_" ) ) ; return backAt ; }
tr	G	public void decrementResources ( int [ ] cost ) { for ( int resourcei = 0 ; resourcei < ResourceGrid . RESOURCE_NAMES . length ; resourcei ++ ) { resources [ resourcei ] -= cost [ resourcei ] ; } }
tr	C	private void manageGameMessage ( int senderID , GameMessage msg ) { if ( gameServer == null ) { console . displayMessage ( "Got gameMessage but game server is null." ) ; } else { gameServer . gameMessage ( senderID , msg ) ; } }
tr	E	public int getVerifiedType ( ) { return verifiedType ; }
tr	G	static List < User > constructResult ( Response res ) throws WeiboException { JSONArray list = res . asJSONArray ( ) ; try { int size = list . length ( ) ; List < User > users = new ArrayList < User > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { users . add ( new User ( list . getJSONObject ( i ) ) ) ; } return users ; } catch ( JSONException e ) { } return null ; }
tr	F	String OriginalComment ( int commentID ) { String comment = "" ; DatabaseConnection db = new DatabaseConnection ( ) ; Connection conn = db . connectToDB ( ) ; String sql = "Select * from " ; if ( bookType == 0 ) { ParentCommentTextArea . setText ( "Insert question below" ) ; } else if ( bookType == 1 ) { sql += "`ForumQuestions` where QuestionID = '" + commentID + "'" ; ResultSet rs = db . getResults ( conn , sql ) ; try { if ( rs . next ( ) ) { ParentCommentTextArea . setText ( rs . getString ( "Question" ) ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ReplyForm . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } else { sql += "`ForumComments` where CommentID = '" + commentID + "'" ; ResultSet rs = db . getResults ( conn , sql ) ; try { if ( rs . next ( ) ) { ParentCommentTextArea . setText ( rs . getString ( "Comment" ) ) ; } } catch ( SQLException ex ) { Logger . getLogger ( ReplyForm . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } return comment ; }
tr	E	private void socketLifeCycle ( ) { notifyConnection ( ) ; if ( isSendHello ( ) ) sendHello ( ) ; try { waitLines ( ) ; Logger . getLogger ( getClass ( ) ) . info ( "Disconnected!" ) ; } catch ( SocketException e ) { Logger . getLogger ( getClass ( ) ) . warn ( e . getMessage ( ) ) ; } catch ( SocketTimeoutException e ) { Logger . getLogger ( getClass ( ) ) . warn ( e . getMessage ( ) ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } finally { if ( getRawSocket ( ) != null ) Logger . getLogger ( getClass ( ) ) . info ( new StringBuffer ( "Disconnect from " ) . append ( getRawSocket ( ) . getInetAddress ( ) . getHostName ( ) ) ) ; try { disconnect ( ) ; notifyDisconnection ( ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } } }
tr	D	private TIPPTool loadTool ( Element toolEl ) { TIPPTool tool = new TIPPTool ( getChildTextByName ( toolEl , ContributorTool . NAME ) , getChildTextByName ( toolEl , ContributorTool . ID ) , getChildTextByName ( toolEl , ContributorTool . VERSION ) ) ; return tool ; }
tr	F	private void newButtonActionPerformed ( java . awt . event . ActionEvent evt ) { pcpreports . Employee e = new pcpreports . Employee ( ) ; entityManager . persist ( e ) ; list . add ( e ) ; int row = list . size ( ) - 1 ; masterTable . setRowSelectionInterval ( row , row ) ; masterTable . scrollRectToVisible ( masterTable . getCellRect ( row , 0 , true ) ) ; unitCombo . requestFocusInWindow ( ) ; saveButton . setEnabled ( true ) ; }
tr	I	public String getUserDomain ( ) { return userDomain ; }
tr	H	public Object getPreviousValue ( ) { return Integer . toString ( getCalendar ( Calendar . YEAR ) - 1 ) ; }
tr	F	protected boolean isLeaf ( ) { return ( ( lesser == null ) && ( greater == null ) ) ; }
tr	I	public void deleteById ( Object id , Connection conn ) { delete ( conn , "WHERE " + Cols . getSingle ( idFields ) . sqlName + "=?" , id ) ; }
tr	A	point ( double x , double y , byte value ) { this . x = x ; this . y = y ; this . value = value ; }
tr	F	public User ( JSONObject json ) throws WeiboException { super ( ) ; init ( json ) ; }
tr	G	public static String optionsCount ( String stock ) { String httpdata = getHtml ( yahoobase + "/op?s=" + stock ) ; if ( httpdata . contains ( ">There is no" ) || httpdata . contains ( "Check your spelling" ) || httpdata . indexOf ( "View By Expiration" ) < 0 ) return "0" ; try { httpdata = httpdata . substring ( httpdata . indexOf ( "View By Expiration" ) ) ; httpdata = httpdata . substring ( 0 , httpdata . indexOf ( "table" ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return "" + ( httpdata . toLowerCase ( ) . split ( "a href" ) . length - 1 ) ; }
tr	J	public void drawEdges ( BufferedImage canvas ) { BufferedImage image = new BufferedImage ( _width , _height , BufferedImage . TYPE_INT_RGB ) ; _edges = findEdges ( ) ; for ( int y = 0 ; y < _height ; y ++ ) { for ( int x = 0 ; x < _width ; x ++ ) { if ( _edges [ y ] [ x ] ) image . setRGB ( x , y , 000000 ) ; else image . setRGB ( x , y , ffffff ) ; } } Graphics2D g = canvas . createGraphics ( ) ; g . drawImage ( image , 0 , 0 , null ) ; }
tr	J	private void fireActionPerformed ( ) { Iterator i = getActionListeners ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { ActionListener al = ( ActionListener ) i . next ( ) ; al . actionPerformed ( new ActionEvent ( this , ActionEvent . ACTION_PERFORMED , "date selected" ) ) ; } }
tr	D	public SyncManager < Data > getSyncManager ( ) { return this . syncManager ; }
tr	B	@ Override public void putSeparator ( ) throws ParsingException { context . warn ( "detected '" + Characters . SEPARATOR + "'  Maybe you missed ';' at the end of the previous query." ) ; putChar ( Characters . SEPARATOR ) ; }
tr	H	private void back ( ) { switch ( _current ) { case PAUSE : case PLAY : _index -- ; if ( _index < 0 ) { _index = 0 ; } else { _player . stop ( ) ; playSong ( _myList . getModel ( ) . getElementAt ( _index ) ) ; } break ; case STOP : break ; } }
tr	C	void desbloquear ( ) { txtCedula . setEnabled ( true ) ; txtNombre . setEnabled ( true ) ; txtApellido . setEnabled ( true ) ; fecha . setEnabled ( true ) ; txtHijos . setEnabled ( true ) ; txtDireccion . setEnabled ( true ) ; txtEmail . setEnabled ( true ) ; txtTelefono . setEnabled ( true ) ; txtCelular . setEnabled ( true ) ; btnGuardar . setEnabled ( true ) ; btnGuardar . setEnabled ( true ) ; }
tr	H	public String getId ( ) { return id ; }
tr	E	private boolean isSendHello ( ) { return sendHello ; }
tr	G	boolean validate ( final Document dom ) { try { InputStream is = getClass ( ) . getResourceAsStream ( "/TIPPManifest-1_5.xsd" ) ; SchemaFactory factory = SchemaFactory . newInstance ( W3C_XML_SCHEMA_NS_URI ) ; factory . setResourceResolver ( new LSResourceResolver ( ) { public LSInput resolveResource ( String type , String namespaceURI , String publicId , String systemId , String baseURI ) { LSInput input = ( ( DOMImplementationLS ) dom . getImplementation ( ) ) . createLSInput ( ) ; if ( ( "TIPPCommon.xsd" . equals ( systemId ) && W3C_XML_SCHEMA_NS_URI . equals ( type ) ) || COMMON_SCHEMA_LOCATION . equalsIgnoreCase ( baseURI ) ) { input . setByteStream ( getClass ( ) . getResourceAsStream ( "/TIPPCommon-1_5.xsd" ) ) ; } else if ( XMLDSIG_SCHEMA_URI . equalsIgnoreCase ( baseURI ) || XMLDSIG_NS_PREFIX . equalsIgnoreCase ( namespaceURI ) ) { input . setByteStream ( getClass ( ) . getResourceAsStream ( "/xmldsig-core-schema.xsd" ) ) ; } else if ( "http://www.w3.org/2001/XMLSchema.dtd" . equals ( baseURI ) || "http://www.w3.org/2001/XMLSchema.dtd" . equals ( systemId ) ) { input . setByteStream ( getClass ( ) . getResourceAsStream ( "/XMLSchema.dtd" ) ) ; } else if ( "datatypes.dtd" . equals ( systemId ) ) { input . setByteStream ( getClass ( ) . getResourceAsStream ( "/datatypes.dtd" ) ) ; } else { return null ; } return input ; } } ) ; Schema schema = factory . newSchema ( new StreamSource ( is ) ) ; Validator validator = schema . newValidator ( ) ; validator . validate ( new DOMSource ( dom ) ) ; is . close ( ) ; return true ; } catch ( SAXException | IOException e ) { errorHandler . reportError ( TIPPErrorType . INVALID_MANIFEST , "Invalid manifest" , e ) ; return false ; } }
tr	C	private void manageGameStartMessage ( int senderID , GameStartMessage msg ) { if ( gameServer == null ) { console . displayMessage ( "Got game start message but game server is null. Dropping message." ) ; return ; } for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == senderID ) { if ( clients . get ( i ) . getCurrentGame ( ) == null ) { clients . get ( i ) . setCurrentGame ( msg . getGameName ( ) ) ; console . displayMessage ( "CLIENT STARTED GAME" ) ; try { gameServer . addPlayer ( clients . get ( i ) ) ; } catch ( GameException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } } else if ( ! clients . get ( i ) . isRunningGame ( ) ) { if ( clients . get ( i ) . getCurrentGame ( ) . equals ( msg . getGameName ( ) ) ) { clients . get ( i ) . startGame ( ) ; console . displayMessage ( "CLIENT STARTED GAME" ) ; try { gameServer . addPlayer ( clients . get ( i ) ) ; } catch ( GameException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } } else { clients . get ( i ) . setCurrentGame ( null ) ; } } else { console . displayMessage ( "Got game start message but client is already running a game." ) ; } return ; } } console . displayMessage ( "Did not find client with id '" + senderID + "'." ) ; }
tr	F	private void initCombo ( ) { combo = new Combo ( dialog , SWT . DROP_DOWN | SWT . READ_ONLY ) ; combo . setItems ( new String [ ] { "Email" , "Email list" , "Constants" , "Numeric Range" , "Date Range" , "Sequence" , "Reference" , "English String" , "Japanese String" , "Custom Class" , "BLOB" , "Duplicated Reference" } ) ; ContentDef cd = fieldDef . getContentDef ( ) ; if ( cd instanceof EmailContentDef ) combo . select ( EMAIL_OPT_IDX ) ; else if ( cd instanceof EmailListContentDef ) combo . select ( EMAIL_LIST_OPT_IDX ) ; else if ( cd instanceof ConstContentDef ) combo . select ( CONSTS_OPT_IDX ) ; else if ( cd instanceof NumericRangeContentDef || cd instanceof PaddedIntContentDef ) combo . select ( NUMERIC_RANGE_OPT_IDX ) ; else if ( cd instanceof DateRangeContentDef ) combo . select ( DATE_RANGE_OPT_IDX ) ; else if ( cd instanceof OracleSequenceContentDef || cd instanceof PostgresSequenceContentDef ) combo . select ( SEQUENCE_OPT_IDX ) ; else if ( cd instanceof ReferenceContentDef ) combo . select ( REFERENCE_OPT_IDX ) ; else if ( cd instanceof DupReferenceContentDef ) combo . select ( DUP_REFERENCE_OPT_IDX ) ; else if ( cd instanceof DependentDupReferenceContentDef ) combo . select ( DEP_DUP_REFERENCE_OPT_IDX ) ; else if ( cd instanceof EnglishStringContentDef ) combo . select ( EN_STRING_OPT_IDX ) ; else if ( cd instanceof JapaneseStringContentDef ) combo . select ( JP_STRING_OPT_IDX ) ; else if ( cd instanceof CustomContentDef ) combo . select ( CUSTOM_OPT_IDX ) ; else if ( cd instanceof Blob ) combo . select ( BLOB_OPT_IDX ) ; combo . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent arg0 ) { int selIdx = combo . getSelectionIndex ( ) ; switch ( selIdx ) { case ( EMAIL_OPT_IDX ) : { togglePanel ( blankPanel ) ; break ; } case ( EMAIL_LIST_OPT_IDX ) : { togglePanel ( blankPanel ) ; break ; } case ( CONSTS_OPT_IDX ) : { togglePanel ( constsPanel ) ; break ; } case ( NUMERIC_RANGE_OPT_IDX ) : { togglePanel ( numRangePanel ) ; break ; } case ( DATE_RANGE_OPT_IDX ) : { togglePanel ( dateRangePanel ) ; break ; } case ( SEQUENCE_OPT_IDX ) : { togglePanel ( sequencePanel ) ; break ; } case ( REFERENCE_OPT_IDX ) : case ( DUP_REFERENCE_OPT_IDX ) : case ( DEP_DUP_REFERENCE_OPT_IDX ) : togglePanel ( refPanel ) ; break ; case ( EN_STRING_OPT_IDX ) : { togglePanel ( blankPanel ) ; break ; } case ( JP_STRING_OPT_IDX ) : { togglePanel ( blankPanel ) ; break ; } case ( CUSTOM_OPT_IDX ) : { togglePanel ( customPanel ) ; break ; } case ( BLOB_OPT_IDX ) : { togglePanel ( blobPanel ) ; break ; } } } } ) ; combo . setLayoutData ( "wrap" ) ; }
tr	E	private void CheckTelefonoActionPerformed ( java . awt . event . ActionEvent evt ) { if ( CheckTelefono . isSelected ( ) ) { CheckLab . setEnabled ( false ) ; CheckNombre . setEnabled ( false ) ; textBuscar . setEnabled ( true ) ; } else { CheckLab . setEnabled ( true ) ; CheckNombre . setEnabled ( true ) ; textBuscar . setEnabled ( false ) ; } }
tr	J	@ Override public void paint ( Graphics g ) { if ( buffer == null ) { buffer = this . createImage ( XLEN , YLEN ) ; buffer_gc = buffer . getGraphics ( ) ; buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . fillRect ( 0 , 0 , XLEN , YLEN ) ; } g . drawImage ( buffer , 0 , 0 , this ) ; }
tr	D	void button_change_clicked ( ) { ++ current_value ; if ( current_value > 3 ) current_value = 1 ; }
tr	G	private float calculateDifferenceBetweenAngles ( float firstAngle , float secondAngle ) { float difference = secondAngle - firstAngle ; while ( difference < - 180 ) difference += 360 ; while ( difference > 180 ) difference -= 360 ; return difference ; }
tr	I	private void sucursalFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( sucursalField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de la sucursal demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
tr	G	public FeatureVector createArcFeatures ( DependencyInstance inst , int h , int c ) { int attDist = getBinnedDistance ( h - c ) ; FeatureVector fv = new FeatureVector ( numArcFeats ) ; addBasic1OFeatures ( fv , inst , h , c , attDist ) ; addCore1OPosFeatures ( fv , inst , h , c , attDist ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . postagids [ h ] , inst . formids [ c ] , inst . postagids [ c ] , attDist ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . postagids [ h ] , inst . lemmaids [ c ] , inst . postagids [ c ] , attDist ) ; addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . cpostagids [ h ] , inst . formids [ c ] , inst . cpostagids [ c ] , attDist ) ; if ( inst . lemmaids != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . cpostagids [ h ] , inst . lemmaids [ c ] , inst . cpostagids [ c ] , attDist ) ; if ( inst . featids [ h ] != null && inst . featids [ c ] != null ) { for ( int i = 0 , N = inst . featids [ h ] . length ; i < N ; ++ i ) for ( int j = 0 , M = inst . featids [ c ] . length ; j < M ; ++ j ) { addCore1OBigramFeatures ( fv , inst . formids [ h ] , inst . featids [ h ] [ i ] , inst . formids [ c ] , inst . featids [ c ] [ j ] , attDist ) ; if ( inst . lemmas != null ) addCore1OBigramFeatures ( fv , inst . lemmaids [ h ] , inst . featids [ h ] [ i ] , inst . lemmaids [ c ] , inst . featids [ c ] [ j ] , attDist ) ; } } return fv ; }
tr	D	private static int atoi ( String s ) { return Integer . parseInt ( s ) ; }
tr	J	public static void main ( String [ ] argv ) { new AppletFrame ( "svm_toy" , new svm_toy ( ) , 500 , 500 + 50 ) ; }
tr	B	public void printFileStats ( ) { File F = new File ( file ) ; long fs = F . length ( ) - 3 ; int ls = b . length ; System . out . println ( "File size: " + fs + " bytes. Number of links: " + ( fs / ls ) ) ; }
tr	E	@ Override public CloseHandshakeType getCloseHandshakeType ( ) { return CloseHandshakeType . ONEWAY ; }
tr	D	@ Override public void setPresenter ( TopicStatisticListPresenter presenter ) { this . presenter = presenter ; }
tr	H	float [ ] getDirtyFloatArray ( final int length ) { if ( length <= MAX_ARRAY_SIZE ) { return getDirtyFloatArrayCache ( length ) . getArray ( ) ; } if ( DO_STATS ) { incOversize ( ) ; } if ( DO_LOG_OVER_SIZE ) { logInfo ( "getDirtyFloatArray[oversize]: length=\t" + length + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return new float [ length ] ; }
tr	H	public String getLocation ( ) { return location ; }
tr	I	public int findGroundLevel ( ) { if ( _groundLevel != 0 ) return _groundLevel ; for ( int y = _height - 1 ; y > 0 ; y -- ) { int counter = 0 ; for ( int x = 0 ; x < _width ; x ++ ) { if ( _class [ y ] [ x ] == GROUND ) counter ++ ; } if ( counter < _width * 0.8 ) { _groundLevel = y ; break ; } } return _groundLevel ; }
tr	D	private void loadTaskRequestOrResponse ( ManifestBuilder builder , Element descriptor ) { Element requestEl = getFirstChildByName ( descriptor , TASK_REQUEST ) ; if ( requestEl != null ) { loadTaskRequest ( builder , requestEl ) ; } else { loadTaskResponse ( builder , getFirstChildByName ( descriptor , TASK_RESPONSE ) ) ; } }
tr	B	protected java . net . Socket getRawSocket ( ) { return this . rawSocket ; }
tr	B	private TcpMessageFilter getInputFilter ( ) { return inputFilter ; }
tr	A	@ Override public boolean isHuman ( ) { return true ; }
tr	I	public T first ( ) { if ( size == 0 ) { throw new IllegalStateException ( "Array is empty." ) ; } return items [ 0 ] ; }
tr	A	protected boolean setCurrentTokens ( int [ ] [ ] currentTokens ) { avoidFromEdge ( currentTokens ) ; if ( checkLocationAvailable ( ) ) { currentTokens [ 0 ] [ 0 ] = x0 ; currentTokens [ 0 ] [ 1 ] = y0 ; currentTokens [ 1 ] [ 0 ] = x1 ; currentTokens [ 1 ] [ 1 ] = y1 ; currentTokens [ 2 ] [ 0 ] = x2 ; currentTokens [ 2 ] [ 1 ] = y2 ; currentTokens [ 3 ] [ 0 ] = x3 ; currentTokens [ 3 ] [ 1 ] = y3 ; return true ; } else { return false ; } }
tr	I	float [ ] widenDirtyFloatArray ( final float [ ] in , final int usedSize , final int needSize ) { final int length = in . length ; if ( DO_CHECKS && length >= needSize ) { return in ; } if ( DO_STATS ) { incResizeDirtyFloat ( ) ; } final float [ ] res = getDirtyFloatArray ( getNewSize ( usedSize , needSize ) ) ; System . arraycopy ( in , 0 , res , 0 , usedSize ) ; putDirtyFloatArray ( in ) ; if ( DO_LOG_WIDEN_ARRAY ) { logInfo ( "widenDirtyFloatArray[" + res . length + "]: usedSize=\t" + usedSize + "\tlength=\t" + length + "\tneeded length=\t" + needSize + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return res ; }
tr	C	public void setWidth ( int w ) { if ( w == 0 ) w = 1 ; for ( int i = 0 ; i < anim . getFrames ( ) . size ( ) ; i ++ ) { Image image = ( ( AnimFrame ) anim . getFrames ( ) . get ( i ) ) . image ; image = image . getScaledInstance ( w , image . getHeight ( null ) , 0 ) ; ( ( AnimFrame ) anim . getFrames ( ) . get ( i ) ) . image = image ; } }
tr	F	protected void updateHeight ( ) { int lesserHeight = 0 ; int greaterHeight = 0 ; if ( lesser != null ) { AVLNode < T > lesserAVLNode = ( AVLNode < T > ) lesser ; lesserHeight = lesserAVLNode . height ; } if ( greater != null ) { AVLNode < T > greaterAVLNode = ( AVLNode < T > ) greater ; greaterHeight = greaterAVLNode . height ; } if ( lesserHeight > greaterHeight ) { height = lesserHeight + 1 ; } else { height = greaterHeight + 1 ; } }
tr	J	public boolean hasOutputVariable ( String name ) { for ( OutputVariable outputVariable : this . outputVariables ) { if ( name . equals ( outputVariable . getName ( ) ) ) { return true ; } } return false ; }
tr	D	public static int nonZeroRandom ( int max ) { assert ( max > 0 ) ; return 1 + random . nextInt ( max - 1 ) ; }
tr	H	public Set < Key > keySet ( ) { return new AbstractSet < Key > ( ) { public Iterator < Key > iterator ( ) { return new FTMKeyIterator < Key > ( tree ) ; } public int size ( ) { return FTreeMap . this . size ( ) ; } public boolean contains ( Object key ) { return containsKey ( key ) ; } } ; }
tr	E	byte [ ] widenDirtyByteArray ( final byte [ ] in , final int usedSize , final int needSize ) { final int length = in . length ; if ( DO_CHECKS && length >= needSize ) { return in ; } if ( DO_STATS ) { incResizeDirtyByte ( ) ; } final byte [ ] res = getDirtyByteArray ( getNewSize ( usedSize , needSize ) ) ; System . arraycopy ( in , 0 , res , 0 , usedSize ) ; putDirtyByteArray ( in ) ; if ( DO_LOG_WIDEN_ARRAY ) { logInfo ( "widenDirtyByteArray[" + res . length + "]: usedSize=\t" + usedSize + "\tlength=\t" + length + "\tneeded length=\t" + needSize + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return res ; }
tr	E	private String psSetUpdate ( List < Field1 < M >> fields ) { return Cols . join ( ( Iterable < String > ) Cols . yield ( fields , ( f ) -> "`" + f . sqlName + "`=?" ) , " " ) ; }
tr	B	private TcpMessageFilter getOutputFilter ( ) { return outputFilter ; }
tr	E	public void setRotation ( float rotation ) { if ( rotation < 0 ) { rotation = 360 + rotation ; } this . currentRotation = rotation ; }
tr	J	public void addOutputVariable ( OutputVariable outputVariable ) { this . outputVariables . add ( outputVariable ) ; }
tr	J	public void setFontSize ( float size ) { Font font = getFont ( ) . deriveFont ( size ) ; getMonthLabel ( ) . setFont ( font ) ; getTodayLabel ( ) . setFont ( font ) ; getYearSpinner ( ) . setFont ( font ) ; dayTable . setFont ( font ) ; dayTable . setRowHeight ( ( int ) ( size * 2 ) ) ; }
tr	I	@ SuppressWarnings ( "unchecked" ) private void teusdayActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . weekCheck [ 2 ] . isSelected ( ) ) { this . numSelected ++ ; if ( this . firstSelection ) { stretch ( ) ; } this . models [ 2 ] = new DefaultListModel < Object > ( ) ; this . weekJobList [ 2 ] . setModel ( this . models [ 2 ] ) ; this . weekScrollPane [ 2 ] . setViewportView ( this . weekJobList [ 2 ] ) ; this . weekJobName [ 2 ] . setColumns ( 20 ) ; this . weekLabel [ 2 ] . setText ( "Job Name:" ) ; this . weekAddJob [ 2 ] . setText ( "Add Job" ) ; this . weekAddJob [ 2 ] . addActionListener ( new java . awt . event . ActionListener ( ) { @ Override public void actionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! Config . this . weekJobName [ 2 ] . getText ( ) . isEmpty ( ) ) { Config . this . models [ 2 ] . addElement ( Config . this . weekJobName [ 2 ] . getText ( ) ) ; Config . this . weekJobList [ 2 ] . setModel ( Config . this . models [ 2 ] ) ; Config . this . weekJobName [ 2 ] . setText ( "" ) ; } } } ) ; this . weekDeleteJob [ 2 ] . setText ( "Delete Job" ) ; this . weekDeleteJob [ 2 ] . addActionListener ( new java . awt . event . ActionListener ( ) { @ Override public void actionPerformed ( java . awt . event . ActionEvent evt ) { while ( ! Config . this . weekJobList [ 2 ] . isSelectionEmpty ( ) ) { int n = Config . this . weekJobList [ 2 ] . getSelectedIndex ( ) ; Config . this . models [ 2 ] . remove ( n ) ; } } } ) ; javax . swing . GroupLayout tuesdayTabLayout = new javax . swing . GroupLayout ( this . weekTab [ 2 ] ) ; this . weekTab [ 2 ] . setLayout ( tuesdayTabLayout ) ; tuesdayTabLayout . setHorizontalGroup ( tuesdayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( tuesdayTabLayout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( this . weekScrollPane [ 2 ] , javax . swing . GroupLayout . PREFERRED_SIZE , 182 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addGroup ( tuesdayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( tuesdayTabLayout . createSequentialGroup ( ) . addComponent ( this . weekLabel [ 2 ] ) . addGroup ( tuesdayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( tuesdayTabLayout . createSequentialGroup ( ) . addGap ( 14 , 14 , 14 ) . addComponent ( this . weekAddJob [ 2 ] ) ) . addGroup ( tuesdayTabLayout . createSequentialGroup ( ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( this . weekJobName [ 2 ] , javax . swing . GroupLayout . PREFERRED_SIZE , 100 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ) . addComponent ( this . weekDeleteJob [ 2 ] ) ) . addContainerGap ( 431 , short . MAX_VALUE ) ) ) ; tuesdayTabLayout . setVerticalGroup ( tuesdayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( tuesdayTabLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( tuesdayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addGroup ( tuesdayTabLayout . createSequentialGroup ( ) . addGroup ( tuesdayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( this . weekJobName [ 2 ] , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( this . weekLabel [ 2 ] ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( this . weekAddJob [ 2 ] ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( this . weekDeleteJob [ 2 ] ) ) . addComponent ( this . weekScrollPane [ 2 ] , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addContainerGap ( 25 , short . MAX_VALUE ) ) ) ; this . dayTabs . addTab ( "Tuesday" , this . weekTab [ 2 ] ) ; } else { this . numSelected -- ; stretch ( ) ; this . dayTabs . remove ( this . weekTab [ 2 ] ) ; } }
tr	J	public void close ( ) throws InterruptedException { if ( reader_instance != null ) { reader_instance . closeFiles ( ) ; } reader_instance = null ; if ( syncManager != null ) { syncManager . shutdown ( ) ; syncManager . join ( ) ; } }
tr	B	public Integer getValue ( DraughtsState ds ) { return evaluate ( ds ) ; }
tr	J	public boolean isGridStyle ( ) { return gridStyle ; }
tr	D	public static void drawVerticalLine ( int x , int y , int height , int colour ) { if ( x < topX || x >= bottomX ) return ; if ( y < topY ) { height -= topY - y ; y = topY ; } if ( y + height > bottomY ) height = bottomY - y ; int pointer = x + y * DrawingArea . width ; for ( int row = 0 ; row < height ; row ++ ) pixels [ pointer + row * DrawingArea . width ] = colour ; }
tr	A	public Rotater ( Token [ ] [ ] tokens ) { this . tokens = tokens ; }
tr	G	public static boolean isPresent ( String className , ClassLoader classLoader ) { try { forName ( className , classLoader ) ; return true ; } catch ( Throwable ex ) { return false ; } }
tr	E	public static boolean pssVerify ( PublicKey key , byte [ ] text , byte [ ] signature ) { try { Signature s = Signature . getInstance ( "RSASSA-PSS" ) ; s . initVerify ( key ) ; s . update ( text ) ; return s . verify ( signature ) ; } catch ( Exception e ) { return false ; } }
tr	E	private void manageStringMessage ( int senderID , StringMessage msg ) throws NetworkMessageException { msg . setSender ( senderID ) ; if ( msg . getAcceptor ( ) == 0 ) { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == msg . getSender ( ) ) { continue ; } clients . get ( i ) . sendMessage ( msg ) ; } console . displayMessage ( getClientNameByID ( msg . getSender ( ) ) + ": " + msg . getStr ( ) ) ; } else { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == msg . getAcceptor ( ) ) { clients . get ( i ) . sendMessage ( msg ) ; break ; } } console . displayMessage ( getClientNameByID ( msg . getSender ( ) ) + " to " + getClientNameByID ( msg . getAcceptor ( ) ) + ": " + msg . getStr ( ) ) ; } }
tr	H	private void initSerial ( ) { Query query = entityManager . createNamedQuery ( "Pcp.findBySetupitem" ) ; query . setParameter ( "setupitem" , "port" ) ; Setup s = ( Setup ) query . getSingleResult ( ) ; try { connect ( s . getSetupvalue ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	H	public int getEndLine ( ) { return bufline [ bufpos ] ; }
tr	G	public String getColumnName ( int colIndex ) { String name ; int index = colIndex + firstDayOfWeek ; if ( index > Calendar . SATURDAY ) { index = Calendar . SUNDAY ; } switch ( index ) { case Calendar . SUNDAY : name = NAMES_OF_DAYS [ 0 ] ; break ; case Calendar . MONDAY : name = NAMES_OF_DAYS [ 1 ] ; break ; case Calendar . TUESDAY : name = NAMES_OF_DAYS [ 2 ] ; break ; case Calendar . WEDNESDAY : name = NAMES_OF_DAYS [ 3 ] ; break ; case Calendar . THURSDAY : name = NAMES_OF_DAYS [ 4 ] ; break ; case Calendar . FRIDAY : name = NAMES_OF_DAYS [ 5 ] ; break ; case Calendar . SATURDAY : name = NAMES_OF_DAYS [ 6 ] ; break ; default : name = "" ; } return name ; }
tr	E	private StringBuilder getFooter2 ( ) throws IOException { return Utils . getFileContent ( Config . getPathIn ( ) + "footer2.html" ) ; }
tr	I	public int getStatusesCount ( ) { return statusesCount ; }
tr	J	@ Override protected void processMouseEvent ( MouseEvent e ) { if ( e . getID ( ) == MouseEvent . MOUSE_PRESSED ) { if ( e . getX ( ) >= XLEN || e . getY ( ) >= YLEN ) return ; point p = new point ( ( double ) e . getX ( ) / XLEN , ( double ) e . getY ( ) / YLEN , current_value ) ; point_list . addElement ( p ) ; draw_point ( p ) ; } }
tr	F	private void init ( JSONObject json ) throws WeiboException { if ( json != null ) { try { id = json . getString ( "id" ) ; screenName = json . getString ( "screen_name" ) ; name = json . getString ( "name" ) ; province = json . getInt ( "province" ) ; city = json . getInt ( "city" ) ; location = json . getString ( "location" ) ; description = json . getString ( "description" ) ; url = json . getString ( "url" ) ; profileImageUrl = json . getString ( "profile_image_url" ) ; userDomain = json . getString ( "domain" ) ; gender = json . getString ( "gender" ) ; followersCount = json . getInt ( "followers_count" ) ; friendsCount = json . getInt ( "friends_count" ) ; favouritesCount = json . getInt ( "favourites_count" ) ; statusesCount = json . getInt ( "statuses_count" ) ; createdAt = parseDate ( json . getString ( "created_at" ) , "EEE MMM dd HH:mm:ss z yyyy" ) ; following = getBoolean ( "following" , json ) ; verified = getBoolean ( "verified" , json ) ; verifiedType = json . getInt ( "verified_type" ) ; verifiedReason = json . getString ( "verified_reason" ) ; allowAllActMsg = json . getBoolean ( "allow_all_act_msg" ) ; allowAllComment = json . getBoolean ( "allow_all_comment" ) ; followMe = json . getBoolean ( "follow_me" ) ; avatarLarge = json . getString ( "avatar_large" ) ; onlineStatus = json . getInt ( "online_status" ) ; statusId = json . getString ( "status_id" ) ; biFollowersCount = json . getInt ( "bi_followers_count" ) ; if ( ! json . getString ( "remark" ) . isEmpty ( ) ) { remark = json . getString ( "remark" ) ; } lang = json . getString ( "lang" ) ; weihao = json . getString ( "weihao" ) ; if ( ! json . isNull ( "status" ) ) { status = new Status ( json . getJSONObject ( "status" ) ) ; } } catch ( JSONException jsone ) { throw new WeiboException ( jsone . getMessage ( ) + ":" + json . toString ( ) , jsone ) ; } } }
tr	F	private Collection getPrintables ( Collection records ) { List l = new ArrayList ( ) ; for ( Iterator iterator = records . iterator ( ) ; iterator . hasNext ( ) ; ) { Record record = ( Record ) iterator . next ( ) ; for ( int c = 0 ; c < record . getChars ( ) . length ( ) ; c ++ ) { l . add ( getPrintable ( record , c , c < record . getChars ( ) . length ( ) - 1 ) ) ; } } return l ; }
tr	C	private void paintGrid ( Graphics g , PageFormat pageFormat , int pageIndex , double scale ) { int topBox = header ? this . topBox : 0 ; int width = getWidth ( ) ; int height = getHeight ( ) ; double drawX ; double drawY ; g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , width , height ) ; if ( pageFormat != null ) { drawX = pageFormat . getImageableX ( ) ; drawY = pageFormat . getImageableY ( ) ; width = ( int ) pageFormat . getImageableWidth ( ) ; height = ( int ) pageFormat . getImageableHeight ( ) ; } else { ( ( Graphics2D ) g ) . scale ( ( double ) getWidth ( ) / ( 8.5d * anInch ) , ( double ) getHeight ( ) / ( 11 * anInch ) ) ; width = ( int ) ( 8.5 * anInch ) ; height = 11 * anInch ; drawX = ( margins * anInch ) ; drawY = ( margins * anInch ) ; width -= ( 2 * drawX ) ; height -= ( 2 * drawY ) ; } drawX += padding ; drawY += padding ; width -= 2 * padding ; height -= 2 * padding ; ( ( Graphics2D ) g ) . translate ( drawX , drawY ) ; g . setColor ( Color . black ) ; int x1 = 0 ; int y1 = topBox ; int x2 = x1 + width ; int y2 = y1 + ( int ) ( height - topBox ) ; int w = x2 - x1 ; int h = y2 - y1 ; int boxW = ( int ) ( boxWInches * anInch ) ; int boxH = ( int ) ( boxHInches * anInch ) ; int boxesAcross = w / boxW ; int boxesDown = h / boxH ; int dx = w % boxW ; int dy = h % boxH ; boxesDown = 10 ; pages = calcPages ( width , height ) ; if ( currentPageIndex > pages - 1 ) { currentPageIndex = pages - 1 ; repaint ( ) ; return ; } if ( header ) { drawHeader ( g , 0 , 0 , width , topBox , pages , pageIndex + 1 ) ; } g . setColor ( boxColor ) ; if ( gridLines ) { for ( int i = 0 ; i < boxesAcross ; i ++ ) { for ( int j = 0 ; j < boxesDown ; j ++ ) { int x = x1 + ( dx / 2 ) + i * boxW ; int y = y1 + ( dy / 2 ) + j * boxH ; if ( drawGuides ) { g . setColor ( guidesColor1 ) ; g . drawLine ( x + boxW / 2 , y , x + boxW / 2 , y + boxH ) ; g . drawLine ( x , y + boxH / 2 , x + boxW , y + boxH / 2 ) ; if ( gridStyle ) { g . setColor ( guidesColor2 ) ; g . drawLine ( x + boxW / 4 , y , x + boxW / 4 , y + boxH ) ; g . drawLine ( x + boxW / 4 + boxW / 2 , y , x + boxW / 4 + boxW / 2 , y + boxH ) ; g . drawLine ( x , y + boxH / 4 , x + boxW , y + boxH / 4 ) ; g . drawLine ( x , y + boxH / 2 + boxH / 4 , x + boxW , y + boxH / 2 + boxH / 4 ) ; } else { g . setColor ( guidesColor2 ) ; g . drawLine ( x , y , x + boxW , y + boxH ) ; g . drawLine ( x + boxW , y , x , y + boxH ) ; } g . setColor ( boxColor ) ; } g . drawRect ( x , y , boxW , boxH ) ; } } } g . setColor ( Color . black ) ; Graphics2D g2 = ( Graphics2D ) g ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; int charsPerPage = 1 ; if ( printMode . getStyle ( ) == PrintMode . STYLE_CRAM ) { charsPerPage = ( boxesDown * ( boxesAcross - ( boxesAcross % 2 ) ) / 2 ) ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ONE_PER_LINE ) { charsPerPage = boxesDown ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ALTERNATING_LINES ) { charsPerPage = boxesDown / 2 ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_READING ) { charsPerPage = boxesDown * boxesAcross ; } PrintableRecord [ ] printableRecords = new PrintableRecord [ charsPerPage ] ; Collection allPrintables = getPrintables ( CharApp . getInstance ( ) . getRecord ( ) . getRecords ( randomOrder ) ) ; List list = new ArrayList ( allPrintables ) ; for ( int i = 0 ; i < printableRecords . length ; i ++ ) { int listIdx = i + pageIndex * charsPerPage ; if ( listIdx < list . size ( ) ) { PrintableRecord rec = ( PrintableRecord ) list . get ( listIdx ) ; printableRecords [ i ] = rec ; } else if ( fillThePage ) { PrintableRecord rec = ( PrintableRecord ) list . get ( listIdx % list . size ( ) ) ; printableRecords [ i ] = rec ; } } int currentRec = 0 ; if ( printMode . getStyle ( ) == PrintMode . STYLE_CRAM ) { for ( int i = 0 ; i < boxesAcross - 1 ; i += 2 ) { for ( int j = 0 ; j < boxesDown ; j ++ ) { if ( printableRecords [ currentRec ] == null ) { if ( fillThePage ) { currentRec = 0 ; } } printText ( g , printableRecords [ currentRec ++ ] , x1 , y1 , dx , dy , i , j , boxW , boxH ) ; } } } else if ( printMode . getStyle ( ) == PrintMode . STYLE_READING ) { for ( int i = 0 ; i < boxesAcross ; i ++ ) { for ( int j = 0 ; j < boxesDown ; j ++ ) { if ( printableRecords [ currentRec ] == null ) { if ( fillThePage ) { currentRec = 0 ; } } printText ( g , printableRecords [ currentRec ++ ] , x1 , y1 , dx , dy , i , j , boxW , boxH ) ; } } } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ONE_PER_LINE ) { for ( int j = 0 ; j < boxesDown ; j ++ ) { printText ( g , printableRecords [ currentRec ++ ] , x1 , y1 , dx , dy , 0 , j , boxW , boxH ) ; } } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ALTERNATING_LINES ) { for ( int j = 0 ; j < boxesDown - 1 ; j += 2 ) { PrintableRecord rec = printableRecords [ currentRec ++ ] ; for ( int i = 0 ; i < boxesAcross ; i ++ ) { printText ( g , rec , x1 , y1 , dx , dy , i , j , boxW , boxH ) ; } } } }
tr	I	public void removeTableModelListener ( TableModelListener arg0 ) { tableModelListeners . remove ( arg0 ) ; }
tr	D	private void SubmitButtonActionPerformed ( java . awt . event . ActionEvent evt ) { DatabaseConnection db = new DatabaseConnection ( ) ; Connection conn = db . connectToDB ( ) ; String sql = "" ; int visibility = VisibleToPublicCheckbox . isSelected ( ) ? 0 : 1 ; if ( bookType == 0 ) { sql = "INSERT INTO  `lepolted`.`ForumQuestions` (" + "`QuestionTitle`  " + "`Question`  " + "`QuestionID`  " + "`SubCategoryID`  " + "`Visibility`  " + "`Author`" + ")" + "VALUES (" + "'" + QuestionTitleTextField . getText ( ) + "'  " + "'" + contentTextArea . getText ( ) + "'  " + "NULL  " + "'" + HelpFunctions . subCat ( subCat ) + "'  " + "'" + visibility + "'  " + "'" + userID + "'" + ")" ; } else if ( bookType == 1 ) { sql = "INSERT INTO  `lepolted`.`ForumComments` (" + "`QuestionID`  " + "`CommentID`  " + "`ReplyID`  " + "`Comment`  " + "`Author`  " + "`Visibility`" + ")" + "VALUES (" + "'" + parentComment + "'  " + "NULL  " + "NULL  " + "'" + contentTextArea . getText ( ) + "'  " + "'" + userID + "'  " + "'" + visibility + "'" + ")" ; } else { sql = "INSERT INTO  `lepolted`.`ForumComments` (" + "`QuestionID`  " + "`CommentID`  " + "`ReplyID`  " + "`Comment`  " + "`Author`  " + "`Visibility`" + ")" + "VALUES (" + "NULL  " + "NULL  " + "'" + parentComment + "'  " + "'" + contentTextArea . getText ( ) + "'  " + "'" + userID + "' " + "'" + visibility + "'" + ")" ; } db . updateDatabase ( conn , sql ) ; this . dispose ( ) ; new LandingForm ( userType , userID ) . setVisible ( true ) ; }
tr	J	public int getPages ( ) { return pages ; }
tr	G	IntArrayCache getDirtyIntArrayCache ( final int length ) { final int bucket = ArrayCache . getBucket ( length ) ; return getArrayCachesHolder ( ) . dirtyIntArrayCaches [ bucket ] ; }
tr	H	@ Override public boolean isEnabled ( ) { return true ; }
tr	B	@ Override public ImageIcon getImg ( ) { return ImageManager . getInstance ( ) . getTileSet ( "items" ) . getTile ( this . getName ( ) ) ; }
tr	G	public String getHtml ( ) throws IOException , ClassNotFoundException , SQLException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( this . getHead ( ) ) ; sb . append ( this . getBody1 ( ) ) ; if ( this . isReferencia ) { sb . append ( this . getReferenciaStart ( ) ) ; } if ( this . isZoznamReferencii ) { sb . append ( this . getReferencieStart ( ) ) ; } if ( ! this . isReferencia ) { sb . append ( Utils . getFileContent ( Config . getPathIn ( ) + this . url + "content.html" ) ) ; } if ( this . product != null ) { sb . append ( this . getListOfProductReferences ( ) ) ; } if ( this . service != null ) { sb . append ( this . getListOfServiceReferences ( ) ) ; } if ( this . service2 != null ) { sb . append ( this . getListOfService2References ( ) ) ; } if ( this . company != null && this . company . hasReferences ( ) ) { sb . append ( this . getListOfReferences ( ) ) ; } if ( this . isReferencia ) { sb . append ( this . getGallery ( ) ) ; sb . append ( this . getVideoGallery ( ) ) ; sb . append ( this . getRefMisc ( ) ) ; } sb . append ( this . getFooter1 ( ) ) ; if ( this . isReferencia ) { sb . append ( this . getGoogleMapsJS ( ) ) ; } if ( this . isZoznamReferencii ) { sb . append ( Utils . getFileContent ( Config . getPathIn ( ) + this . url + "content2.php" ) ) ; } sb . append ( this . getFooter2 ( ) ) ; return sb . toString ( ) ; }
tr	G	public T removeIndex ( int index ) { if ( index >= size ) { throw new IndexOutOfBoundsException ( "index can't be >= size: " + index + " >= " + size ) ; } T [ ] items = this . items ; T value = ( T ) items [ index ] ; size -- ; if ( ordered ) { System . arraycopy ( items , index + 1 , items , index , size - index ) ; } else { items [ index ] = items [ size ] ; } items [ size ] = null ; return value ; }
tr	C	private static void registerCommonClasses ( class < ? > ... commonClasses ) { for ( class < ? > clazz : commonClasses ) { commonClassCache . put ( clazz . getName ( ) , clazz ) ; } }
tr	A	@ Override public void putCharWhileBlockComment ( char c ) throws ParsingException { token . addChar ( c ) ; }
tr	H	public static double randomDouble ( double min , double max ) { if ( min == max ) { return min ; } else { return min + random . nextDouble ( ) * ( max - min ) ; } }
tr	H	private void connect ( String portName ) throws Exception { CommPortIdentifier portIdentifier = CommPortIdentifier . getPortIdentifier ( portName ) ; if ( portIdentifier . isCurrentlyOwned ( ) ) { System . out . println ( "Error: Port is currently in use" ) ; } else { CommPort commPort = portIdentifier . open ( this . getClass ( ) . getName ( ) , 2000 ) ; if ( commPort instanceof SerialPort ) { SerialPort serialPort = ( SerialPort ) commPort ; serialPort . setSerialPortParams ( 9600 , SerialPort . DATABITS_8 , SerialPort . STOPBITS_1 , SerialPort . PARITY_NONE ) ; InputStream in = serialPort . getInputStream ( ) ; serialPort . addEventListener ( new SerialReader ( in ) ) ; serialPort . notifyOnDataAvailable ( true ) ; } else { System . out . println ( "Error: Only serial ports are handled by this example." ) ; } } }
tr	F	private static byte [ ] pssPad ( byte [ ] salt , byte [ ] text , boolean doHash , int emLen ) { try { MessageDigest md = MessageDigest . getInstance ( "SHA1" ) ; byte [ ] h1 = null ; if ( doHash ) { h1 = md . digest ( text ) ; } else { h1 = text ; } int hLen = h1 . length ; int sLen = 20 ; int psLen = emLen - sLen - hLen - 2 ; byte [ ] output = new byte [ emLen ] ; md . update ( output , 0 , ( short ) 8 ) ; md . update ( h1 , 0 , hLen ) ; byte [ ] tmpHash = md . digest ( salt ) ; output [ psLen ] = ( byte ) 01 ; int hOffset = emLen - hLen - 1 ; System . arraycopy ( tmpHash , 0 , output , hOffset , hLen ) ; System . arraycopy ( salt , 0 , output , psLen + 1 , salt . length ) ; output [ emLen - 1 ] = ( byte ) bc ; int counter = 0 ; int outOffset = 0 ; byte [ ] c = new byte [ 4 ] ; while ( outOffset < hOffset ) { c [ c . length - 1 ] = ( byte ) counter ; md . update ( output , hOffset , hLen ) ; tmpHash = md . digest ( c ) ; if ( outOffset + hLen > hOffset ) { hLen = hOffset - outOffset ; } for ( int i = 0 ; i < hLen ; i ++ ) { output [ outOffset ++ ] ^= tmpHash [ i ] ; } counter ++ ; } return output ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	A	public void drop ( String name ) { if ( tables . remove ( name ) == null ) { throw new SqlException ( "No such table: " + name ) ; } }
tr	E	public void setVerifiedReason ( String verifiedReason ) { this . verifiedReason = verifiedReason ; }
tr	G	public List < Data > searchForData ( HeaderIndexFile < Data > indexFile , byte [ ] ... keys ) throws IOException { Arrays . sort ( keys , new ByteArrayComparator ( ) ) ; List < Data > result = new ArrayList < Data > ( ) ; IndexForHeaderIndexFile index = indexFile . getIndex ( ) ; int actualChunkIdx = 0 , lastChunkIdx = - 1 ; long actualChunkOffset = 0 , oldChunkOffset = - 1 ; int indexInChunk = 0 ; ByteBuffer workingBuffer = ByteBuffer . allocate ( ( int ) indexFile . getChunkSize ( ) ) ; byte [ ] tmpB = new byte [ gp . getElementSize ( ) ] ; for ( byte [ ] key : keys ) { actualChunkIdx = index . getChunkId ( key ) ; actualChunkOffset = index . getStartOffsetOfChunk ( actualChunkIdx ) ; if ( actualChunkIdx != lastChunkIdx ) { if ( oldChunkOffset > - 1 ) { indexFile . read ( oldChunkOffset , workingBuffer ) ; indexInChunk = 0 ; } indexFile . read ( actualChunkOffset , workingBuffer ) ; } indexInChunk = findElementInReadBuffer ( workingBuffer , key , indexInChunk ) ; if ( indexInChunk == - 1 ) { indexInChunk = 0 ; continue ; } workingBuffer . position ( indexInChunk ) ; workingBuffer . get ( tmpB ) ; @ SuppressWarnings ( "unchecked" ) Data copy = ( Data ) prototype . fromByteBuffer ( ByteBuffer . wrap ( tmpB ) ) ; result . add ( copy ) ; if ( indexInChunk == - 1 ) { logger . warn ( "Element with key {} was not found." , key ) ; indexInChunk = 0 ; } lastChunkIdx = actualChunkIdx ; oldChunkOffset = actualChunkOffset ; } return result ; }
tr	A	public String getPassword ( ) { return password ; }
tr	D	private static String simplifyFieldName ( String fname ) { int lastDollar = fname . lastIndexOf ( $ ) ; if ( lastDollar < 0 || lastDollar == fname . length ( ) ) { return fname ; } return fname . substring ( lastDollar + 1 , fname . length ( ) ) ; }
tr	F	private boolean mapConstraint ( Loc l , int dir ) { int x = l . x ; int y = l . y ; switch ( dir ) { case 0 : return ( y + 1 >= map . gridSize && ! map . isCollision ( x , y - 1 ) ) || ( map . isCollision ( x , y + 1 ) && ! ( y - 1 < 0 ) ) ; case 1 : return ( y - 1 < 0 && ! map . isCollision ( x , y + 1 ) ) || ( map . isCollision ( x , y - 1 ) && ! ( y + 1 >= map . gridSize ) ) ; case 2 : return ( x + 1 >= map . gridSize && ! map . isCollision ( x - 1 , y ) ) || ( map . isCollision ( x + 1 , y ) && ! ( x - 1 < 0 ) ) ; case 3 : return ( x - 1 < 0 && ! map . isCollision ( x + 1 , y ) ) || ( map . isCollision ( x - 1 , y ) && ! ( x + 1 >= map . gridSize ) ) ; default : return false ; } }
tr	A	public static StrategyEscape require ( Personality ps ) { return ( StrategyEscape ) ps . requireStrategy ( new StrategyEscape ( ) ) ; }
tr	D	private void setTableContent ( ) { Object [ ] [ ] data = new Object [ this . presenter . getModel ( ) . getCards ( ) . size ( ) ] [ 5 ] ; int count = 0 ; for ( Card card : this . presenter . getModel ( ) . getCards ( ) ) { data [ count ] [ 0 ] = card . getBox ( ) ; data [ count ] [ 1 ] = card . getQuestion ( ) ; data [ count ] [ 2 ] = card . getAnswer ( ) ; data [ count ] [ 3 ] = card . getStatisticCountWrong ( ) ; data [ count ] [ 4 ] = card . getStatisticCountRight ( ) ; count ++ ; } String box = TranslationManager . getinstance ( ) . getText ( "box" ) ; String question = TranslationManager . getinstance ( ) . getText ( "question" ) ; String answer = TranslationManager . getinstance ( ) . getText ( "answer" ) ; String countWrong = TranslationManager . getinstance ( ) . getText ( "countWrong" ) ; String countRight = TranslationManager . getinstance ( ) . getText ( "countRight" ) ; String [ ] columnNames = { box , question , answer , countWrong , countRight } ; TableModel model = new DefaultTableModel ( data , columnNames ) ; this . table . setModel ( model ) ; }
tr	I	public static void main ( String [ ] args ) { JFrame testFrame = new JFrame ( ) ; testFrame . getContentPane ( ) . add ( new JDatePanel ( ) ) ; testFrame . setBounds ( 300 , 200 , 300 , 200 ) ; testFrame . setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ) ; testFrame . setVisible ( true ) ; }
tr	D	ByteArrayCache getDirtyByteArrayCache ( final int length ) { final int bucket = ArrayCache . getBucketDirtyBytes ( length ) ; return getArrayCachesHolder ( ) . dirtyByteArrayCaches [ bucket ] ; }
tr	J	public void join ( ) throws InterruptedException { syncManager . join ( ) ; }
tr	H	FloatArrayCache getDirtyFloatArrayCache ( final int length ) { final int bucket = ArrayCache . getBucket ( length ) ; return getArrayCachesHolder ( ) . dirtyFloatArrayCaches [ bucket ] ; }
tr	E	public static void threatBasedSecurityGoalSimplification ( ModelSet ms , RequirementGraph req_model , int scope ) throws IOException , ScriptException { String req_bus_model_file = ms . req_bus_model . generateFormalExpressionToFile ( scope ) ; String req_app_model_file = ms . req_app_model . generateFormalExpressionToFile ( scope ) ; String req_phy_model_file = ms . req_phy_model . generateFormalExpressionToFile ( scope ) ; String inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/threat_based_simplification.rule " + InfoEnum . current_directory + "/dlv/models/data_flow_model.dl " + InfoEnum . current_directory + "/dlv/models/threat_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_bus_model_file + req_app_model_file + req_phy_model_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( inference_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < SecurityGoal > highlight_sgs = new LinkedList < SecurityGoal > ( ) ; LinkedList < SecurityGoal > highlight_ap_sgs = new LinkedList < SecurityGoal > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "is_critical" ) ) { s = s . replaceAll ( "is\\_critical\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; int separator = s . indexOf ( " " ) ; String sg_id = s . substring ( 0 , separator ) ; String threat_id = s . substring ( separator + 1 ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findElementById ( sg_id ) ; if ( critical_sec_goal != null ) { critical_sec_goal . setCriticality ( true ) ; if ( ! critical_sec_goal . threats . contains ( threat_id ) ) { critical_sec_goal . threats . add ( threat_id ) ; } if ( ! highlight_sgs . contains ( critical_sec_goal ) ) { highlight_sgs . add ( critical_sec_goal ) ; } } else { CommandPanel . logger . severe ( "Simplification error: cannot find the security goal element" ) ; } } if ( s . startsWith ( "is_applicable" ) ) { s = s . replaceAll ( "is\\_applicable\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal applicable_sec_goal = ( SecurityGoal ) req_model . findElementByFormalName ( s ) ; if ( applicable_sec_goal != null ) { applicable_sec_goal . applicability = true ; if ( ! highlight_ap_sgs . contains ( applicable_sec_goal ) ) { highlight_ap_sgs . add ( applicable_sec_goal ) ; } } else { CommandPanel . logger . severe ( "Simplification error: cannot find the security goal element" ) ; } } } } for ( SecurityGoal applicable_sec_goal : highlight_ap_sgs ) { AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , applicable_sec_goal . getLayer ( ) , applicable_sec_goal . getId ( ) , "2" , "none" , "none" ) ; } for ( SecurityGoal critical_sec_goal : highlight_sgs ) { AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal . getId ( ) , "5" , "none" , "none" ) ; AppleScript . addUserData2 ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal , critical_sec_goal . owner_text ) ; } }
tr	B	public float getMaxSpeed ( ) { return ( float ) this . dMaxSpeed ; }
tr	A	@ Override public void vote ( Playable p , BallotBox ballot ) { long startTime = System . currentTimeMillis ( ) ; BallotBox bb = new BallotBox ( ) ; BallotBox dd = new BallotBox ( ) ; MappingField f = p . getField ( ) ; Map < Direction , MappingField > diradj = f . getDirAdjMap ( ) ; for ( Map . Entry < Direction , MappingField > e : diradj . entrySet ( ) ) { if ( cr . isCrossingOffensive ( p , e . getKey ( ) ) ) { ballot . put ( e . getKey ( ) , - 100d ) ; } else { for ( Playable pe : e . getValue ( ) . getPlayables ( ) ) { if ( ! pe . equals ( p ) && ! pe . equals ( p . getCollegue ( ) ) ) { ballot . put ( e . getKey ( ) , - 100d ) ; } } } dd . addElement ( e . getKey ( ) , de . getDeadendDistance ( e . getValue ( ) ) ) ; } dd . normalize ( ) ; dd . magnify ( 0.01d ) ; ballot . submit ( dd ) ; if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( "Escape: " + ( System . currentTimeMillis ( ) - startTime ) + "ms" ) ; } }
tr	D	public Integer loadLevelPacks ( final URI uri ) { final ArrayList < ILevelPack > loadedLevels = LevelPackLoader . loadLevelPacks ( uri ) ; if ( loadedLevels == null ) { return - 1 ; } Integer count = 0 ; for ( final ILevelPack levelPack : loadedLevels ) { if ( levelPack . isNotInitialized ( ) ) { levelPack . initialize ( ) ; levelPack . setInitialized ( true ) ; } if ( register ( levelPack . getLevelStage ( ) , levelPack ) == true ) { count ++ ; } } return count ; }
tr	D	public void paint ( Graphics gr ) { final int w = map . getWidth ( ) ; final int h = map . getHeight ( ) ; gr . getClipBounds ( clip ) ; final int floor = Math . max ( currentLayer , 0 ) ; if ( hasTransparentTiles ) { for ( int n = 0 ; n < floor ; n ++ ) { for ( int y = 0 ; y < h ; y ++ ) { for ( int x = 0 ; x < w ; x ++ ) { paintTile ( gr , n , x , y ) ; } } } } if ( currentLayer > 0 ) { paintGrid ( gr , clip ) ; } final int layers = map . getLayerCount ( ) ; if ( hasTransparentTiles ) { for ( int y = floor ; y < h ; y ++ ) { for ( int x = 0 ; x < w ; x ++ ) { for ( int n = 0 ; n < layers ; n -- ) { paintTile ( gr , n , x , y ) ; } } } } else { for ( int y = 0 ; y < h ; y ++ ) { for ( int x = 0 ; x < w ; x ++ ) { boolean go = true ; for ( int n = layers - 1 ; go && n >= floor ; n -- ) { go = ! paintTile ( gr , n , x , y ) ; } } } } if ( markX != - 1 && markY != - 1 ) { final int xpos = xoff + tileLocator . getTileScreenX ( markX , markY ) ; final int ypos = yoff + tileLocator . getTileScreenY ( markX , markY ) ; gr . setColor ( Color . WHITE ) ; gr . drawRect ( xpos , ypos , tileLocator . getCursorX ( ) , tileLocator . getCursorY ( ) ) ; } }
tr	A	public String getName ( ) { return name ; }
tr	A	public TextHandler ( TokenContext context ) { super ( context ) ; this . token = new Token ( ) ; }
tr	B	public String getFormat ( ) { return format ; }
tr	I	void button_load_clicked ( ) { FileDialog dialog = new FileDialog ( new Frame ( ) , "Load" , FileDialog . LOAD ) ; dialog . setVisible ( true ) ; String filename = dialog . getDirectory ( ) + dialog . getFile ( ) ; if ( filename == null ) return ; clear_all ( ) ; try { BufferedReader fp = new BufferedReader ( new FileReader ( filename ) ) ; String line ; while ( ( line = fp . readLine ( ) ) != null ) { StringTokenizer st = new StringTokenizer ( line , " \t\n\r\f:" ) ; if ( st . countTokens ( ) == 5 ) { byte value = ( byte ) atoi ( st . nextToken ( ) ) ; st . nextToken ( ) ; double x = atof ( st . nextToken ( ) ) ; st . nextToken ( ) ; double y = atof ( st . nextToken ( ) ) ; point_list . addElement ( new point ( x , y , value ) ) ; } else if ( st . countTokens ( ) == 3 ) { double y = atof ( st . nextToken ( ) ) ; st . nextToken ( ) ; double x = atof ( st . nextToken ( ) ) ; point_list . addElement ( new point ( x , y , current_value ) ) ; } else break ; } fp . close ( ) ; } catch ( IOException e ) { System . err . print ( e ) ; } draw_all_points ( ) ; }
tr	C	void BuscarClienteEditar ( String cod ) { conectar cc = new conectar ( ) ; Connection cn = cc . conexion ( ) ; try { limpiar ( ) ; String ced = "" , nom = "" , ape = "" , sex , fechaN , ecivil , nhijos = "" , municipios = "" , direccion = "" , email = "" , telefono = "" , celular = "" ; String cons = "select * from cliente WHERE Cedula='" + cod + "'" ; Statement st = cn . createStatement ( ) ; ResultSet rs = st . executeQuery ( cons ) ; while ( rs . next ( ) ) { ced = rs . getString ( 2 ) ; nom = rs . getString ( 3 ) ; ape = rs . getString ( 4 ) ; sex = rs . getString ( 5 ) ; fechaN = rs . getString ( 6 ) ; ecivil = rs . getString ( 7 ) ; nhijos = rs . getString ( 8 ) ; municipios = rs . getString ( 9 ) ; direccion = rs . getString ( 10 ) ; email = rs . getString ( 11 ) ; telefono = rs . getString ( 12 ) ; celular = rs . getString ( 13 ) ; } txtCedula . setText ( ced ) ; txtNombre . setText ( nom ) ; txtApellido . setText ( ape ) ; txtEmail . setText ( email ) ; txtHijos . setText ( nhijos ) ; txtDireccion . setText ( direccion ) ; txtTelefono . setText ( telefono ) ; txtCelular . setText ( celular ) ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } }
tr	E	public void setOutputFilter ( TcpMessageFilter outputFilter ) { this . outputFilter = outputFilter ; }
tr	A	public void add ( Table table ) { if ( tables . putIfAbsent ( table . getName ( ) , table ) != null ) { throw new SqlException ( "Cannot create table with name '" + table . getName ( ) + "' - table already exists" ) ; } }
tr	H	void button_clear_clicked ( ) { clear_all ( ) ; }
tr	H	@ Deprecated public int getLine ( ) { return bufline [ bufpos ] ; }
tr	G	public static void securityGoalSimplification ( RequirementGraph req_model , ActorAssociationGraph actor_model , int scope ) throws IOException , ScriptException { String req_model_file = req_model . generateFormalExpressionToFile ( scope ) ; String actor_model_file = InfoEnum . current_directory + "/dlv/models/actor_association_model.dl " ; if ( actor_model . getElements ( ) . size ( ) != 0 ) { actor_model_file = actor_model . generateFormalExpressionToFile ( ) ; } String inference_rule = "" ; if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . BUSINESS . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_bus.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/business_process_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . APPLICATION . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_app.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/software_architecture_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . PHYSICAL . name ( ) ) ) { inference_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/simplification_phy.rule " + InfoEnum . current_directory + "/dlv/rules/simplification_general.rule " + InfoEnum . current_directory + "/dlv/models/deployment_model.dl " + InfoEnum . current_directory + "/dlv/models/software_architecture_model.dl " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + req_model_file + " " + actor_model_file ; } else { CommandPanel . logger . severe ( "Error refinement type!" ) ; } Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( inference_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { CommandPanel . logger . info ( s ) ; if ( s . startsWith ( "is_critical" ) ) { s = s . replaceAll ( "is\\_critical\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findElementByFormalName ( s ) ; critical_sec_goal . setCriticality ( true ) ; AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal . getId ( ) , "5" , "none" , "none" ) ; } else if ( s . startsWith ( "non_deterministic" ) ) { s = s . replaceAll ( "non\\_deterministic\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; SecurityGoal critical_sec_goal = ( SecurityGoal ) req_model . findElementByFormalName ( s ) ; critical_sec_goal . setNon_deterministic ( true ) ; AppleScript . changeAttributeOfElement ( InfoEnum . REQ_TARGET_CANVAS , critical_sec_goal . getLayer ( ) , critical_sec_goal . getId ( ) , "3" , "none" , "none" ) ; } } } input . close ( ) ; }
tr	J	private void textBuscarKeyTyped ( java . awt . event . KeyEvent evt ) { if ( CheckNombre . isSelected ( ) ) { if ( ! Character . isLetter ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre del proveedor demadiado largo." , "ADVERTENCIA" , WIDTH ) ; } } if ( CheckLab . isSelected ( ) ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de laboratorio demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } } if ( CheckTelefono . isSelected ( ) ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( textBuscar . getText ( ) . length ( ) == 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } } }
tr	J	private void jToggleButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { bloquear ( ) ; }
tr	B	@ Override public void putTab ( ) throws ParsingException { if ( token . isStarted ( ) ) putChar ( Characters . TAB ) ; }
tr	B	public int getWidth ( ) { return width ; }
tr	E	public void setRotationSpeed ( float rotationSpeed ) { this . rotationSpeed = rotationSpeed ; }
tr	J	public boolean isfollowMe ( ) { return followMe ; }
tr	G	static double [ ] dataLightSubprocessor ( String datain ) { String [ ] dataInSplit = datain . replaceAll ( "@" , " " ) . replaceAll ( "_" , " " ) . split ( " " ) ; if ( dataInSplit . length != 175 ) System . out . println ( dataInSplit . length ) ; double [ ] processed = new double [ dataInSplit . length ] ; for ( int i = 0 ; i < dataInSplit . length ; i ++ ) { double factor = 1 ; String data = dataInSplit [ i ] . replace ( "$" , "" ) ; data = data . replace ( "%" , "" ) ; data = data . replaceAll ( "--" , "" ) ; data = data . replaceAll ( "\\(" , "-" ) ; data = data . replaceAll ( "\\)" , "" ) ; data = data . replaceAll ( "NM" , "" ) ; data = data . replaceAll ( "Dividend" , "" ) ; for ( int j = 0 ; j < months . length ; j ++ ) { if ( data . equals ( months [ j ] ) ) { data = "" + j ; } } if ( data . equals ( "#" ) ) processed [ i ] = - 0.0000001 ; if ( data . contains ( "B" ) ) { factor = 1000000000 ; data = data . replaceAll ( "B" , "" ) ; } if ( data . contains ( "M" ) ) { factor = 1000000 ; data = data . replaceAll ( "M" , "" ) ; } if ( data . contains ( "K" ) ) { factor = 1000 ; data = data . replaceAll ( "K" , "" ) ; } if ( data != null ) { String dat = data . replaceAll ( " " , "" ) ; double dub = doDouble ( dat ) ; processed [ i ] = dub * factor ; } else { processed [ i ] = - 0.0000001 ; } } return processed ; }
tr	B	public int getNumberOfLinks ( int threshold ) { initTreeTraversal ( ) ; LinkSetNode L = getNextInOrder ( ) ; int c = 0 ; while ( L != null ) { if ( L . w > threshold ) { c ++ ; } L = getNextInOrder ( ) ; } return c ; }
tr	H	@ Deprecated public int getColumn ( ) { return bufcolumn [ bufpos ] ; }
tr	G	public synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	F	private int getSequence ( Element el , Sequences sequences ) { Integer sequence = FormattingUtil . parseInt ( el . getAttribute ( ObjectFile . ATTR_SEQUENCE ) ) ; return ( sequence == null ) ? sequence = sequences . nextSequence ( ) : sequences . see ( sequence ) ; }
tr	A	public Socket ( java . net . Socket socket ) { super ( ) ; if ( ! socket . isConnected ( ) ) return ; setRawSocket ( socket ) ; if ( socket . getInetAddress ( ) != null ) Logger . getLogger ( getClass ( ) ) . info ( new StringBuffer ( String . format ( "Connect from %s" , socket . getInetAddress ( ) . getHostName ( ) ) ) ) ; try { bufferedreader = new BufferedReader ( new InputStreamReader ( getRawSocket ( ) . getInputStream ( ) ) ) ; printwriter = new PrintWriter ( getRawSocket ( ) . getOutputStream ( ) , true ) ; } catch ( IOException e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } }
tr	G	public String getSitemapPriority ( ) { assert this . sitemapPriority != null ; return this . sitemapPriority ; }
tr	B	private static void makeSureFilesExist ( String makeFileWithName ) { File newFile = new File ( makeFileWithName ) ; try { newFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	C	@ Override protected Node < T > removeValue ( T value ) { Node < T > nodeToRemoved = this . getNode ( value ) ; if ( nodeToRemoved != null ) { Node < T > replacementNode = this . getReplacementNode ( nodeToRemoved ) ; AVLNode < T > nodeToRefactor = null ; if ( replacementNode != null ) nodeToRefactor = ( AVLNode < T > ) replacementNode . parent ; if ( nodeToRefactor == null ) nodeToRefactor = ( AVLNode < T > ) nodeToRemoved . parent ; if ( nodeToRefactor != null && nodeToRefactor . equals ( nodeToRemoved ) ) nodeToRefactor = ( AVLNode < T > ) replacementNode ; replaceNodeWithNode ( nodeToRemoved , replacementNode ) ; if ( nodeToRefactor != null ) { while ( nodeToRefactor != null ) { nodeToRefactor . updateHeight ( ) ; balanceAfterDelete ( nodeToRefactor ) ; nodeToRefactor = ( AVLNode < T > ) nodeToRefactor . parent ; } } } return nodeToRemoved ; }
tr	B	@ Override public void putSpace ( ) throws ParsingException { if ( token . isStarted ( ) ) putChar ( Characters . SPACE ) ; }
tr	D	private void loadTaskRequest ( ManifestBuilder builder , Element requestEl ) { loadTask ( builder , requestEl ) ; builder . setIsRequest ( true ) ; }
tr	F	private static int getArrayLength ( Object ar ) throws BuildException { try { return Array . getLength ( ar ) ; } catch ( Exception e ) { throw new BuildException ( "Error getting length on " + ar . toString ( ) , e ) ; } }
tr	E	@ Override public Draft copyInstance ( ) { return new Draft_76 ( ) ; }
tr	I	private void initDateRangePanel ( Composite mainPanel ) { dateRangePanel = new Composite ( mainPanel , SWT . NONE ) ; dateRangePanel . setLayout ( new MigLayout ( ) ) ; Label label = new Label ( dateRangePanel , SWT . NONE ) ; label . setText ( "Minimum Value: " ) ; dateMinValDt = new DateTime ( dateRangePanel , SWT . DATE | SWT . BORDER ) ; dateMinValDt . setLayoutData ( "wrap" ) ; label = new Label ( dateRangePanel , SWT . NONE ) ; label . setText ( "Maximum Value: " ) ; dateMaxValDt = new DateTime ( dateRangePanel , SWT . DATE | SWT . BORDER ) ; dateMaxValDt . setLayoutData ( "wrap" ) ; label = new Label ( dateRangePanel , SWT . NONE ) ; label . setText ( "Date format: " ) ; dateFormat = new Text ( dateRangePanel , SWT . BORDER ) ; dateFormat . setText ( "yyyy/MM/dd" ) ; if ( fieldDef . getContentDef ( ) instanceof DateRangeContentDef ) { DateRangeContentDef cd = ( DateRangeContentDef ) fieldDef . getContentDef ( ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( cd . getMinVal ( ) ) ; dateMinValDt . setYear ( cal . get ( Calendar . YEAR ) ) ; dateMinValDt . setMonth ( cal . get ( Calendar . MONTH + 1 ) ) ; dateMinValDt . setDay ( cal . get ( Calendar . DAY_OF_MONTH ) ) ; cal . setTime ( cd . getMaxVal ( ) ) ; dateMaxValDt . setYear ( cal . get ( Calendar . YEAR ) ) ; dateMaxValDt . setMonth ( cal . get ( Calendar . MONTH + 1 ) ) ; dateMaxValDt . setDay ( cal . get ( Calendar . DAY_OF_MONTH ) ) ; dateRangePanel . setVisible ( true ) ; } else dateRangePanel . setVisible ( false ) ; }
tr	H	private void next ( ) { switch ( _current ) { case PAUSE : case PLAY : _index ++ ; if ( _myList . getModel ( ) . getSize ( ) == _index ) { _index -- ; } else { _player . stop ( ) ; playSong ( _myList . getModel ( ) . getElementAt ( _index ) ) ; } break ; case STOP : break ; } }
tr	E	private void sendHello ( ) { send ( new FppsResponse ( getClass ( ) . getSimpleName ( ) . concat ( "()" ) ) ) ; }
tr	B	public float getX ( ) { return ( float ) position . x ; }
tr	E	@ Override public ByteBuffer createBinaryFrame ( Framedata framedata ) { if ( framedata . getOpcode ( ) == Opcode . CLOSING ) return ByteBuffer . wrap ( closehandshake ) ; return super . createBinaryFrame ( framedata ) ; }
tr	A	private boolean checkLocationAvailable ( ) { if ( y0 < 0 || y1 < 0 || y2 < 0 || y3 < 0 || y0 > 19 || y1 > 19 || y2 > 19 || y3 > 19 || tokens [ y0 ] [ x0 ] . getType ( ) > 0 || tokens [ y1 ] [ x1 ] . getType ( ) > 0 || tokens [ y2 ] [ x2 ] . getType ( ) > 0 || tokens [ y3 ] [ x3 ] . getType ( ) > 0 ) { return false ; } return true ; }
tr	I	public int getFavouritesCount ( ) { return favouritesCount ; }
tr	E	public String getUrl ( ) { return url ; }
tr	E	public synchronized Connection getConnection ( ) { Connection connection = null ; if ( connectionPool . size ( ) > 0 ) { connection = connectionPool . get ( 0 ) ; connectionPool . remove ( 0 ) ; dbPoolIdleSize -- ; if ( ! testConnection ( connection ) ) { try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connection = createNewConnection ( ) ; if ( connection == null ) { dbPoolSize -- ; CDbError . logError ( errfile , false , "Got null connection from pool  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } } else if ( dbPoolSize < dbPoolMax ) { connection = createNewConnection ( ) ; if ( connection == null ) CDbError . logError ( errfile , false , "Adding null connection ignored  database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; else { dbPoolSize ++ ; CDbError . logError ( errfile , false , "Added connection to database (" + dbUrl + ") connection pool " + Integer . toString ( dbPoolSize ) , null ) ; } } else { CDbError . logError ( errfile , false , "Database (" + dbUrl + ") connection pool cannot be extended " + Integer . toString ( dbPoolSize ) , null ) ; } return ( connection ) ; }
tr	G	public static X509Certificate readCertFromDER ( String fileName ) { try { CertificateFactory cf = CertificateFactory . getInstance ( "X509" ) ; InputStream certstream = fullStream ( fileName ) ; Certificate c = cf . generateCertificate ( certstream ) ; return ( X509Certificate ) c ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	A	public String getUsername ( ) { return username ; }
tr	A	public void postTurn ( ) { }
tr	B	public void closeAlphabets ( ) { wordAlphabet . stopGrowth ( ) ; stoppedGrowth = true ; }
tr	D	private void manageDecisionMessage ( int senderID , DecisionMessage msg ) { currentVoting . decisionMessage ( senderID , msg ) ; if ( ! currentVoting . isPending ( ) ) { currentVoting . printResult ( ) ; } }
tr	H	public URL getURL ( ) { try { return new URL ( url ) ; } catch ( MalformedURLException ex ) { return null ; } }
tr	I	public boolean isVerified ( ) { return verified ; }
tr	C	@ Override public HandshakeState acceptHandshakeAsClient ( ClientHandshake request , ServerHandshake response ) { if ( failed ) { return HandshakeState . NOT_MATCHED ; } try { if ( ! response . getFieldValue ( "Sec-WebSocket-Origin" ) . equals ( request . getFieldValue ( "Origin" ) ) || ! basicAccept ( response ) ) { return HandshakeState . NOT_MATCHED ; } byte [ ] content = response . getContent ( ) ; if ( content == null || content . length == 0 ) { throw new IncompleteHandshakeException ( ) ; } if ( Arrays . equals ( content , createChallenge ( request . getFieldValue ( "Sec-WebSocket-Key1" ) , request . getFieldValue ( "Sec-WebSocket-Key2" ) , request . getContent ( ) ) ) ) { return HandshakeState . MATCHED ; } else { return HandshakeState . NOT_MATCHED ; } } catch ( InvalidHandshakeException e ) { throw new RuntimeException ( "bad handshakerequest" , e ) ; } }
tr	F	public void keyReleased ( java . awt . event . KeyEvent evt ) { }
tr	G	private static boolean isNumberObject ( class < ? > clazz , Map < String , Object > options ) { if ( clazz . equals ( byte . class ) ) return true ; if ( clazz . equals ( short . class ) ) return true ; if ( clazz . equals ( Integer . class ) ) return true ; if ( clazz . equals ( long . class ) ) return true ; if ( clazz . equals ( float . class ) ) return true ; if ( clazz . equals ( double . class ) ) return true ; return false ; }
tr	D	private void notifyClients ( int newClientID , String name ) { console . displayMessage ( "Notifying clients" ) ; for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) != newClientID ) { console . displayMessage ( "Notifying " + clients . get ( i ) . getID ( ) + " about " + newClientID ) ; try { clients . get ( i ) . sendMessage ( new IdentificationMessage ( newClientID , name ) ) ; } catch ( NetworkMessageException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } } } }
tr	I	public Date getCreatedAt ( ) { return createdAt ; }
tr	F	private static Object getArrayValue ( Object ar , int i ) throws BuildException { try { return Array . get ( ar , i ) ; } catch ( Exception e ) { throw new BuildException ( "Error getting value[" + i + "] on " + ar . toString ( ) , e ) ; } }
tr	F	int [ ] getIntArray ( final int length ) { if ( length <= MAX_ARRAY_SIZE ) { return getIntArrayCache ( length ) . getArray ( ) ; } if ( DO_STATS ) { incOversize ( ) ; } if ( DO_LOG_OVER_SIZE ) { logInfo ( "getIntArray[oversize]: length=\t" + length + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return new int [ length ] ; }
tr	G	int [ ] getDirtyIntArray ( final int length ) { if ( length <= MAX_ARRAY_SIZE ) { return getDirtyIntArrayCache ( length ) . getArray ( ) ; } if ( DO_STATS ) { incOversize ( ) ; } if ( DO_LOG_OVER_SIZE ) { logInfo ( "getDirtyIntArray[oversize]: length=\t" + length + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return new int [ length ] ; }
tr	C	public int monsterCount ( ) { return monsters . size ( ) ; }
tr	H	public int getBeginColumn ( ) { return bufcolumn [ tokenBegin ] ; }
tr	C	@ Override public HandshakeState acceptHandshakeAsServer ( ClientHandshake handshakedata ) { if ( handshakedata . getFieldValue ( "Upgrade" ) . equals ( "WebSocket" ) && handshakedata . getFieldValue ( "Connection" ) . contains ( "Upgrade" ) && handshakedata . getFieldValue ( "Sec-WebSocket-Key1" ) . length ( ) > 0 && ! handshakedata . getFieldValue ( "Sec-WebSocket-Key2" ) . isEmpty ( ) && handshakedata . hasFieldValue ( "Origin" ) ) return HandshakeState . MATCHED ; return HandshakeState . NOT_MATCHED ; }
tr	B	public void addMonster ( Monster m ) { monsters . add ( m ) ; }
tr	I	public static void exhaustiveSecurityGoalRefineAnalysis ( ModelSet ms , RequirementGraph req_model , ActorAssociationGraph actor_model , int visual_type , int scope ) throws IOException , ScriptException { req_model . getSg_elem ( ) . clear ( ) ; req_model . getSg_links ( ) . clear ( ) ; String expression_file = req_model . generateFormalExpressionToFile ( scope ) ; String security_model_file = InfoEnum . current_directory + "/dlv/models/security_model_" + req_model . getLayer ( ) . toLowerCase ( ) + ".dl " ; String refine_rule = "" ; refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/refine_all.rule " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + expression_file + " " + security_model_file ; Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; int number = 100000 ; for ( String s : result ) { if ( s . startsWith ( "ex_and_refined_sec_goal" ) ) { s = s . replaceAll ( "ex_and_refined_sec_goal\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; s = s . replaceAll ( "\\_" , " " ) ; String [ ] sg = s . split ( " " ) ; SecurityGoal new_sg = req_model . findExhausiveSecurityGoalByAttributes ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , sg [ 3 ] ) ; SecurityGoal refined_sg = req_model . findExhausiveSecurityGoalByAttributes ( sg [ 4 ] , sg [ 5 ] , sg [ 6 ] , sg [ 7 ] ) ; if ( new_sg == null ) { Element re = req_model . findElementById ( sg [ 3 ] ) ; if ( re != null ) { new_sg = new SecurityGoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , re , InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) , req_model . getLayer ( ) ) ; new_sg . setId ( String . valueOf ( number ) ) ; number ++ ; req_model . getSg_elem ( ) . add ( new_sg ) ; } else { CommandPanel . logger . severe ( "Security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } } if ( refined_sg == null ) { Element re = req_model . findElementById ( sg [ 7 ] ) ; if ( re != null ) { refined_sg = new SecurityGoal ( sg [ 4 ] , sg [ 5 ] , sg [ 6 ] , re , InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) , req_model . getLayer ( ) ) ; refined_sg . setId ( String . valueOf ( number ) ) ; number ++ ; req_model . getSg_elem ( ) . add ( refined_sg ) ; } else { CommandPanel . logger . severe ( "Security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } } RequirementLink new_and_refine = new RequirementLink ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) , new_sg , refined_sg ) ; if ( ! sg [ 1 ] . equals ( sg [ 5 ] ) ) { new_and_refine . refine_type = InfoEnum . RefineType . ATTRIBUTE . name ( ) ; } else if ( ! sg [ 2 ] . equals ( sg [ 6 ] ) ) { new_and_refine . refine_type = InfoEnum . RefineType . ASSET . name ( ) ; } else if ( ! sg [ 3 ] . equals ( sg [ 7 ] ) ) { new_and_refine . refine_type = InfoEnum . RefineType . INTERVAL . name ( ) ; } else { CommandPanel . logger . log ( Level . SEVERE , "Refine type is not set correctly" ) ; } if ( ! req_model . getSg_links ( ) . contains ( new_and_refine ) ) { req_model . getSg_links ( ) . add ( new_and_refine ) ; } refined_sg . and_refine_links . add ( new_and_refine ) ; new_sg . parent = refined_sg ; new_sg . parent_link = new_and_refine ; } } if ( visual_type == InfoEnum . GRAPHVIZ ) { VisualizationFunctions . visualizeGraph ( ms , req_model , actor_model , InfoEnum . GRAPHVIZ , InfoEnum . INITIAL_VIEW ) ; VisualizationFunctions . visualizeGraph ( ms , req_model , actor_model , InfoEnum . GRAPHVIZ , InfoEnum . HIGHLIGHT_VIEW ) ; VisualizationFunctions . visualizeGraph ( ms , req_model , actor_model , InfoEnum . GRAPHVIZ , InfoEnum . SIMPLIFIED_VIEW ) ; } else if ( visual_type == InfoEnum . CANVAS ) { VisualizationFunctions . visualizeGraph ( ms , req_model , actor_model , InfoEnum . CANVAS , InfoEnum . HIGHLIGHT_VIEW ) ; } else { CommandPanel . logger . warning ( "Visualization type error!" ) ; } } }
tr	I	public List < InputVariable > getInputVariables ( ) { return this . inputVariables ; }
tr	F	private List < Field1 < M >> allFields ( ) { LinkedList < Field1 < M >> ret = new LinkedList < > ( ) ; ret . addAll ( idFields ) ; ret . addAll ( dataFields ) ; return ret ; }
tr	F	public static String limitToTen ( String pastPrices ) { if ( pastPrices . contains ( "Split" ) ) System . out . println ( "**S-->" + pastPrices ) ; if ( pastPrices . equals ( "HISTORIC" ) ) return "#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#@#_#_#_#_#_#_#_#_#" + " #" + " #" ; split = 1 ; dividends = 0 ; String [ ] days = pastPrices . split ( "@" ) ; StringBuilder reconstruct = new StringBuilder ( ) ; int counter = 0 ; for ( int i = 0 ; i < days . length ; i ++ ) { String [ ] data = days [ i ] . split ( "_" ) ; if ( data . length < 9 ) { System . out . println ( pastPrices ) ; String [ ] determine = days [ i ] . split ( ":" ) ; try { if ( determine . length < 2 ) dividends += doDouble ( days [ i ] . split ( "_" ) [ 3 ] ) ; else if ( counter < 5 ) { split = doDouble ( determine [ 0 ] . split ( "_" ) [ 3 ] ) / doDouble ( determine [ 1 ] . toLowerCase ( ) . replace ( "stock_split" , "" ) . replaceAll ( "_" , "" ) ) ; System . out . println ( "SPLIT: " + split + "\nFrom: " + pastPrices ) ; } } catch ( Exception e ) { System . out . println ( days [ i ] ) ; e . printStackTrace ( ) ; } } else { reconstruct . append ( days [ i ] + "@" ) ; counter ++ ; if ( counter == 10 ) break ; } } for ( int j = counter - 1 ; j < 9 ; j ++ ) reconstruct . append ( "#_#_#_#_#_#_#_#_#@" ) ; return reconstruct . append ( " " + dividends + " " + split ) . deleteCharAt ( reconstruct . lastIndexOf ( "@" ) ) . toString ( ) ; }
tr	G	public static PrivateKey readPrivateKeyFromDER ( String fileName ) { try { InputStream fl = fullStream ( fileName ) ; byte [ ] key = new byte [ fl . available ( ) ] ; KeyFactory kf = KeyFactory . getInstance ( "RSA" ) ; fl . read ( key , 0 , fl . available ( ) ) ; fl . close ( ) ; PKCS8EncodedKeySpec keysp = new PKCS8EncodedKeySpec ( key ) ; PrivateKey privK = kf . generatePrivate ( keysp ) ; return privK ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
tr	C	private static void saveMapToTextFile ( String fileToSaveTo ) { FileWriter writeto = null ; try { writeto = new FileWriter ( fileToSaveTo , true ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( writeto == null ) { System . out . println ( "file not initialized" ) ; return ; } for ( Map . Entry < String , String > entry : rawMap . entrySet ( ) ) { String textadd = entry . getKey ( ) + SPLITTER + entry . getValue ( ) + "\n" ; char [ ] buffer = new char [ textadd . length ( ) ] ; textadd . getChars ( 0 , textadd . length ( ) , buffer , 0 ) ; try { writeto . write ( buffer ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { writeto . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
tr	A	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jScrollPane1 = new javax . swing . JScrollPane ( ) ; jTable1 = new javax . swing . JTable ( ) ; CheckNombre = new javax . swing . JCheckBox ( ) ; CheckTelefono = new javax . swing . JCheckBox ( ) ; CheckLab = new javax . swing . JCheckBox ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; textBuscar = new javax . swing . JTextField ( ) ; buscarButton = new javax . swing . JButton ( ) ; limpiarButton = new javax . swing . JButton ( ) ; salirButton = new javax . swing . JButton ( ) ; modificarButton = new javax . swing . JButton ( ) ; eliminarButton = new javax . swing . JButton ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . DISPOSE_ON_CLOSE ) ; setTitle ( "Buscar proveedor" ) ; setResizable ( false ) ; jTable1 . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { } , new String [ ] { "ID" , "Nombre" , "Telefono" , "Laboratorio" } ) { boolean [ ] canEdit = new boolean [ ] { false , false , false , false } ; public boolean isCellEditable ( int rowIndex , int columnIndex ) { return canEdit [ columnIndex ] ; } } ) ; jTable1 . getTableHeader ( ) . setReorderingAllowed ( false ) ; jTable1 . addMouseListener ( new java . awt . event . MouseAdapter ( ) { public void mouseClicked ( java . awt . event . MouseEvent evt ) { jTable1MouseClicked ( evt ) ; } } ) ; jScrollPane1 . setViewportView ( jTable1 ) ; jTable1 . getColumnModel ( ) . getColumn ( 0 ) . setResizable ( false ) ; jTable1 . getColumnModel ( ) . getColumn ( 1 ) . setResizable ( false ) ; jTable1 . getColumnModel ( ) . getColumn ( 2 ) . setResizable ( false ) ; jTable1 . getColumnModel ( ) . getColumn ( 3 ) . setResizable ( false ) ; CheckNombre . setText ( "Nombre" ) ; CheckNombre . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { CheckNombreActionPerformed ( evt ) ; } } ) ; CheckTelefono . setText ( "Telefono" ) ; CheckTelefono . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { CheckTelefonoActionPerformed ( evt ) ; } } ) ; CheckLab . setText ( "Laboratorio" ) ; CheckLab . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { CheckLabActionPerformed ( evt ) ; } } ) ; jLabel1 . setFont ( new java . awt . Font ( "Tahoma" , 1 , 11 ) ) ; jLabel1 . setText ( "Seleccione por que elemento desea hacer la busqueda del proveedor" ) ; textBuscar . setEnabled ( false ) ; textBuscar . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyTyped ( java . awt . event . KeyEvent evt ) { textBuscarKeyTyped ( evt ) ; } } ) ; buscarButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/farmacia/find.png" ) ) ) ; buscarButton . setText ( "Buscar" ) ; buscarButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { buscarButtonActionPerformed ( evt ) ; } } ) ; limpiarButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/farmacia/refresh.png" ) ) ) ; limpiarButton . setText ( "Limpiar" ) ; limpiarButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { limpiarButtonActionPerformed ( evt ) ; } } ) ; salirButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/farmacia/salir.png" ) ) ) ; salirButton . setText ( "Salir" ) ; salirButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { salirButtonActionPerformed ( evt ) ; } } ) ; modificarButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/farmacia/modificar.jpg" ) ) ) ; modificarButton . setText ( "Modificar" ) ; modificarButton . setEnabled ( false ) ; modificarButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { modificarButtonActionPerformed ( evt ) ; } } ) ; eliminarButton . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/farmacia/eliminar.jpg" ) ) ) ; eliminarButton . setText ( "Eliminar" ) ; eliminarButton . setEnabled ( false ) ; eliminarButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { eliminarButtonActionPerformed ( evt ) ; } } ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 23 , 23 , 23 ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addComponent ( textBuscar ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( buscarButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( limpiarButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( modificarButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( eliminarButton ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( salirButton ) ) ) ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 71 , 71 , 71 ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jLabel1 ) . addGroup ( layout . createSequentialGroup ( ) . addGap ( 150 , 150 , 150 ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . TRAILING ) . addComponent ( CheckLab ) . addComponent ( CheckTelefono , javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( CheckNombre , javax . swing . GroupLayout . Alignment . LEADING ) ) ) . addComponent ( jScrollPane1 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . PREFERRED_SIZE , 375 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ) . addContainerGap ( javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( layout . createSequentialGroup ( ) . addComponent ( jScrollPane1 , javax . swing . GroupLayout . PREFERRED_SIZE , 92 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addComponent ( jLabel1 ) . addGap ( 18 , 18 , 18 ) . addComponent ( CheckNombre ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( CheckTelefono ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( CheckLab ) . addGap ( 6 , 6 , 6 ) . addComponent ( textBuscar , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( buscarButton ) . addComponent ( salirButton ) . addComponent ( limpiarButton ) . addComponent ( modificarButton ) . addComponent ( eliminarButton ) ) . addContainerGap ( 22 , short . MAX_VALUE ) ) ) ; pack ( ) ; }
tr	J	public void setCurrentPageIndex ( int currentPageIndex ) { this . currentPageIndex = currentPageIndex ; repaint ( ) ; }
tr	F	public void kick ( int id ) { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == id ) { try { clients . get ( i ) . sendMessage ( new StringMessage ( 0 , id , "Kicked" ) ) ; clients . get ( i ) . stop ( ) ; } catch ( NetworkMessageException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } catch ( IOException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } return ; } } console . displayMessage ( "Could not kick client with id " + id ) ; }
tr	A	public BuscarProveedor ( ) { initComponents ( ) ; conectarBaseDeDatos ( ) ; this . setModal ( true ) ; }
tr	C	@ Override public void updateViewFromModel ( ) { topic . setText ( presenter . getModel ( ) . getName ( ) ) ; setTableContent ( ) ; }
tr	H	public boolean removeAll ( Array < ? extends T > array , boolean identity ) { int size = this . size ; int startSize = size ; T [ ] items = this . items ; if ( identity ) { for ( int i = 0 , n = array . size ; i < n ; i ++ ) { T item = array . get ( i ) ; for ( int ii = 0 ; ii < size ; ii ++ ) { if ( item == items [ ii ] ) { removeIndex ( ii ) ; size -- ; break ; } } } } else { for ( int i = 0 , n = array . size ; i < n ; i ++ ) { T item = array . get ( i ) ; for ( int ii = 0 ; ii < size ; ii ++ ) { if ( item . equals ( items [ ii ] ) ) { removeIndex ( ii ) ; size -- ; break ; } } } } return size != startSize ; }
tr	A	final public static GraphPoint buildNode ( Object o , Graph graph , GraphBuildContext context , int nestingLevel ) throws BuildException { if ( o == null ) { System . err . printf ( "Won't build a null\n" ) ; return null ; } final Map < String , Object > options = context . getOptions ( ) ; final boolean showSystemHash = ( options . containsKey ( BuilderOptions . SHOW_SYSHASH ) ? ( boolean ) options . get ( BuilderOptions . SHOW_SYSHASH ) : BuilderOptions . DEFAULT_SHOW_SYSHASH ) ; final int MAX_NESTING = ( options . containsKey ( BuilderOptions . MAX_NESTING ) ? ( Integer ) options . get ( BuilderOptions . MAX_NESTING ) : BuilderOptions . DEFAULT_MAX_NESTING ) ; final int MAX_ARRAY_LENGTH = ( options . containsKey ( BuilderOptions . MAX_ARRAY_LENGTH ) ? ( Integer ) options . get ( BuilderOptions . MAX_ARRAY_LENGTH ) : BuilderOptions . DEFAULT_MAX_ARRAY_LENGTH ) ; final int generation = ( Integer ) options . get ( BuilderOptions . GENERATION ) ; try { final String classname = getClassName ( o ) ; final String packageNameOfInstance = classNameToPackage ( o . getClass ( ) . getName ( ) ) ; if ( o . getClass ( ) . isArray ( ) ) { int length = getArrayLength ( o ) ; if ( length > MAX_ARRAY_LENGTH ) { System . out . printf ( "Truncating array type %s of length %d to %d\n" , classname , length , MAX_ARRAY_LENGTH ) ; length = MAX_ARRAY_LENGTH ; } final boolean inlineValues = shouldInlineArrayValues ( o , options ) ; NodeArray array = new NodeArray ( NamedIDGenerator . next ( ) , " " , length , generation , inlineValues ) ; array . putAttr ( Named . class , classname ) ; for ( int i = 0 ; i < length ; i ++ ) { Object val = getArrayValue ( o , i ) ; if ( val == null ) continue ; if ( inlineValues ) { Node node = new Node ( NamedIDGenerator . next ( ) , generation ) ; node . putAttr ( Named . class , getClassName ( val ) ) ; node . putAttr ( Named . ARRAY_INDEX , i ) ; node . putAttr ( Named . VALUE , val ) ; array . set ( i , node ) ; } else if ( nestingLevel < MAX_NESTING ) { enqueueNode ( context , nestingLevel , array , String . format ( "%d" , i ) , val ) ; } else { String reason = "" ; if ( nestingLevel >= MAX_NESTING ) { reason = String . format ( "nestingLevel %d exceeds MAX_NESTING %d" , nestingLevel , MAX_NESTING ) ; } System . out . printf ( "Not following array %s because %s.\n" , classname , reason ) ; } } if ( showSystemHash ) NodeUtil . addSystemHash ( array , o ) ; context . addPoint ( o , array ) ; return array ; } else { Node node = new Node ( NamedIDGenerator . next ( ) , generation ) ; node . putAttr ( Named . class , classname ) ; if ( showSystemHash ) { NodeUtil . addSystemHash ( node , o ) ; } class < ? > clazz = o . getClass ( ) ; while ( clazz != null && classNameToPackage ( clazz . getName ( ) ) . equals ( packageNameOfInstance ) ) { Field [ ] fields = clazz . getDeclaredFields ( ) ; for ( Field field : fields ) { field . setAccessible ( true ) ; final String fieldName = field . getName ( ) ; final String simpleFieldName = simplifyFieldName ( fieldName ) ; Object fieldValue = null ; try { fieldValue = field . get ( o ) ; if ( fieldValue == null ) continue ; } catch ( IllegalArgumentException e ) { throw new BuildException ( "Error accessing field " + classname + "." + fieldName , e ) ; } catch ( IllegalAccessException e ) { throw new BuildException ( "Error accessing field " + classname + "." + fieldName , e ) ; } Pair < boolean , List < String >> followAsPair = shouldFollowField ( nestingLevel , MAX_NESTING , o , field ) ; if ( ! followAsPair . first ( ) ) { List < String > reasons = followAsPair . second ( ) ; if ( reasons . size ( ) > 0 ) { StringBuilder reason = new StringBuilder ( ) ; for ( int i = 0 ; i < ( reasons . size ( ) - 1 ) ; i ++ ) { reason . append ( reasons . get ( i ) ) ; reason . append ( "  " ) ; } reason . append ( reasons . get ( reasons . size ( ) - 1 ) ) ; System . out . printf ( "Not following field %s:%s because %s.\n" , fieldName , fieldValue . getClass ( ) , reason ) ; } continue ; } if ( shouldInlineField ( o , field , options ) ) { node . putAttr ( simpleFieldName , fieldValue ) ; } else { enqueueNode ( context , nestingLevel , node , simpleFieldName , fieldValue ) ; } } clazz = clazz . getSuperclass ( ) ; } context . addPoint ( o , node ) ; return node ; } } catch ( BuildException be ) { be . printStackTrace ( ) ; throw be ; } catch ( NullPointerException npe ) { npe . printStackTrace ( ) ; throw npe ; } catch ( Throwable t ) { t . printStackTrace ( ) ; throw new RuntimeException ( t ) ; } }
tr	G	public static String [ ] constructIds ( Response res ) throws WeiboException { try { JSONArray list = res . asJSONObject ( ) . getJSONArray ( "ids" ) ; String temp = list . toString ( ) . substring ( 1 , list . toString ( ) . length ( ) - 1 ) ; String [ ] ids = temp . split ( " " ) ; return ids ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone . getMessage ( ) + ":" + jsone . toString ( ) , jsone ) ; } }
tr	E	private void CheckNombreActionPerformed ( java . awt . event . ActionEvent evt ) { if ( CheckNombre . isSelected ( ) ) { CheckLab . setEnabled ( false ) ; CheckTelefono . setEnabled ( false ) ; textBuscar . setEnabled ( true ) ; } else { CheckLab . setEnabled ( true ) ; CheckTelefono . setEnabled ( true ) ; textBuscar . setEnabled ( false ) ; } }
tr	G	protected int getBalanceFactor ( ) { int lesserHeight = 0 ; int greaterHeight = 0 ; if ( lesser != null ) { AVLNode < T > lesserAVLNode = ( AVLNode < T > ) lesser ; lesserHeight = lesserAVLNode . height ; } if ( greater != null ) { AVLNode < T > greaterAVLNode = ( AVLNode < T > ) greater ; greaterHeight = greaterAVLNode . height ; } return greaterHeight - lesserHeight ; }
tr	A	public void setBestMove ( int move ) { throw new UnsupportedOperationException ( "Not supported yet." ) ; }
tr	J	public void setChineseFont ( Font chineseFont ) { this . chineseFont = chineseFont ; repaint ( ) ; }
tr	A	@ Override public void exit ( ) throws ParsingException { context . queryBuilder . addText ( token ) ; context . setHandler ( context . idHandler ) ; }
tr	H	public int getCity ( ) { return city ; }
tr	I	public boolean isallowAllActMsg ( ) { return allowAllActMsg ; }
tr	H	void button_save_clicked ( String args ) { FileDialog dialog = new FileDialog ( new Frame ( ) , "Save" , FileDialog . SAVE ) ; dialog . setVisible ( true ) ; String filename = dialog . getDirectory ( ) + dialog . getFile ( ) ; if ( filename == null ) return ; try { DataOutputStream fp = new DataOutputStream ( new BufferedOutputStream ( new FileOutputStream ( filename ) ) ) ; int svm_type = svm_parameter . C_SVC ; int svm_type_idx = args . indexOf ( "-s " ) ; if ( svm_type_idx != - 1 ) { StringTokenizer svm_str_st = new StringTokenizer ( args . substring ( svm_type_idx + 2 ) . trim ( ) ) ; svm_type = atoi ( svm_str_st . nextToken ( ) ) ; } int n = point_list . size ( ) ; if ( svm_type == svm_parameter . EPSILON_SVR || svm_type == svm_parameter . NU_SVR ) { for ( int i = 0 ; i < n ; i ++ ) { point p = point_list . elementAt ( i ) ; fp . writeBytes ( p . y + " 1:" + p . x + "\n" ) ; } } else { for ( int i = 0 ; i < n ; i ++ ) { point p = point_list . elementAt ( i ) ; fp . writeBytes ( p . value + " 1:" + p . x + " 2:" + p . y + "\n" ) ; } } fp . close ( ) ; } catch ( IOException e ) { System . err . print ( e ) ; } }
tr	J	public T [ ] ensureCapacity ( int additionalCapacity ) { int sizeNeeded = size + additionalCapacity ; if ( sizeNeeded > items . length ) { resize ( Math . max ( 8 , sizeNeeded ) ) ; } return items ; }
tr	J	@ Override public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( id == null ) ? 0 : id . hashCode ( ) ) ; return result ; }
tr	B	public String get_name ( ) { return _name ; }
tr	C	public void printStreamedTree ( ) { initTreeTraversal ( ) ; LinkSetNode L = getNextInOrder ( ) ; while ( L != null ) { System . out . println ( L ) ; L = getNextInOrder ( ) ; } }
tr	E	public static byte [ ] getHash ( String algName , byte [ ] text , boolean derWrapped ) { try { MessageDigest md = MessageDigest . getInstance ( algName ) ; byte [ ] data = md . digest ( text ) ; if ( derWrapped ) { String oid = algName . equals ( "SHA1" ) ? PKIService . OID_SHA1 : PKIService . OID_SHA256 ; DigestInfo di = new DigestInfo ( new AlgorithmIdentifier ( new DERObjectIdentifier ( oid ) ) , data ) ; return di . getDEREncoded ( ) ; } else { return data ; } } catch ( Exception e ) { return null ; } }
tr	C	public static void loadDataFromFile ( String fileName ) { Scanner previoustickers = null ; try { previoustickers = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } String key = "" ; String value = "" ; while ( previoustickers . hasNextLine ( ) ) { String filedata = previoustickers . nextLine ( ) ; if ( filedata . equals ( "" ) ) continue ; String [ ] linedata = filedata . split ( "\\^" ) ; if ( linedata . length > 1 ) { key = linedata [ 0 ] ; value = linedata [ 1 ] ; lightMap . put ( key , dataLightSubprocessor ( value ) ) ; } } }
tr	F	private void paintGrid ( Graphics gr , Rectangle clip ) { gr . setColor ( gridColor ) ; for ( int y = clip . y ; y < clip . y + clip . height ; y ++ ) { if ( ( y & 3 ) == 0 ) { gr . fillRect ( clip . x , y , clip . width , 1 ) ; } } }
tr	H	public ArrayList < ConnectedComponent > findTrajectory ( ) { ArrayList < ConnectedComponent > traj = new ArrayList < ConnectedComponent > ( ) ; boolean searched [ ] [ ] = new boolean [ _height ] [ _width ] ; for ( int x = 50 ; x < _width - 50 ; x ++ ) for ( int y = _groundLevel - 1 ; y > _height * 0.1 ; y -- ) { int cls = _class [ y ] [ x ] ; if ( ! searched [ y ] [ x ] && cls == TRAJECTORY ) { ConnectedComponent cc ; cc = new ConnectedComponent ( _class , x , y , searched , false ) ; if ( cc . getArea ( ) >= MIN_SIZE [ TRAJECTORY ] && cc . getArea ( ) <= MAX_SIZE [ TRAJECTORY ] ) traj . add ( cc ) ; } } return traj ; }
tr	I	public DRUMSIterator < Data > getIterator ( ) { return new DRUMSIterator < Data > ( hashFunction , gp ) ; }
tr	C	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	I	public int getFollowersCount ( ) { return followersCount ; }
tr	J	public void drawClassification ( BufferedImage canvas ) { BufferedImage image = new BufferedImage ( _width , _height , BufferedImage . TYPE_INT_RGB ) ; for ( int y = 0 ; y < _height ; y ++ ) { for ( int x = 0 ; x < _width ; x ++ ) { int c = _class [ y ] [ x ] ; image . setRGB ( x , y , _drawColor [ c ] ) ; } } Graphics2D g = canvas . createGraphics ( ) ; g . drawImage ( image , 0 , 0 , null ) ; }
tr	C	private void logReceived ( String message ) { logMessage ( getInputFilter ( ) , new StringBuffer ( "Received: " ) . append ( message ) . toString ( ) ) ; }
tr	C	@ Override public ClientHandshakeBuilder postProcessHandshakeRequestAsClient ( ClientHandshakeBuilder request ) { request . put ( "Upgrade" , "WebSocket" ) ; request . put ( "Connection" , "Upgrade" ) ; request . put ( "Sec-WebSocket-Key1" , generateKey ( ) ) ; request . put ( "Sec-WebSocket-Key2" , generateKey ( ) ) ; if ( ! request . hasFieldValue ( "Origin" ) ) { request . put ( "Origin" , "random" + reuseableRandom . nextInt ( ) ) ; } byte [ ] key3 = new byte [ 8 ] ; reuseableRandom . nextBytes ( key3 ) ; request . setContent ( key3 ) ; return request ; }
tr	C	@ Override public LinkSetNode getNextInOrder ( ) { try { if ( memory == null ) { int r = in . read ( b ) ; if ( r != b . length ) { in . close ( ) ; return null ; } } else { if ( memory . position ( ) == memory . capacity ( ) ) { return null ; } memory . get ( b ) ; } switch ( type ) { case 1 : return new LinkSetNode ( b ) ; case 3 : return new TimedLinkSetNode ( b ) ; default : System . out . println ( "Error. Unknown LinkSetNode type in preamble" ) ; in . close ( ) ; System . exit ( 22 ) ; break ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; }
tr	G	private void masterTableMouseClicked ( java . awt . event . MouseEvent evt ) { saveButton . setEnabled ( true ) ; deleteButton . setEnabled ( true ) ; }
tr	I	public int findElementInReadBuffer ( ByteBuffer workingBuffer , byte [ ] key , int indexInChunk ) { workingBuffer . position ( indexInChunk ) ; int minElement = indexInChunk / gp . getElementSize ( ) ; int numberOfEntries = workingBuffer . limit ( ) / gp . getElementSize ( ) ; int maxElement = numberOfEntries - 1 ; int midElement ; int comp ; byte [ ] tempKey = new byte [ gp . getKeySize ( ) ] ; while ( minElement <= maxElement ) { midElement = minElement + ( maxElement - minElement ) / 2 ; indexInChunk = midElement * gp . getElementSize ( ) ; workingBuffer . position ( indexInChunk ) ; workingBuffer . get ( tempKey ) ; comp = KeyUtils . compareKey ( key , tempKey , gp . getKeySize ( ) ) ; if ( comp == 0 ) { return indexInChunk ; } else if ( comp < 0 ) { maxElement = midElement - 1 ; } else { minElement = midElement + 1 ; } } return - 1 ; }
tr	B	void bloquear ( ) { txtCedula . setEnabled ( false ) ; txtNombre . setEnabled ( false ) ; txtApellido . setEnabled ( false ) ; fecha . setEnabled ( false ) ; txtHijos . setEnabled ( false ) ; txtDireccion . setEnabled ( false ) ; txtEmail . setEnabled ( false ) ; txtTelefono . setEnabled ( false ) ; txtCelular . setEnabled ( false ) ; btnGuardar . setEnabled ( false ) ; }
tr	H	public String getDescription ( ) { return description ; }
tr	E	public Image getImage ( ) { return anim . getImage ( ) ; }
tr	J	public double getOutputValue ( String name ) { OutputVariable outputVariable = getOutputVariable ( name ) ; return outputVariable . defuzzify ( ) ; }
tr	I	public void deleteAll ( Connection conn ) { delete ( conn , null ) ; }
tr	C	public static ClassLoader getDefaultClassLoader ( ) { ClassLoader cl = null ; try { cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; } catch ( Throwable ex ) { } if ( cl == null ) { cl = ClassUtils . class . getClassLoader ( ) ; if ( cl == null ) { try { cl = ClassLoader . getSystemClassLoader ( ) ; } catch ( Throwable ex ) { } } } return cl ; }
tr	E	public void setInputFilter ( TcpMessageFilter inputFilter ) { this . inputFilter = inputFilter ; }
tr	E	private void setRawSocket ( java . net . Socket rawSocket ) { this . rawSocket = rawSocket ; }
tr	D	private static double atof ( String s ) { return double . valueOf ( s ) . doubleValue ( ) ; }
tr	H	public long size ( ) throws FileLockException , IOException { long size = 0 ; for ( int bucketId = 0 ; bucketId < hashFunction . getNumberOfBuckets ( ) ; bucketId ++ ) { HeaderIndexFile < Data > headerIndexFile = new HeaderIndexFile < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( bucketId ) , gp . HEADER_FILE_LOCK_RETRY , gp ) ; size += headerIndexFile . getFilledUpFromContentStart ( ) / gp . getElementSize ( ) ; headerIndexFile . close ( ) ; } return size ; }
tr	B	private static byte [ ] getPart ( String key ) throws InvalidHandshakeException { try { long keyNumber = long . parseLong ( key . replaceAll ( "[^0-9]" , "" ) ) ; long keySpace = key . split ( " " ) . length - 1 ; if ( keySpace == 0 ) { throw new InvalidHandshakeException ( "invalid Sec-WebSocket-Key (/key2/)" ) ; } long part = new long ( keyNumber / keySpace ) ; return new byte [ ] { ( byte ) ( part >> 24 ) , ( byte ) ( ( part << 8 ) >> 24 ) , ( byte ) ( ( part << 16 ) >> 24 ) , ( byte ) ( ( part << 24 ) >> 24 ) } ; } catch ( NumberFormatException e ) { throw new InvalidHandshakeException ( "invalid Sec-WebSocket-Key (/key1/ or /key2/)" ) ; } }
tr	F	public String format ( double number ) { int sign = 1 ; if ( number < 0 ) { sign = - 1 ; } number = Math . abs ( number ) ; String fractionalPart = ":" ; int integerPart ; integerPart = ( ( int ) Math . floor ( number ) ) ; double fractional = Math . abs ( number - integerPart ) ; if ( fractionLength < 6 ) { double minutes = fractional * 60 ; String form = "%02.0f" ; if ( fractionLength == 5 ) { form = "%04.1f" ; } Formatter formatter = new Formatter ( Locale . US ) ; String newMinutes = formatter . format ( form , minutes ) . toString ( ) ; if ( double . parseDouble ( newMinutes ) >= 60.0 ) { minutes = 0.0 ; integerPart ++ ; } formatter = new Formatter ( Locale . US ) ; fractionalPart += formatter . format ( form , minutes ) ; } else { double minutes = Math . floor ( fractional * 60 ) ; double rest = fractional - ( ( double ) minutes / 60.0 ) ; double seconds = rest * 3600 ; String form = "%02.0f" ; if ( fractionLength == 8 ) { form = "%04.1f" ; } else if ( fractionLength == 9 ) { form = "%05.2f" ; } Formatter formatter = new Formatter ( Locale . US ) ; String newSeconds = formatter . format ( form , seconds ) . toString ( ) ; if ( double . parseDouble ( newSeconds ) >= 60.0 ) { seconds = 0.0 ; minutes ++ ; } formatter = new Formatter ( Locale . US ) ; String newMinutes = formatter . format ( "%02.0f" , minutes ) . toString ( ) ; if ( double . parseDouble ( newMinutes ) >= 60.0 ) { minutes = 0.0 ; integerPart ++ ; } formatter = new Formatter ( Locale . US ) ; fractionalPart += formatter . format ( "%02.0f:" + form , minutes , seconds ) ; } String res = integerPart + fractionalPart ; if ( sign < 0 ) { res = "-" + res ; } res = padLeft ( res , length ) ; return res ; }
tr	C	public void setTag ( String tag ) { this . tag = tag ; }
tr	D	public BucketContainer < Data > getBucketContainer ( ) { return this . bucketContainer ; }
tr	B	@ Override public void putParameter ( ) throws ParsingException { putChar ( Characters . QUESTION ) ; context . setCallerHandler ( this ) ; context . setHandler ( context . parameterHandler ) ; }
tr	I	public boolean isallowAllComment ( ) { return allowAllComment ; }
tr	J	@ Override public Dimension getPreferredSize ( ) { return new Dimension ( XLEN , YLEN + 50 ) ; }
tr	F	private TIPPFile loadFileResource ( Element el , TIPPSectionType sectionType , Map < TIPPFile , String > locationMap , Sequences sequences ) { int sequence = getSequence ( el , sequences ) ; String location = getChildTextByName ( el , ObjectFile . LOCATION ) ; if ( ! FormattingUtil . validLocationString ( sectionType , location ) ) { errorHandler . reportError ( INVALID_RESOURCE_LOCATION_IN_MANIFEST , "Invalid location: " + location , null ) ; } String name = getChildTextByName ( el , ObjectFile . NAME ) ; if ( name == null ) name = location ; TIPPFile file = new TIPPFile ( sectionType , name , sequence ) ; locationMap . put ( file , location ) ; return file ; }
tr	J	private void btnNuevoActionPerformed ( java . awt . event . ActionEvent evt ) { desbloquear ( ) ; txtCedula . requestFocus ( ) ; }
tr	I	public static String getShortNameAsProperty ( class < ? > clazz ) { String shortName = ClassUtils . getShortName ( clazz ) ; int dotIndex = shortName . lastIndexOf ( . ) ; shortName = ( dotIndex != - 1 ? shortName . substring ( dotIndex + 1 ) : shortName ) ; return Introspector . decapitalize ( shortName ) ; }
tr	E	private TIPPSection loadPackageObjectSection ( Element section , TIPPErrorHandler errorHandler , Map < TIPPFile , String > locationMap ) { TIPPSectionType type = TIPPSectionType . byElementName ( section . getNodeName ( ) ) ; if ( type == null ) { throw new IllegalStateException ( "Invalid section element" ) ; } List < TIPPFile > resources = new ArrayList < > ( ) ; Sequences sequences = new Sequences ( ) ; if ( type . equals ( TIPPSectionType . REFERENCE ) ) { NodeList children = section . getElementsByTagName ( REFERENCE_FILE_RESOURCE ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { resources . add ( loadReferenceFileResource ( ( Element ) children . item ( i ) , type , locationMap , sequences ) ) ; } } else { NodeList children = section . getElementsByTagName ( FILE_RESOURCE ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { resources . add ( loadFileResource ( ( Element ) children . item ( i ) , type , locationMap , sequences ) ) ; } } return type == TIPPSectionType . REFERENCE ? new TIPPReferenceSection ( resources ) : new TIPPSection ( type , resources ) ; }
tr	A	@ Override public void init ( ) { setSize ( getSize ( ) ) ; final Button button_change = new Button ( "Change" ) ; Button button_run = new Button ( "Run" ) ; Button button_clear = new Button ( "Clear" ) ; Button button_save = new Button ( "Save" ) ; Button button_load = new Button ( "Load" ) ; final TextField input_line = new TextField ( DEFAULT_PARAM ) ; BorderLayout layout = new BorderLayout ( ) ; this . setLayout ( layout ) ; Panel p = new Panel ( ) ; GridBagLayout gridbag = new GridBagLayout ( ) ; p . setLayout ( gridbag ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; c . gridwidth = 1 ; gridbag . setConstraints ( button_change , c ) ; gridbag . setConstraints ( button_run , c ) ; gridbag . setConstraints ( button_clear , c ) ; gridbag . setConstraints ( button_save , c ) ; gridbag . setConstraints ( button_load , c ) ; c . weightx = 5 ; c . gridwidth = 5 ; gridbag . setConstraints ( input_line , c ) ; button_change . setBackground ( colors [ current_value ] ) ; p . add ( button_change ) ; p . add ( button_run ) ; p . add ( button_clear ) ; p . add ( button_save ) ; p . add ( button_load ) ; p . add ( input_line ) ; this . add ( p , BorderLayout . SOUTH ) ; button_change . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { button_change_clicked ( ) ; button_change . setBackground ( colors [ current_value ] ) ; } } ) ; button_run . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { button_run_clicked ( input_line . getText ( ) ) ; } } ) ; button_clear . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { button_clear_clicked ( ) ; } } ) ; button_save . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { button_save_clicked ( input_line . getText ( ) ) ; } } ) ; button_load . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { button_load_clicked ( ) ; } } ) ; input_line . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { button_run_clicked ( input_line . getText ( ) ) ; } } ) ; this . enableEvents ( AWTEvent . MOUSE_EVENT_MASK ) ; }
tr	F	public static boolean printQuickCount ( StringBuilder saveAsText ) { String [ ] sections = saveAsText . toString ( ) . replaceAll ( "@" , " " ) . split ( " " ) ; StringBuilder build = new StringBuilder ( ) ; for ( String s : sections ) { build . append ( " " + s . split ( "_" ) . length ) ; } return build . toString ( ) . equals ( " 2 36 44 9 9 9 9 9 9 9 9 9 9 1 1 1" ) ; }
tr	H	@ Override public void onMoveBackward ( Board board , Move move ) { }
tr	I	private static double doDouble ( String value ) { try { double val = double . parseDouble ( value ) ; if ( val == val ) return val ; else return - 0.0000001 ; } catch ( Exception e ) { return - 0.0000001 ; } }
tr	H	public Set < Integer > getValidValuesForElementWithNumber ( int elementNumber ) { Set < Integer > validElementsFromRuleset = ruleSet . getValidElementValues ( this , elementNumber ) ; Set < Integer > validValues = validElementsFromRuleset ; validValues . removeAll ( eliminatedValues . get ( elementNumber ) ) ; return validValues ; }
tr	I	private static String distribute ( String document , String outer , String inner ) { Matcher paragraph = Pattern . compile ( "<" + outer + ">([\\s\\S]*?)</" + outer + ">" ) . matcher ( document ) ; StringBuilder newDoc = new StringBuilder ( ) ; int start = 0 ; while ( paragraph . find ( start ) ) { newDoc . append ( document . substring ( start , paragraph . start ( ) ) ) ; newDoc . append ( paragraph . group ( 1 ) . replaceAll ( "(<" + inner + "[^>]*>)([\\s\\S]*?)(</" + inner + ">)" , "$1<" + outer + ">$2</" + outer + ">$3" ) ) ; start = paragraph . end ( ) ; } newDoc . append ( document . substring ( start , document . length ( ) ) ) ; return newDoc . toString ( ) ; }
tr	J	public String getavatarLarge ( ) { return avatarLarge ; }
tr	D	public void reOrderArgLabel ( ) { Dictionary old = dicts [ DictionaryTypes . AUGLABEL . ordinal ( ) ] ; Dictionary newDict = new Dictionary ( ) ; Object [ ] keys = old . toArray ( ) ; int id = newDict . lookupIndex ( unseen ) ; Utils . assert ( id == 1 ) ; int maxID = 0 ; for ( Object key : keys ) { if ( ( ( String ) key ) . indexOf ( "-" ) == - 1 ) { maxID = newDict . lookupIndex ( ( String ) key ) ; } } ARGINDEX = maxID + 1 ; for ( Object key : keys ) { if ( ( ( String ) key ) . indexOf ( "-" ) != - 1 ) { newDict . lookupIndex ( ( String ) key ) ; } } dicts [ DictionaryTypes . AUGLABEL . ordinal ( ) ] = newDict ; System . out . println ( "arg label index reordered" ) ; }
tr	F	private void getChildren ( DefaultMutableTreeNode node ) { if ( node . toString ( ) . equals ( "Songs" ) ) { for ( int i = 0 ; i < node . getChildCount ( ) ; ++ i ) { if ( _song . equals ( ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) ) . getUserObject ( ) ) ) { _children . add ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) ) ; } } } else if ( node . toString ( ) . equals ( "Playlists" ) ) { for ( int i = 0 ; i < node . getChildCount ( ) ; ++ i ) { for ( int j = 0 ; j < node . getChildAt ( i ) . getChildCount ( ) ; ++ j ) { if ( _song . equals ( ( Song ) ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) . getChildAt ( j ) ) . getUserObject ( ) ) ) _children . add ( ( DefaultMutableTreeNode ) node . getChildAt ( i ) . getChildAt ( j ) ) ; } } } }
tr	I	public static void testRandomSet ( int n , int sum ) { int [ ] test = randomSet ( n , sum ) ; int gensum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( test [ i ] + " " ) ; gensum += test [ i ] ; } System . out . println ( "= " + gensum ) ; }
tr	E	int nextSequence ( ) { while ( true ) { int i = nextSequence ++ ; if ( ! seenSequences . contains ( i ) ) { return see ( i ) ; } } }
tr	H	private void nombrelaboratoriosFieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isLetterOrDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) && ! Character . isWhitespace ( evt . getKeyChar ( ) ) && evt . getKeyChar ( ) != . && evt . getKeyChar ( ) != - ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( nombrelaboratoriosField . getText ( ) . length ( ) == 45 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Nombre de laboratorio demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
tr	G	public static boolean isCacheSafe ( class < ? > clazz , ClassLoader classLoader ) { assert . notNull ( clazz , "Class must not be null" ) ; try { ClassLoader target = clazz . getClassLoader ( ) ; if ( target == null ) { return true ; } ClassLoader cur = classLoader ; if ( cur == target ) { return true ; } while ( cur != null ) { cur = cur . getParent ( ) ; if ( cur == target ) { return true ; } } return false ; } catch ( SecurityException ex ) { return true ; } }
tr	I	public boolean hasInputVariable ( String name ) { for ( InputVariable inputVariable : this . inputVariables ) { if ( name . equals ( inputVariable . getName ( ) ) ) { return true ; } } return false ; }
tr	A	public ServerClass ( ServerConsole console ) { clients = new ArrayList < ClientInfo > ( ) ; this . console = console ; console . setServerClass ( this ) ; votingCounter = 0 ; }
tr	B	public void initFeatureAlphabets ( DependencyInstance inst ) { int n = inst . length ; for ( int i = 0 ; i < n ; ++ i ) createWordFeatures ( inst , i ) ; int [ ] heads = inst . heads ; int [ ] deplbids = inst . deplbids ; DependencyArcList arcLis = new DependencyArcList ( heads , options . useHO ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( heads [ i ] == - 1 ) continue ; int parent = heads [ i ] ; createArcFeatures ( inst , parent , i ) ; if ( options . learnLabel ) { int type = deplbids [ i ] ; boolean toRight = parent < i ; createLabelFeatures ( inst , arcLis , heads , i , type ) ; } } if ( options . learningMode != LearningMode . Basic ) { for ( int h = 0 ; h < n ; ++ h ) { int st = arcLis . startIndex ( h ) ; int ed = arcLis . endIndex ( h ) ; for ( int p = st ; p + 1 < ed ; ++ p ) { int m = arcLis . get ( p ) ; int s = arcLis . get ( p + 1 ) ; if ( options . useCS ) { createTripsFeatureVector ( inst , h , m , s ) ; createSibFeatureVector ( inst , m , s ) ; } int gp = heads [ h ] ; if ( options . useGS && gp >= 0 ) { createGPSibFeatureVector ( inst , gp , h , m , s ) ; } if ( options . useTS && p + 2 < ed ) { int s2 = arcLis . get ( p + 2 ) ; createTriSibFeatureVector ( inst , h , m , s , s2 ) ; } if ( options . usePSC ) { int mst = arcLis . startIndex ( m ) ; int med = arcLis . endIndex ( m ) ; for ( int mp = mst ; mp < med ; ++ mp ) { int c = arcLis . get ( mp ) ; createPSCFeatureVector ( inst , h , m , c , s ) ; } int sst = arcLis . startIndex ( s ) ; int sed = arcLis . endIndex ( s ) ; for ( int sp = sst ; sp < sed ; ++ sp ) { int c = arcLis . get ( sp ) ; createPSCFeatureVector ( inst , h , s , c , m ) ; } } } } for ( int m = 1 ; m < n ; ++ m ) { int h = heads [ m ] ; Utils . assert ( h >= 0 ) ; int gp = heads [ h ] ; if ( options . useGP && gp != - 1 ) { createGPCFeatureVector ( inst , gp , h , m ) ; } if ( options . useHB && m + 1 < n ) { int h2 = heads [ m + 1 ] ; Utils . assert ( h2 >= 0 ) ; createHeadBiFeatureVector ( inst , m , h , h2 ) ; } if ( options . useGGP && gp != - 1 && heads [ gp ] != - 1 ) { int ggp = heads [ gp ] ; createGGPCFeatureVector ( inst , ggp , gp , h , m ) ; } } if ( options . useHO ) { FeatureVector fv = new FeatureVector ( numArcFeats ) ; int [ ] toks = inst . formids ; int [ ] pos = inst . postagids ; int [ ] posA = inst . cpostagids ; SpecialPos [ ] specialPos = inst . specialPos ; int [ ] spanLeft = arcLis . left ; int [ ] spanRight = arcLis . right ; long code = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( SpecialPos . P == specialPos [ i ] ) { int par = heads [ i ] ; int [ ] c = findPPArg ( inst . heads , inst . specialPos , arcLis , i ) ; for ( int z = 0 ; z < c . length ; ++ z ) { if ( par != - 1 && c [ z ] != - 1 ) { createPPFeatureVector ( inst , par , i , c [ z ] ) ; } } } if ( SpecialPos . C == specialPos [ i ] ) { int [ ] arg = findConjArg ( arcLis , heads , i ) ; int head = arg [ 0 ] ; int left = arg [ 1 ] ; int right = arg [ 2 ] ; if ( left != - 1 && right != - 1 && left < right ) { createCC1FeatureVector ( inst , left , i , right ) ; if ( head != - 1 ) { createCC2FeatureVector ( inst , i , head , left ) ; createCC2FeatureVector ( inst , i , head , right ) ; } } } if ( SpecialPos . PNX == specialPos [ i ] ) { int j = findPuncCounterpart ( toks , i ) ; if ( j != - 1 && heads [ i ] == heads [ j ] ) createPNXFeatureVector ( inst , heads [ i ] , i , j ) ; } } int rb = getMSTRightBranch ( specialPos , arcLis , 0 , 0 ) ; code = createArcCodeP ( Arc . RB , 0 ) ; addArcFeature ( code , ( double ) rb / n , fv ) ; for ( int m = 1 ; m < n ; ++ m ) { int leftNum = 0 ; int rightNum = 0 ; int maxDigit = 64 - Arc . numArcFeatBits - flagBits ; int maxChildStrNum = ( maxDigit / tagNumBits ) - 1 ; int childStrNum = 0 ; code = pos [ m ] ; int st = arcLis . startIndex ( m ) ; int ed = arcLis . endIndex ( m ) ; for ( int j = st ; j < ed ; ++ j ) { int cid = arcLis . get ( j ) ; if ( SpecialPos . PNX != specialPos [ cid ] ) { if ( cid < m && leftNum < GlobalFeatureData . MAX_CHILD_NUM ) leftNum ++ ; else if ( cid > m && rightNum < GlobalFeatureData . MAX_CHILD_NUM ) rightNum ++ ; if ( childStrNum < maxChildStrNum ) { code = ( ( code << tagNumBits ) | pos [ cid ] ) ; childStrNum ++ ; } } } code = ( ( code << Arc . numArcFeatBits ) | Arc . CN_STR . ordinal ( ) ) << flagBits ; addArcFeature ( code , fv ) ; createChildNumFeatureVector ( inst , m , leftNum , rightNum ) ; int end = spanRight [ m ] == n ? 1 : 0 ; int punc = ( spanRight [ m ] < n && SpecialPos . PNX == specialPos [ spanRight [ m ] ] ) ? 1 : 0 ; int bin = Math . min ( GlobalFeatureData . MAX_SPAN_LENGTH , ( spanRight [ m ] - spanLeft [ m ] ) ) ; createSpanFeatureVector ( inst , m , end , punc , bin ) ; if ( heads [ m ] != - 1 ) { int leftID = spanLeft [ m ] > 0 ? posA [ spanLeft [ m ] - 1 ] : TOKEN_START ; int rightID = spanRight [ m ] < n ? posA [ spanRight [ m ] ] : TOKEN_END ; if ( leftID > 0 && rightID > 0 ) { createNeighborFeatureVector ( inst , heads [ m ] , m , leftID , rightID ) ; } } } } } }
tr	J	public void setGridStyle ( boolean gridStyle ) { this . gridStyle = gridStyle ; }
tr	G	public static UserWapper constructWapperUsers ( Response res ) throws WeiboException { JSONObject jsonUsers = res . asJSONObject ( ) ; try { JSONArray user = jsonUsers . getJSONArray ( "users" ) ; int size = user . length ( ) ; List < User > users = new ArrayList < User > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { users . add ( new User ( user . getJSONObject ( i ) ) ) ; } long previousCursor = jsonUsers . getLong ( "previous_curosr" ) ; long nextCursor = jsonUsers . getLong ( "next_cursor" ) ; long totalNumber = jsonUsers . getLong ( "total_number" ) ; String hasvisible = jsonUsers . getString ( "hasvisible" ) ; return new UserWapper ( users , previousCursor , nextCursor , totalNumber , hasvisible ) ; } catch ( JSONException jsone ) { throw new WeiboException ( jsone ) ; } }
tr	D	public void setVelocityX ( float dx ) { velocity . x = dx ; }
tr	I	public static String reformat ( String input ) { String output = input . replaceAll ( "@" , "_" ) . replaceAll ( "^" , "_" ) . replaceAll ( "\\*" , "_" ) ; if ( input . contains ( "</table>" ) ) output = output . substring ( 0 , output . indexOf ( "</table>" ) ) ; output = output . replaceAll ( "d><t" , "d> <t" ) . replaceAll ( "h><t" , "h> <t" ) . replaceAll ( "d></t" , "d>@</t" ) . replaceAll ( "&nbsp;" , "-" ) . replaceAll ( "--" , "" ) ; return output ; }
tr	G	public Query ( List < Field1 < M >> fields , String cond ) { this . fields = fields ; this . cond = cond ; }
tr	I	public SerialReader ( InputStream in ) { this . in = in ; }
tr	G	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	C	public TiledMapPainter ( ) { mouseToTile = new Point ( ) ; markX = markY = - 1 ; }
tr	C	public void setSynchronizerFactory ( ISynchronizerFactory < Data > factory ) { this . synchronizerFactory = factory ; this . syncManager . setSynchronizer ( factory ) ; }
tr	A	public void addClient ( ClientInfo client ) { synchronized ( clients ) { clients . add ( client ) ; } }
tr	C	@ Override public TopicStatisticListPresenter getPresenter ( ) { return this . presenter ; }
tr	I	public static void print ( int [ ] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { System . out . print ( array [ i ] + " " ) ; } System . out . println ( ) ; }
tr	H	private StringBuilder getMenu ( ) { StringBuilder m = new StringBuilder ( ) ; m . append ( "<div class=\"fixed\">" ) ; Utils . appendNewLine ( m ) ; m . append ( "<nav class=\"top-bar\" data-topbar>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<ul class=\"title-area\">" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"name\">" ) ; Utils . appendNewLine ( m ) ; m . append ( "<h1><a href=\"/sk/\">Bezpe\u010Dn\u00E9 panel\u00E1ky</a></h1>" ) ; Utils . appendNewLine ( m ) ; m . append ( "</li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"toggle-topbar menu-icon\"><a href=\"#\"><span>Menu</span></a></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "</ul>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<section class=\"top-bar-section\">" ) ; Utils . appendNewLine ( m ) ; m . append ( "<ul class=\"left\">" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li><a href=\"/sk/projekt/\">Projekt</a></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"has-dropdown\"><a href=\"/sk/sluzby/\">Slu\u017Eby</a>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<ul class=\"dropdown\">" ) ; m . append ( "<li class=\"extra_menu_item\"><a href=\"/sk/sluzby/\">Slu\u017Eby</a></li>" ) ; m . append ( "<li class=\"has-dropdown\"><a href=\"/sk/sluzby/pristupove-systemy/\">Pr\u00EDstupov\u00E9 syst\u00E9my</a>" ) ; m . append ( "<ul class=\"dropdown\">" ) ; m . append ( "<li class=\"extra_menu_item\"><a href=\"/sk/sluzby/pristupove-systemy/\">Pr\u00EDstupov\u00E9 syst\u00E9my</a>" ) ; m . append ( "<li><a href=\"/sk/sluzby/pristupove-systemy/dek/\">Dotykov\u00FD syst\u00E9m DEK</a></li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/pristupove-systemy/bes/\">Bezdotykov\u00FD syst\u00E9m BES</a></li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/pristupove-systemy/rak/\">Jednoduch\u00E9 syst\u00E9my RAK</a></li>" ) ; m . append ( "</ul>" ) ; m . append ( "</li>" ) ; m . append ( "<li class=\"has-dropdown\"><a href=\"/sk/sluzby/dorozumievacie-systemy/\">Dorozumievacie syst\u00E9my</a>" ) ; m . append ( "<ul class=\"dropdown\">" ) ; m . append ( "<li class=\"extra_menu_item\"><a href=\"/sk/sluzby/dorozumievacie-systemy/\">Dorozumievacie syst\u00E9my</a>" ) ; m . append ( "<li><a href=\"/sk/sluzby/dorozumievacie-systemy/dds/\">Digit\u00E1lne audio syst\u00E9my DDS</a></li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/dorozumievacie-systemy/ddv/\">Digit\u00E1lny videosyst\u00E9m DDV</a></li>" ) ; m . append ( "</ul>" ) ; m . append ( "</li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/senzorove-osvetlenie/\">Senzorov\u00E9 osvetlenie</a></li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/kovovyroba/\">Kovov\u00FDroba</a></li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/elektroinstalacie/\">Elektroin\u0161tal\u00E1cie</a></li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/revizie/\">Rev\u00EDzie</a></li>" ) ; m . append ( "<li><a href=\"/sk/sluzby/bleskozvody/\">Bleskozvody</a></li>" ) ; m . append ( "</ul>" ) ; m . append ( "</li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li><a href=\"/sk/referencie/\">Referencie</a></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li><a href=\"/sk/cenova-ponuka/\">Cenov\u00E1 ponuka</a></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li><a href=\"/sk/produkty/\">Produkty</a>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"has-dropdown\"><a href=\"/sk/firmy/\">Firmy</a>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<ul class=\"dropdown\">" ) ; m . append ( "<li class=\"extra_menu_item\"><a href=\"/sk/firmy/\">Firmy</a>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/ac-blesk-dc/\">AC blesk DC s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/kadasa/\">KADASA s. r. o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/pavol-strapac-siel/\">Pavol Strap\u00E1\u010D - SIEL</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/dusan-balaz/\">Du\u0161an Bal\u00E1\u017E</a></li>" ) ; m . append ( "<li class=\"divider\"></li>" ) ; m . append ( "<li class=\"has-dropdown\"><a href=\"/sk/firmy/\">V\u00FDrobcovia</a>" ) ; m . append ( "<ul class=\"dropdown\">" ) ; m . append ( "<li class=\"extra_menu_item\"><a href=\"/sk/firmy/\">V\u00FDrobcovia</a>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/rys/\">RYS</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/tesla-stropkov/\">TESLA Stropkov  a.s.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/steinel/\">STEINEL</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/ab-team/\">AB TEAM  s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/al-doors/\">AL doors spol.s r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/alex/\">ALEX</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/aneko-sk/\">ANEKO SK  s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/pavel-blahuta/\">Pavel Blahuta</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/chmelar/\">Chmel\u00E1r  spol. s r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/incon/\">INCON  spol. s r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/kalypso-sk/\">KALYPSO SK  spol. s r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/slovaktual/\">SLOVAKTUAL s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/prowind-slovakia/\">ProWind Slovakia s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/martin-vadkerti/\">Martin Vadkerti</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/plast-rol/\">PLAST-ROL s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/alu-solid/\">ALU-SOLID s.r.o.</a></li>" ) ; m . append ( "</ul>" ) ; m . append ( "</li>" ) ; m . append ( "<li class=\"has-dropdown\"><a href=\"/sk/firmy/\">In\u00E9 firmy</a>" ) ; m . append ( "<ul class=\"dropdown\">" ) ; m . append ( "<li class=\"extra_menu_item\"><a href=\"/sk/firmy/\">In\u00E9 firmy</a>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/bratislavsky-vyskovy-servis/\">Bratislavsk\u00FD v\u00FD\u0161kov\u00FD servis</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/rvstav/\">RV stav  s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/aps/\">APS s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/lp-axis/\">LP-AXIS s.r.o.</a></li>" ) ; m . append ( "<li><a class=\"fix1\" href=\"/sk/firmy/vap-slovakia/\">V a P Slovakia  s. r. o.</a></li>" ) ; m . append ( "</ul>" ) ; m . append ( "</li>" ) ; m . append ( "<li><a href=\"/sk/firmy/spravcovia/\">Spr\u00E1vcovia (33)</a></li>" ) ; m . append ( "</ul>" ) ; m . append ( "</li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li><a href=\"/sk/kontakt/\">Kontakt</a></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"divider\"></li>" ) ; Utils . appendNewLine ( m ) ; m . append ( "</ul>" ) ; Utils . appendNewLine ( m ) ; m . append ( "<ul class=\"right\">" ) ; Utils . appendNewLine ( m ) ; m . append ( "<li class=\"has-form\">" ) ; m . append ( "<a class=\"button\" href=\"/sk/kontakt/\">M\u00E1m ot\u00E1zku</a>" ) ; m . append ( "</li>" ) ; m . append ( "</ul>" ) ; Utils . appendNewLine ( m ) ; m . append ( "</section>" ) ; Utils . appendNewLine ( m ) ; m . append ( "</nav>" ) ; Utils . appendNewLine ( m ) ; m . append ( "</div>" ) ; Utils . appendNewLine ( m ) ; return m ; }
tr	I	public int getverifiedType ( ) { return verifiedType ; }
tr	H	public int getRowCount ( ) { return 6 ; }
tr	G	private static String getClassName ( Object o ) { return o . getClass ( ) . getSimpleName ( ) ; }
tr	A	public AnnotationIndexToken ( A annotation ) { this . annotation = annotation ; }
tr	C	public Monster [ ] getMonsters ( ) { Monster [ ] all = new Monster [ monsters . size ( ) ] ; monsters . toArray ( all ) ; return all ; }
tr	I	public static String getClassFileName ( class < ? > clazz ) { assert . notNull ( clazz , "Class must not be null" ) ; String className = clazz . getName ( ) ; int lastDotIndex = className . lastIndexOf ( PACKAGE_SEPARATOR ) ; return className . substring ( lastDotIndex + 1 ) + CLASS_FILE_SUFFIX ; }
tr	D	private void notifyDisconnection ( ) { raiseEvent ( new EventDisconnected ( ) ) ; }
tr	D	@ Override public Handshakedata translateHandshake ( ByteBuffer buf ) throws InvalidHandshakeException { HandshakeBuilder bui = translateHandshakeHttp ( buf , role ) ; if ( ( bui . hasFieldValue ( "Sec-WebSocket-Key1" ) || role == Role . CLIENT ) && ! bui . hasFieldValue ( "Sec-WebSocket-Version" ) ) { byte [ ] key3 = new byte [ role == Role . SERVER ? 8 : 16 ] ; try { buf . get ( key3 ) ; } catch ( BufferUnderflowException e ) { throw new IncompleteHandshakeException ( buf . capacity ( ) + 16 ) ; } bui . setContent ( key3 ) ; } return bui ; }
tr	D	public void getCursorRectangle ( final Rectangle redrawRect ) { redrawRect . x = xoff + tileLocator . getTileScreenX ( markX , markY ) ; redrawRect . y = yoff + tileLocator . getTileScreenY ( markX , markY ) ; redrawRect . width = tileLocator . getCursorX ( ) + 1 ; redrawRect . height = tileLocator . getCursorY ( ) + 1 ; }
tr	A	@ Override public void putCharWhileLineComment ( char c ) throws ParsingException { }
tr	J	protected T [ ] resize ( int newSize ) { T [ ] items = this . items ; T [ ] newItems = ( T [ ] ) ArrayReflection . newInstance ( items . getClass ( ) . getComponentType ( ) , newSize ) ; System . arraycopy ( items , 0 , newItems , 0 , Math . min ( size , newItems . length ) ) ; this . items = newItems ; return newItems ; }
tr	H	public Object getValueAt ( int row , int col ) { Calendar firstDayOfMonth = ( Calendar ) calendar . clone ( ) ; firstDayOfMonth . set ( Calendar . DATE , 1 ) ; int DOW = firstDayOfMonth . get ( Calendar . DAY_OF_WEEK ) ; int value = col - DOW + row * 7 + ( firstDayOfWeek + 1 ) ; return new Integer ( value ) ; }
tr	H	public Set < Integer > getRelatedElementNumbersForElementWithNumber ( int elementNumber ) { return ruleSet . getRelatedElementNumbers ( this , elementNumber ) ; }
tr	E	private boolean canAdd ( Loc l , int dir , State rr ) { int x = l . x ; int y = l . y ; switch ( dir ) { case 0 : return ( y - 1 >= 0 && ! map . isCollision ( x , y - 1 ) && ! rr . contains ( new Loc ( x , y - 1 ) ) ) ; case 1 : return ( y + 1 < map . gridSize && ! map . isCollision ( x , y + 1 ) && ! rr . contains ( new Loc ( x , y + 1 ) ) ) ; case 2 : return ( x - 1 >= 0 && ! map . isCollision ( x - 1 , y ) && ! rr . contains ( new Loc ( x - 1 , y ) ) ) ; case 3 : return ( x + 1 < map . gridSize && ! map . isCollision ( x + 1 , y ) && ! rr . contains ( new Loc ( x + 1 , y ) ) ) ; default : return false ; } }
tr	G	private List < Field1 < M >> parseFields ( String fields ) { if ( fields == null ) { return allFields ( ) ; } LinkedList < Field1 < M >> ret = new LinkedList < > ( ) ; for ( String sqlName : fields . split ( "\\s* \\s*" ) ) { ret . add ( getField ( sqlName ) ) ; } return ret ; }
tr	E	public String getProfileImageUrl ( ) { return profileImageUrl ; }
tr	E	public List < M > selectAll ( Connection conn ) { List < Field1 < M >> fields = allFields ( ) ; String cond = "" ; return selectList ( conn , fields , cond , null ) ; }
tr	C	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	A	public static String fileTitle ( String nasOrNy ) { double time = System . currentTimeMillis ( ) ; time /= 1000 ; time /= 3600 ; time /= 24 ; time = ( double ) ( ( int ) ( time * 10 ) / 10.0 ) ; return nasOrNy + "_" + time + ".txt" ; }
tr	A	public void addPiece ( Piece piece ) { _pieces . add ( piece ) ; }
tr	A	public Sprite ( Animation anim , ResourceManager parent ) { this . anim = anim ; this . parent = parent ; velocity = new Vector2D ( 0 , 0 ) ; position = new Vector2D ( 0 , 0 ) ; heading = new Vector2D ( 1 , 0 ) ; oldheading = new Vector2D ( 0 , 0 ) ; side = new Vector2D ( 0 , 0 ) ; steering = new SteeringBehaviors ( this ) ; }
tr	J	public boolean isDrawGuides ( ) { return drawGuides ; }
tr	C	@ Deprecated public double parseSexagesimal2 ( String number ) throws IllegalArgumentException { number = number . replace (   , : ) ; number = number . replace ( ; , : ) ; if ( number . indexOf ( ":" ) == - 1 ) { try { double n = double . parseDouble ( number ) ; return n ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Sexagesimal number format not correct (not even single number)" ) ; } } StringTokenizer st = new StringTokenizer ( number , ":" , false ) ; double degrees = 0 ; double minutes = 0 ; double seconds = 0 ; try { String aux = st . nextToken ( ) . trim ( ) ; if ( aux . length ( ) > 0 ) { degrees = double . parseDouble ( aux ) ; } aux = st . nextToken ( ) . trim ( ) ; if ( aux . length ( ) > 0 ) { minutes = double . parseDouble ( aux ) ; } if ( fractionLength > 5 ) { aux = st . nextToken ( ) . trim ( ) ; if ( aux . length ( ) > 0 ) { seconds = double . parseDouble ( aux ) ; } } } catch ( NoSuchElementException e ) { throw new IllegalArgumentException ( "Sexagesimal number format not correct" ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Sexagesimal number component not correct" ) ; } double res = degrees ; if ( degrees > 0 ) { res += ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } else { res -= ( minutes / 60.0 ) + ( seconds / 3600.0 ) ; } return res ; }
tr	H	public boolean isCellEditable ( int arg0 , int arg1 ) { return false ; }
tr	A	public static String [ ] csvHeaders ( ) { String [ ] headers = { "Name" , "Cost" , "Weight" , "MinDamage" , "MaxDamage" , "DamageMsg" , "Special" } ; return headers ; }
tr	E	private StringBuilder getGoogleMapsJS ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "<script type=\"text/javascript\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "var map;" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "function initialize() {" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "google.maps.visualRefresh = true;" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "var myLatlng = new google.maps.LatLng(" ) ; sb . append ( this . latitude ) ; sb . append ( " " ) ; sb . append ( this . longitude ) ; sb . append ( ");" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "var myOptions = {" ) ; sb . append ( "zoom: 12 " ) ; sb . append ( "center: myLatlng " ) ; sb . append ( "scrollwheel: false " ) ; sb . append ( "mapTypeId: google.maps.MapTypeId.ROADMAP" ) ; sb . append ( "}" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "var map = new google.maps.Map(document.getElementById(\"map-canvas\")  myOptions);" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "var marker = new google.maps.Marker({" ) ; sb . append ( "position: myLatlng " ) ; sb . append ( "map: map " ) ; sb . append ( "title:\"" ) ; sb . append ( this . title ) ; sb . append ( "\"" ) ; sb . append ( "});" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "}" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "function loadScript() {" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "var script = document.createElement('script');" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "script.type = 'text/javascript';" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "script.src = 'https://maps.googleapis.com/maps/api/js?v=3.exp" ) ; sb . append ( "&key=" ) ; sb . append ( "AIzaSyCcAXi0GZ2JBMeLJLcZqnLQsz7kEfJRyoI" ) ; sb . append ( "&language=" ) ; sb . append ( "sk" ) ; sb . append ( "&sensor=false" ) ; sb . append ( "&callback=initialize';" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "document.body.appendChild(script);" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "}" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "window.onload = loadScript;" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</script>" ) ; Utils . appendNewLine ( sb ) ; return sb ; }
tr	D	private void manageIdentificationMessage ( int senderID , IdentificationMessage msg ) { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == senderID && ! clients . get ( i ) . isInitialized ( ) ) { console . displayMessage ( clients . get ( i ) . getID ( ) + " is " + msg . getName ( ) ) ; clients . get ( i ) . setName ( msg . getName ( ) ) ; console . connected ( clients . get ( i ) ) ; notifyClients ( senderID , msg . getName ( ) ) ; return ; } } }
tr	F	public static class < ? > resolvePrimitiveClassName ( String name ) { class < ? > result = null ; if ( name != null && name . length ( ) <= 8 ) { result = primitiveTypeNameMap . get ( name ) ; } return result ; }
tr	H	public static boolean isValidSwitchRule ( String rule ) { try { parseSwitchRule ( rule ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
tr	H	boolean validateSignature ( final Document doc , KeySelector keySelector , InputStream payloadStream ) { ManifestSigner signer = new ManifestSigner ( ) ; if ( signer . hasSignature ( doc ) ) { if ( keySelector != null ) { if ( ! signer . validateSignature ( doc , keySelector , payloadStream ) ) { errorHandler . reportError ( INVALID_SIGNATURE , "Invalid digital signature" , null ) ; return false ; } } else { errorHandler . reportError ( UNABLE_TO_VERIFY_SIGNATURE , "No key provided to verify digital signature" , null ) ; return false ; } } return true ; }
tr	E	public boolean contains ( T value , boolean identity ) { T [ ] items = this . items ; int i = size - 1 ; if ( identity || value == null ) { while ( i >= 0 ) { if ( items [ i -- ] == value ) { return true ; } } } else { while ( i >= 0 ) { if ( value . equals ( items [ i -- ] ) ) { return true ; } } } return false ; }
tr	H	public void backup ( int amount ) { inBuf += amount ; if ( ( bufpos -= amount ) < 0 ) bufpos += bufsize ; }
tr	A	public INDISexagesimalFormatter ( String format ) throws IllegalArgumentException { this . format = format ; checkFormat ( ) ; }
tr	C	private void loadDescriptor ( ManifestBuilder builder , Element descriptor ) { builder . setPackageId ( getChildTextByName ( descriptor , UNIQUE_PACKAGE_ID ) ) ; builder . setCreator ( loadCreator ( getFirstChildByName ( descriptor , PACKAGE_CREATOR ) ) ) ; }
tr	J	private void btnModificarActionPerformed ( java . awt . event . ActionEvent evt ) { try { int filaMod = tablaCliente . getSelectedRow ( ) ; if ( filaMod == - 1 ) { JOptionPane . showMessageDialog ( null , "Seleccione alguna fila" ) ; } else { btnModificar . setEnabled ( true ) ; String cod = ( String ) tablaCliente . getValueAt ( filaMod , 0 ) ; desbloquear ( ) ; BuscarClienteEditar ( cod ) ; } } catch ( Exception e ) { } }
tr	C	public void setX ( float x ) { position . x = x ; }
tr	A	public NodeLVL2 ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "gs in gamenode" ) ; } NodeLVL2 . ds = ds . clone ( ) ; }
tr	D	public boolean isLevelStageNotValid ( final Integer levelStage ) { if ( levelStage == null || levelStage < 0 || levelStage > Settings_Level . LEVEL_STAGE_END ) { return true ; } else { return false ; } }
tr	E	public float getRotation ( ) { if ( currentRotation < 0 ) { currentRotation = 360 - currentRotation ; } currentRotation %= 360 ; return currentRotation ; }
tr	C	@ Override public void translate ( ) { super . setTitle ( TranslationManager . getinstance ( ) . getText ( "statistic" ) ) ; updateViewFromModel ( ) ; }
tr	A	public Database ( String name ) { this . name = name ; }
tr	J	public static String keyBasedData ( String addy , String [ ] keys ) { for ( int i = 0 ; i < 10 ; i ++ ) { if ( i > 0 ) System . out . println ( "\nConnection Failure. Trying again: " + i ) ; String httpdata = getHtml ( addy ) ; String yhdata = "" ; String str = httpdata ; if ( str . contains ( "was not found" ) ) return "#_#_#" ; if ( str . contains ( "Recommendation Trends" ) ) { str = ( str . substring ( str . indexOf ( "Recommendation Trends" ) ) ) ; str = str . replaceAll ( "d><t" , "d> <t" ) ; } for ( String key : keys ) { if ( str . contains ( ">" + key ) ) { String strx = str . substring ( str . indexOf ( ">" + key ) + 1 ) ; if ( ! strx . contains ( "</tr>" ) ) return "#_#_#" ; strx = strx . substring ( 0 , strx . indexOf ( "</tr>" ) ) ; if ( key . equals ( "Sector" ) ) strx = strx . replaceAll ( " " , "|" ) ; strx = removeHtml ( strx , true ) . replaceAll ( "@" , " " ) ; if ( strx . length ( ) == 0 ) strx = "#" ; yhdata += strx + "_" ; } else { yhdata += "#_" ; } } return ( yhdata . replaceAll ( "--" , "#" ) . replaceAll ( "_" , " " ) . trim ( ) . replaceAll ( " " , "_" ) ) ; } return "#_#" ; }
tr	B	public Voting getCurrentVoting ( ) { return currentVoting ; }
tr	D	public static void drawUnfilledRectangleAlpha ( int i , int j , int k , int l , int i1 , int j1 ) { method340 ( l , i1 , i , k , j1 ) ; method340 ( l , i1 , ( i + j ) - 1 , k , j1 ) ; if ( j >= 3 ) { method342 ( l , j1 , k , i + 1 , j - 2 ) ; method342 ( l , ( j1 + i1 ) - 1 , k , i + 1 , j - 2 ) ; } }
tr	F	private void waitLines ( ) throws IOException { do { String s = bufferedreader . readLine ( ) ; if ( s == null ) break ; logReceived ( s ) ; try { Calendar start = Calendar . getInstance ( ) ; processStringRequest ( s ) ; Calendar end = Calendar . getInstance ( ) ; if ( end . getTimeInMillis ( ) - start . getTimeInMillis ( ) > 1000 ) Logger . getLogger ( getClass ( ) ) . info ( String . format ( "%s accept runned for %dms" , s , Calendar . getInstance ( ) . getTimeInMillis ( ) - start . getTimeInMillis ( ) ) ) ; } catch ( Exception e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } } while ( Thread . currentThread ( ) . isAlive ( ) ) ; }
tr	D	public static ClassLoader overrideThreadContextClassLoader ( ClassLoader classLoaderToUse ) { Thread currentThread = Thread . currentThread ( ) ; ClassLoader threadContextClassLoader = currentThread . getContextClassLoader ( ) ; if ( classLoaderToUse != null && ! classLoaderToUse . equals ( threadContextClassLoader ) ) { currentThread . setContextClassLoader ( classLoaderToUse ) ; return threadContextClassLoader ; } else { return null ; } }
tr	I	public int numberOfInputVariables ( ) { return this . inputVariables . size ( ) ; }
tr	J	public DRUMSReader < Data > getReader ( ) throws FileLockException , IOException { if ( reader_instance != null && ! reader_instance . filesAreOpened ) { reader_instance . openFiles ( ) ; } else { reader_instance = new DRUMSReader < Data > ( this ) ; } return reader_instance ; }
tr	G	private void fireTableModelEvent ( ) { Iterator i = tableModelListeners . iterator ( ) ; TableModelListener tl ; while ( i . hasNext ( ) ) { tl = ( TableModelListener ) i . next ( ) ; tl . tableChanged ( new TableModelEvent ( this ) ) ; } }
tr	H	public String getScreenName ( ) { return screenName ; }
tr	E	public void setWeihao ( String weihao ) { this . weihao = weihao ; }
tr	J	private void txtNombreActionPerformed ( java . awt . event . ActionEvent evt ) { txtNombre . transferFocus ( ) ; }
tr	H	public boolean isValidValueForElementAtPosition ( int rowNumber , int columnNumber , int value ) { return isValidValueForElementWithNumber ( getElementNumber ( rowNumber , columnNumber ) , value ) ; }
tr	J	private void initCustomPanel ( Composite mainPanel ) { customPanel = new Composite ( mainPanel , SWT . NONE ) ; customPanel . setLayout ( new MigLayout ( ) ) ; Label label = new Label ( customPanel , SWT . NONE ) ; label . setText ( "Class: " ) ; customClassNameCombo = new Combo ( customPanel , SWT . DROP_DOWN | SWT . READ_ONLY ) ; for ( int i = 0 , size = TestDataCreator . customContentClasses . size ( ) ; i < size ; i ++ ) { customClassNameCombo . add ( TestDataCreator . customContentClasses . get ( i ) . getName ( ) ) ; } customClassNameCombo . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent arg0 ) { try { customContentDef = ( CustomContentDef ) TestDataCreator . customContentClasses . get ( customClassNameCombo . getSelectionIndex ( ) ) . newInstance ( ) ; } catch ( Exception e ) { TestDataCreator . showErrMsg ( dialog , "Failed to instantiate custom class" ) ; e . printStackTrace ( ) ; } } } ) ; ContentDef cd = fieldDef . getContentDef ( ) ; if ( cd instanceof CustomContentDef ) { for ( int i = 0 , size = customClassNameCombo . getItemCount ( ) ; i < size ; i ++ ) { if ( customClassNameCombo . getItem ( i ) . equals ( cd . getClass ( ) . getName ( ) ) ) { customClassNameCombo . select ( i ) ; break ; } } customPanel . setVisible ( true ) ; } else customPanel . setVisible ( false ) ; }
tr	H	public int getBeginLine ( ) { return bufline [ tokenBegin ] ; }
tr	A	void cargar ( String valor ) { String [ ] titulos = { "Cedula" , "Nombre" , "Apellido" , "Sexo" , "Fecha Nacimiento" , "Municipio" , "Direccion" , "Correo" , "Celular" } ; String [ ] registros = new String [ 9 ] ; String sql = "select Cedula Nombre Apellido Sexo fchNacimiento Municipio Direccion Email Celular from cliente where concat(Nombre '' Apellido) like '%" + valor + "%'" ; model = new DefaultTableModel ( null , titulos ) ; conectar cc = new conectar ( ) ; Connection cn = cc . conexion ( ) ; try { Statement st = cn . createStatement ( ) ; ResultSet rs = st . executeQuery ( sql ) ; while ( rs . next ( ) ) { registros [ 0 ] = rs . getString ( "Cedula" ) ; registros [ 1 ] = rs . getString ( "Nombre" ) ; registros [ 2 ] = rs . getString ( "Apellido" ) ; registros [ 3 ] = rs . getString ( "Sexo" ) ; registros [ 4 ] = rs . getString ( "FchNacimiento" ) ; registros [ 5 ] = rs . getString ( "Municipio" ) ; registros [ 6 ] = rs . getString ( "Direccion" ) ; registros [ 7 ] = rs . getString ( "Email" ) ; registros [ 8 ] = rs . getString ( "Celular" ) ; model . addRow ( registros ) ; } tablaCliente . setModel ( model ) ; } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( null , ex ) ; } }
tr	A	@ Override public void putCharWhileString ( char c ) throws ParsingException { token . addChar ( c ) ; }
tr	D	@ Override public HandshakeBuilder postProcessHandshakeResponseAsServer ( ClientHandshake request , ServerHandshakeBuilder response ) throws InvalidHandshakeException { response . setHttpStatusMessage ( "WebSocket Protocol Handshake" ) ; response . put ( "Upgrade" , "WebSocket" ) ; response . put ( "Connection" , request . getFieldValue ( "Connection" ) ) ; response . put ( "Sec-WebSocket-Origin" , request . getFieldValue ( "Origin" ) ) ; String location = "ws://" + request . getFieldValue ( "Host" ) + request . getResourceDescriptor ( ) ; response . put ( "Sec-WebSocket-Location" , location ) ; String key1 = request . getFieldValue ( "Sec-WebSocket-Key1" ) ; String key2 = request . getFieldValue ( "Sec-WebSocket-Key2" ) ; byte [ ] key3 = request . getContent ( ) ; if ( key1 == null || key2 == null || key3 == null || key3 . length != 8 ) { throw new InvalidHandshakeException ( "Bad keys" ) ; } response . setContent ( createChallenge ( key1 , key2 , key3 ) ) ; return response ; }
tr	J	public String getLang ( ) { return lang ; }
tr	J	public JDatePanel ( ) { super ( ) ; initialize ( ) ; }
tr	C	public OutputStream getSocketOutputStream ( ) throws IOException { if ( getRawSocket ( ) == null ) return null ; return getRawSocket ( ) . getOutputStream ( ) ; }
tr	A	@ Override public void run ( ) { console . displayMessage ( "Server thread started" ) ; try { console . displayMessage ( "Starting..." ) ; while ( true ) { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { NetworkMessage tmp = clients . get ( i ) . readMessage ( ) ; if ( tmp != null ) { manageMessage ( clients . get ( i ) . getID ( ) , tmp ) ; } } Thread . sleep ( 100 ) ; } } catch ( NetworkMessageException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } catch ( Exception ex ) { console . displayMessage ( ex . getClass ( ) + " " + ex . getMessage ( ) ) ; } console . displayMessage ( "Server thread stopped" ) ; }
tr	C	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
tr	A	@ Override public String getName ( ) { return "human" ; }
tr	B	public void setVelocity ( Vector2D vel ) { velocity = vel ; }
tr	E	public double getRotationSpeed ( ) { return rotationSpeed ; }
tr	B	public int getLength ( ) { currIndex = 0 ; maxIndex = Integer . MAX_VALUE ; preTraverse ( first ) ; return currIndex ; }
tr	E	public String getStatusId ( ) { return statusId ; }
tr	B	void limpiar ( ) { txtCedula . setText ( "" ) ; txtNombre . setText ( "" ) ; txtApellido . setText ( "" ) ; txtHijos . setText ( "" ) ; txtDireccion . setText ( "" ) ; txtEmail . setText ( "" ) ; txtTelefono . setText ( "" ) ; txtCelular . setText ( "" ) ; }
tr	I	public static String pastPrices ( String stock ) { String httpdata = getHtml ( yahoobase + "/hp?s=" + stock ) ; if ( ! httpdata . contains ( "Adj Close" ) ) return "HISTORIC" ; httpdata = removeHtml ( reformat ( httpdata . substring ( httpdata . indexOf ( "Adj Close" ) ) ) , false ) ; httpdata = httpdata . substring ( 0 , httpdata . lastIndexOf ( "@" ) ) ; if ( httpdata . indexOf ( "@" ) < 2 ) httpdata = httpdata . substring ( httpdata . indexOf ( "@" ) + 1 ) ; if ( httpdata . lastIndexOf ( "@" ) > 1 ) httpdata = ( httpdata . substring ( 0 , httpdata . lastIndexOf ( "@" ) ) . replaceAll ( " " , "" ) ) ; return httpdata ; }
tr	C	protected DRUMS ( AbstractHashFunction hashFunction , AccessMode accessMode , DRUMSParameterSet < Data > gp ) throws IOException { this . prototype = gp . getPrototype ( ) ; this . hashFunction = hashFunction ; this . gp = gp ; DynamicMemoryAllocater . instantiate ( gp ) ; gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC = ( int ) ( ( gp . BUCKET_MEMORY - gp . BUCKET_MEMORY % gp . MEMORY_CHUNK ) / hashFunction . getNumberOfBuckets ( ) / prototype . getSize ( ) / 2 ) ; logger . info ( "Setted MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC to {}" , gp . MIN_ELEMENT_IN_BUCKET_BEFORE_SYNC ) ; if ( accessMode == AccessMode . READ_WRITE ) { @ SuppressWarnings ( "unchecked" ) Bucket < Data > [ ] tmp = new Bucket [ hashFunction . getNumberOfBuckets ( ) ] ; buckets = tmp ; for ( int i = 0 ; i < hashFunction . getNumberOfBuckets ( ) ; i ++ ) { buckets [ i ] = new Bucket < Data > ( i , gp ) ; String tmpFileName = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( i ) ; if ( ! new File ( tmpFileName ) . exists ( ) ) { HeaderIndexFile < Data > tmpFile ; try { tmpFile = new HeaderIndexFile < Data > ( tmpFileName , HeaderIndexFile . AccessMode . READ_WRITE , 1 , gp ) ; tmpFile . close ( ) ; } catch ( FileLockException e ) { logger . error ( "Can't create file {}  because file is locked by another process." , tmpFileName ) ; } catch ( IOException e ) { logger . error ( "Can't create file {}. {}" , tmpFileName , e ) ; throw e ; } } } bucketContainer = new BucketContainer < Data > ( buckets , hashFunction ) ; synchronizerFactory = new SynchronizerFactory < Data > ( ) ; syncManager = new SyncManager < Data > ( bucketContainer , synchronizerFactory , gp ) ; syncManager . start ( ) ; } }
tr	F	IntArrayCache getIntArrayCache ( final int length ) { final int bucket = ArrayCache . getBucket ( length ) ; return getArrayCachesHolder ( ) . intArrayCaches [ bucket ] ; }
tr	B	private void manageMessage ( int senderID , NetworkMessage nm ) throws NetworkMessageException { switch ( nm . messageType ( ) ) { case NetworkMessage . STRING_MESSAGE : manageStringMessage ( senderID , ( StringMessage ) nm ) ; break ; case NetworkMessage . IDENTIFICATION_MESSAGE : manageIdentificationMessage ( senderID , ( IdentificationMessage ) nm ) ; break ; case NetworkMessage . DECISION_MESSAGE : manageDecisionMessage ( senderID , ( DecisionMessage ) nm ) ; break ; case NetworkMessage . GAME_START_MESSAGE : manageGameStartMessage ( senderID , ( GameStartMessage ) nm ) ; break ; case NetworkMessage . GAME_MESSAGE : manageGameMessage ( senderID , ( GameMessage ) nm ) ; break ; default : break ; } }
tr	J	static protected String getHtml ( String suf ) { URL url ; InputStream is ; InputStreamReader isr ; BufferedReader r ; String str = "" ; String nl = "" ; try { url = new URL ( suf ) ; is = url . openStream ( ) ; isr = new InputStreamReader ( is ) ; r = new BufferedReader ( isr ) ; do { nl = r . readLine ( ) ; if ( nl != null ) { nl = nl . trim ( ) + " " ; } str += nl ; } while ( nl != null ) ; } catch ( MalformedURLException e ) { System . out . println ( "Must enter a valid URL" ) ; } catch ( IOException e ) { } return str ; }
tr	F	public int lastIndexOf ( T value , boolean identity ) { T [ ] items = this . items ; if ( identity || value == null ) { for ( int i = size - 1 ; i >= 0 ; i -- ) { if ( items [ i ] == value ) { return i ; } } } else { for ( int i = size - 1 ; i >= 0 ; i -- ) { if ( value . equals ( items [ i ] ) ) { return i ; } } } return - 1 ; }
tr	F	private void deleteButtonActionPerformed ( java . awt . event . ActionEvent evt ) { int [ ] selected = masterTable . getSelectedRows ( ) ; List < pcpreports . Employee > toRemove = new ArrayList < pcpreports . Employee > ( selected . length ) ; for ( int idx = 0 ; idx < selected . length ; idx ++ ) { pcpreports . Employee e = list . get ( masterTable . convertRowIndexToModel ( selected [ idx ] ) ) ; toRemove . add ( e ) ; entityManager . remove ( e ) ; } list . removeAll ( toRemove ) ; saveData ( ) ; refreshData ( ) ; saveButton . setEnabled ( false ) ; deleteButton . setEnabled ( false ) ; }
tr	B	public Vector2D getVelocity ( ) { return velocity ; }
tr	B	public void startGame ( GameServerClass gameServer ) { if ( gameServer . minPlayers ( ) >= clients . size ( ) && clients . size ( ) <= gameServer . maxPlayers ( ) ) { this . gameServer = gameServer ; try { sendNetworkMessage ( new GameStartMessage ( gameServer . getName ( ) ) ) ; } catch ( NetworkMessageException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } } else { console . displayMessage ( "Can not start game. You need between " + gameServer . minPlayers ( ) + " and " + gameServer . maxPlayers ( ) + " players for this game." ) ; } }
tr	A	public Player ( String name , int number ) { _money = 5000 ; _name = name ; _number = number ; _pieces = new ArrayList < Piece > ( ) ; _score = 0 ; }
tr	F	public void keyTyped ( java . awt . event . KeyEvent evt ) { if ( evt . getSource ( ) == nombrelaboratoriosField ) { RegistroLaboratorios . this . nombrelaboratoriosFieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) == telefonolaboratorios1Field ) { RegistroLaboratorios . this . telefonolaboratorios1FieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) == telefonolaboratorios2Field ) { RegistroLaboratorios . this . telefonolaboratorios2FieldKeyTyped ( evt ) ; } else if ( evt . getSource ( ) == sucursalField ) { RegistroLaboratorios . this . sucursalFieldKeyTyped ( evt ) ; } }
tr	H	private void initNumRangePanel ( Composite mainPanel ) { numRangePanel = new Composite ( mainPanel , SWT . NONE ) ; numRangePanel . setLayout ( new MigLayout ( ) ) ; Label label = new Label ( numRangePanel , SWT . NONE ) ; label . setText ( "Minimum Value: " ) ; numMinValSp = new Spinner ( numRangePanel , SWT . BORDER ) ; numMinValSp . setLayoutData ( "width 50  wrap" ) ; numMinValSp . setMinimum ( - 9999999 ) ; numMinValSp . setMaximum ( 9999999 ) ; label = new Label ( numRangePanel , SWT . NONE ) ; label . setText ( "Maximum Value: " ) ; numMaxValSp = new Spinner ( numRangePanel , SWT . BORDER ) ; numMaxValSp . setLayoutData ( "width 50  wrap" ) ; numMaxValSp . setMinimum ( - 9999999 ) ; numMaxValSp . setMaximum ( 9999999 ) ; paddedBtn = new Button ( numRangePanel , SWT . CHECK ) ; paddedBtn . setText ( "Pad number with zeros" ) ; if ( fieldDef . getContentDef ( ) instanceof NumericRangeContentDef ) { NumericRangeContentDef cd = ( NumericRangeContentDef ) fieldDef . getContentDef ( ) ; numMinValSp . setSelection ( ( int ) cd . getMinVal ( ) ) ; numMaxValSp . setSelection ( ( int ) cd . getMaxVal ( ) ) ; paddedBtn . setSelection ( false ) ; numRangePanel . setVisible ( true ) ; } else if ( fieldDef . getContentDef ( ) instanceof PaddedIntContentDef ) { PaddedIntContentDef cd = ( PaddedIntContentDef ) fieldDef . getContentDef ( ) ; numMinValSp . setSelection ( cd . getMinVal ( ) ) ; numMaxValSp . setSelection ( cd . getMaxVal ( ) ) ; paddedBtn . setSelection ( true ) ; numRangePanel . setVisible ( true ) ; } else numRangePanel . setVisible ( false ) ; }
tr	C	RendererContext ( final String name ) { if ( LOG_CREATE_CONTEXT ) { MarlinUtils . logInfo ( "new RendererContext = " + name ) ; } this . name = name ; nPCPathIterator = new NormalizingPathIterator . NearestPixelCenter ( float6 ) ; nPQPathIterator = new NormalizingPathIterator . NearestPixelQuarter ( float6 ) ; transformerPC2D = new TransformingPathConsumer2D ( ) ; cache = new MarlinCache ( this ) ; renderer = new Renderer ( this ) ; ptg = new MarlinTileGenerator ( renderer ) ; stroker = new Stroker ( this ) ; dasher = new Dasher ( this ) ; switch ( MarlinRenderingEngine . REF_TYPE ) { default : case MarlinRenderingEngine . REF_HARD : reference = this ; break ; case MarlinRenderingEngine . REF_SOFT : reference = new SoftReference < RendererContext > ( this ) ; break ; case MarlinRenderingEngine . REF_WEAK : reference = new WeakReference < RendererContext > ( this ) ; break ; } }
tr	F	private boolean pieceConstraint ( Loc l , int dir , State rr ) { int x = l . x ; int y = l . y ; switch ( dir ) { case 0 : return ( y - 1 >= 0 && ! map . isCollision ( x , y - 1 ) && ! rr . contains ( new Loc ( x , y + 1 ) ) ) ; case 1 : return ( y + 1 < map . gridSize && ! map . isCollision ( x , y + 1 ) && ! rr . contains ( new Loc ( x , y - 1 ) ) ) ; case 2 : return ( x - 1 >= 0 && ! map . isCollision ( x - 1 , y ) && ! rr . contains ( new Loc ( x + 1 , y ) ) ) ; case 3 : return ( x + 1 < map . gridSize && ! map . isCollision ( x + 1 , y ) && ! rr . contains ( new Loc ( x - 1 , y ) ) ) ; default : return false ; } }
tr	B	public Point getPlayerSpawn ( ) { return spawn ; }
tr	H	private void setHumanMovesEnabled ( boolean enable ) { Board board = boardPanel . getBoard ( ) ; moveBoardListener . setEnabled ( enable ) ; if ( enable ) { board . addMoveListener ( ml ) ; } else { board . removeMoveListener ( ml ) ; } }
tr	C	@ Override public void updateModelFromView ( ) { }
tr	C	public float getWidth ( ) { return anim . getImage ( ) . getWidth ( null ) ; }
tr	H	public void save ( M m , Connection conn ) { Object id = getId ( m ) ; if ( id != null ) { int result = update ( m , allFields ( ) , conn , "WHERE " + Cols . getSingle ( idFields ) . sqlName + "=?" , id ) ; if ( result != 1 ) { throw new RuntimeException ( "Failed to update record into " + tableName + " table" ) ; } } else { insert ( m , conn ) ; } }
tr	G	public String getSitemapChangeFreq ( ) { assert this . sitemapChangeFreq != null ; return this . sitemapChangeFreq ; }
tr	D	ArrayCachesHolder getArrayCachesHolder ( ) { ArrayCachesHolder holder = hardRefArrayCaches ; if ( holder == null ) { holder = ( refArrayCaches != null ) ? refArrayCaches . get ( ) : null ; if ( holder == null ) { if ( LOG_CREATE_CONTEXT ) { MarlinUtils . logInfo ( "new ArrayCachesHolder for " + "RendererContext = " + name ) ; } holder = new ArrayCachesHolder ( ) ; if ( USE_CACHE_HARD_REF ) { hardRefArrayCaches = holder ; } refArrayCaches = new WeakReference < ArrayCachesHolder > ( holder ) ; } } return holder ; }
tr	H	private void telefonolaboratorios1FieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( telefonolaboratorios1Field . getText ( ) . length ( ) == 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
tr	C	void clear_all ( ) { point_list . removeAllElements ( ) ; if ( buffer != null ) { buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . fillRect ( 0 , 0 , XLEN , YLEN ) ; } repaint ( ) ; }
tr	E	public static String cnnForecast ( String stock ) { for ( int i = 0 ; i < 4 ; i ++ ) { String httpdata = getHtml ( fcstbase + stock ) ; if ( httpdata == null ) System . out . println ( "null forecast" ) ; if ( httpdata . contains ( ">There is no" ) || httpdata . contains ( "was not found" ) ) { return "#_#" ; } String chop = "#_#" ; if ( httpdata . contains ( ">Stock Price Forecast" ) ) { if ( i > 0 ) System . out . print ( "\n*" + i + "*" ) ; chop = httpdata . substring ( httpdata . indexOf ( ">Stock Price Forecast" ) ) ; if ( chop . contains ( "Earnings and Sales Forecasts" ) && chop . contains ( "The" ) ) chop = chop . substring ( chop . indexOf ( "The" ) + 3 ) ; String analysts = "#" ; String forecast = "#" ; try { if ( chop . contains ( "analyst" ) ) analysts = chop . substring ( 0 , chop . indexOf ( "analyst" ) ) . trim ( ) ; if ( chop . contains ( "represents a" ) ) forecast = chop . substring ( chop . indexOf ( "represents a" ) + 12 , chop . indexOf ( "%" ) ) . replaceAll ( "_" , "" ) ; if ( forecast . contains ( ">" ) ) forecast = forecast . substring ( forecast . indexOf ( ">" ) + 1 ) . trim ( ) ; } catch ( Exception e ) { } chop = analysts + "_" + forecast ; } return ( chop ) ; } return "#_#_#" ; }
tr	F	public void setLevelStage ( final Integer levelStage ) { this . levelStage = levelStage ; }
tr	G	private boolean goalTest ( State r , Loc g ) { return ( r . size ( ) == 1 && r . contains ( g ) ) ; }
tr	D	public float getVelocityX ( ) { return ( float ) velocity . x ; }
tr	D	public void run ( ) { socketLifeCycle ( ) ; }
tr	E	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( ReplyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( ReplyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( ReplyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( ReplyForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new ReplyForm ( ) . setVisible ( true ) ; } } ) ; }
tr	C	private boolean paintTile ( final Graphics gr , final int n , final int x , final int y ) { final int ypos = yoff + tileLocator . getTileScreenY ( x , y ) ; if ( ypos > clip . y - 64 && ypos < clip . y + clip . height + 100 ) { final int xpos = xoff + tileLocator . getTileScreenX ( x , y ) ; if ( xpos > clip . x - 100 && xpos < clip . x + clip . width + 100 ) { final int tileNo = map . get ( n , x , y ) ; if ( tileNo > 0 ) { tilePainter . paint ( gr , n , x , y , xpos + map . getXoff ( n , x , y ) , ypos + map . getYoff ( n , x , y ) , tileNo ) ; return true ; } if ( showScripts ) { String script = map . getScript ( x , y ) ; if ( script . length ( ) > 0 ) { gr . setColor ( Color . PINK ) ; gr . drawString ( script . substring ( 0 , Math . min ( script . length ( ) , 5 ) ) , xpos + 4 , ypos + 20 ) ; } } } } return false ; }
tr	B	private void avoidFromEdge ( int [ ] [ ] currentTokens ) { while ( x0 < 0 || x1 < 0 || x2 < 0 || x3 < 0 ) { currentTokens [ 0 ] [ 0 ] ++ ; currentTokens [ 1 ] [ 0 ] ++ ; currentTokens [ 2 ] [ 0 ] ++ ; currentTokens [ 3 ] [ 0 ] ++ ; x0 ++ ; x1 ++ ; x2 ++ ; x3 ++ ; } while ( x0 > 9 || x1 > 9 || x2 > 9 || x3 > 9 ) { currentTokens [ 0 ] [ 0 ] -- ; currentTokens [ 1 ] [ 0 ] -- ; currentTokens [ 2 ] [ 0 ] -- ; currentTokens [ 3 ] [ 0 ] -- ; x0 -- ; x1 -- ; x2 -- ; x3 -- ; } }
tr	I	private void telefonolaboratorios2FieldKeyTyped ( java . awt . event . KeyEvent evt ) { if ( ! Character . isDigit ( evt . getKeyChar ( ) ) && ! Character . isISOControl ( evt . getKeyChar ( ) ) ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; } if ( telefonolaboratorios2Field . getText ( ) . length ( ) == 13 ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; evt . consume ( ) ; JOptionPane . showMessageDialog ( this , "Telefono demasiado largo." , "ADVERTENCIA" , WIDTH ) ; } }
tr	C	public void vacio ( ) { this . size = 0 ; }
tr	D	private Date loadDate ( Element dateNode ) { return FormattingUtil . parseTIPPDate ( getTextContent ( dateNode ) ) ; }
tr	B	public void set_board ( Board board ) { _board = board ; }
tr	D	public void setVelocityY ( float dy ) { velocity . y = dy ; }
tr	E	private static void method342 ( int i , int j , int k , int l , int i1 ) { if ( j < topX || j >= bottomX ) return ; if ( l < topY ) { i1 -= topY - l ; l = topY ; } if ( l + i1 > bottomY ) i1 = bottomY - l ; int j1 = 256 - k ; int k1 = ( i >> 16 & ff ) * k ; int l1 = ( i >> 8 & ff ) * k ; int i2 = ( i & ff ) * k ; int i3 = j + l * width ; for ( int j3 = 0 ; j3 < i1 ; j3 ++ ) { int j2 = ( pixels [ i3 ] >> 16 & ff ) * j1 ; int k2 = ( pixels [ i3 ] >> 8 & ff ) * j1 ; int l2 = ( pixels [ i3 ] & ff ) * j1 ; int k3 = ( ( k1 + j2 >> 8 ) << 16 ) + ( ( l1 + k2 >> 8 ) << 8 ) + ( i2 + l2 >> 8 ) ; pixels [ i3 ] = k3 ; i3 += width ; } }
tr	J	public Status getStatus ( ) { return status ; }
tr	B	public Vector2D getPosition ( ) { return position ; }
tr	H	private void initConstsPanel ( Composite mainPanel ) { constsPanel = new Composite ( mainPanel , SWT . NONE ) ; constsPanel . setLayout ( new MigLayout ( "nogrid" ) ) ; Label label = new Label ( constsPanel , SWT . NONE ) ; label . setText ( "Possible values: " ) ; constsTxt = new Text ( constsPanel , SWT . BORDER ) ; constsTxt . setLayoutData ( "wrap" ) ; if ( fieldDef . getContentDef ( ) instanceof ConstContentDef ) { ConstContentDef cd = ( ConstContentDef ) fieldDef . getContentDef ( ) ; StringBuffer allowedValsStr = new StringBuffer ( ) ; Vector < String > allowedVals = cd . getAllowedVals ( ) ; for ( Iterator < String > it = allowedVals . iterator ( ) ; it . hasNext ( ) ; ) { allowedValsStr . append ( it . next ( ) ) . append ( " " ) ; } allowedValsStr . deleteCharAt ( allowedValsStr . length ( ) - 1 ) ; constsTxt . setText ( allowedValsStr . toString ( ) ) ; constsPanel . setVisible ( true ) ; } else constsPanel . setVisible ( false ) ; label = new Label ( constsPanel , SWT . NONE ) ; label . setText ( "(comma separated)" ) ; }
tr	B	@ Override public void putEnd ( ) throws ParsingException { close ( ) ; }
tr	B	@ Override public void putSubId ( ) throws ParsingException { context . subIdHandler . setWhereItStart ( token . length ( ) ) ; context . setHandler ( context . subIdHandler ) ; }
tr	E	byte [ ] getDirtyByteArray ( final int length ) { if ( length <= MAX_DIRTY_BYTE_ARRAY_SIZE ) { return getDirtyByteArrayCache ( length ) . getArray ( ) ; } if ( DO_STATS ) { incOversize ( ) ; } if ( DO_LOG_OVER_SIZE ) { logInfo ( "getDirtyByteArray[oversize]: length=\t" + length + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return new byte [ length ] ; }
tr	F	public List < Data > read ( int bucketId , int elementOffset , int numberToRead ) throws FileLockException , IOException { String filename = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( bucketId ) ; HeaderIndexFile < Data > indexFile = new HeaderIndexFile < Data > ( filename , HeaderIndexFile . AccessMode . READ_ONLY , gp . HEADER_FILE_LOCK_RETRY , gp ) ; List < Data > result = new ArrayList < Data > ( ) ; long actualOffset = elementOffset * gp . getElementSize ( ) ; ByteBuffer dataBuffer = ByteBuffer . allocate ( numberToRead * gp . getElementSize ( ) ) ; indexFile . read ( actualOffset , dataBuffer ) ; dataBuffer . flip ( ) ; byte [ ] dataArray = new byte [ gp . getElementSize ( ) ] ; while ( dataBuffer . position ( ) < dataBuffer . limit ( ) ) { dataBuffer . get ( dataArray ) ; @ SuppressWarnings ( "unchecked" ) Data copy = ( Data ) prototype . fromByteBuffer ( ByteBuffer . wrap ( dataArray ) ) ; result . add ( copy ) ; } indexFile . close ( ) ; return result ; }
tr	H	public static SwitchRules parseSwitchRule ( String rule ) throws IllegalArgumentException { if ( rule . compareTo ( "OneOfMany" ) == 0 ) { return SwitchRules . ONE_OF_MANY ; } else if ( rule . compareTo ( "AtMostOne" ) == 0 ) { return SwitchRules . AT_MOST_ONE ; } else if ( rule . compareTo ( "AnyOfMany" ) == 0 ) { return SwitchRules . ANY_OF_MANY ; } throw new IllegalArgumentException ( "Invalid SwitchRules String: '" + rule + "'" ) ; }
tr	H	public Object getValue ( ) { return Integer . toString ( getCalendar ( Calendar . YEAR ) ) ; }
tr	J	private void txtCedulaActionPerformed ( java . awt . event . ActionEvent evt ) { txtCedula . transferFocus ( ) ; }
tr	E	public String getVerifiedReason ( ) { return verifiedReason ; }
tr	G	private static boolean shouldInLineType ( class < ? > clazz , Map < String , Object > options ) { if ( clazz . equals ( String . class ) ) { boolean inlineString = BuilderOptions . DEFAULT_INLINE_STRINGS ; if ( options . containsKey ( BuilderOptions . INLINE_STRINGS ) ) { inlineString = ( boolean ) options . get ( BuilderOptions . INLINE_STRINGS ) ; } return inlineString ; } if ( clazz . isPrimitive ( ) ) return true ; if ( isNumberObject ( clazz , options ) ) { boolean inlineNumbers = BuilderOptions . DEFAULT_INLINE_NUMBERS ; if ( options . containsKey ( BuilderOptions . INLINE_NUMBERS ) ) { inlineNumbers = ( boolean ) options . get ( BuilderOptions . INLINE_NUMBERS ) ; } return inlineNumbers ; } return false ; }
tr	F	public boolean removeValue ( T value , boolean identity ) { T [ ] items = this . items ; if ( identity || value == null ) { for ( int i = 0 , n = size ; i < n ; i ++ ) { if ( items [ i ] == value ) { removeIndex ( i ) ; return true ; } } } else { for ( int i = 0 , n = size ; i < n ; i ++ ) { if ( value . equals ( items [ i ] ) ) { removeIndex ( i ) ; return true ; } } } return false ; }
tr	G	private void newButtonActionPerformed ( java . awt . event . ActionEvent evt ) { farmacia . Laboratorios l = new farmacia . Laboratorios ( ) ; entityManager . persist ( l ) ; list . add ( l ) ; int row = list . size ( ) - 1 ; masterTable . setRowSelectionInterval ( row , row ) ; masterTable . scrollRectToVisible ( masterTable . getCellRect ( row , 0 , true ) ) ; saveButton . setEnabled ( true ) ; newButton . setEnabled ( false ) ; }
tr	B	public boolean boundaryCheck ( Point point ) { if ( ( point . x > 0 ) && point . x < width ) { if ( ( point . y > 0 ) && point . y < height ) { return true ; } } return false ; }
tr	C	public void paint ( Graphics g ) { double scale = 1.0 ; paintGrid ( g , null , currentPageIndex , scale ) ; }
tr	F	FormListener ( ) { }
tr	B	public java . net . InetAddress getInetAddress ( ) { if ( getRawSocket ( ) == null ) return null ; return getRawSocket ( ) . getInetAddress ( ) ; }
tr	G	public String getUrl ( ) { assert this . url != null ; return this . url ; }
tr	A	public StreamedLinkSet ( String _file ) { file = _file ; }
tr	H	public void setInputValue ( String name , double value ) { InputVariable inputVariable = getInputVariable ( name ) ; inputVariable . setInputValue ( value ) ; }
tr	D	private static Pair < boolean , List < String >> shouldFollowField ( int nestingLevel , int MAX_NESTING , Object o , Field field ) { boolean shouldFollow = true ; List < String > reasons = new ArrayList < String > ( ) ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { shouldFollow = false ; return new Pair < boolean , List < String >> ( shouldFollow , reasons ) ; } if ( nestingLevel >= MAX_NESTING ) { shouldFollow = false ; reasons . add ( String . format ( "nestingLevel %d exceeds MAX_NESTING %d" , nestingLevel , MAX_NESTING ) ) ; } if ( field . getName ( ) . equals ( "serialVersionUID" ) ) { shouldFollow = false ; reasons . add ( "field named serialVersionUID" ) ; } if ( field . getName ( ) . equals ( "serialPersistentFields" ) ) { shouldFollow = false ; reasons . add ( "field named serialPersistentFields" ) ; } if ( o . getClass ( ) . getName ( ) . endsWith ( "TaskSupport" ) ) { shouldFollow = false ; reasons . add ( "Parent object is a TaskSupport" ) ; } if ( o . getClass ( ) . getName ( ) . equals ( "java.lang.Class" ) ) { shouldFollow = false ; reasons . add ( "Parent object is a java.lang.Class" ) ; } if ( o . getClass ( ) . getName ( ) . startsWith ( "java.util.concurrent.ThreadPoolExecutor" ) ) { shouldFollow = false ; reasons . add ( "Parent object is a java.util.concurrent.ThreadPoolExecutor" ) ; } if ( o . getClass ( ) . getName ( ) . endsWith ( "Thread" ) ) { shouldFollow = false ; reasons . add ( "Parent object is a Thread" ) ; } if ( field . getName ( ) . equals ( "_meta" ) ) { shouldFollow = false ; reasons . add ( "field named _meta" ) ; } return new Pair < boolean , List < String >> ( shouldFollow , reasons ) ; }
tr	C	public boolean isConnected ( ) { return getRawSocket ( ) != null && getRawSocket ( ) . isConnected ( ) ; }
tr	F	private static boolean shouldInlineArrayValues ( Object o , Map < String , Object > options ) { if ( ! o . getClass ( ) . isArray ( ) ) { throw new IllegalArgumentException ( "first argument to this method must be an array" ) ; } class < ? > contentType = o . getClass ( ) . getComponentType ( ) ; if ( shouldInLineType ( contentType , options ) ) return true ; boolean shouldInLine = true ; final int N = Array . getLength ( o ) ; for ( int i = 0 ; i < N ; i ++ ) { Object val = Array . get ( o , i ) ; if ( val == null ) continue ; shouldInLine = shouldInLine && shouldInLineType ( val . getClass ( ) , options ) ; } return shouldInLine ; }
tr	D	private void loadTaskResponse ( ManifestBuilder builder , Element responseEl ) { loadTask ( builder , responseEl ) ; builder . setIsRequest ( false ) ; Element inResponseTo = getFirstChildByName ( responseEl , TaskResponse . IN_RESPONSE_TO ) ; builder . setRequestPackageId ( getChildTextByName ( inResponseTo , UNIQUE_PACKAGE_ID ) ) ; builder . setRequestCreator ( loadCreator ( getFirstChildByName ( inResponseTo , PACKAGE_CREATOR ) ) ) ; builder . setComment ( getChildTextByName ( responseEl , TaskResponse . COMMENT ) ) ; String rawMessage = getChildTextByName ( responseEl , TaskResponse . MESSAGE ) ; TIPPResponseCode msg = TIPPResponseCode . fromSchemaValue ( rawMessage ) ; builder . setResponseCode ( msg ) ; }
tr	A	public Map ( int width , int height ) { this . width = width ; this . height = height ; grid = new Tile [ width ] [ height ] ; }
tr	E	public Object clone ( ResourceManager p ) { return new Sprite ( ( Animation ) anim . clone ( ) , p ) ; }
tr	A	public int getBestMove ( ) { return 0 ; }
tr	G	public int getColumnCount ( ) { return 7 ; }
tr	F	@ Override public String toString ( ) { return new FclExporter ( ) . toString ( this ) ; }
tr	C	@ Override public void close ( ) { TranslationManager . getinstance ( ) . removeListener ( this ) ; dispose ( ) ; }
tr	E	public M selectById ( Object id , Connection conn ) { if ( id == null ) { return null ; } return select ( conn , "WHERE `" + Cols . getSingle ( idFields ) . sqlName + "`=?" , id ) ; }
tr	G	int [ ] widenDirtyIntArray ( final int [ ] in , final int usedSize , final int needSize ) { final int length = in . length ; if ( DO_CHECKS && length >= needSize ) { return in ; } if ( DO_STATS ) { incResizeDirtyInt ( ) ; } final int [ ] res = getDirtyIntArray ( getNewSize ( usedSize , needSize ) ) ; System . arraycopy ( in , 0 , res , 0 , usedSize ) ; putDirtyIntArray ( in ) ; if ( DO_LOG_WIDEN_ARRAY ) { logInfo ( "widenDirtyIntArray[" + res . length + "]: usedSize=\t" + usedSize + "\tlength=\t" + length + "\tneeded length=\t" + needSize + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return res ; }
tr	B	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
tr	E	private static void enqueueNode ( GraphBuildContext context , int nestingLevel , GraphPoint fromNode , final String edgeName , Object value ) { if ( context . hasPoint ( value ) ) { final EdgeSuspension edgeSusp = new EdgeSuspension ( fromNode , context . getPoint ( value ) , edgeName ) ; context . enqueueEdgeToBuild ( edgeSusp ) ; } else { final GraphPointSuspension pointSusp = new GraphPointSuspension ( nestingLevel + 1 , value ) ; context . enqueuePointToBuild ( pointSusp ) ; final EdgeSuspension edgeSusp = new EdgeSuspension ( fromNode , value , edgeName ) ; context . enqueueEdgeToBuild ( edgeSusp ) ; } }
tr	B	public int get_score ( ) { return _score ; }
tr	J	private static String cleanTitle ( String document , String creator ) { document = document . trim ( ) ; document = fixTypos ( document ) ; document = fixQuotesInParagraph ( document ) ; document = document . replaceAll ( "<center>|</center>|<span[^>]*>|<font[^>]*>|</span>|</font>| align=\"center\"|" + "<strong>|</strong>|<em>|</em>|<b>|</b>|<i>|</i>|" + "<td>|</td>|<tr>|</tr>|<table>|</table>" , "" ) ; document = document . replaceAll ( "</p>\\s*<p>" , "<br /><br />" ) ; document = document . replaceAll ( "<p[^>]*>" , "<p>" ) ; document = document . replaceAll ( "[\u00A0\\s]*<br />[\u00A0\\s]*" , "<br />" ) ; document = document . replaceAll ( "<p><br />" , "<p>" ) ; document = document . replaceAll ( "<p>\\s*</p>" , "<br />" ) ; document = document . replaceAll ( "(<br />)+</p>" , "<p>" ) ; document = document . replaceAll ( "([^>])<br />SUR" , "$1<br /><br />SUR" ) ; document = document . replaceAll ( "VOLONT\u00C9<br />" , "VOLONT\u00C9<br /><br />" ) ; document = document . replaceAll ( "<br />\u00C0 L\u2019OCCASION" , "<br /><br />\u00C0 L\u2019OCCASION" ) ; document = document . replaceAll ( "PAUL VI" , "<br />PAUL VI" ) ; document = document . replaceAll ( "(BENO\u00CET XVI|JEAN-PAUL II|PAUL VI|FRAN\u00C7OIS)" , "<span class=\"author\">$1</span><br />" ) ; if ( document . indexOf ( "LETTRE ENCYCLIQUE" ) > 4 ) { document = document . replaceAll ( "<p>(.*?)<br />" , "<p><span class=\"title\">$1</span><br />" ) ; } else { document = document . replaceAll ( "(LETTRE ENCYCLIQUE<br />)(.*?)<br />" , "<span class=\"title\">$2</span><br /><br />$1" ) ; } document = document . replaceAll ( "</p>\\s*</p>" , "</p>" ) ; document = document . replaceAll ( "<br />\\s*(<br /><br />|</p>)" , "$1" ) ; while ( document . endsWith ( "<p>" ) ) { document = document . substring ( 0 , document . length ( ) - 3 ) ; } while ( document . startsWith ( "<br />" ) ) { document = document . substring ( 6 ) . trim ( ) ; } while ( document . endsWith ( "<br />" ) ) { document = document . substring ( 0 , document . length ( ) - 6 ) . trim ( ) ; } if ( ! document . endsWith ( "</p>" ) ) { document = document + "</p>" ; } if ( ! document . startsWith ( "<p>" ) ) { document = "<p>" + document ; } document = "<object width=\"200em\" data=\"img/" + creator + "-bw.svg\" type=\"image/svg+xml\"></object>" + document ; return document ; }
tr	I	public void setPrintMode ( PrintMode printMode ) { this . printMode = printMode ; calcPages ( this . getWidth ( ) - padding * 2 , this . getHeight ( ) - padding * 2 ) ; repaint ( ) ; }
tr	J	public static String getQualifiedMethodName ( Method method ) { assert . notNull ( method , "Method must not be null" ) ; return method . getDeclaringClass ( ) . getName ( ) + "." + method . getName ( ) ; }
tr	J	private void initSequencePanel ( Composite mainPanel ) { sequencePanel = new Composite ( mainPanel , SWT . NONE ) ; sequencePanel . setLayout ( new MigLayout ( ) ) ; Label label = new Label ( sequencePanel , SWT . NONE ) ; label . setText ( "Style: " ) ; pgsqlBtn = new Button ( sequencePanel , SWT . RADIO ) ; pgsqlBtn . setText ( "Postgres" ) ; pgsqlBtn . setSelection ( true ) ; oraBtn = new Button ( sequencePanel , SWT . RADIO ) ; oraBtn . setText ( "Oracle" ) ; oraBtn . setLayoutData ( "wrap" ) ; label = new Label ( sequencePanel , SWT . NONE ) ; label . setText ( "Sequence Name: " ) ; seqNameTxt = new Text ( sequencePanel , SWT . BORDER ) ; seqNameTxt . setLayoutData ( "span 2  width 120" ) ; ContentDef cd = fieldDef . getContentDef ( ) ; if ( cd instanceof OracleSequenceContentDef || cd instanceof PostgresSequenceContentDef ) { pgsqlBtn . setSelection ( cd instanceof OracleSequenceContentDef ) ; pgsqlBtn . setSelection ( cd instanceof PostgresSequenceContentDef ) ; sequencePanel . setVisible ( true ) ; } else sequencePanel . setVisible ( false ) ; }
tr	F	public void keyPressed ( java . awt . event . KeyEvent evt ) { }
tr	D	void button_run_clicked ( String args ) { if ( point_list . isEmpty ( ) ) return ; svm_parameter param = new svm_parameter ( ) ; param . svm_type = svm_parameter . C_SVC ; param . kernel_type = svm_parameter . RBF ; param . degree = 3 ; param . gamma = 0 ; param . coef0 = 0 ; param . nu = 0.5 ; param . cache_size = 40 ; param . C = 1 ; param . eps = 1e-3 ; param . p = 0.1 ; param . shrinking = 1 ; param . probability = 0 ; param . nr_weight = 0 ; param . weight_label = new int [ 0 ] ; param . weight = new double [ 0 ] ; StringTokenizer st = new StringTokenizer ( args ) ; String [ ] argv = new String [ st . countTokens ( ) ] ; for ( int i = 0 ; i < argv . length ; i ++ ) argv [ i ] = st . nextToken ( ) ; for ( int i = 0 ; i < argv . length ; i ++ ) { if ( argv [ i ] . charAt ( 0 ) != - ) break ; if ( ++ i >= argv . length ) { System . err . print ( "unknown option\n" ) ; break ; } switch ( argv [ i - 1 ] . charAt ( 1 ) ) { case s : param . svm_type = atoi ( argv [ i ] ) ; break ; case t : param . kernel_type = atoi ( argv [ i ] ) ; break ; case d : param . degree = atoi ( argv [ i ] ) ; break ; case g : param . gamma = atof ( argv [ i ] ) ; break ; case r : param . coef0 = atof ( argv [ i ] ) ; break ; case n : param . nu = atof ( argv [ i ] ) ; break ; case m : param . cache_size = atof ( argv [ i ] ) ; break ; case c : param . C = atof ( argv [ i ] ) ; break ; case e : param . eps = atof ( argv [ i ] ) ; break ; case p : param . p = atof ( argv [ i ] ) ; break ; case h : param . shrinking = atoi ( argv [ i ] ) ; break ; case b : param . probability = atoi ( argv [ i ] ) ; break ; case w : ++ param . nr_weight ; { int [ ] old = param . weight_label ; param . weight_label = new int [ param . nr_weight ] ; System . arraycopy ( old , 0 , param . weight_label , 0 , param . nr_weight - 1 ) ; } { double [ ] old = param . weight ; param . weight = new double [ param . nr_weight ] ; System . arraycopy ( old , 0 , param . weight , 0 , param . nr_weight - 1 ) ; } param . weight_label [ param . nr_weight - 1 ] = atoi ( argv [ i - 1 ] . substring ( 2 ) ) ; param . weight [ param . nr_weight - 1 ] = atof ( argv [ i ] ) ; break ; default : System . err . print ( "unknown option\n" ) ; } } svm_problem prob = new svm_problem ( ) ; prob . l = point_list . size ( ) ; prob . y = new double [ prob . l ] ; if ( param . kernel_type == svm_parameter . PRECOMPUTED ) { } else if ( param . svm_type == svm_parameter . EPSILON_SVR || param . svm_type == svm_parameter . NU_SVR ) { if ( param . gamma == 0 ) param . gamma = 1 ; prob . x = new svm_node [ prob . l ] [ 1 ] ; for ( int i = 0 ; i < prob . l ; i ++ ) { point p = point_list . elementAt ( i ) ; prob . x [ i ] [ 0 ] = new svm_node ( ) ; prob . x [ i ] [ 0 ] . index = 1 ; prob . x [ i ] [ 0 ] . value = p . x ; prob . y [ i ] = p . y ; } svm_model model = svm . svm_train ( prob , param ) ; svm_node [ ] x = new svm_node [ 1 ] ; x [ 0 ] = new svm_node ( ) ; x [ 0 ] . index = 1 ; int [ ] j = new int [ XLEN ] ; Graphics window_gc = getGraphics ( ) ; for ( int i = 0 ; i < XLEN ; i ++ ) { x [ 0 ] . value = ( double ) i / XLEN ; j [ i ] = ( int ) ( YLEN * svm . svm_predict ( model , x ) ) ; } buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . drawLine ( 0 , 0 , 0 , YLEN - 1 ) ; window_gc . setColor ( colors [ 0 ] ) ; window_gc . drawLine ( 0 , 0 , 0 , YLEN - 1 ) ; int p = ( int ) ( param . p * YLEN ) ; for ( int i = 1 ; i < XLEN ; i ++ ) { buffer_gc . setColor ( colors [ 0 ] ) ; buffer_gc . drawLine ( i , 0 , i , YLEN - 1 ) ; window_gc . setColor ( colors [ 0 ] ) ; window_gc . drawLine ( i , 0 , i , YLEN - 1 ) ; buffer_gc . setColor ( colors [ 5 ] ) ; window_gc . setColor ( colors [ 5 ] ) ; buffer_gc . drawLine ( i - 1 , j [ i - 1 ] , i , j [ i ] ) ; window_gc . drawLine ( i - 1 , j [ i - 1 ] , i , j [ i ] ) ; if ( param . svm_type == svm_parameter . EPSILON_SVR ) { buffer_gc . setColor ( colors [ 2 ] ) ; window_gc . setColor ( colors [ 2 ] ) ; buffer_gc . drawLine ( i - 1 , j [ i - 1 ] + p , i , j [ i ] + p ) ; window_gc . drawLine ( i - 1 , j [ i - 1 ] + p , i , j [ i ] + p ) ; buffer_gc . setColor ( colors [ 2 ] ) ; window_gc . setColor ( colors [ 2 ] ) ; buffer_gc . drawLine ( i - 1 , j [ i - 1 ] - p , i , j [ i ] - p ) ; window_gc . drawLine ( i - 1 , j [ i - 1 ] - p , i , j [ i ] - p ) ; } } } else { if ( param . gamma == 0 ) param . gamma = 0.5 ; prob . x = new svm_node [ prob . l ] [ 2 ] ; for ( int i = 0 ; i < prob . l ; i ++ ) { point p = point_list . elementAt ( i ) ; prob . x [ i ] [ 0 ] = new svm_node ( ) ; prob . x [ i ] [ 0 ] . index = 1 ; prob . x [ i ] [ 0 ] . value = p . x ; prob . x [ i ] [ 1 ] = new svm_node ( ) ; prob . x [ i ] [ 1 ] . index = 2 ; prob . x [ i ] [ 1 ] . value = p . y ; prob . y [ i ] = p . value ; } svm_model model = svm . svm_train ( prob , param ) ; svm_node [ ] x = new svm_node [ 2 ] ; x [ 0 ] = new svm_node ( ) ; x [ 1 ] = new svm_node ( ) ; x [ 0 ] . index = 1 ; x [ 1 ] . index = 2 ; Graphics window_gc = getGraphics ( ) ; for ( int i = 0 ; i < XLEN ; i ++ ) for ( int j = 0 ; j < YLEN ; j ++ ) { x [ 0 ] . value = ( double ) i / XLEN ; x [ 1 ] . value = ( double ) j / YLEN ; double d = svm . svm_predict ( model , x ) ; if ( param . svm_type == svm_parameter . ONE_CLASS && d < 0 ) d = 2 ; buffer_gc . setColor ( colors [ ( int ) d ] ) ; window_gc . setColor ( colors [ ( int ) d ] ) ; buffer_gc . drawLine ( i , j , i , j ) ; window_gc . drawLine ( i , j , i , j ) ; } } draw_all_points ( ) ; }
tr	C	private void checkSectionForDuplicateSequence ( TIPPSection section ) { Set < Integer > seen = new HashSet < Integer > ( ) ; for ( TIPPFile r : section . getFileResources ( ) ) { if ( seen . contains ( r . getSequence ( ) ) ) { errorHandler . reportError ( DUPLICATE_RESOURCE_SEQUENCE_IN_MANIFEST , "Duplicate sequence number in " + section . getType ( ) . getElementName ( ) + ": " + r . getSequence ( ) , null ) ; } seen . add ( r . getSequence ( ) ) ; } }
tr	H	void putDirtyIntArray ( final int [ ] array ) { final int length = array . length ; if ( ( ( length & 1 ) == 0 ) && ( length <= MAX_ARRAY_SIZE ) ) { getDirtyIntArrayCache ( length ) . putDirtyArray ( array , length ) ; } }
tr	D	public boolean isLevelStageValid ( final Integer levelStage ) { return ! isLevelStageNotValid ( levelStage ) ; }
tr	A	String getPreviousColumnName ( ) { return token . getPreviousColumnName ( ) ; }
tr	I	public void drawComponents ( BufferedImage canvas , boolean drawCorner ) { if ( _components == null ) findComponents ( ) ; BufferedImage image = new BufferedImage ( _width , _height , BufferedImage . TYPE_INT_RGB ) ; for ( int x = 0 ; x < _width ; x ++ ) for ( int y = 0 ; y < _height ; y ++ ) image . setRGB ( x , y , ffffff ) ; for ( ConnectedComponent cc : _components ) cc . draw ( image , true , drawCorner ) ; canvas . createGraphics ( ) . drawImage ( image , 0 , 0 , null ) ; }
tr	A	@ Override public void putChar ( char c ) throws ParsingException { token . addChar ( c ) ; }
tr	B	public SyntacticFeatureFactory ( Options options ) { this . options = options ; wordAlphabet = new Alphabet ( ) ; stoppedGrowth = false ; featureHashSet = new TLongHashSet ( 100000 ) ; numWordFeats = 0 ; }
tr	F	public ArrayList < TopicOutput > getAllTopics ( ) { return allTopics ; }
tr	G	private void saveData ( ) { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < pcpreports . Employee > merged = new ArrayList < pcpreports . Employee > ( list . size ( ) ) ; for ( pcpreports . Employee e : list ) { merged . add ( entityManager . merge ( e ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; } }
tr	G	public void removeRange ( int start , int end ) { if ( end >= size ) { throw new IndexOutOfBoundsException ( "end can't be >= size: " + end + " >= " + size ) ; } if ( start > end ) { throw new IndexOutOfBoundsException ( "start can't be > end: " + start + " > " + end ) ; } T [ ] items = this . items ; int count = end - start + 1 ; if ( ordered ) { System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; } else { int lastIndex = this . size - 1 ; for ( int i = 0 ; i < count ; i ++ ) { items [ start + i ] = items [ lastIndex - i ] ; } } size -= count ; }
tr	J	public void addActionListener ( ActionListener arg ) { getActionListeners ( ) . add ( arg ) ; }
tr	D	private void logSent ( String message ) { logMessage ( getOutputFilter ( ) , new StringBuffer ( "Sent: " ) . append ( message ) . toString ( ) ) ; }
tr	F	private TIPPReferenceFile loadReferenceFileResource ( Element el , TIPPSectionType sectionType , Map < TIPPFile , String > locationMap , Sequences sequences ) { int sequence = getSequence ( el , sequences ) ; String location = getChildTextByName ( el , ObjectFile . LOCATION ) ; if ( ! FormattingUtil . validLocationString ( sectionType , location ) ) { errorHandler . reportError ( INVALID_RESOURCE_LOCATION_IN_MANIFEST , "Invalid location: " + location , null ) ; } String name = getChildTextByName ( el , ObjectFile . NAME ) ; if ( name == null ) name = location ; LanguageChoice lc = null ; if ( el . hasAttribute ( ObjectFile . ATTR_LANGUAGE_CHOICE ) ) { lc = TIPPReferenceFile . LanguageChoice . valueOf ( el . getAttribute ( ObjectFile . ATTR_LANGUAGE_CHOICE ) ) ; } TIPPReferenceFile file = new TIPPReferenceFile ( sectionType , name , sequence , lc ) ; locationMap . put ( file , location ) ; return file ; }
tr	B	public org . w3c . dom . Node item ( int index ) { currIndex = 0 ; maxIndex = index ; preTraverse ( first ) ; if ( currIndex > maxIndex && currNode != null ) return currNode . getAdapter ( ) ; else return null ; }
tr	F	public Point mousePosToTile ( int mousex , int mousey ) { final int w = map . getWidth ( ) ; final int h = map . getHeight ( ) ; int best = 99999999 ; int bestRow = 0 ; mousex -= tileLocator . getCursorX ( ) / 2 ; mousey -= tileLocator . getRasterY ( ) / 2 ; for ( int y = 0 ; y < h ; y += 2 ) { for ( int x = 0 ; x < w ; x += 5 ) { final int xpos = xoff + tileLocator . getTileScreenX ( x , y ) ; final int ypos = yoff + tileLocator . getTileScreenY ( x , y ) ; final int dist = ( xpos - mousex ) * ( xpos - mousex ) + ( ypos - mousey ) * ( ypos - mousey ) ; if ( dist < best ) { best = dist ; bestRow = y ; } } } best = 999999 ; for ( int y = bestRow - 5 ; y < bestRow + 5 ; y ++ ) { for ( int x = 0 ; x < w ; x ++ ) { final int xpos = xoff + tileLocator . getTileScreenX ( x , y ) ; final int ypos = yoff + tileLocator . getTileScreenY ( x , y ) ; final int dist = ( xpos - mousex ) * ( xpos - mousex ) + ( ypos - mousey ) * ( ypos - mousey ) ; if ( dist < best ) { mouseToTile . x = x ; mouseToTile . y = y ; best = dist ; if ( best < 16 ) { return mouseToTile ; } } } } return mouseToTile ; }
tr	D	private void loadTask ( ManifestBuilder builder , Element taskEl ) { builder . setSourceLocale ( getChildTextByName ( taskEl , Task . SOURCE_LANGUAGE ) ) ; builder . setTargetLocale ( getChildTextByName ( taskEl , Task . TARGET_LANGUAGE ) ) ; builder . setTaskType ( getChildTextByName ( taskEl , Task . TYPE ) ) ; }
tr	E	private boolean testConnection ( Connection aconn ) { try { Statement stmt = aconn . createStatement ( ) ; stmt . executeQuery ( dbTestQry ) ; stmt . close ( ) ; return ( true ) ; } catch ( Exception ex ) { } return ( false ) ; }
tr	J	public static String getQualifiedName ( class < ? > clazz ) { assert . notNull ( clazz , "Class must not be null" ) ; if ( clazz . isArray ( ) ) { return getQualifiedNameForArray ( clazz ) ; } else { return clazz . getName ( ) ; } }
tr	C	private void initOKBtn ( ) { Button btn = new Button ( dialog , SWT . PUSH ) ; btn . setText ( "OK" ) ; btn . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent arg0 ) { ContentDef cd = null ; int selIdx = combo . getSelectionIndex ( ) ; switch ( selIdx ) { case ( EMAIL_OPT_IDX ) : { cd = new EmailContentDef ( ) ; break ; } case ( EMAIL_LIST_OPT_IDX ) : { cd = new EmailListContentDef ( ) ; break ; } case ( CONSTS_OPT_IDX ) : { String [ ] vals = constsTxt . getText ( ) . split ( " " ) ; cd = new ConstContentDef ( new Vector < String > ( Arrays . asList ( vals ) ) ) ; break ; } case ( NUMERIC_RANGE_OPT_IDX ) : { int minVal = numMinValSp . getSelection ( ) ; int maxVal = numMaxValSp . getSelection ( ) ; if ( minVal > maxVal ) { TestDataCreator . showErrMsg ( dialog , "Maximum value must be larger than the minimum value" ) ; return ; } if ( paddedBtn . getSelection ( ) ) { cd = new PaddedIntContentDef ( minVal , maxVal ) ; } else { cd = new NumericRangeContentDef ( minVal , maxVal , fieldDef . getPrecision ( ) ) ; } break ; } case ( DATE_RANGE_OPT_IDX ) : { Calendar cal = Calendar . getInstance ( ) ; cal . set ( dateMinValDt . getYear ( ) , dateMinValDt . getMonth ( ) , dateMinValDt . getDay ( ) ) ; Date minDate = cal . getTime ( ) ; cal . set ( dateMaxValDt . getYear ( ) , dateMaxValDt . getMonth ( ) , dateMaxValDt . getDay ( ) ) ; Date maxDate = cal . getTime ( ) ; if ( minDate . getTime ( ) >= maxDate . getTime ( ) ) { TestDataCreator . showErrMsg ( dialog , "Maximum date must be larger than the minimum value" ) ; return ; } cd = new DateRangeContentDef ( minDate , maxDate , dateFormat . getText ( ) , fieldDef . getType ( ) ) ; break ; } case ( SEQUENCE_OPT_IDX ) : { if ( seqNameTxt . getText ( ) . trim ( ) . length ( ) == 0 ) { TestDataCreator . showErrMsg ( dialog , "Please fill in the sequence name" ) ; return ; } cd = pgsqlBtn . getSelection ( ) ? new PostgresSequenceContentDef ( seqNameTxt . getText ( ) ) : new OracleSequenceContentDef ( seqNameTxt . getText ( ) ) ; break ; } case ( REFERENCE_OPT_IDX ) : { int idx = refTableNameCombo . getSelectionIndex ( ) ; if ( idx == - 1 ) { TestDataCreator . showErrMsg ( dialog , "Please select a table" ) ; return ; } TableDef td = ( ( TableDef [ ] ) refTableNameCombo . getData ( ) ) [ idx ] ; idx = refFieldNameCombo . getSelectionIndex ( ) ; if ( idx == - 1 ) { TestDataCreator . showErrMsg ( dialog , "Please select a field" ) ; return ; } FieldDef fd = ( ( FieldDef [ ] ) refFieldNameCombo . getData ( ) ) [ idx ] ; fd . setReferenced ( true ) ; cd = new ReferenceContentDef ( td , fd ) ; break ; } case ( DUP_REFERENCE_OPT_IDX ) : { int idx = refTableNameCombo . getSelectionIndex ( ) ; if ( idx == - 1 ) { TestDataCreator . showErrMsg ( dialog , "Please select a table" ) ; return ; } TableDef td = ( ( TableDef [ ] ) refTableNameCombo . getData ( ) ) [ idx ] ; idx = refFieldNameCombo . getSelectionIndex ( ) ; if ( idx == - 1 ) { TestDataCreator . showErrMsg ( dialog , "Please select a field" ) ; return ; } FieldDef fd = ( ( FieldDef [ ] ) refFieldNameCombo . getData ( ) ) [ idx ] ; fd . setReferenced ( true ) ; cd = new DupReferenceContentDef ( tableDef , fieldDef , td , fd ) ; break ; } case ( DEP_DUP_REFERENCE_OPT_IDX ) : { int idx = refTableNameCombo . getSelectionIndex ( ) ; if ( idx == - 1 ) { TestDataCreator . showErrMsg ( dialog , "Please select a table" ) ; return ; } TableDef td = ( ( TableDef [ ] ) refTableNameCombo . getData ( ) ) [ idx ] ; idx = refFieldNameCombo . getSelectionIndex ( ) ; if ( idx == - 1 ) { TestDataCreator . showErrMsg ( dialog , "Please select a field" ) ; return ; } FieldDef fd = ( ( FieldDef [ ] ) refFieldNameCombo . getData ( ) ) [ idx ] ; fd . setReferenced ( true ) ; cd = new DependentDupReferenceContentDef ( null , null , tableDef , fieldDef , td , fd ) ; break ; } case ( EN_STRING_OPT_IDX ) : { cd = new EnglishStringContentDef ( ) ; break ; } case ( JP_STRING_OPT_IDX ) : { cd = new JapaneseStringContentDef ( ) ; break ; } case ( CUSTOM_OPT_IDX ) : { if ( customContentDef == null ) { TestDataCreator . showErrMsg ( dialog , "Please select a class file" ) ; return ; } cd = customContentDef ; break ; } case ( BLOB_OPT_IDX ) : { int idx = blobFileNameFieldCombo . getSelectionIndex ( ) ; if ( idx == - 1 ) { TestDataCreator . showErrMsg ( dialog , "Please select a field" ) ; return ; } cd = new Blob ( ) ; ( ( Blob ) cd ) . setFileNameField ( blobFileNameFieldCombo . getItem ( idx ) ) ; break ; } } fieldDef . setContentDef ( cd ) ; fieldDef . setNullOk ( allowNullValsBtn . getSelection ( ) ) ; fieldDef . setNullRatio ( allowNullValsBtn . getSelection ( ) ? nullValuesRatioSpinner . getSelection ( ) : 0 ) ; dialog . close ( ) ; parentDlg . populateTable ( ) ; } } ) ; }
tr	E	private String getClientNameByID ( int id ) { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == id ) { return clients . get ( i ) . getName ( ) ; } } return "NOT_FOUND" ; }
tr	A	public static byte [ ] createChallenge ( String key1 , String key2 , byte [ ] key3 ) throws InvalidHandshakeException { byte [ ] part1 = getPart ( key1 ) ; byte [ ] part2 = getPart ( key2 ) ; byte [ ] challenge = new byte [ 16 ] ; challenge [ 0 ] = part1 [ 0 ] ; challenge [ 1 ] = part1 [ 1 ] ; challenge [ 2 ] = part1 [ 2 ] ; challenge [ 3 ] = part1 [ 3 ] ; challenge [ 4 ] = part2 [ 0 ] ; challenge [ 5 ] = part2 [ 1 ] ; challenge [ 6 ] = part2 [ 2 ] ; challenge [ 7 ] = part2 [ 3 ] ; challenge [ 8 ] = key3 [ 0 ] ; challenge [ 9 ] = key3 [ 1 ] ; challenge [ 10 ] = key3 [ 2 ] ; challenge [ 11 ] = key3 [ 3 ] ; challenge [ 12 ] = key3 [ 4 ] ; challenge [ 13 ] = key3 [ 5 ] ; challenge [ 14 ] = key3 [ 6 ] ; challenge [ 15 ] = key3 [ 7 ] ; MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } return md5 . digest ( challenge ) ; }
tr	H	private void stop ( ) { switch ( _current ) { case PAUSE : case PLAY : _index = - 1 ; _player . stop ( ) ; _current = Status . STOP ; _playPause . setIcon ( _playEnabled ) ; _playPause . removeActionListener ( _pause ) ; _playPause . addActionListener ( _play ) ; _seek . setString ( "00:00/00:00" ) ; break ; case STOP : break ; } }
tr	F	private void CheckLabActionPerformed ( java . awt . event . ActionEvent evt ) { if ( CheckLab . isSelected ( ) ) { CheckNombre . setEnabled ( false ) ; CheckTelefono . setEnabled ( false ) ; textBuscar . setEnabled ( true ) ; } else { CheckNombre . setEnabled ( true ) ; CheckTelefono . setEnabled ( true ) ; textBuscar . setEnabled ( false ) ; } }
tr	E	public List < Data > select ( byte [ ] ... keys ) throws DRUMSException { List < Data > result = new ArrayList < Data > ( ) ; IntObjectOpenHashMap < ArrayList < byte [ ] >> bucketKeyMapping = getBucketKeyMapping ( keys ) ; String filename ; for ( IntObjectCursor < ArrayList < byte [ ] >> entry : bucketKeyMapping ) { filename = gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) ; HeaderIndexFile < Data > indexFile = null ; try { indexFile = new HeaderIndexFile < Data > ( filename , HeaderIndexFile . AccessMode . READ_ONLY , gp . HEADER_FILE_LOCK_RETRY , gp ) ; ArrayList < byte [ ] > keyList = entry . value ; result . addAll ( searchForData ( indexFile , keyList . toArray ( new byte [ keyList . size ( ) ] [ ] ) ) ) ; } catch ( FileLockException ex ) { logger . error ( "Could not access the file {} within {} retries. The file seems to be locked." , filename , gp . HEADER_FILE_LOCK_RETRY ) ; throw new DRUMSException ( ex ) ; } catch ( IOException ex ) { logger . error ( "An exception occurred while trying to get objects from the file {}." , filename , ex ) ; throw new DRUMSException ( ex ) ; } finally { if ( indexFile != null ) { indexFile . close ( ) ; } } } return result ; }
tr	J	public int getCurrentPageIndex ( ) { return currentPageIndex ; }
tr	J	@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; User other = ( User ) obj ; if ( id == null ) { if ( other . id != null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; return true ; }
tr	F	int [ ] widenIntArray ( final int [ ] in , final int usedSize , final int needSize , final int clearTo ) { final int length = in . length ; if ( DO_CHECKS && length >= needSize ) { return in ; } if ( DO_STATS ) { incResizeInt ( ) ; } final int [ ] res = getIntArray ( getNewSize ( usedSize , needSize ) ) ; System . arraycopy ( in , 0 , res , 0 , usedSize ) ; putIntArray ( in , 0 , clearTo ) ; if ( DO_LOG_WIDEN_ARRAY ) { logInfo ( "widenIntArray[" + res . length + "]: usedSize=\t" + usedSize + "\tlength=\t" + length + "\tneeded length=\t" + needSize + "\tfrom=\t" + getCallerInfo ( className ) ) ; } return res ; }
tr	D	private void raiseEvent ( Object event ) { try { setChanged ( ) ; notifyObservers ( event ) ; } catch ( Exception e ) { Logger . getLogger ( getClass ( ) ) . error ( e . getMessage ( ) , e ) ; } }
tr	A	@ Override public Move getMove ( DraughtsState s ) { throw new UnsupportedOperationException ( "should never be called!!!" ) ; }
tr	G	public void setupButtons ( ) { side_hud_panel . removeAll ( ) ; if ( selected . size ( ) > 0 && selected . getFirst ( ) instanceof VillagerEntity ) { VillagerEntity tower = ( ( VillagerEntity ) selected . getFirst ( ) ) ; final JCheckBox build = new JCheckBox ( "Build: " + createCostString ( VillagerEntity . MAKE_TOWER_COST ) ) ; side_hud_panel . add ( build ) ; pack ( ) ; build . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { if ( build . isSelected ( ) ) { mode = BUILD_MODE ; } else { mode = NORMAL_MODE ; } } } ) ; } if ( selected . size ( ) > 0 && selected . getFirst ( ) instanceof TowerEntity ) { TowerEntity tower = ( ( TowerEntity ) selected . getFirst ( ) ) ; final JButton upgrade = new JButton ( "Upgrade: " + createCostString ( TowerEntity . UPGRADE_COST [ tower . level ] ) ) ; final JButton villager = new JButton ( "Make villager: " + createCostString ( TowerEntity . MAKE_VILLAGER_COST ) ) ; side_hud_panel . add ( upgrade ) ; side_hud_panel . add ( villager ) ; pack ( ) ; upgrade . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { TowerEntity tower = ( ( TowerEntity ) selected . getFirst ( ) ) ; if ( canAfford ( TowerEntity . UPGRADE_COST [ tower . level ] ) ) { if ( tower . upgrade ( ) ) { decrementResources ( TowerEntity . UPGRADE_COST [ tower . level - 1 ] ) ; upgrade . setText ( "Upgrade: " + createCostString ( TowerEntity . UPGRADE_COST [ tower . level ] ) ) ; } } } } ) ; villager . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { TowerEntity tower = ( ( TowerEntity ) selected . getFirst ( ) ) ; if ( canAfford ( TowerEntity . MAKE_VILLAGER_COST ) ) { fireGlobalEvent ( new AddEntity ( this , ADD_VILLAGER , ( int ) tower . point . x , ( int ) tower . point . y ) ) ; decrementResources ( TowerEntity . MAKE_VILLAGER_COST ) ; } } } ) ; } }
tr	C	private void initNullOkCheckbox ( ) { allowNullValsBtn = new Button ( dialog , SWT . CHECK ) ; allowNullValsBtn . setText ( "Allow NULL values" ) ; allowNullValsBtn . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent arg0 ) { nullValuesRatioSpinner . setEnabled ( allowNullValsBtn . getSelection ( ) ) ; } } ) ; allowNullValsBtn . setSelection ( fieldDef . isNullOk ( ) ) ; }
tr	G	public int getCalendar ( int field ) { return calendar . get ( field ) ; }
tr	E	void putDirtyByteArray ( final byte [ ] array ) { final int length = array . length ; if ( ( ( length & 1 ) == 0 ) && ( length <= MAX_DIRTY_BYTE_ARRAY_SIZE ) ) { getDirtyByteArrayCache ( length ) . putDirtyArray ( array , length ) ; } }
tr	B	public int getHeight ( ) { return height ; }
tr	H	public String getName ( ) { return name ; }
tr	A	public int hashCode ( ) { int prime = 3 ; int hash = prime * annotation . hashCode ( ) ; return hash ; }
tr	C	private void initNullOkRatioSpinner ( ) { Label l = new Label ( dialog , SWT . NONE ) ; l . setText ( "  (" ) ; nullValuesRatioSpinner = new Spinner ( dialog , SWT . BORDER ) ; nullValuesRatioSpinner . setMaximum ( 100 ) ; nullValuesRatioSpinner . setSelection ( fieldDef . getNullRatio ( ) ) ; nullValuesRatioSpinner . setEnabled ( fieldDef . isNullOk ( ) ) ; l = new Label ( dialog , SWT . NONE ) ; l . setText ( "% of rows)" ) ; l . setLayoutData ( "wrap" ) ; }
tr	G	private void refreshData ( ) { entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; }
tr	I	public int getFriendsCount ( ) { return friendsCount ; }
tr	I	public T pop ( ) { if ( size == 0 ) { throw new IllegalStateException ( "Array is empty." ) ; } -- size ; T item = items [ size ] ; items [ size ] = null ; return item ; }
tr	J	public static void testRandomDivisible ( int max , int divisor ) { System . out . println ( max + " " + divisor + " " + randomDivisible ( max , divisor ) ) ; }
tr	I	public PrintMode getPrintMode ( ) { return printMode ; }
tr	F	private void addVillager ( int x , int y ) { VillagerEntity entity = new VillagerEntity ( x , y , grid , this , resource_grid ) ; entity . addGradient ( avoid_edges ) ; entities . add ( entity ) ; }
tr	J	public void rightclick ( Point p , boolean ctrl ) { }
tr	F	protected void setDelimitadorEnvio ( String delimitadorEnvio ) { this . delimitadorEnvio = delimitadorEnvio ; }
tr	F	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	C	public void close ( ) { try { in . close ( ) ; } catch ( IOException ex ) { Logger . getLogger ( StreamedLinkSet . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	I	public void addInputVariable ( InputVariable inputVariable ) { this . inputVariables . add ( inputVariable ) ; }
tr	F	private void buscarButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( textBuscar . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Escriba lo que desee buscar." , "Campo de busqueda vacio" , WIDTH ) ; } else { if ( CheckNombre . isSelected ( ) ) { try { result = stmt . executeQuery ( "Select proyectofarmacia.proveedores.Id_proveedores  proyectofarmacia.proveedores.Nombre_proveedores  proyectofarmacia.proveedores.Telefono_proveedores  proyectofarmacia.proveedores.Laboratorio_pertenece from proveedores where Nombre_proveedores= '" + textBuscar . getText ( ) + "'" ) ; if ( result . next ( ) ) { DefaultTableModel modelo = ( DefaultTableModel ) jTable1 . getModel ( ) ; Object [ ] nuevo = { modelo . getRowCount ( ) , "" , "" } ; modelo . addRow ( nuevo ) ; int id = result . getInt ( "Id_proveedores" ) ; jTable1 . setValueAt ( id , 0 , 0 ) ; String nombre = result . getString ( "Nombre_proveedores" ) ; jTable1 . setValueAt ( nombre , 0 , 1 ) ; String telefono = result . getString ( "Telefono_proveedores" ) ; jTable1 . setValueAt ( telefono , 0 , 2 ) ; String lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , 0 , 3 ) ; for ( int i = 1 ; result . next ( ) ; i ++ ) { modelo . addRow ( nuevo ) ; id = result . getInt ( "Id_" ) ; jTable1 . setValueAt ( id , i , 0 ) ; nombre = result . getString ( "Nombre_medicamentos" ) ; jTable1 . setValueAt ( nombre , i , 1 ) ; telefono = result . getString ( "Telefono_medicamentos" ) ; jTable1 . setValueAt ( telefono , i , 2 ) ; lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , i , 3 ) ; } textBuscar . setText ( "" ) ; buscarButton . setEnabled ( false ) ; } else { int aviso = JOptionPane . showConfirmDialog ( this , "No existe proveedor con ese nombre. \n Desea agregarlo?" , "Busqueda sin exito" , JOptionPane . YES_NO_OPTION ) ; if ( aviso == JOptionPane . YES_OPTION ) { RegistroProveedores prov = new RegistroProveedores ( ) ; prov . mostrar ( ) ; } textBuscar . setText ( "" ) ; textBuscar . setText ( "" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( this , "Error al tratar de conectar la base  verifica tus datos de conexion" ) ; } } if ( CheckLab . isSelected ( ) ) { try { result = stmt . executeQuery ( "Select proyectofarmacia.proveedores.Id_proveedores  proyectofarmacia.proveedores.Nombre_proveedores  proyectofarmacia.proveedores.Telefono_proveedores  proyectofarmacia.proveedores.Laboratorio_pertenece from proveedores where Laboratorio_pertenece= '" + textBuscar . getText ( ) + "'" ) ; if ( result . next ( ) ) { DefaultTableModel modelo = ( DefaultTableModel ) jTable1 . getModel ( ) ; Object [ ] nuevo = { modelo . getRowCount ( ) , "" , "" } ; modelo . addRow ( nuevo ) ; int id = result . getInt ( "Id_proveedores" ) ; jTable1 . setValueAt ( id , 0 , 0 ) ; String nombre = result . getString ( "Nombre_proveedores" ) ; jTable1 . setValueAt ( nombre , 0 , 1 ) ; String telefono = result . getString ( "Telefono_proveedores" ) ; jTable1 . setValueAt ( telefono , 0 , 2 ) ; String lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , 0 , 3 ) ; for ( int i = 1 ; result . next ( ) ; i ++ ) { modelo . addRow ( nuevo ) ; id = result . getInt ( "Id_" ) ; jTable1 . setValueAt ( id , i , 0 ) ; nombre = result . getString ( "Nombre_medicamentos" ) ; jTable1 . setValueAt ( nombre , i , 1 ) ; telefono = result . getString ( "Telefono_medicamentos" ) ; jTable1 . setValueAt ( telefono , i , 2 ) ; lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , i , 3 ) ; } textBuscar . setText ( "" ) ; buscarButton . setEnabled ( false ) ; } else { int aviso = JOptionPane . showConfirmDialog ( this , "No existe proveedor perteneciente a ese laboratorio. \n Desea agregarlo?" , "Busqueda sin exito" , JOptionPane . YES_NO_OPTION ) ; if ( aviso == JOptionPane . YES_OPTION ) { RegistroProveedores prov = new RegistroProveedores ( ) ; prov . mostrar ( ) ; } textBuscar . setText ( "" ) ; textBuscar . setText ( "" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( this , "Error al tratar de conectar la base  verifica tus datos de conexion" ) ; } } if ( CheckTelefono . isSelected ( ) ) { try { result = stmt . executeQuery ( "Select proyectofarmacia.proveedores.Id_proveedores  proyectofarmacia.proveedores.Nombre_proveedores  proyectofarmacia.proveedores.Telefono_proveedores  proyectofarmacia.proveedores.Laboratorio_pertenece from proveedores where Telefono_proveedores= '" + textBuscar . getText ( ) + "'" ) ; if ( result . next ( ) ) { DefaultTableModel modelo = ( DefaultTableModel ) jTable1 . getModel ( ) ; Object [ ] nuevo = { modelo . getRowCount ( ) , "" , "" } ; modelo . addRow ( nuevo ) ; int id = result . getInt ( "Id_proveedores" ) ; jTable1 . setValueAt ( id , 0 , 0 ) ; String nombre = result . getString ( "Nombre_proveedores" ) ; jTable1 . setValueAt ( nombre , 0 , 1 ) ; String telefono = result . getString ( "Telefono_proveedores" ) ; jTable1 . setValueAt ( telefono , 0 , 2 ) ; String lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , 0 , 3 ) ; for ( int i = 1 ; result . next ( ) ; i ++ ) { modelo . addRow ( nuevo ) ; id = result . getInt ( "Id_" ) ; jTable1 . setValueAt ( id , i , 0 ) ; nombre = result . getString ( "Nombre_medicamentos" ) ; jTable1 . setValueAt ( nombre , i , 1 ) ; telefono = result . getString ( "Telefono_medicamentos" ) ; jTable1 . setValueAt ( telefono , i , 2 ) ; lab = result . getString ( "Laboratorio_pertenece" ) ; jTable1 . setValueAt ( lab , i , 3 ) ; } textBuscar . setText ( "" ) ; buscarButton . setEnabled ( false ) ; } else { int aviso = JOptionPane . showConfirmDialog ( this , "No exsite proveedor con ese telefono. \n Desea agregarlo?" , "Busqueda sin exito" , JOptionPane . YES_NO_OPTION ) ; if ( aviso == JOptionPane . YES_OPTION ) { RegistroProveedores prov = new RegistroProveedores ( ) ; prov . mostrar ( ) ; } textBuscar . setText ( "" ) ; textBuscar . setText ( "" ) ; } } catch ( SQLException ex ) { JOptionPane . showMessageDialog ( this , "Error al tratar de conectar la base  verifica tus datos de conexion" ) ; } } } }
tr	H	public static boolean randomToss ( double bias ) { if ( random . nextDouble ( ) <= bias ) { return true ; } else { return false ; } }
tr	F	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { saveData ( ) ; refreshData ( ) ; saveButton . setEnabled ( false ) ; deleteButton . setEnabled ( false ) ; }
tr	I	public String tableName ( ) { return tableName ; }
tr	J	ArrayCachesHolder ( ) { intArrayCaches = new IntArrayCache [ BUCKETS ] ; dirtyIntArrayCaches = new IntArrayCache [ BUCKETS ] ; dirtyFloatArrayCaches = new FloatArrayCache [ BUCKETS ] ; dirtyByteArrayCaches = new ByteArrayCache [ BUCKETS ] ; for ( int i = 0 ; i < BUCKETS ; i ++ ) { intArrayCaches [ i ] = new IntArrayCache ( ARRAY_SIZES [ i ] ) ; dirtyIntArrayCaches [ i ] = new IntArrayCache ( ARRAY_SIZES [ i ] ) ; dirtyFloatArrayCaches [ i ] = new FloatArrayCache ( ARRAY_SIZES [ i ] ) ; dirtyByteArrayCaches [ i ] = new ByteArrayCache ( DIRTY_BYTE_ARRAY_SIZES [ i ] ) ; } }
tr	H	private int calcPages ( int width , int height ) { int w = width ; int h = height - topBox ; int boxW = ( int ) ( boxWInches * anInch ) ; int boxH = ( int ) ( boxHInches * anInch ) ; double boxesAcross = w / boxW ; double boxesDown = h / boxH ; int recordCount = CharApp . getInstance ( ) . getRecord ( ) . getRecords ( randomOrder ) . size ( ) ; int pages = 0 ; if ( printMode . getStyle ( ) == PrintMode . STYLE_CRAM ) { pages = ( int ) Math . ceil ( recordCount / ( boxesDown * ( boxesAcross - ( boxesAcross % 2 ) ) / 2 ) ) ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ONE_PER_LINE ) { pages = ( int ) Math . ceil ( recordCount / boxesDown ) ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_ALTERNATING_LINES ) { pages = ( int ) Math . ceil ( recordCount / ( boxesDown / 2 ) ) ; } else if ( printMode . getStyle ( ) == PrintMode . STYLE_READING ) { pages = ( int ) Math . ceil ( recordCount / ( boxesDown * boxesAcross ) ) ; } return pages ; }
tr	G	@ Override public void terminateLastTurn ( ) { this . currentTurn . terminatedCorrect = true ; }
tr	H	public Set < Integer > getRelatedElementNumbersForElementAtPosition ( int rowNumber , int columnNumber ) { return getRelatedElementNumbersForElementWithNumber ( getElementNumber ( rowNumber , columnNumber ) ) ; }
tr	D	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { txtCedula = new javax . swing . JTextField ( ) ; txtNombre = new javax . swing . JTextField ( ) ; txtApellido = new javax . swing . JTextField ( ) ; btnGuardar = new javax . swing . JToggleButton ( ) ; btnNuevo = new javax . swing . JToggleButton ( ) ; btnModificar = new javax . swing . JToggleButton ( ) ; jToggleButton3 = new javax . swing . JToggleButton ( ) ; jScrollPane1 = new javax . swing . JScrollPane ( ) ; tablaCliente = new javax . swing . JTable ( ) ; txtBuscar = new javax . swing . JTextField ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; jToggleButton4 = new javax . swing . JToggleButton ( ) ; sexo = new javax . swing . JComboBox ( ) ; municipio = new javax . swing . JComboBox ( ) ; txtDireccion = new javax . swing . JTextField ( ) ; txtTelefono = new javax . swing . JTextField ( ) ; txtEmail = new javax . swing . JTextField ( ) ; txtCelular = new javax . swing . JTextField ( ) ; fecha = new com . toedter . calendar . JDateChooser ( ) ; jLabel2 = new javax . swing . JLabel ( ) ; jLabel3 = new javax . swing . JLabel ( ) ; jLabel4 = new javax . swing . JLabel ( ) ; jLabel5 = new javax . swing . JLabel ( ) ; jLabel6 = new javax . swing . JLabel ( ) ; jLabel7 = new javax . swing . JLabel ( ) ; jLabel8 = new javax . swing . JLabel ( ) ; jLabel9 = new javax . swing . JLabel ( ) ; jLabel10 = new javax . swing . JLabel ( ) ; jLabel11 = new javax . swing . JLabel ( ) ; jLabel12 = new javax . swing . JLabel ( ) ; jLabel13 = new javax . swing . JLabel ( ) ; txtHijos = new javax . swing . JTextField ( ) ; jLabel14 = new javax . swing . JLabel ( ) ; civil = new javax . swing . JComboBox ( ) ; btnEliminar = new javax . swing . JButton ( ) ; jButton2 = new javax . swing . JButton ( ) ; btnActualizar = new javax . swing . JButton ( ) ; jToggleButton2 = new javax . swing . JToggleButton ( ) ; jToggleButton5 = new javax . swing . JToggleButton ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; setBackground ( new java . awt . Color ( 255 , 255 , 255 ) ) ; getContentPane ( ) . setLayout ( new org . netbeans . lib . awtextra . AbsoluteLayout ( ) ) ; txtCedula . setText ( "Cedula" ) ; txtCedula . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { txtCedulaActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( txtCedula , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 204 , 73 , 141 , - 1 ) ) ; txtNombre . setText ( "Nombre" ) ; txtNombre . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { txtNombreActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( txtNombre , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 204 , 102 , 141 , - 1 ) ) ; txtApellido . setText ( "Apellido" ) ; txtApellido . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { txtApellidoActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( txtApellido , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 204 , 128 , 141 , - 1 ) ) ; btnGuardar . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/Guardar.png" ) ) ) ; btnGuardar . setToolTipText ( "Guardar" ) ; btnGuardar . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnGuardarActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( btnGuardar , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 90 , 280 , 60 , - 1 ) ) ; btnNuevo . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/nuevo.png" ) ) ) ; btnNuevo . setToolTipText ( "Nuevo" ) ; btnNuevo . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnNuevoActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( btnNuevo , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 30 , 280 , 50 , 60 ) ) ; btnModificar . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/editar.png" ) ) ) ; btnModificar . setToolTipText ( "Modificar" ) ; btnModificar . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnModificarActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( btnModificar , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 160 , 280 , 60 , - 1 ) ) ; jToggleButton3 . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/cancelar.png" ) ) ) ; jToggleButton3 . setToolTipText ( "Cancelar" ) ; jToggleButton3 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jToggleButton3ActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( jToggleButton3 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 370 , 280 , 60 , - 1 ) ) ; tablaCliente . setModel ( new javax . swing . table . DefaultTableModel ( new Object [ ] [ ] { } , new String [ ] { } ) ) ; jScrollPane1 . setViewportView ( tablaCliente ) ; getContentPane ( ) . add ( jScrollPane1 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 0 , 351 , 950 , 270 ) ) ; txtBuscar . setToolTipText ( "Digite el nombre o apellido a buscar" ) ; txtBuscar . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { txtBuscarActionPerformed ( evt ) ; } } ) ; txtBuscar . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyReleased ( java . awt . event . KeyEvent evt ) { txtBuscarKeyReleased ( evt ) ; } } ) ; getContentPane ( ) . add ( txtBuscar , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 570 , 290 , 100 , 30 ) ) ; jLabel1 . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/Buscar.png" ) ) ) ; getContentPane ( ) . add ( jLabel1 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 510 , 280 , 48 , - 1 ) ) ; jToggleButton4 . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/reporte.png" ) ) ) ; jToggleButton4 . setToolTipText ( "Informe" ) ; jToggleButton4 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jToggleButton4ActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( jToggleButton4 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 440 , 280 , 60 , - 1 ) ) ; sexo . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "Masculino" , "Femenino" } ) ) ; sexo . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { sexoActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( sexo , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 204 , 186 , 141 , - 1 ) ) ; municipio . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "Bucaramanga" , "Florida" , "Giron" , "Piedecuesta" , "Santaf\u00E9 de Bogot\u00E1" , "Puerto Nari\u00F1o" , "Leticia" , "Medell\u00EDn" , "Abejorral" , "Abriaqui" , "Alejandr\u00EDa" , "Amag\u00E1" , "Amalfi" , "Andes" , "Angel\u00F3polis" , "Angostura" , "Anor\u00ED" , "Antioquia" , "Anz\u00E1" , "Apartad\u00F3" , "Arboletes" , "Argelia" , "Armenia" , "Barbosa" , "Belmira" , "Bello" , "Betania" , "Betulia" , "Bol\u00EDvar" , "Brise\u00F1o" , "Buritic\u00E1" , "C\u00E1ceres" , "Caicedo" , "Caldas" , "Campamento" , "Ca\u00F1asgordas" , "Caracol\u00ED" , "Caramanta" , "Carepa" , "Carmen de Viboral" , "Carolina" , "Caucasia" , "Chigorod\u00F3" , "Cisneros" , "Cocorn\u00E1" , "Concepci\u00F3n" , "Concordia" , "Copacabana" , "Dabeiba" , "Don Mat\u00EDas" , "Eb\u00E9jico" , "El Bagre" , "Entrerr\u00EDos" , "Envigado" , "Fredonia" , "Frontino" , "Giraldo" , "Girardota" , "G\u00F3mez Plata" , "Granada" , "Guadalupe" , "Guarne" , "Guatap\u00E9" , "Heliconia" , "Hispania" , "Itag\u00FC\u00ED" , "Ituango" , "Jard\u00EDn" , "Jeric\u00F3" , "La Estrella" , "La Pintada" , "La Uni\u00F3n" , "Liborina" , "Maceo" , "Marinilla" , "Montebello" , "Murind\u00F3" , "Mutat\u00E1" , "Nari\u00F1o" , "Necocl\u00ED" , "Nech\u00ED" , "Olaya" , "Pe\u00F1ol" , "Peque" , "Pueblorrico" , "Puerto Berr\u00EDo" , "Puerto Nare" , "Puerto Triunfo" , "Remedios" , "Retiro" , "Rionegro" , "Sabanalarga" , "Sabaneta" , "Salgar" , "San Andr\u00E9s" , "San Carlos" , "San francisco" , "San Jer\u00F3nimo" , "San Jos\u00E9 de Monta\u00F1a" , "San Juan de Urab\u00E1" , "San Luis" , "San Pedro" , "San Pedro de Urab\u00E1" , "San Rafael" , "San Roque" , "San Vicente" , "Santa B\u00E1rbara" , "Santa Rosa de Osos" , "Santo Domingo" , "Santuario" , "Segovia" , "Sons\u00F3n" , "Sopetr\u00E1n" , "T\u00E1mesis" , "Taraz\u00E1" , "Tarso" , "Titirib\u00ED" , "Toledo" , "Turbo" , "Uramita" , "Urrao" , "Valdivia" , "Valpara\u00EDso" , "Vegach\u00ED" , "Venecia" , "Vig\u00EDa del Fuerte" , "Yal\u00ED" , "Yarumal" , "Yolomb\u00F3" , "Yond\u00F3 (Casabe)" , "Zaragoza 895" , "Arauca" , "Arauquita" , "Cravo Norte" , "Fortul" , "Puerto Rond\u00F3n" , "Fortul" , "Puerto Rond\u00F3n" , "Saravena" , "Tame" , "Barranquilla" , "Baranoa" , "Campo de la Cruz" , "Candelaria" , "Galapa" , "Juan de Acosta" , "Luruaco" , "Malambo" , "Manat\u00ED" , "Palmar de Varela" , "Pioj\u00F3" , "Polonuevo" , "Ponedera" , "Puerto Colombia" , "Repel\u00F3n" , "Sabanagrande" , "Sabanalarga" , "Santa Luc\u00EDa" , "Santo Tom\u00E1s" , "Soledad" , "Su\u00E1n" , "Tubar\u00E1" , "Usiacur\u00ED" , "Cartagena" , "Ach\u00ED" , "Altos del Rosario" , "Arenal" , "Arjona" , "Arroyohondo" , "Barranco de Loba" , "Calamar" , "Cantagallo" , "Cicuto" , "C\u00F3rdoba" , "Clemencia" , "El Carmen de Bol\u00EDvar" , "El Guamo" , "El Pe\u00F1\u00F3n" , "Hatillo de Loba" , "Magangue" , "Mahates" , "Margarita" , "Mar\u00EDa la Baja" , "Montecristo" , "Momp\u00F3s" , "Morales" , "Pinillos" , "Regidor" , "R\u00EDo Viejo" , "San Crist\u00F3bal" , "San Estanislao" , "San Fernando" , "San Jacinto" , "San Jacinto del Cauca" , "San Juan Nepomuceno" , "San Mart\u00EDn de Loba" , "San Pablo" , "Santa Catalina" , "Santa Rosa" , "Santa Rosa del Sur" , "Simit\u00ED" , "Soplaviento" , "Talaigua Nuevo" , "Tiquisio (Puerto Rico)" , "Turbaco" , "Turban\u00E1" , "Villanueva" , "Zambrano" , "Boyac\u00E1 15" , "Tunja" , "Almeida" , "Aquitania" , "Arcabuco" , "Bel\u00E9n" , "Berbeo" , "Beteitiva" , "Boavita" , "Boyac\u00E1" , "Brise\u00F1o" , "Buenavista" , "Busbanz\u00E1" , "Caldas" , "Campohermoso" , "Cerinza" , "Chinavita" , "Chiquinquir\u00E1" , "Chiscas" , "Chita" , "Chitaranque" , "Chivat\u00E1" , "Ci\u00E9naga" , "C\u00F3mbita" , "Coper" , "Corrales" , "Covarachia" , "Cubar" , "Cucaita" , "Cuitiva" , "Ch\u00EDquiza" , "Chivor" , "Duitama" , "El Cocuy" , "El Espino" , "Firavitoba" , "Floresta" , "Gachantiv\u00E1" , "G\u00E1meza" , "Garagoa" , "Guacamayas" , "Guateque" , "Guayat\u00E1" , "Guic\u00E1n" , "Iza" , "Jenesano" , "Jeric\u00F3" , "Labranzagrande" , "La Capilla" , "La Victoria" , "La Ubita" , "Villa de Leyva" , "Macanal" , "Marip\u00ED" , "Miraflores" , "Mongua" , "Mongu\u00ED" , "Moniquir\u00E1" , "Motavita" , "Muzo" , "Nobsa" , "Nuevo Col\u00F3n" , "Oicat\u00E1" , "Otanche" , "Pachavita" , "P\u00E1ez" , "Paipa" , "Pajarito" , "Panqueba" , "Pauna" , "Paya" , "Paz de R\u00EDo" , "Pesca" , "Pisva" , "Puerto Boyac\u00E1" , "Qu\u00EDpama" , "Ramiquir\u00ED" , "R\u00E1quira" , "Rond\u00F3n" , "Saboy\u00E1" , "S\u00E1chica" , "Samac\u00E1" , "San Eduardo" , "San Jos\u00E9 de Pare" , "San Luis de Gaceno" , "San Mateo" , "San Miguel de Sema" , "San Pablo de Borbur" , "Santana" , "Santa Mar\u00EDa" , "Santa Rosa de Viterbo" , "Santa Sof\u00EDa" , "Sativanorte" , "Sativasur" , "Siachoque" , "Soat\u00E1" , "Socot\u00E1" , "Socha" , "Sogamoso" , "Somondoco" , "Sora" , "Sotaquir\u00E1" , "Sorac\u00E1" , "Susac\u00F3n" , "Sutamarch\u00E1n" , "Sutatenza" , "Tasco" , "Tenza" , "Tiban\u00E1" , "Tibasosa" , "Tinjac\u00E1" , "Tipacoque" , "Toca" , "Togu\u00ED" , "T\u00F3paga" , "Tota" , "Tunungua" , "Turmequ\u00E9" , "Tuta" , "Tutaz\u00E1" , "\u00DAmbita" , "Ventaquemada" , "Viracach\u00E1" , "Zetaquir\u00E1" , "Manizales" , "Aguadas" , "Anserma" , "Aranzazu" , "Belalc\u00E1zar" , "Chinchina" , "Filadelfia" , "La Dorada" , "La Merced" , "Manzanares" , "Marmato" , "Marquetalia" , "Marulanda" , "Neira" , "P\u00E1cora" , "Palestina" , "Pensilvania" , "Riosucio" , "Risaralda" , "Salamina" , "Saman\u00E1" , "San Jos\u00E9" , "Sup\u00EDa" , "Victoria" , "Villamar\u00EDa" , "Viterbo" , "Caquet\u00E1 18 Florencia" , "Albania" , "Bel\u00E9n de los Andaqu\u00EDes" , "Cartagena del Chair\u00E1" , "Curillo" , "El Doncello" , "El Paujil" , "La Monta\u00F1ita" , "Mil\u00E1n" , "Morelia" , "Puerto Rico" , "San Jos\u00E9 del Fragua" , "San Vicente del Cagu\u00E1n" , "Solano" , "Solita" , "Valpara\u00EDso" , "Yopal" , "Aguazul" , "Chameza" , "Hato Corozal" , "La Salina" , "Man\u00ED" , "Monterrey" , "Nunch\u00EDa" , "Orocu\u00E9" , "Paz de Ariporo" , "Pore" , "Recetor" , "Sabalarga" , "S\u00E1cama" , "San Luis de Palenque" , "T\u00E1mara" , "Tauramena" , "Trinidad" , "Villanueva" , "Popay\u00E1n" , "Almaguer" , "Argelia" , "Balboa" , "Bol\u00EDvar" , "Buenos Aires" , "Cajib\u00EDo" , "Caldono" , "Caloto" , "Corinto" , "El Tambo" , "Florencia" , "Guapi" , "Inz\u00E1" , "Jambal\u00F3" , "La Sierra" , "La Vega" , "L\u00F3pez (Micay)" , "Mercaderes" , "Miranda" , "Morales" , "Padilla" , "P\u00E1ez (Belalcazar)" , "Pat\u00EDa (El Bordo)" , "Piamonte" , "Piendam\u00F3" , "Puerto Tejada" , "Purac\u00E9 (Coconuco)" , "Rosas" , "San Sebasti\u00E1n" , "Santander de Quilichao" , "Santa Rosa" , "Silvia" , "Sotar\u00E1 (Paispamba)" , "Su\u00E1rez" , "Timb\u00EDo" , "Timbiqu\u00ED" , "Torib\u00EDo" , "Totoro" , "Valledupar" , "Aguachica" , "Agust\u00EDn Codazzi" , "Astrea" , "Becerril" , "Bosconia" , "Chimichagua" , "Chiriguan\u00E1" , "Curuman\u00ED" , "El Copey" , "El Paso" , "Gamarra" , "Gonz\u00E1lez" , "La Gloria" , "La Jagua de Ibirico" , "Manaure Balc\u00F3n Cesar" , "Pailitas" , "Pelaya" , "Pueblo Bello" , "R\u00EDo de Oro" , "La Paz (Robles)" , "San Alberto" , "San Diego" , "San Mart\u00EDn" , "Tamalameque" , "Monter\u00EDa" , "Ayapel" , "Buenavista" , "Canalete" , "Ceret\u00E9" , "Chima" , "Chin\u00FA" , "Ci\u00E9naga de Oro" , "Cotorra" , "La Apartada (Frontera)" , "Lorica" , "Los C\u00F3rdobas" , "Momil" , "Montel\u00EDbano" , "Monitos" , "Planeta Rica" , "Pueblo Nuevo" , "Puerto Escondido" , "Puerto Libertador" , "Pur\u00EDsima" , "Sahag\u00FAn" , "San Andr\u00E9s Sotavento" , "San Antero" , "San Bernardo del Viento" , "San Carlos" , "San Pelayo" , "Tierralta" , "Valencia" , "Agua de Dios" , "Alb\u00E1n" , "Anapoima" , "Anolaima" , "Arbel\u00E1ez" , "Beltr\u00E1n" , "Bituima" , "Bojac\u00E1" , "Cabrera" , "Cachipay" , "Cajic\u00E1" , "Caparrap\u00ED" , "C\u00E1queza" , "Carmen de Carupa" , "Chaguan\u00ED" , "Ch\u00EDa" , "Chipaque" , "Choach\u00ED" , "Chocont\u00E1" , "Cogua" , "Cota" , "Cucunub\u00E1" , "El Colegio" , "El Pe\u00F1\u00F3n" , "El Rosal" , "Facatativ\u00E1" , "F\u00F3meque" , "Fosca " , "Funza" , "F\u00FAquene" , "Fusagasug\u00E1" , "Gachal\u00E1" , "Gachancip\u00E1" , "Gachet\u00E1" , "Gama" , "Girardot" , "Granada" , "Guachet\u00E1" , "Guaduas" , "Guasca" , "Guataqu\u00ED" , "Guatavita" , "Guayabal de S\u00EDquima" , "Guayabetal" , "Guti\u00E9rrez" , "Jerusal\u00E9n" , "Jun\u00EDn" , "La Calera" , "La Mesa" , "La Palma" , "La Pe\u00F1a" , "La Vega" , "Lenguazaque" , "Machet\u00E1" , "Madrid" , "Manta" , "Medina" , "Mosquera" , "Nari\u00F1o" , "Nemoc\u00F3n" , "Nilo" , "Nimaima" , "Nocaima" , "Venecia (Ospina P\u00E9rez)" , "Pacho" , "Paime" , "Pandi" , "Paratebueno" , "Pasca" , "Puerto Salgar" , "Pul\u00ED" , "Quebradanegra" , "Quetame" , "Quipile" , "Rafael" , "Ricaurte" , "San Antonio de Tequendama" , "San Bernardo" , "San Cayetano" , "San Francisco" , "San Juan de Rioseco" , "Sasaima" , "Sesquil\u00E9" , "Sibate" , "Silvania" , "Simijaca" , "Soacha" , "Sop\u00F3" , "Subachoque" , "Suesca" , "Supat\u00E1" , "Susa" , "Sutatausa" , "Tabio" , "Tausa" , "Tena" , "Tenjo" , "Tibacuy" , "Tibirit\u00E1" , "Tocaima" , "Tocancip\u00E1" , "Topaip\u00ED" , "Ubal\u00E1" , "Ubaque" , "Ubat\u00E9" , "Une" , "\u00DAtica" , "Vergara" , "Vian\u00ED" , "Villag\u00F3mez" , "Villapinz\u00F3n" , "Villeta" , "Viot\u00E1" , "Yacop\u00ED" , "Zipac\u00F3n" , "Zipaquir\u00E1" , "Quibd\u00F3" , "Acand\u00ED" , "Alto Baud\u00F3 (Pie de Pato)" , "Atrato (Yuto)" , "Bagad\u00F3" , "Bah\u00EDa Solano (M\u00FAtis)" , "Bajo Baud\u00F3 (Pizarro)" , "Bojay\u00E1 (Bellavista)" , "Cant\u00F3n de San Pablo" , "Condoto" , "El Carmen" , "El Litoral de San Juan" , "Itsmina" , "Jurad\u00F3" , "Llor\u00F3" , "N\u00F3vita" , "Nuqu\u00ED" , "Riosucio" , "San Jos\u00E9 del Palmar" , "Sip\u00ED" , "Tad\u00F3" , "Ungu\u00EDa" , "In\u00EDrida" , "San Jos\u00E9 del Guaviare" , "Calamar" , "El Retorno" , "Miraflores" , "Neiva" , "Acevedo" , "Agrado" , "Aipe" , "Algeciras" , "Altamira" , "Baraya" , "Campoalegre" , "Colombia" , "El\u00EDas" , "Garz\u00F3n" , "Gigante" , "Guadalupe" , "Hobo" , "Iquira" , "Isnos" , "La Argentina" , "La Plata" , "N\u00E1taga" , "Oporapa" , "Paicol" , "Palermo" , "Palestina" , "Pital" , "Pitalito" , "Rivera" , "Saladoblanco" , "San Agust\u00EDn" , "Santa Mar\u00EDa" , "Suaz\u00E1" , "Tarqui" , "Tesalia" , "Tello" , "Teruel" , "Timan\u00E1" , "Villavieja" , "Yaguar\u00E1" , "Riohacha" , "Barrancas" , "Dibulla" , "Distracci\u00F3n" , "El Molino" , "Fonseca" , "Hatonuevo" , "Maicao" , "Manaure" , "San Juan del Cesar" , "Urib\u00EDa" , "Urumita" , "Villanueva" , "Santa Marta" , "Aracataca" , "Ariguan\u00ED (El Dif\u00EDcil)" , "Cerro San Antonio" , "Chivolo" , "Ci\u00E9naga" , "El Banco" , "El Pi\u00F1\u00F3n" , "El Ret\u00E9n" , "Fundaci\u00F3n" , "Guamal" , "Pedraza" , "Piji\u00F1o del Carmen" , "Pivijay" , "Plato" , "Publoviejo" , "Remolino" , "Salamina" , "San Sebasti\u00E1n de Buuenavista" , "San Zen\u00F3n" , "Santa Ana" , "Sitionuevo" , "Tenerife" , "Meta 50 Villavicencio" , "Acacias" , "Barranca de Up\u00EDa" , "Cabuyaro" , "Castilla la Nueva" , "Cubarral" , "Cumaral" , "El Calvario" , "El Castillo" , "El Dorado" , "Fuente de Oro" , "Granada" , "Guamal" , "Mapirip\u00E1n" , "Mesetas" , "La Macarena" , "La Uribe" , "Lejan\u00EDas" , "Puerto Concordia" , "Puerto Gait\u00E1n" , "Puerto L\u00F3pez" , "Puerto Lleras" , "Puerto Rico" , "Restrepo" , "San Carlos de Guaroa" , "San Juan de Arama" , "San Juanito" , "San Mart\u00EDn" , "Vistahermosa" , "Pasto" , "Alb\u00E1n (San Jos\u00E9)" , "Aldana" , "Ancuy\u00E1" , "Arboleda (Berruecos)" , "Barbacoas" , "Bel\u00E9n" , "Buesaco" , "Col\u00F3n (G\u00E9nova)" , "Consac\u00E1" , "Contadero" , "C\u00F3rdoba" , "Cuaspud (Carlosama)" , "Cumbal" , "Cumbitar\u00E1" , "Chachag\u00FCi" , "El Charco" , "El Rosario" , "El Tabl\u00F3n" , "El Tambo" , "Funes" , "Guachucal" , "Guaitarilla" , "Gualmat\u00E1n" , "Iles" , "Im\u00FAes" , "Ipiales" , "La Cruz" , "La Florida" , "La Llanada" , "La Tola" , "La Uni\u00F3n" , "Leiva" , "Linares" , "Los Andes (Sotomayor)" , "Mag\u00FC\u00ED (Pay\u00E1n)" , "Mallama (Piedrancha)" , "Mosquera" , "Olaya" , "Ospina" , "Francisco Pizarro" , "Policarpa" , "Potos\u00ED" , "Providencia" , "Puerres" , "Pupiales" , "Ricaurte" , "Roberto Pay\u00E1n (San Jos\u00E9)" , "Samaniego" , "Sandon\u00E1" , "San Bernardo" , "San Lorenzo" , "San Pablo" , "San Pedro de Cartago" , "Santa B\u00E1rbara (Iscuand\u00E9)" , "Santa Cruz (Guach\u00E1vez)" , "Sapuy\u00E9s" , "Taminango" , "Tangua" , "Tumaco" , "T\u00FAquerres" , "Yacuanquer" , "C\u00FAcuta" , "Abrego" , "Arboledas" , "Bochalema" , "Bucarasica" , "C\u00E1cota" , "C\u00E1chira" , "Chin\u00E1cota" , "Chitag\u00E1" , "Convenci\u00F3n" , "Cucutilla" , "Durania" , "El Carmen" , "El Tarra" , "El Zulia" , "Gramalote" , "Hacar\u00ED" , "Herr\u00E1n" , "Labateca" , "La Esperanza" , "La Playa" , "Los Patios" , "Lourdes" , "Mutiscua" , "Oca\u00F1a" , "Pamplona" , "Pamplonita" , "Puerto Santander" , "Ragonvalia" , "Salazar" , "San Calixto" , "San Cayetano" , "Santiago" , "Sardinata" , "Silos" , "Teorama" , "Tib\u00FA" , "Toledo" , "Villacaro" , "Villa del Rosario" , "Mocoa" , "Col\u00F3n" , "Orito" , "Puerto As\u00EDs" , "Puerto Caicedo" , "Puerto Guzm\u00E1n" , "Puerto Legu\u00EDzamo" , "Sibundoy" , "San Francisco" , "San Miguel" , "Santiago" , "Villa Gamuez (La Hormiga)" , "Villa Garz\u00F3n" , "Quind\u00EDo 63 Armenia" , "Buenavista" , "Calarc\u00E1" , "Circasia" , "C\u00F3rdoba" , "Filandia" , "G\u00E9nova" , "La Tebaida" , "Montenegro" , "Pijao" , "Quimbaya" , "Salento" , "Pereira" , "Ap\u00EDa" , "Balboa" , "Bel\u00E9n de Umbr\u00EDa" , "Dos Quebradas" , "Gu\u00E1tica" , "La Celia" , "La Virginia" , "Marsella" , "Mistrat\u00F3" , "Pueblo Rico" , "Quinchia" , "Santa Rosa de Cabal" , "Santuario" , "San Andr\u00E9s 88\tSan Andr\u00E9s" , "Providencia" , "Bucaramanga" , "Aguada" , "Albania" , "Aratoca" , "Barbosa" , "Barichara" , "Barrancabermeja" , "Betulia" , "Bol\u00EDvar" , "Cabrera" , "California" , "Capitanejo" , "Carcas\u00ED" , "Cepit\u00E1" , "Cerrito" , "Charal\u00E1" , "Charta" , "Chima" , "Chipat\u00E1" , "Cimitarra" , "Concepci\u00F3n" , "Confines" , "Contrataci\u00F3n" , "Coromoro" , "Curit\u00ED" , "El Carmen" , "El Guacamayo" , "El Pe\u00F1\u00F3n" , "El Play\u00F3n" , "Encino" , "Enciso" , "Flori\u00E1n" , "Floridablanca" , "Gal\u00E1n" , "G\u00E1mbita" , "Gir\u00F3n" , "Guaca" , "Guadalupe" , "Guapot\u00E1" , "Guavata" , "Guepsa" , "Hato" , "Jes\u00FAs Mar\u00EDa" , "Jord\u00E1n" , "La Belleza" , "Land\u00E1zuri" , "La Paz" , "Lebrija" , "Los Santos" , "Macaravita" , "M\u00E1laga" , "Matanza" , "Mogotes" , "Molagavita" , "Ocamonte" , "Oiba" , "Onz\u00E1ga" , "Palmar" , "Palmas del Socorro" , "P\u00E1ramo" , "Pie de Cuesta" , "Pinchote" , "Puente Nacional" , "Puerto Parra" , "Puerto Wilches" , "Rionegro" , "Sabana de Torres" , "San Andr\u00E9s" , "San Benito" , "San Gil" , "San Joaqu\u00EDn" , "San Jos\u00E9 de Miranda" , "San Miguel" , "San Vicente de Chucur\u00ED" , "Santa B\u00E1rbara" , "Santa Helena del Op\u00F3n" , "Simacota" , "Socorro" , "Suaita" , "Sucre" , "Surat\u00E1" , "Tona" , "Valle de San Jos\u00E9" , "V\u00E9lez" , "Vetas" , "Villanueva" , "Zapatoca" , "Sincelejo" , "Buenavista" , "Caimito" , "Coloso (Ricaurte)" , "Corozal" , "Chal\u00E1n" , "Galeras (Nueva Granada)" , "Guarand\u00E1" , "La Uni\u00F3n" , "Los Palmitos" , "Majagual" , "Morroa" , "Ovejas" , "Palmito" , "Sampu\u00E9s" , "San Benito Abad" , "San Juan de Betulia" , "San Marcos" , "San Onofre" , "San Pedro" , "Sinc\u00E9" , "Sucre" , "Tol\u00FA" , "Toluviejo" , "Ibagu\u00E9" , "Alpujarra" , "Alvarado" , "Ambalema" , "Anz\u00F3ategui" , "Armero (Guayabal)" , "Ataco" , "Cajamarca" , "Carmen de Apical\u00E1" , "Casabianca" , "Chaparral" , "Coello" , "Coyaima" , "Cunday" , "Dolores" , "Espinal" , "Fal\u00E1n" , "Flandes" , "Fresno" , "Guamo" , "Herveo" , "Honda" , "Icononzo" , "L\u00E9rida" , "L\u00EDbano" , "Mariquita" , "Melgar" , "Murillo" , "Natagaima" , "Ortega" , "Palocabildo" , "Piedras" , "Planadas" , "Prado" , "Purificaci\u00F3n" , "Rioblanco" , "Roncesvalles" , "Rovira" , "Salda\u00F1a" , "San Antonio" , "San Luis" , "Santa Isabel" , "Su\u00E1rez" , "Valle de San Juan" , "Venadillo" , "Villahermosa" , "Villarrica" , "Cali" , "Alcal\u00E1" , "Andaluc\u00EDa" , "Ansermanuevo" , "Argelia" , "Bol\u00EDvar" , "Buenaventura" , "Buga" , "Bugalagrande" , "Caicedonia" , "Calima (Dari\u00E9n)" , "Candelaria" , "Cartago" , "Dagua" , "El \u00C1guila" , "El Cairo" , "El Cerrito" , "El Dovio" , "Florida" , "Ginebra" , "Guacar\u00ED" , "Jamund\u00ED" , "La Cumbre" , "La Uni\u00F3n" , "La Victoria" , "Obando" , "Palmira" , "Pradera" , "Restrepo" , "Riofr\u00EDo" , "Roldanillo" , "San Pedro" , "Sevilla" , "Toro" , "Trujillo" , "Tulu\u00E1" , "Ulloa" , "Versalles" , "Vijes" , "Yotoco" , "Yumbo" , "Zarzal" , "Mit\u00FA" , "Carur\u00FA" , "Tatam\u00E1" , "Vichada 99 Puerto Carre\u00F1o" , "La Primavera" , "Santa Rosalia" , "Cumaribo" } ) ) ; getContentPane ( ) . add ( municipio , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 540 , 100 , - 1 , - 1 ) ) ; getContentPane ( ) . add ( txtDireccion , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 540 , 130 , 170 , - 1 ) ) ; txtTelefono . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { txtTelefonoActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( txtTelefono , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 540 , 200 , 170 , - 1 ) ) ; txtEmail . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { txtEmailActionPerformed ( evt ) ; } } ) ; txtEmail . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyTyped ( java . awt . event . KeyEvent evt ) { txtEmailKeyTyped ( evt ) ; } } ) ; getContentPane ( ) . add ( txtEmail , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 540 , 160 , 170 , - 1 ) ) ; txtCelular . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyTyped ( java . awt . event . KeyEvent evt ) { txtCelularKeyTyped ( evt ) ; } } ) ; getContentPane ( ) . add ( txtCelular , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 540 , 230 , 170 , - 1 ) ) ; getContentPane ( ) . add ( fecha , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 204 , 159 , 141 , - 1 ) ) ; jLabel2 . setText ( "Cedula" ) ; getContentPane ( ) . add ( jLabel2 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 73 , 76 , 54 , - 1 ) ) ; jLabel3 . setText ( "Nombre" ) ; getContentPane ( ) . add ( jLabel3 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 69 , 105 , 58 , - 1 ) ) ; jLabel4 . setText ( "Apellido" ) ; getContentPane ( ) . add ( jLabel4 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 69 , 136 , 58 , - 1 ) ) ; jLabel5 . setText ( "Fecha de Nacimiento" ) ; getContentPane ( ) . add ( jLabel5 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 69 , 161 , - 1 , - 1 ) ) ; jLabel6 . setText ( "Sexo" ) ; getContentPane ( ) . add ( jLabel6 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 70 , 190 , - 1 , - 1 ) ) ; jLabel7 . setText ( "Numero de Hijos" ) ; getContentPane ( ) . add ( jLabel7 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 439 , 76 , - 1 , - 1 ) ) ; jLabel8 . setText ( "Municipio" ) ; getContentPane ( ) . add ( jLabel8 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 439 , 104 , - 1 , - 1 ) ) ; jLabel9 . setText ( "Correo" ) ; getContentPane ( ) . add ( jLabel9 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 439 , 168 , - 1 , - 1 ) ) ; jLabel10 . setText ( "Direccion" ) ; getContentPane ( ) . add ( jLabel10 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 439 , 136 , - 1 , - 1 ) ) ; jLabel11 . setText ( "Telefono" ) ; getContentPane ( ) . add ( jLabel11 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 439 , 199 , - 1 , - 1 ) ) ; jLabel12 . setText ( "Celular" ) ; getContentPane ( ) . add ( jLabel12 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 439 , 233 , - 1 , - 1 ) ) ; jLabel13 . setFont ( new java . awt . Font ( "Tahoma" , 0 , 14 ) ) ; jLabel13 . setText ( "Ingrese  los Datos del Cliente" ) ; getContentPane ( ) . add ( jLabel13 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 279 , 11 , 275 , 40 ) ) ; txtHijos . addKeyListener ( new java . awt . event . KeyAdapter ( ) { public void keyTyped ( java . awt . event . KeyEvent evt ) { txtHijosKeyTyped ( evt ) ; } } ) ; getContentPane ( ) . add ( txtHijos , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 540 , 70 , 170 , - 1 ) ) ; jLabel14 . setText ( "Estado CIvil" ) ; getContentPane ( ) . add ( jLabel14 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 70 , 220 , - 1 , - 1 ) ) ; civil . setModel ( new javax . swing . DefaultComboBoxModel ( new String [ ] { "Soltero " , "Casado " , "Divorciado " , "Viudo" } ) ) ; getContentPane ( ) . add ( civil , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 204 , 224 , 141 , - 1 ) ) ; btnEliminar . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/eliminar.png" ) ) ) ; btnEliminar . setToolTipText ( "Eliminar" ) ; btnEliminar . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnEliminarActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( btnEliminar , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 300 , 280 , 60 , - 1 ) ) ; jButton2 . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/salir.png" ) ) ) ; jButton2 . setToolTipText ( "Salir" ) ; jButton2 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jButton2ActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( jButton2 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 680 , 280 , 70 , - 1 ) ) ; btnActualizar . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/actualizar.png" ) ) ) ; btnActualizar . setToolTipText ( "Actualizar" ) ; btnActualizar . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { btnActualizarActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( btnActualizar , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 230 , 280 , 60 , - 1 ) ) ; jToggleButton2 . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/promociones.png" ) ) ) ; jToggleButton2 . setSelected ( true ) ; jToggleButton2 . setToolTipText ( "Promociones" ) ; jToggleButton2 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jToggleButton2ActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( jToggleButton2 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 780 , 40 , 130 , 100 ) ) ; jToggleButton5 . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/Imagenes/Encuestas.png" ) ) ) ; jToggleButton5 . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent evt ) { jToggleButton5ActionPerformed ( evt ) ; } } ) ; getContentPane ( ) . add ( jToggleButton5 , new org . netbeans . lib . awtextra . AbsoluteConstraints ( 780 , 150 , 130 , 80 ) ) ; pack ( ) ; }
tr	B	public void startVoting ( String [ ] options ) { try { currentVoting = new Voting ( console , options , votingCounter ++ ) ; currentVoting . setVoters ( clients ) ; } catch ( ServerException ex ) { console . displayMessage ( ex . getMessage ( ) ) ; } }
tr	G	public boolean exists ( Connection conn , String cond , Object ... params ) { PreparedStatement ps = null ; ResultSet rs = null ; try { ps = conn . prepareStatement ( "SELECT 1 FROM `" + tableName + "` " + cond + " LIMIT 1" ) ; SQLUtil . psSet1 ( params , ps ) ; rs = ps . executeQuery ( ) ; return rs . next ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } finally { IOUtil . close ( rs ) ; IOUtil . close ( ps ) ; } }
tr	G	Document parse ( InputStream is ) throws ParserConfigurationException , IOException { try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; return builder . parse ( is ) ; } catch ( Exception e ) { errorHandler . reportError ( TIPPErrorType . CORRUPT_MANIFEST , "Could not parse manifest" , e ) ; return null ; } finally { is . close ( ) ; } }
tr	B	protected void preTraverse ( Node node ) { if ( node == null ) return ; if ( node . type == Node . StartTag || node . type == Node . StartEndTag ) { if ( currIndex <= maxIndex && ( tagName . equals ( "*" ) || tagName . equals ( node . element ) ) ) { currIndex += 1 ; currNode = node ; } } if ( currIndex > maxIndex ) return ; node = node . content ; while ( node != null ) { preTraverse ( node ) ; node = node . next ; } }
tr	D	public void setCalendarWeek ( Integer calendarWeek ) { this . calendarWeek = calendarWeek ; }
tr	A	@ Override public void close ( ) throws ParsingException { token . close ( ) ; exit ( ) ; }
tr	C	private void validateManifest ( Manifest manifest ) { TIPPTaskType taskType = manifest . getTask ( ) . getTaskType ( ) ; for ( TIPPSection section : manifest . getSections ( ) ) { checkSectionForDuplicateSequence ( section ) ; if ( taskType != null && ! ( taskType instanceof CustomTaskType ) && ! taskType . getSupportedSectionTypes ( ) . contains ( section . getType ( ) ) ) { errorHandler . reportError ( TIPPErrorType . INVALID_SECTION_FOR_TASK , "Invalid section for task type: " + section . getType ( ) , null ) ; } } }
tr	J	public double getMargins ( ) { return margins ; }
tr	I	private void limpiarButtonActionPerformed ( java . awt . event . ActionEvent evt ) { limpiarTabla ( jTable1 ) ; buscarButton . setEnabled ( true ) ; CheckLab . setSelected ( false ) ; CheckNombre . setSelected ( false ) ; CheckTelefono . setSelected ( false ) ; CheckLab . setEnabled ( true ) ; CheckNombre . setEnabled ( true ) ; CheckTelefono . setEnabled ( true ) ; }
tr	E	public void setFutureRotation ( float toRotation ) { if ( toRotation < 0 ) { toRotation = 360 + toRotation ; } this . futureRotation = toRotation ; }
tr	I	private static String cleanHead ( String document ) { document = document . replaceAll ( "<meta[^>]*name=\"[^\"]* [^\"]*\"[^>]*/>" , "" ) ; document = document . replaceAll ( "<style.*?</style>" , "" ) ; document = document . replaceAll ( "<link.*?/>" , "" ) ; document = document . replaceAll ( "</head>" , "<style type=\"text/css\">\n" + " #title { color: #663300; text-align: center; }\n" + " #title .title { font-style:italic; font-size: larger; font-weight:bold; }\n" + " #title .author { font-weight:bold; }\n" + " #bened { font-style:italic; } \n" + " #main .numpara { font-family: Verdana; font-size: smaller; font-weight: bold; }\n" + " #main .footnote { vertical-align: super; font-size: 70%; line-height: 80%; }\n" + " #main .center { text-align: center; }\n" + " #notes p { margin: 0; padding: 0; font-size: smaller; }\n" + " #notes .ref { font-family: Verdana; font-size: smaller; font-weight: bold; }\n" + " #copyright { color: #663300; text-align: center; font-size: smaller; }\n" + " .hr { background-color: #FFFFFF; border: 1px solid #000000; height: 0px; margin: 10px 30%; width: 40%; }\n" + " .smallcaps { font-size: smaller; }\n" + "</style>" + "</head>" ) ; return document ; }
tr	B	public ArrayList < Piece > get_pieces ( ) { return _pieces ; }
tr	E	private void loadPackageObjects ( ManifestBuilder builder , Element parent ) { NodeList children = parent . getChildNodes ( ) ; EnumSet < TIPPSectionType > seenSections = EnumSet . noneOf ( TIPPSectionType . class ) ; Map < TIPPFile , String > locationMap = new HashMap < > ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { if ( children . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) { continue ; } TIPPSection section = loadPackageObjectSection ( ( Element ) children . item ( i ) , errorHandler , locationMap ) ; if ( seenSections . contains ( section . getType ( ) ) ) { errorHandler . reportError ( TIPPErrorType . DUPLICATE_SECTION_IN_MANIFEST , "Duplicate section: " + section . getType ( ) , null ) ; continue ; } seenSections . add ( section . getType ( ) ) ; builder . addSection ( section ) ; } builder . setLocationMap ( locationMap ) ; }
tr	A	public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( ! ( obj instanceof IAnnotation < ? > ) ) { return false ; } else { IAnnotation < ? > ann = ( IAnnotation < ? > ) obj ; if ( ! ( ann . getAnnotation ( ) . getClass ( ) == this . getAnnotation ( ) . getClass ( ) ) ) { return false ; } else { if ( ann . getAnnotation ( ) . equals ( this . getAnnotation ( ) ) ) { return true ; } } } return false ; }
tr	F	protected void setSendHello ( boolean sendHello ) { this . sendHello = sendHello ; }
tr	F	private void regLvlPckSpfcContent ( final ILevelPack levelPack ) { if ( levelPack . getEvents ( ) != null ) { for ( final MainEvent event : levelPack . getEvents ( ) ) { ActionObserver . getInstance ( ) . registerEvent ( event ) ; } } if ( levelPack . getTradeables ( ) != null ) { for ( final ITradeable tradeable : levelPack . getTradeables ( ) ) { TradeableHandler . getInstance ( ) . registerActiveTradeable ( tradeable ) ; } } }
tr	G	private String padLeft ( String s , int n ) { if ( s . length ( ) >= n ) { return s ; } String spaces = "" ; for ( int i = 0 ; i < n - s . length ( ) ; i ++ ) { spaces += " " ; } return spaces + s ; }
tr	B	public static int evaluate ( DraughtsState ds ) { if ( ds == null ) { throw new IllegalArgumentException ( "ds in evaluate" ) ; } int total = 0 ; boolean isWhite = ds . isWhiteToMove ( ) ; for ( int c = 0 ; c != 10 ; c ++ ) { for ( int r = 0 ; r != 10 ; r ++ ) { total += addValue ( r , c , ds ) ; } } if ( ! isWhite ) { total = - total ; } return total ; }
tr	J	public int getonlineStatus ( ) { return onlineStatus ; }
tr	B	boolean canLog ( TcpMessageFilter filter , String message ) { return filter == null || filter . accept ( message ) ; }
tr	B	public void addRoom ( Rectangle room ) { rooms . add ( room ) ; }
tr	D	private void notifyConnection ( ) { raiseEvent ( new EventConnected ( ) ) ; }
tr	J	public String getRemark ( ) { return remark ; }
tr	I	public T peek ( ) { if ( size == 0 ) { throw new IllegalStateException ( "Array is empty." ) ; } return items [ size - 1 ] ; }
tr	C	public String getTag ( ) { return tag ; }
tr	H	public int getEndColumn ( ) { return bufcolumn [ bufpos ] ; }
tr	D	private static void method340 ( int i , int j , int k , int l , int i1 ) { if ( k < topY || k >= bottomY ) return ; if ( i1 < topX ) { j -= topX - i1 ; i1 = topX ; } if ( i1 + j > bottomX ) j = bottomX - i1 ; int j1 = 256 - l ; int k1 = ( i >> 16 & ff ) * l ; int l1 = ( i >> 8 & ff ) * l ; int i2 = ( i & ff ) * l ; int i3 = i1 + k * width ; for ( int j3 = 0 ; j3 < j ; j3 ++ ) { int j2 = ( pixels [ i3 ] >> 16 & ff ) * j1 ; int k2 = ( pixels [ i3 ] >> 8 & ff ) * j1 ; int l2 = ( pixels [ i3 ] & ff ) * j1 ; int k3 = ( ( k1 + j2 >> 8 ) << 16 ) + ( ( l1 + k2 >> 8 ) << 8 ) + ( i2 + l2 >> 8 ) ; pixels [ i3 ++ ] = k3 ; } }
tr	B	@ Override public void putNewLine ( ) throws ParsingException { if ( token . isStarted ( ) ) putChar ( Characters . NEWLINE ) ; else token . start ( ) ; }
tr	D	public static int [ ] maxNonZeroRandomSet ( int n , int sum , int max ) { if ( sum < n ) { throw new IllegalArgumentException ( "Cannot satisfy sum." ) ; } for ( int i = 0 ; i < MAX_TRIES ; i ++ ) { boolean found = true ; int [ ] temp = randomSet ( n , sum ) ; inner : for ( int j = 0 ; j < n ; j ++ ) { if ( temp [ j ] == 0 || temp [ j ] > max ) { found = false ; break inner ; } } if ( found ) { return temp ; } } throw new RuntimeException ( "too many attempts. n  sum  max = " + n + "  " + sum + "  " + max ) ; }
tr	E	public void setStatusId ( String statusId ) { this . statusId = statusId ; }
tr	C	public void setY ( float y ) { position . y = y ; }
tr	C	private Manifest loadManifest ( Document document ) { ManifestBuilder builder = new ManifestBuilder ( ) ; Element manifestEl = getFirstChildElement ( document ) ; loadDescriptor ( builder , getFirstChildByName ( manifestEl , GLOBAL_DESCRIPTOR ) ) ; loadTaskRequestOrResponse ( builder , manifestEl ) ; loadPackageObjects ( builder , getFirstChildByName ( manifestEl , PACKAGE_OBJECTS ) ) ; return builder . build ( ) ; }
tr	C	void draw_all_points ( ) { int n = point_list . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) draw_point ( point_list . elementAt ( i ) ) ; }
tr	I	private static String replaceAllFull ( String document , String regexp , String repl ) { for ( ; ; ) { String doc = document . replaceAll ( regexp , repl ) ; if ( doc . equals ( document ) ) { return doc ; } else { document = doc ; } } }
tr	A	public void setTile ( int x , int y , Tile tile ) { grid [ x ] [ y ] = tile ; tile . setRow ( y ) ; tile . setColumn ( x ) ; }
tr	B	public Board get_board ( ) { return _board ; }
tr	D	public Integer getCalendarWeek ( ) { return calendarWeek ; }
tr	J	public static void main ( String [ ] args ) { testCloseNonZeroRandoms ( 5 , 7 , 0.25 ) ; }
tr	E	public void serverMessage ( String msg ) throws NetworkMessageException { NetworkMessage nm = new StringMessage ( 0 , 0 , msg ) ; for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { clients . get ( i ) . sendMessage ( nm ) ; } console . displayMessage ( "Server: " + msg ) ; }
tr	F	@ Override public Node < T > createNewNode ( Node < T > parent , T id ) { return ( new AVLNode < T > ( parent , id ) ) ; }
tr	G	private static String classNameToPackage ( String classname ) { int lastdot = classname . lastIndexOf ( . ) ; if ( lastdot < 0 ) return "no-package" ; return classname . substring ( 0 , lastdot ) ; }
tr	E	@ Override protected boolean validateNode ( Node < T > node ) { boolean bst = super . validateNode ( node ) ; if ( ! bst ) return false ; AVLNode < T > avlNode = ( AVLNode < T > ) node ; int balanceFactor = avlNode . getBalanceFactor ( ) ; if ( balanceFactor > 1 || balanceFactor < - 1 ) { return false ; } if ( avlNode . isLeaf ( ) ) { if ( avlNode . height != 1 ) return false ; } else { AVLNode < T > avlNodeLesser = ( AVLNode < T > ) avlNode . lesser ; int lesserHeight = 1 ; if ( avlNodeLesser != null ) lesserHeight = avlNodeLesser . height ; AVLNode < T > avlNodeGreater = ( AVLNode < T > ) avlNode . greater ; int greaterHeight = 1 ; if ( avlNodeGreater != null ) greaterHeight = avlNodeGreater . height ; if ( avlNode . height == ( lesserHeight + 1 ) || avlNode . height == ( greaterHeight + 1 ) ) return true ; return false ; } return true ; }
tr	I	public void setValueAt ( Object arg0 , int arg1 , int arg2 ) { }
tr	B	private void checkFormat ( ) throws IllegalArgumentException { if ( ! format . startsWith ( "%" ) ) { throw new IllegalArgumentException ( "Number format not starting with %" ) ; } if ( ! format . endsWith ( "m" ) ) { throw new IllegalArgumentException ( "Sexagesimal format not recognized (not ending m)" ) ; } String remaining = format . substring ( 1 , format . length ( ) - 1 ) ; int dotPos = remaining . indexOf ( "." ) ; if ( dotPos == - 1 ) { throw new IllegalArgumentException ( "Sexagesimal format not correct (no dot)" ) ; } String l = remaining . substring ( 0 , dotPos ) ; String frLength = remaining . substring ( dotPos + 1 ) ; try { length = Integer . parseInt ( l ) ; fractionLength = Integer . parseInt ( frLength ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Illegal sexagesimal length or fraction length" ) ; } if ( ( fractionLength != 3 ) && ( fractionLength != 5 ) && ( fractionLength != 6 ) && ( fractionLength != 8 ) && ( fractionLength != 9 ) ) { throw new IllegalArgumentException ( "Illegal sexagesimal fraction length" ) ; } }
tr	J	public Font getChineseFont ( ) { return chineseFont ; }
tr	C	public void removeMonster ( Monster monster ) { monster . getLocation ( ) . removeOccupant ( ) ; monster . setLocation ( null ) ; monsters . remove ( monster ) ; }
tr	D	public float getHeight ( ) { return anim . getImage ( ) . getHeight ( null ) ; }
tr	C	private void logMessage ( TcpMessageFilter filter , String message ) { if ( ! canLog ( filter , message ) ) { if ( Logger . getLogger ( getClass ( ) ) . isDebugEnabled ( ) ) Logger . getLogger ( getClass ( ) ) . debug ( message ) ; return ; } Logger . getLogger ( getClass ( ) ) . info ( message ) ; }
tr	C	public Monster getMonster ( int i ) { return monsters . get ( i ) ; }
tr	A	public DraughtsState getState ( ) { return NodeLVL2 . ds ; }
tr	I	public void removeMonthLabel ( JLabel label ) { monthLabels . remove ( label ) ; }
tr	F	private void printText ( Graphics g , PrintableRecord record , int x1 , int y1 , int dx , int dy , int i , int j , int boxW , int boxH ) { if ( record == null ) { return ; } g . setFont ( record . getFont ( ) ) ; FontMetrics fm = g . getFontMetrics ( g . getFont ( ) ) ; String rawText = record . getTextToPrint ( ) ; String lines [ ] = new String [ ] { rawText } ; if ( rawText . indexOf ( "\n" ) > 0 ) { StringTokenizer st = new StringTokenizer ( rawText , "\n" ) ; lines = new String [ st . countTokens ( ) ] ; int s = 0 ; while ( st . hasMoreTokens ( ) ) { lines [ s ++ ] = st . nextToken ( ) ; } } for ( int k = 0 ; k < lines . length ; k ++ ) { int x = ( x1 + ( dx / 2 ) + i * boxW ) ; int y = ( y1 + ( dy / 2 ) + j * boxH ) ; String line = lines [ k ] ; java . awt . geom . Rectangle2D rect = fm . getStringBounds ( line , g ) ; int textHeight = ( int ) ( rect . getHeight ( ) ) ; int textWidth = ( int ) ( rect . getWidth ( ) ) ; x += ( boxW - textWidth ) / 2 ; y += ( boxH - ( textHeight * lines . length ) ) / 2 + fm . getAscent ( ) ; y += textHeight * k ; g . drawString ( line , x , y ) ; } }
tr	J	private void txtApellidoActionPerformed ( java . awt . event . ActionEvent evt ) { txtApellido . transferFocus ( ) ; }
tr	I	public int print ( Graphics graphics , PageFormat pageFormat , int pageIndex ) throws PrinterException { if ( pageIndex < calcPages ( ( int ) pageFormat . getImageableWidth ( ) - padding * 2 , ( int ) pageFormat . getImageableHeight ( ) - padding * 2 ) ) { paintGrid ( graphics , pageFormat , pageIndex , 1.0 ) ; return Printable . PAGE_EXISTS ; } else { return Printable . NO_SUCH_PAGE ; } }
tr	B	public void setPlayerSpawn ( Point spawn ) { this . spawn = spawn ; }
tr	E	public M select ( Connection conn , String query , Object ... params ) { Query < M > parseQuery = parseSelectQuery ( query ) ; AtomicReference < M > ret = new AtomicReference < > ( ) ; F1 < M , boolean > f1 = Fs . f1 ( Fs . setter ( ret ) , true ) ; String cond = ( parseQuery . cond != null ? parseQuery . cond : "" ) + " LIMIT 1" ; each ( f1 , conn , parseQuery . fields , cond , params ) ; return ret . get ( ) ; }
tr	A	public Table get ( String name ) { Table table = tables . get ( name ) ; if ( table == null ) { throw new SqlException ( "No such table: " + name ) ; } return table ; }
tr	C	public float getY ( ) { return ( float ) position . y ; }
tr	I	public void clear ( ) { T [ ] items = this . items ; for ( int i = 0 , n = size ; i < n ; i ++ ) { items [ i ] = null ; } size = 0 ; }
tr	C	public void setHeight ( int h ) { for ( int i = 0 ; i < anim . getFrames ( ) . size ( ) ; i ++ ) { Image image = ( ( AnimFrame ) anim . getFrames ( ) . get ( i ) ) . image ; image = image . getScaledInstance ( image . getWidth ( null ) , h , 0 ) ; ( ( AnimFrame ) anim . getFrames ( ) . get ( i ) ) . image = image ; } }
tr	H	public Object getNextValue ( ) { return Integer . toString ( getCalendar ( Calendar . YEAR ) + 1 ) ; }
tr	F	DrawingArea ( ) { }
tr	H	public URL getProfileImageURL ( ) { try { return new URL ( profileImageUrl ) ; } catch ( MalformedURLException ex ) { return null ; } }
tr	I	public static void testNonZeroRandomSet ( int n , int sum ) { int [ ] test = nonZeroRandomSet ( n , sum ) ; int gensum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( test [ i ] + " " ) ; gensum += test [ i ] ; } System . out . println ( "= " + gensum ) ; }
tr	A	public void preTurn ( ) { for ( Piece p : _pieces ) { p . set_active ( true ) ; } System . out . println ( _name + "'s turn." ) ; }
tr	D	@ Override public List < Framedata > translateFrame ( ByteBuffer buffer ) throws InvalidDataException { buffer . mark ( ) ; List < Framedata > frames = super . translateRegularFrame ( buffer ) ; if ( frames == null ) { buffer . reset ( ) ; frames = readyframes ; readingState = true ; if ( currentFrame == null ) currentFrame = ByteBuffer . allocate ( 2 ) ; else { throw new InvalidFrameException ( ) ; } if ( buffer . remaining ( ) > currentFrame . remaining ( ) ) { throw new InvalidFrameException ( ) ; } else { currentFrame . put ( buffer ) ; } if ( ! currentFrame . hasRemaining ( ) ) { if ( Arrays . equals ( currentFrame . array ( ) , closehandshake ) ) { frames . add ( new CloseFrameBuilder ( CloseFrame . NORMAL ) ) ; return frames ; } else { throw new InvalidFrameException ( ) ; } } else { readyframes = new LinkedList < Framedata > ( ) ; return frames ; } } else { return frames ; } }
tr	A	public void setPassword ( String password ) { this . password = password ; }
tr	A	@ Override public void init ( Headquater hq ) { cr = InsightCrossing . require ( hq ) ; de = InsightDeadend . require ( hq ) ; }
tr	E	int see ( int sequence ) { seenSequences . add ( sequence ) ; return sequence ; }
tr	A	public A getAnnotation ( ) { return annotation ; }
tr	A	public void update ( long elapsedTime ) { anim . update ( elapsedTime ) ; }
tr	H	private static InputStream fullStream ( String fname ) throws IOException { InputStream in = new DataInputStream ( new FileInputStream ( fname ) ) ; ByteArrayOutputStream collect = new ByteArrayOutputStream ( ) ; int c = in . read ( ) ; while ( c != - 1 ) { collect . write ( c ) ; c = in . read ( ) ; } ByteArrayInputStream bais = new ByteArrayInputStream ( collect . toByteArray ( ) ) ; return bais ; }
tr	B	public void set_money ( int money ) { _money = money ; }
tr	D	public void setYear ( Integer year ) { this . year = year ; }
tr	H	public Set < Map . Entry < Key , Val >> entrySet ( ) { return new AbstractSet < Map . Entry < Key , Val >> ( ) { public Iterator iterator ( ) { return FTreeMap . this . iterator ( ) ; } public int size ( ) { return FTreeMap . this . size ( ) ; } public boolean contains ( Object x ) { if ( ! ( x instanceof Map . Entry ) ) return false ; else { Map . Entry < Object , Object > ent = ( Map . Entry < Object , Object > ) x ; Object ekey = ent . getKey ( ) ; Object eval = ent . getValue ( ) ; if ( containsKey ( ekey ) ) return eql ( eval , get ( ekey ) ) ; else return false ; } } public boolean remove ( Object x ) { throw new UnsupportedOperationException ( ) ; } public void clear ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
tr	B	static void loadTickerSet ( String fileName , ArrayList < String > tickers ) { Scanner inFile = null ; try { inFile = new Scanner ( new File ( fileName ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } if ( inFile == null ) { System . out . println ( "invalid file no symbols loaded" ) ; return ; } boolean firstLine = true ; while ( inFile . hasNextLine ( ) ) { String ticker = inFile . nextLine ( ) ; if ( firstLine ) { firstLine = false ; continue ; } String [ ] getTicker = ticker . split ( " " ) ; tickers . add ( getTicker [ 0 ] . replaceAll ( "\"" , "" ) ) ; } }
tr	F	private int getFontWidth ( Font font ) { FontMetrics metrics = getFontMetrics ( font ) ; int [ ] ints = metrics . getWidths ( ) ; int fontWidth = ints [ 20 ] + ints [ 40 ] + ints [ 60 ] + ints [ 80 ] + ints [ 100 ] + ints [ 120 ] + ints [ 140 ] + ints [ 180 ] + ints [ 200 ] + ints [ 220 ] + ints [ 240 ] ; fontWidth /= 10 ; return fontWidth ; }
tr	E	public int indexOf ( T value , boolean identity ) { T [ ] items = this . items ; if ( identity || value == null ) { for ( int i = 0 , n = size ; i < n ; i ++ ) { if ( items [ i ] == value ) { return i ; } } } else { for ( int i = 0 , n = size ; i < n ; i ++ ) { if ( value . equals ( items [ i ] ) ) { return i ; } } } return - 1 ; }
tr	I	void putDirtyFloatArray ( final float [ ] array ) { final int length = array . length ; if ( ( ( length & 1 ) == 0 ) && ( length <= MAX_ARRAY_SIZE ) ) { getDirtyFloatArrayCache ( length ) . putDirtyArray ( array , length ) ; } }
tr	D	private void balanceAfterDelete ( AVLNode < T > node ) { int balanceFactor = node . getBalanceFactor ( ) ; if ( balanceFactor == - 2 || balanceFactor == 2 ) { if ( balanceFactor == - 2 ) { AVLNode < T > ll = ( AVLNode < T > ) node . lesser . lesser ; int lesser = ( ll != null ) ? ll . height : 0 ; AVLNode < T > lr = ( AVLNode < T > ) node . lesser . greater ; int greater = ( lr != null ) ? lr . height : 0 ; if ( lesser >= greater ) { rotateRight ( node ) ; node . updateHeight ( ) ; if ( node . parent != null ) ( ( AVLNode < T > ) node . parent ) . updateHeight ( ) ; } else { rotateLeft ( node . lesser ) ; rotateRight ( node ) ; AVLNode < T > p = ( AVLNode < T > ) node . parent ; if ( p . lesser != null ) ( ( AVLNode < T > ) p . lesser ) . updateHeight ( ) ; if ( p . greater != null ) ( ( AVLNode < T > ) p . greater ) . updateHeight ( ) ; p . updateHeight ( ) ; } } else if ( balanceFactor == 2 ) { AVLNode < T > rr = ( AVLNode < T > ) node . greater . greater ; int greater = ( rr != null ) ? rr . height : 0 ; AVLNode < T > rl = ( AVLNode < T > ) node . greater . lesser ; int lesser = ( rl != null ) ? rl . height : 0 ; if ( greater >= lesser ) { rotateLeft ( node ) ; node . updateHeight ( ) ; if ( node . parent != null ) ( ( AVLNode < T > ) node . parent ) . updateHeight ( ) ; } else { rotateRight ( node . greater ) ; rotateLeft ( node ) ; AVLNode < T > p = ( AVLNode < T > ) node . parent ; if ( p . lesser != null ) ( ( AVLNode < T > ) p . lesser ) . updateHeight ( ) ; if ( p . greater != null ) ( ( AVLNode < T > ) p . greater ) . updateHeight ( ) ; p . updateHeight ( ) ; } } } }
tr	G	public Type type ( ) { if ( outputVariables . isEmpty ( ) ) { return Type . NONE ; } boolean mamdani = true ; for ( OutputVariable outputVariable : outputVariables ) { for ( Term term : outputVariable . getTerms ( ) ) { mamdani &= term != null && ! ( term instanceof Constant || term instanceof Linear ) ; } mamdani &= outputVariable . getDefuzzifier ( ) instanceof IntegralDefuzzifier ; } boolean larsen = mamdani ; if ( mamdani ) { for ( RuleBlock ruleBlock : ruleBlocks ) { larsen &= ruleBlock . getActivation ( ) instanceof AlgebraicProduct ; } } if ( larsen ) { return Type . LARSEN ; } if ( mamdani ) { return Type . MAMDANI ; } boolean takagiSugeno = true ; for ( OutputVariable outputVariable : outputVariables ) { for ( Term term : outputVariable . getTerms ( ) ) { takagiSugeno &= term instanceof Constant || term instanceof Linear || term instanceof Function ; } Defuzzifier defuzzifier = outputVariable . getDefuzzifier ( ) ; takagiSugeno &= defuzzifier != null && ! ( defuzzifier instanceof IntegralDefuzzifier ) ; } if ( takagiSugeno ) { return Type . TAKAGI_SUGENO ; } boolean tsukamoto = true ; for ( OutputVariable outputVariable : outputVariables ) { for ( Term term : outputVariable . getTerms ( ) ) { tsukamoto &= term instanceof Ramp || term instanceof Sigmoid || term instanceof SShape || term instanceof ZShape ; } Defuzzifier defuzzifier = outputVariable . getDefuzzifier ( ) ; tsukamoto &= defuzzifier != null && ! ( defuzzifier instanceof IntegralDefuzzifier ) ; } if ( tsukamoto ) { return Type . TSUKAMOTO ; } boolean inverseTsukamoto = true ; for ( OutputVariable outputVariable : outputVariables ) { for ( Term term : outputVariable . getTerms ( ) ) { inverseTsukamoto &= term != null && ! ( term instanceof Constant || term instanceof Linear ) ; } Defuzzifier defuzzifier = outputVariable . getDefuzzifier ( ) ; inverseTsukamoto &= defuzzifier != null && ! ( defuzzifier instanceof IntegralDefuzzifier ) ; } if ( inverseTsukamoto ) { return Type . INVERSE_TSUKAMOTO ; } return Type . UNKNOWN ; }
tr	D	public void update ( Data ... records ) throws IOException { IntObjectOpenHashMap < ArrayList < Data >> bucketDataMapping = new IntObjectOpenHashMap < ArrayList < Data >> ( ) ; int bucketId ; for ( Data d : records ) { bucketId = hashFunction . getBucketId ( d . getKey ( ) ) ; if ( ! bucketDataMapping . containsKey ( bucketId ) ) { bucketDataMapping . put ( bucketId , new ArrayList < Data > ( ) ) ; } bucketDataMapping . get ( bucketId ) . add ( d ) ; } for ( IntObjectCursor < ArrayList < Data >> entry : bucketDataMapping ) { UpdateOnlySynchronizer < Data > synchronizer = new UpdateOnlySynchronizer < Data > ( gp . DATABASE_DIRECTORY + "/" + hashFunction . getFilename ( entry . key ) , gp ) ; @ SuppressWarnings ( "unchecked" ) Data [ ] toUpdate = ( Data [ ] ) entry . value . toArray ( new AbstractKVStorable [ entry . value . size ( ) ] ) ; Arrays . sort ( toUpdate , new AbstractKVStorableComparator ( ) ) ; synchronizer . upsert ( toUpdate ) ; } }
tr	E	private StringBuilder getFooter1 ( ) throws IOException { return Utils . getFileContent ( Config . getPathIn ( ) + "footer1.html" ) ; }
tr	J	public void setDrawGuides ( boolean drawGuides ) { this . drawGuides = drawGuides ; }
tr	C	void draw_point ( point p ) { Color c = colors [ p . value + 3 ] ; Graphics window_gc = getGraphics ( ) ; buffer_gc . setColor ( c ) ; buffer_gc . fillRect ( ( int ) ( p . x * XLEN ) , ( int ) ( p . y * YLEN ) , 4 , 4 ) ; window_gc . setColor ( c ) ; window_gc . fillRect ( ( int ) ( p . x * XLEN ) , ( int ) ( p . y * YLEN ) , 4 , 4 ) ; }
tr	I	public void drawHeader ( Graphics g , int x , int y , int width , int height , int pages , int currentPage ) { String headerString1 = title1 ; String headerString2 = title2 + "Page " + currentPage + "/" + pages ; g . setFont ( headerFont ) ; g . setColor ( Color . black ) ; FontMetrics fm = g . getFontMetrics ( g . getFont ( ) ) ; java . awt . geom . Rectangle2D rect1 = fm . getStringBounds ( headerString1 , g ) ; java . awt . geom . Rectangle2D rect2 = fm . getStringBounds ( headerString2 , g ) ; int textWidth1 = ( int ) ( rect1 . getWidth ( ) ) ; int textWidth2 = ( int ) ( rect2 . getWidth ( ) ) ; int x1 = x , y1 = y , x2 = x , y2 = y ; x1 += ( width - textWidth1 ) / 2 ; x2 += ( width - textWidth2 ) / 2 ; y1 += fm . getAscent ( ) ; y2 += height ; g . drawString ( headerString1 , x1 , y1 ) ; g . drawString ( headerString2 , x2 , y2 ) ; }
tr	H	public < IDT > F1 < IDT , M > selectByIdF ( Connection conn ) { return id -> selectById ( id , conn ) ; }
tr	G	public class getColumnClass ( int arg0 ) { return Integer . class ; }
tr	G	@ SuppressWarnings ( "unchecked" ) private void mondayActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . weekCheck [ 1 ] . isSelected ( ) ) { this . numSelected ++ ; if ( this . firstSelection ) { stretch ( ) ; } this . models [ 1 ] = new DefaultListModel < Object > ( ) ; this . weekJobList [ 1 ] . setModel ( this . models [ 1 ] ) ; this . weekScrollPane [ 1 ] . setViewportView ( this . weekJobList [ 1 ] ) ; this . weekJobName [ 1 ] . setColumns ( 20 ) ; this . weekLabel [ 1 ] . setText ( "Job Name:" ) ; this . weekAddJob [ 1 ] . setText ( "Add Job" ) ; this . weekAddJob [ 1 ] . addActionListener ( new java . awt . event . ActionListener ( ) { @ Override public void actionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! Config . this . weekJobName [ 1 ] . getText ( ) . isEmpty ( ) ) { Config . this . models [ 1 ] . addElement ( Config . this . weekJobName [ 1 ] . getText ( ) ) ; Config . this . weekJobList [ 1 ] . setModel ( Config . this . models [ 1 ] ) ; Config . this . weekJobName [ 1 ] . setText ( "" ) ; } } } ) ; this . weekDeleteJob [ 1 ] . setText ( "Delete Job" ) ; this . weekDeleteJob [ 1 ] . addActionListener ( new java . awt . event . ActionListener ( ) { @ Override public void actionPerformed ( java . awt . event . ActionEvent evt ) { while ( ! Config . this . weekJobList [ 1 ] . isSelectionEmpty ( ) ) { int n = Config . this . weekJobList [ 1 ] . getSelectedIndex ( ) ; Config . this . models [ 1 ] . remove ( n ) ; } } } ) ; javax . swing . GroupLayout mondayTabLayout = new javax . swing . GroupLayout ( this . weekTab [ 1 ] ) ; this . weekTab [ 1 ] . setLayout ( mondayTabLayout ) ; mondayTabLayout . setHorizontalGroup ( mondayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( mondayTabLayout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( this . weekScrollPane [ 1 ] , javax . swing . GroupLayout . PREFERRED_SIZE , 182 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addGroup ( mondayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( mondayTabLayout . createSequentialGroup ( ) . addComponent ( this . weekLabel [ 1 ] ) . addGroup ( mondayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( mondayTabLayout . createSequentialGroup ( ) . addGap ( 14 , 14 , 14 ) . addComponent ( this . weekAddJob [ 1 ] ) ) . addGroup ( mondayTabLayout . createSequentialGroup ( ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( this . weekJobName [ 1 ] , javax . swing . GroupLayout . PREFERRED_SIZE , 100 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ) . addComponent ( this . weekDeleteJob [ 1 ] ) ) . addContainerGap ( 431 , short . MAX_VALUE ) ) ) ; mondayTabLayout . setVerticalGroup ( mondayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( mondayTabLayout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( mondayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addGroup ( mondayTabLayout . createSequentialGroup ( ) . addGroup ( mondayTabLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( this . weekJobName [ 1 ] , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( this . weekLabel [ 1 ] ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( this . weekAddJob [ 1 ] ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( this . weekDeleteJob [ 1 ] ) ) . addComponent ( this . weekScrollPane [ 1 ] , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addContainerGap ( 25 , short . MAX_VALUE ) ) ) ; this . dayTabs . addTab ( "Monday" , this . weekTab [ 1 ] ) ; } else { this . numSelected -- ; stretch ( ) ; this . dayTabs . remove ( this . weekTab [ 1 ] ) ; } }
tr	J	public void setMargins ( double margins ) { this . margins = margins ; }
tr	I	public boolean isFollowing ( ) { return following ; }
tr	I	public String getGender ( ) { return gender ; }
tr	G	@ Override public boolean lastTurnTerminatedCorrect ( ) { return this . currentTurn . terminatedCorrect ; }
tr	F	private static boolean shouldInlineField ( Object o , Field field , Map < String , Object > options ) { return shouldInLineType ( field . getType ( ) , options ) ; }
tr	C	@ Override public void open ( ) { TranslationManager . getinstance ( ) . addListener ( this ) ; translate ( ) ; setVisible ( true ) ; }
tr	F	public int getBiFollowersCount ( ) { return biFollowersCount ; }
tr	C	private TIPPCreator loadCreator ( Element creatorEl ) { TIPPCreator creator = new TIPPCreator ( getChildTextByName ( creatorEl , Creator . NAME ) , getChildTextByName ( creatorEl , Creator . ID ) , loadDate ( getFirstChildByName ( creatorEl , Creator . UPDATE ) ) , loadTool ( getFirstChildByName ( creatorEl , TOOL ) ) ) ; return creator ; }
tr	E	public void printLevelPacks ( final Integer levelStage ) { if ( isLevelStageNotValid ( levelStage ) || getLevelPacks ( levelStage ) == null ) { return ; } Integer i = 0 ; for ( final ILevelPack levelPack : getLevelPacks ( levelStage ) ) { Printer . print ( Settings_Output . OUT_OPTION , i , levelPack . getName ( ) , levelPack . getDescription ( ) ) ; i ++ ; } }
tr	D	public static class < ? > forName ( String name , ClassLoader classLoader ) throws ClassNotFoundException , LinkageError { assert . notNull ( name , "Name must not be null" ) ; class < ? > clazz = resolvePrimitiveClassName ( name ) ; if ( clazz == null ) { clazz = commonClassCache . get ( name ) ; } if ( clazz != null ) { return clazz ; } if ( name . endsWith ( ARRAY_SUFFIX ) ) { String elementClassName = name . substring ( 0 , name . length ( ) - ARRAY_SUFFIX . length ( ) ) ; class < ? > elementClass = forName ( elementClassName , classLoader ) ; return Array . newInstance ( elementClass , 0 ) . getClass ( ) ; } if ( name . startsWith ( NON_PRIMITIVE_ARRAY_PREFIX ) && name . endsWith ( ";" ) ) { String elementName = name . substring ( NON_PRIMITIVE_ARRAY_PREFIX . length ( ) , name . length ( ) - 1 ) ; class < ? > elementClass = forName ( elementName , classLoader ) ; return Array . newInstance ( elementClass , 0 ) . getClass ( ) ; } if ( name . startsWith ( INTERNAL_ARRAY_PREFIX ) ) { String elementName = name . substring ( INTERNAL_ARRAY_PREFIX . length ( ) ) ; class < ? > elementClass = forName ( elementName , classLoader ) ; return Array . newInstance ( elementClass , 0 ) . getClass ( ) ; } ClassLoader clToUse = classLoader ; if ( clToUse == null ) { clToUse = getDefaultClassLoader ( ) ; } try { return ( clToUse != null ? clToUse . loadClass ( name ) : class . forName ( name ) ) ; } catch ( ClassNotFoundException ex ) { int lastDotIndex = name . lastIndexOf ( . ) ; if ( lastDotIndex != - 1 ) { String innerClassName = name . substring ( 0 , lastDotIndex ) + $ + name . substring ( lastDotIndex + 1 ) ; try { return ( clToUse != null ? clToUse . loadClass ( innerClassName ) : class . forName ( innerClassName ) ) ; } catch ( ClassNotFoundException ex2 ) { } } throw ex ; } }
tr	E	public static void setDrawingArea ( int h , int j , int w , int l ) { if ( j < 0 ) j = 0 ; if ( l < 0 ) l = 0 ; if ( w > width ) w = width ; if ( h > height ) h = height ; topX = j ; topY = l ; bottomX = w ; bottomY = h ; centerX = bottomX - 1 ; viewportCentreX = bottomX / 2 ; viewportCentreY = bottomY / 2 ; }
tr	G	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( EmployeeForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( EmployeeForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( EmployeeForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( EmployeeForm . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { EmployeeForm dialog = new EmployeeForm ( new javax . swing . JFrame ( ) , true ) ; dialog . addWindowListener ( new java . awt . event . WindowAdapter ( ) { @ Override public void windowClosing ( java . awt . event . WindowEvent e ) { System . exit ( 0 ) ; } } ) ; dialog . setVisible ( true ) ; } } ) ; }
tr	D	public static void main ( String [ ] args ) throws Exception { ArrayList < Pipe > pipeList = new ArrayList < Pipe > ( ) ; pipeList . add ( new CharSequenceLowercase ( ) ) ; pipeList . add ( new CharSequence2TokenSequence ( Pattern . compile ( "\\p{L}[\\p{L}\\p{P}]+\\p{L}" ) ) ) ; pipeList . add ( new TokenSequenceRemoveStopwords ( new File ( "src\\stoplists\\en.txt" ) , "UTF-8" , false , false , false ) ) ; pipeList . add ( new TokenSequenceRemoveStopwords ( new File ( "src\\stoplists\\ph.txt" ) , "UTF-8" , false , false , false ) ) ; pipeList . add ( new TokenSequence2FeatureSequence ( ) ) ; InstanceList instances = new InstanceList ( new SerialPipes ( pipeList ) ) ; Reader fileReader = new InputStreamReader ( new FileInputStream ( new File ( "src\\uaap.txt" ) ) , "UTF-8" ) ; instances . addThruPipe ( new CsvIterator ( fileReader , Pattern . compile ( "^(\\S*)[\\s ]*(\\S*)[\\s ]*(.*)$" ) , 3 , 2 , 1 ) ) ; int numTopics = 20 ; ParallelTopicModel model = new ParallelTopicModel ( numTopics , 1.0 , 0.01 ) ; model . addInstances ( instances ) ; model . setNumThreads ( 2 ) ; model . setNumIterations ( 50 ) ; model . estimate ( ) ; Alphabet dataAlphabet = instances . getDataAlphabet ( ) ; FeatureSequence tokens = ( FeatureSequence ) model . getData ( ) . get ( 0 ) . instance . getData ( ) ; LabelSequence topics = model . getData ( ) . get ( 0 ) . topicSequence ; Formatter out = new Formatter ( new StringBuilder ( ) , Locale . US ) ; for ( int position = 0 ; position < tokens . getLength ( ) ; position ++ ) { out . format ( "%s-%d " , dataAlphabet . lookupObject ( tokens . getIndexAtPosition ( position ) ) , topics . getIndexAtPosition ( position ) ) ; } System . out . println ( out ) ; double [ ] topicDistribution = model . getTopicProbabilities ( 0 ) ; ArrayList < TreeSet < IDSorter >> topicSortedWords = model . getSortedWords ( ) ; for ( int topic = 0 ; topic < numTopics ; topic ++ ) { Iterator < IDSorter > iterator = topicSortedWords . get ( topic ) . iterator ( ) ; out = new Formatter ( new StringBuilder ( ) , Locale . US ) ; out . format ( "%d\t%.3f\t" , topic , topicDistribution [ topic ] ) ; int rank = 0 ; while ( iterator . hasNext ( ) && rank < 10 ) { IDSorter idCountPair = iterator . next ( ) ; out . format ( "%s (%.0f) " , dataAlphabet . lookupObject ( idCountPair . getID ( ) ) , idCountPair . getWeight ( ) ) ; rank ++ ; } System . out . println ( out ) ; } StringBuilder topicZeroText = new StringBuilder ( ) ; Iterator < IDSorter > iterator = topicSortedWords . get ( 0 ) . iterator ( ) ; int rank = 0 ; while ( iterator . hasNext ( ) && rank < 5 ) { IDSorter idCountPair = iterator . next ( ) ; topicZeroText . append ( dataAlphabet . lookupObject ( idCountPair . getID ( ) ) + " " ) ; rank ++ ; } InstanceList testing = new InstanceList ( instances . getPipe ( ) ) ; testing . addThruPipe ( new Instance ( topicZeroText . toString ( ) , null , "test instance" , null ) ) ; TopicInferencer inferencer = model . getInferencer ( ) ; double [ ] testProbabilities = inferencer . getSampledDistribution ( testing . get ( 0 ) , 10 , 1 , 5 ) ; System . out . println ( "0\t" + testProbabilities [ 0 ] ) ; }
tr	G	public void setLevelStageMap ( final HashMap < Integer , ArrayList < ILevelPack >> hashMap ) { levelStageMap = hashMap ; }
tr	B	public int get_money ( ) { return _money ; }
tr	G	private Field1 < M > getField ( String sqlName ) { for ( Field1 < M > field1 : idFields ) { if ( field1 . sqlName . equals ( sqlName ) ) { return field1 ; } } for ( Field1 < M > field1 : dataFields ) { if ( field1 . sqlName . equals ( sqlName ) ) { return field1 ; } } throw new RuntimeException ( "Can not find this field: " + sqlName ) ; }
tr	F	public void actionPerformed ( java . awt . event . ActionEvent evt ) { if ( evt . getSource ( ) == saveButton ) { RegistroLaboratorios . this . saveButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == limpiarButton ) { RegistroLaboratorios . this . limpiarButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == newButton ) { RegistroLaboratorios . this . newButtonActionPerformed ( evt ) ; } else if ( evt . getSource ( ) == buscarButton ) { RegistroLaboratorios . this . buscarButtonActionPerformed ( evt ) ; } }
tr	I	public void setInputVariables ( List < InputVariable > inputVariables ) { this . inputVariables = inputVariables ; }
tr	J	public T [ ] shrink ( ) { if ( items . length != size ) { resize ( size ) ; } return items ; }
tr	B	private static String generateKey ( ) { Random r = new Random ( ) ; long maxNumber = 4294967295 ; long spaces = r . nextInt ( 12 ) + 1 ; int max = new long ( maxNumber / spaces ) . intValue ( ) ; max = Math . abs ( max ) ; int number = r . nextInt ( max ) + 1 ; long product = number * spaces ; String key = long . toString ( product ) ; int numChars = r . nextInt ( 12 ) + 1 ; for ( int i = 0 ; i < numChars ; i ++ ) { int position = r . nextInt ( key . length ( ) ) ; position = Math . abs ( position ) ; char randChar = ( char ) ( r . nextInt ( 95 ) + 33 ) ; if ( randChar >= 48 && randChar <= 57 ) { randChar -= 15 ; } key = new StringBuilder ( key ) . insert ( position , randChar ) . toString ( ) ; } for ( int i = 0 ; i < spaces ; i ++ ) { int position = r . nextInt ( key . length ( ) - 1 ) + 1 ; position = Math . abs ( position ) ; key = new StringBuilder ( key ) . insert ( position , " " ) . toString ( ) ; } return key ; }
tr	H	public int getProvince ( ) { return province ; }
tr	G	protected IntObjectOpenHashMap < ArrayList < byte [ ] >> getBucketKeyMapping ( byte [ ] ... keys ) { IntObjectOpenHashMap < ArrayList < byte [ ] >> bucketKeyMapping = new IntObjectOpenHashMap < ArrayList < byte [ ] >> ( ) ; int bucketId ; for ( byte [ ] key : keys ) { bucketId = hashFunction . getBucketId ( key ) ; if ( ! bucketKeyMapping . containsKey ( bucketId ) ) { bucketKeyMapping . put ( bucketId , new ArrayList < byte [ ] > ( ) ) ; } bucketKeyMapping . get ( bucketId ) . add ( key ) ; } return bucketKeyMapping ; }
tr	F	public static class < ? > resolveClassName ( String className , ClassLoader classLoader ) throws IllegalArgumentException { try { return forName ( className , classLoader ) ; } catch ( ClassNotFoundException ex ) { throw new IllegalArgumentException ( "Cannot find class [" + className + "]" , ex ) ; } catch ( LinkageError ex ) { throw new IllegalArgumentException ( "Error loading class [" + className + "]: problem with class file or dependent class." , ex ) ; } }
tr	F	private void rsSet ( List < Field1 < M >> fields , M m , ResultSet rs ) { int index = 1 ; for ( Field1 field : fields ) { field . setValue ( field . rsGet . e ( rs , index ++ ) , m ) ; } }
tr	J	public static void main ( String [ ] args ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException ex ) { java . util . logging . Logger . getLogger ( RegistroLaboratorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { java . util . logging . Logger . getLogger ( RegistroLaboratorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { java . util . logging . Logger . getLogger ( RegistroLaboratorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } catch ( javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( RegistroLaboratorios . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } }
tr	B	public void disconnect ( ) throws IOException { if ( getRawSocket ( ) == null ) return ; getRawSocket ( ) . close ( ) ; setRawSocket ( null ) ; }
tr	G	private String getDir ( int dir ) { switch ( dir ) { case 0 : return "North" ; case 1 : return "South" ; case 2 : return "West" ; case 3 : return "East" ; case - 1 : return "Start" ; default : return "not a direction" ; } }
tr	B	public int get_number ( ) { return _number ; }
tr	A	public void setUsername ( String username ) { this . username = username ; }
tr	I	private void buscarButtonActionPerformed ( java . awt . event . ActionEvent evt ) { BuscarLaboratorio buscar_laboratorio = new BuscarLaboratorio ( ) ; buscar_laboratorio . setVisible ( true ) ; dialogo . setModal ( false ) ; }
tr	I	public void mostrar ( ) { dialogo . setContentPane ( new RegistroLaboratorios ( ) ) ; dialogo . setDefaultCloseOperation ( JDialog . DISPOSE_ON_CLOSE ) ; dialogo . setTitle ( "Registro de laboratorios" ) ; dialogo . setResizable ( false ) ; dialogo . pack ( ) ; dialogo . setModal ( true ) ; dialogo . setLocationRelativeTo ( null ) ; dialogo . setVisible ( true ) ; }
tr	G	void putIntArray ( final int [ ] array , final int fromIndex , final int toIndex ) { final int length = array . length ; if ( ( ( length & 1 ) == 0 ) && ( length <= MAX_ARRAY_SIZE ) ) { getIntArrayCache ( length ) . putArray ( array , length , fromIndex , toIndex ) ; } }
tr	G	@ SuppressWarnings ( "unchecked" ) private void limpiarButtonActionPerformed ( java . awt . event . ActionEvent evt ) { entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; }
tr	D	public static void initDrawingArea ( int height , int width , int pixels [ ] ) { DrawingArea . pixels = pixels ; DrawingArea . width = width ; DrawingArea . height = height ; setDrawingArea ( height , 0 , width , 0 ) ; }
tr	F	protected AVLNode ( Node < T > parent , T value ) { super ( parent , value ) ; }
tr	E	public float getFutureRotation ( ) { return futureRotation ; }
tr	G	private void saveButtonActionPerformed ( java . awt . event . ActionEvent evt ) { if ( nombrelaboratoriosField . getText ( ) . trim ( ) . isEmpty ( ) || telefonolaboratorios1Field . getText ( ) . trim ( ) . isEmpty ( ) || sucursalField . getText ( ) . trim ( ) . isEmpty ( ) ) { JOptionPane . showMessageDialog ( this , "Debe de llenar todos los campos marcados con * como minimo para poder guardar." , "ADVERTENCIA" , WIDTH ) ; } else { try { entityManager . getTransaction ( ) . commit ( ) ; entityManager . getTransaction ( ) . begin ( ) ; JOptionPane . showMessageDialog ( this , "Laboratorio guardado existosamente." , "Laboratorio guardado" , WIDTH ) ; entityManager . getTransaction ( ) . rollback ( ) ; entityManager . getTransaction ( ) . begin ( ) ; java . util . Collection data = query . getResultList ( ) ; for ( Object entity : data ) { entityManager . refresh ( entity ) ; } list . clear ( ) ; list . addAll ( data ) ; newButton . setEnabled ( true ) ; saveButton . setEnabled ( false ) ; } catch ( RollbackException rex ) { rex . printStackTrace ( ) ; entityManager . getTransaction ( ) . begin ( ) ; List < farmacia . Laboratorios > merged = new ArrayList < farmacia . Laboratorios > ( list . size ( ) ) ; for ( farmacia . Laboratorios l : list ) { merged . add ( entityManager . merge ( l ) ) ; } list . clear ( ) ; list . addAll ( merged ) ; newButton . setEnabled ( true ) ; } } }
tr	A	@ Override public void initTreeTraversal ( ) { try { if ( memory != null ) { memory . rewind ( ) ; return ; } if ( in != null ) { in . close ( ) ; } in = new BufferedInputStream ( new FileInputStream ( file ) ) ; b = new byte [ 3 ] ; in . read ( b ) ; type = b [ 0 ] ; b = new byte [ b [ 2 ] ] ; if ( fromMemory ) { File F = new File ( file ) ; int fs = ( int ) ( F . length ( ) - 3 ) ; System . out . println ( "allocating byte buffer of size: " + fs ) ; memory = ByteBuffer . allocateDirect ( fs ) ; System . out . println ( "Reading file contents" ) ; while ( in . read ( b ) == b . length ) { memory . put ( b ) ; } System . out . println ( "Done" ) ; memory . rewind ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
tr	J	private void salirButtonActionPerformed ( java . awt . event . ActionEvent evt ) { this . setVisible ( false ) ; }
tr	D	public void insertOrMerge ( Data ... toPersist ) throws DRUMSException , InterruptedException { try { bucketContainer . addToCache ( toPersist ) ; } catch ( BucketContainerException ex ) { throw new DRUMSException ( ex ) ; } }
tr	B	public Rectangle [ ] getRooms ( ) { Rectangle [ ] all = new Rectangle [ rooms . size ( ) ] ; rooms . toArray ( all ) ; return all ; }
va	G	private void setHumanToMove ( Game game ) { boolean w2m = ds . isWhiteToMove ( ) ; Player p = w2m ? game . first : currentGame . second ; setHumanMovesEnabled ( p . isHuman ( ) ) ; }
va	E	@ SuppressWarnings ( "unchecked" ) private void sundayActionPerformed ( java . awt . event . ActionEvent evt ) { if ( this . weekCheck [ 0 ] . isSelected ( ) ) { this . numSelected ++ ; if ( this . firstSelection ) { stretch ( ) ; } this . models [ 0 ] = new DefaultListModel < Object > ( ) ; this . weekJobList [ 0 ] . setModel ( this . models [ 0 ] ) ; this . weekScrollPane [ 0 ] . setViewportView ( this . weekJobList [ 0 ] ) ; this . weekJobName [ 0 ] . setColumns ( 20 ) ; this . weekLabel [ 0 ] . setText ( "Job Name:" ) ; this . weekAddJob [ 0 ] . setText ( "Add Job" ) ; this . weekAddJob [ 0 ] . addActionListener ( new java . awt . event . ActionListener ( ) { @ Override public void actionPerformed ( java . awt . event . ActionEvent evt ) { if ( ! Config . this . weekJobName [ 0 ] . getText ( ) . isEmpty ( ) ) { Config . this . models [ 0 ] . addElement ( Config . this . weekJobName [ 0 ] . getText ( ) ) ; Config . this . weekJobList [ 0 ] . setModel ( Config . this . models [ 0 ] ) ; Config . this . weekJobName [ 0 ] . setText ( "" ) ; } } } ) ; this . weekDeleteJob [ 0 ] . setText ( "Delete Job" ) ; this . weekDeleteJob [ 0 ] . addActionListener ( new java . awt . event . ActionListener ( ) { @ Override public void actionPerformed ( java . awt . event . ActionEvent evt ) { while ( ! Config . this . weekJobList [ 0 ] . isSelectionEmpty ( ) ) { int n = Config . this . weekJobList [ 0 ] . getSelectedIndex ( ) ; Config . this . models [ 0 ] . remove ( n ) ; } } } ) ; javax . swing . GroupLayout weekTab0Layout = new javax . swing . GroupLayout ( this . weekTab [ 0 ] ) ; this . weekTab [ 0 ] . setLayout ( weekTab0Layout ) ; weekTab0Layout . setHorizontalGroup ( weekTab0Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( weekTab0Layout . createSequentialGroup ( ) . addContainerGap ( ) . addComponent ( this . weekScrollPane [ 0 ] , javax . swing . GroupLayout . PREFERRED_SIZE , 182 , javax . swing . GroupLayout . PREFERRED_SIZE ) . addGap ( 18 , 18 , 18 ) . addGroup ( weekTab0Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( weekTab0Layout . createSequentialGroup ( ) . addComponent ( this . weekLabel [ 0 ] ) . addGroup ( weekTab0Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( weekTab0Layout . createSequentialGroup ( ) . addGap ( 14 , 14 , 14 ) . addComponent ( this . weekAddJob [ 0 ] ) ) . addGroup ( weekTab0Layout . createSequentialGroup ( ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( this . weekJobName [ 0 ] , javax . swing . GroupLayout . PREFERRED_SIZE , 100 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ) ) . addComponent ( this . weekDeleteJob [ 0 ] ) ) . addContainerGap ( 431 , short . MAX_VALUE ) ) ) ; weekTab0Layout . setVerticalGroup ( weekTab0Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addGroup ( weekTab0Layout . createSequentialGroup ( ) . addContainerGap ( ) . addGroup ( weekTab0Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING , false ) . addGroup ( weekTab0Layout . createSequentialGroup ( ) . addGroup ( weekTab0Layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . BASELINE ) . addComponent ( this . weekJobName [ 0 ] , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) . addComponent ( this . weekLabel [ 0 ] ) ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED ) . addComponent ( this . weekAddJob [ 0 ] ) . addPreferredGap ( javax . swing . LayoutStyle . ComponentPlacement . RELATED , javax . swing . GroupLayout . DEFAULT_SIZE , short . MAX_VALUE ) . addComponent ( this . weekDeleteJob [ 0 ] ) ) . addComponent ( this . weekScrollPane [ 0 ] , javax . swing . GroupLayout . PREFERRED_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . PREFERRED_SIZE ) ) . addContainerGap ( 25 , short . MAX_VALUE ) ) ) ; this . dayTabs . addTab ( "Sunday" , this . weekTab [ 0 ] ) ; } else { this . numSelected -- ; stretch ( ) ; this . dayTabs . remove ( this . weekTab [ 0 ] ) ; } }
va	J	public Directive ( int column , int direction ) { this . column = column ; this . direction = direction ; }
va	F	private void fireCalendarChanged ( ) { Iterator i = changeListeners . iterator ( ) ; while ( i . hasNext ( ) ) { ChangeListener cl = ( ChangeListener ) i . next ( ) ; cl . stateChanged ( new ChangeEvent ( this ) ) ; } }
va	I	@ Test public void canUpdateCategory ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory = new CategoryModel ( "toAddCategory" , generatedStaffId ) ; CategoryModel updateCategory = null ; CategoryModel retrieved = null ; try { addCategory = insertCategory ( addCategory ) ; updateCategory = new CategoryModel ( addCategory . getId ( ) , "categoryUpdated" , generatedStaffId ) ; cd . updateCategory ( updateCategory ) ; retrieved = getCategoryByName ( "categoryUpdated" ) ; deleteCategoryById ( addCategory . getId ( ) ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; fail ( "Exception" ) ; } assertEquals ( addCategory , retrieved ) ; }
va	G	private void term ( ) { TokenType [ ] op = new TokenType [ ] { TokenType . SSTAR , TokenType . SDIVD , TokenType . SMOD , TokenType . SAND } ; factor ( ) ; while ( whenToken ( op ) ) { factor ( ) ; } }
va	H	public static void triangle1 ( String s ) { char c [ ] = s . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { System . out . println ( ) ; for ( int j = 0 ; j <= i ; j ++ ) { System . out . print ( c [ j ] ) ; } } }
va	C	public static byte [ ] pkcs1Sign ( PrivateKey key , byte [ ] text ) { try { Cipher c = Cipher . getInstance ( "RSA/ECB/PKCS1Padding" ) ; c . init ( Cipher . ENCRYPT_MODE , key ) ; return c . doFinal ( text ) ; } catch ( Exception e ) { return null ; } }
va	F	public boolean turnIsTerminated ( ) { return this . currentTurn . terminatedCorrect ; }
va	G	public boolean containsKey ( Object key ) { return get ( tree , key ) != NO_ELEMENT ; }
va	A	@ Override public int hashCode ( ) { return hasher . hashFor ( wrapped ) ; }
va	E	@ Override public int getTotalTime ( ) { return 0 ; }
va	J	public void drawImage ( BufferedImage canvas ) { BufferedImage image = decompressImage ( _image ) ; Graphics2D g = canvas . createGraphics ( ) ; g . drawImage ( image , 0 , 0 , null ) ; }
va	B	public void setMaxDamage ( int maxDamage ) { this . maxDamage = maxDamage ; }
va	G	public ArrayList < ConnectedComponent > findComponents ( ) { _edges = findEdges ( ) ; for ( int y = _groundLevel - 1 ; y > 0 ; y -- ) for ( int x = 0 ; x < _width ; x ++ ) { if ( ! ( _class [ y ] [ x ] >= ICE && _class [ y ] [ x ] <= STONE ) ) continue ; if ( _edges [ y ] [ x ] ) _class [ y ] [ x ] = EDGE ; } _components = new ArrayList < ConnectedComponent > ( ) ; boolean searched [ ] [ ] = new boolean [ _height ] [ _width ] ; for ( int x = 50 ; x < _width - 50 ; x ++ ) for ( int y = _groundLevel - 1 ; y > _height * 0.2 ; y -- ) { int cls = _class [ y ] [ x ] ; if ( ! searched [ y ] [ x ] && cls > GROUND && cls < EDGE ) { ConnectedComponent cc ; if ( cls >= SLING && cls <= BLACK_BIRD ) cc = new ConnectedComponent ( _class , x , y , searched , true ) ; else cc = new ConnectedComponent ( _class , x , y , searched , false ) ; if ( cc . getArea ( ) >= MIN_SIZE [ cls ] && cc . getArea ( ) <= MAX_SIZE [ cls ] ) _components . add ( cc ) ; } } return _components ; }
va	F	private void fireMonthTextFieldsUpdate ( ) { Iterator i = monthLabels . iterator ( ) ; JLabel label ; DateFormatSymbols df ; while ( i . hasNext ( ) ) { label = ( JLabel ) i . next ( ) ; df = new DateFormatSymbols ( DEFAULT_LOCALE ) ; label . setText ( df . getMonths ( ) [ calendar . get ( Calendar . MONTH ) ] ) ; } }
va	J	private boolean solveWithBacktrackingRecursive ( int currentElementNumber , boolean guessRandomly ) { Set < Integer > validElements = getValidValuesForElementWithNumber ( currentElementNumber ) ; if ( validElements . size ( ) < 1 ) { return false ; } else { while ( validElements . size ( ) > 0 ) { int nextIndex ; if ( guessRandomly ) { nextIndex = randomNumberGenerator . nextInt ( validElements . size ( ) ) ; } else { nextIndex = 0 ; } Integer validElement = null ; int currentIndex = 0 ; for ( Integer validElementC : validElements ) { if ( nextIndex == currentIndex ) { validElement = validElementC ; break ; } currentIndex ++ ; } setElementWithNumber ( currentElementNumber , validElement ) ; try { if ( ! solveWithBacktrackingRecursive ( getNextMostConstrainedEmptyElementNumber ( ) , guessRandomly ) ) { validElements . remove ( validElement ) ; } else { return true ; } } catch ( NoElementsEmptyException e ) { return true ; } } emptyElementWithNumber ( currentElementNumber ) ; return false ; } }
va	D	public void actionPerformed ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) . equals ( nextMonthButton ) ) { GregorianCalendar cal = ( GregorianCalendar ) calendarModel . getCalendarClone ( ) ; int day = cal . get ( Calendar . DATE ) ; cal . set ( cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) + 1 , 1 ) ; if ( day > cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) { cal . set ( Calendar . DATE , cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; } else { cal . set ( Calendar . DATE , day ) ; } calendarModel . setCalendar ( cal . getTime ( ) ) ; } else if ( arg0 . getSource ( ) . equals ( previousMonthButton ) ) { GregorianCalendar cal = ( GregorianCalendar ) calendarModel . getCalendarClone ( ) ; int day = cal . get ( Calendar . DATE ) ; cal . set ( cal . get ( Calendar . YEAR ) , cal . get ( Calendar . MONTH ) - 1 , 1 ) ; if ( day > cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) { cal . set ( Calendar . DATE , cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; } else { cal . set ( Calendar . DATE , day ) ; } calendarModel . setCalendar ( cal . getTime ( ) ) ; } else { for ( int month = 0 ; month < monthPopupMenuItems . length ; month ++ ) { if ( arg0 . getSource ( ) . equals ( monthPopupMenuItems [ month ] ) ) { GregorianCalendar cal = ( GregorianCalendar ) calendarModel . getCalendarClone ( ) ; int day = cal . get ( Calendar . DATE ) ; cal . set ( cal . get ( Calendar . YEAR ) , month , 1 ) ; if ( day > cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) { cal . set ( Calendar . DATE , cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ) ; } else { cal . set ( Calendar . DATE , day ) ; } calendarModel . setCalendar ( cal . getTime ( ) ) ; } } } }
va	A	private void excuteMethod ( Message m , boolean fstatic ) { Object res = null ; Object id = null ; try { Object [ ] params = ( Object [ ] ) m . getData ( ) ; id = params [ 0 ] ; String className = ( String ) params [ 1 ] ; params = params . length > 2 ? ( Object [ ] ) params [ 2 ] : null ; class < ? > clazz = class . forName ( className ) ; Method method = clazz . getMethod ( fstatic ? "executeStatic" : "execute" , new class [ ] { Object . class } ) ; if ( Modifier . isStatic ( method . getModifiers ( ) ) == fstatic ) { Object target = fstatic ? null : clazz . newInstance ( ) ; res = method . invoke ( target , params ) ; } } catch ( Exception e ) { res = e ; } DefaultMessage dm = new DefaultMessage ( "executeComplete" , new Object [ ] { id , res } ) ; getManager ( ) . send ( dm , this , m . getSource ( ) ) ; }
va	J	public boolean importData ( TransferSupport support ) { if ( ! canImport ( support ) ) return false ; Transferable transferable = support . getTransferable ( ) ; try { ArrayList < Object > data = ( ArrayList < Object > ) transferable . getTransferData ( new DataFlavor ( DataFlavor . javaJVMLocalObjectMimeType + ";class=java.util.ArrayList" ) ) ; JList . DropLocation location = ( JList . DropLocation ) support . getDropLocation ( ) ; for ( int i = 0 ; i < data . size ( ) ; ++ i ) { if ( data . get ( i ) instanceof Song ) { ( ( DefaultListModel ) _myList . getModel ( ) ) . insertElementAt ( ( Song ) data . get ( i ) , location . getIndex ( ) ) ; } else if ( data . get ( i ) instanceof Playlist ) { while ( ( ( Playlist ) data . get ( i ) ) . hasNext ( ) ) { Song current = ( ( Playlist ) data . get ( i ) ) . getNext ( ) ; ( ( DefaultListModel ) _myList . getModel ( ) ) . insertElementAt ( current , location . getIndex ( ) ) ; } ( ( Playlist ) data . get ( i ) ) . reset ( ) ; } } } catch ( UnsupportedFlavorException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } return true ; }
va	H	public static void triangle4 ( String s ) { char c [ ] = s . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { System . out . println ( ) ; for ( int j = 0 ; j < c . length ; j ++ ) { if ( j < ( c . length - i ) ) { System . out . print ( c [ j ] ) ; } else { System . out . print ( " " ) ; } } for ( int j = 0 ; j < c . length ; j ++ ) { if ( i <= j ) { System . out . print ( c [ j ] ) ; } else { System . out . print ( " " ) ; } } } }
va	I	protected void removeValueForElementWithNumber ( int elementNumber , int elementValue ) { eliminatedValues . get ( elementNumber ) . add ( elementValue ) ; validElementsCache . get ( elementNumber ) . remove ( elementValue ) ; }
va	H	@ Test public void canGetProductsByCategory ( ) { List < Integer > categories = new ArrayList < > ( ) ; categories . add ( CategoryJUnit . getACategory ( ) ) ; ProductModel addedProduct = ProductModel . builder ( "Night Visions" , 1 ) . description ( "Imagine Dragons" ) . cost ( 149 ) . rrp ( 400 ) . categories ( categories ) . build ( ) ; List < ProductModel > products = null ; boolean isInResult = false ; try { addedProduct = new ProductModel ( insertProduct ( addedProduct ) , addedProduct ) ; products = pd . getProductsByCategory ( addedProduct . getCategories ( ) . get ( 0 ) ) ; for ( ProductModel product : products ) { if ( addedProduct . equals ( product ) ) { isInResult = true ; break ; } } deleteProduct ( addedProduct . getId ( ) ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; } assertTrue ( isInResult ) ; }
va	H	@ Test public void canGetProductByNonExcistingCost ( ) { List < ProductModel > products = new ArrayList < > ( ) ; try { products = pd . getProductsByCost ( 123456 ) ; } catch ( WebshopAppException e ) { } assertTrue ( ( products != null ) && ( products . size ( ) == 0 ) ) ; }
va	F	public void removeCurrentTurn ( ) { Turn toRemove = this . turns . get ( this . turns . size ( ) - 1 ) ; if ( ! toRemove . terminatedCorrect ) { this . turns . remove ( toRemove ) ; startTurn ( ) ; } }
va	F	private void addTower ( int x , int y ) { TowerEntity entity = new TowerEntity ( x , y , grid , attract_tower , avoid_tower , resource_grid ) ; entity . autoFinish ( ) ; entities . add ( entity ) ; }
va	B	public void setMinDamage ( int minDamage ) { this . minDamage = minDamage ; }
va	G	@ Override public void onAIMove ( Move m ) { animateMove ( m ) ; setHumanToMove ( currentGame ) ; }
va	G	@ Override public void terminateLastTurn ( ) { this . currentTurn . terminatedCorrect = true ; }
va	F	public void addTodayLabel ( JLabel label ) { DateFormat df1 = DateFormat . getDateInstance ( dateFormat , DEFAULT_LOCALE ) ; label . setText ( TODAY + df1 . format ( new Date ( ) ) ) ; }
va	C	public Integer incLevelStage ( ) { return ++ levelStage ; }
va	B	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn == null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . add ( myconn ) ; dbPoolSize ++ ; dbPoolIdleSize ++ ; } CDbError . logError ( errfile , false , "Initial database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
va	D	public void addThrow ( int i ) { this . alreadyReceivedScoreEvents = true ; throwz . add ( i ) ; }
va	D	private StringBuilder getBody1 ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "<body>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<header>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( this . getMenu ( ) ) ; sb . append ( "</header>" ) ; Utils . appendNewLine ( sb ) ; if ( this . company != null ) { sb . append ( "<main itemscope itemtype=\"http://schema.org/LocalBusiness\">" ) ; } else { sb . append ( "<main>" ) ; } Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"row\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<div class=\"large-12 columns\">" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "<h1>" ) ; sb . append ( this . h1 ) ; sb . append ( "</h1>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( this . getBreadCrumbs ( ) ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; sb . append ( "</div>" ) ; Utils . appendNewLine ( sb ) ; return sb ; }
va	A	public static void setHasher ( Hasher toUse ) { hasher = toUse ; }
va	E	public void mouseExited ( MouseEvent arg0 ) { }
va	A	public Circle smallCopy ( ) { Circle w = new Circle ( this . x , this . y - 20 , this . width / 2 , this . height / 2 ) ; return w ; }
va	F	public void addTableModelListener ( TableModelListener arg0 ) { tableModelListeners . add ( arg0 ) ; }
va	F	public void updateHUD ( ) { score_label . setText ( "Score: " + score ) ; mode_label . setText ( "Mode: " + mode ) ; farmed_label . setText ( "Food: " + resources [ ResourceGrid . FOOD ] ) ; mined_label . setText ( "Minerals: " + resources [ ResourceGrid . MINERALS ] ) ; pack ( ) ; }
va	I	public static BLOBEnables parseBLOBEnable ( String BLOBEnable ) throws IllegalArgumentException { if ( BLOBEnable . compareTo ( "Never" ) == 0 ) { return BLOBEnables . NEVER ; } else if ( BLOBEnable . compareTo ( "Also" ) == 0 ) { return BLOBEnables . ALSO ; } else if ( BLOBEnable . compareTo ( "Only" ) == 0 ) { return BLOBEnables . ONLY ; } throw new IllegalArgumentException ( "Invalid BLOBEnable String: '" + BLOBEnable + "'" ) ; }
va	F	public boolean alreadyReceivedScoreEvents ( ) { return this . currentTurn . alreadyReceivedScoreEvents ; }
va	F	public void reopenTurn ( ) { if ( this . currentTurn . closedWithUnthrownDarts ) { this . currentTurn . closedWithUnthrownDarts = false ; } if ( this . currentTurn . closedWithoutThrownDarts ) { removeCurrentTurn ( ) ; if ( this . turns . size ( ) > 0 ) { this . currentTurn = this . turns . get ( this . turns . size ( ) - 1 ) ; } else { startTurn ( ) ; } } }
va	I	public ConstraintPuzzle getSolution ( ) { ConstraintPuzzle copy = ConstraintPuzzle . getCopy ( this ) ; copy . solveWithBacktracking ( ) ; return copy ; }
va	J	private void resetLastInvalidOnParent ( Container parent ) { while ( parent != null ) { LayoutManager layoutManager = parent . getLayout ( ) ; if ( layoutManager instanceof MigLayout ) { ( ( MigLayout ) layoutManager ) . lastWasInvalid = false ; } parent = parent . getParent ( ) ; } }
va	A	@ Override public void runTest ( ) { TreeNode root = new TreeNode ( 1 ) ; TreeNode t = new TreeNode ( 2 ) ; root . left = t ; t = new TreeNode ( 3 ) ; root . right = t ; t = new TreeNode ( 4 ) ; root . left . left = t ; t = new TreeNode ( 5 ) ; root . left . right = t ; t = new TreeNode ( 6 ) ; root . right . right = t ; t = new TreeNode ( 7 ) ; root . left . left . left = t ; t = new TreeNode ( 8 ) ; root . right . right . right = t ; List < Integer > res = new ArrayList < > ( ) ; res = preorderTraversal ( root ) ; for ( int i : res ) dbg ( i ) ; }
va	G	public static String getPropertyStateAsString ( PropertyStates propertyState ) { if ( propertyState == PropertyStates . ALERT ) { return "Alert" ; } else if ( propertyState == PropertyStates . BUSY ) { return "Busy" ; } else if ( propertyState == PropertyStates . OK ) { return "Ok" ; } else if ( propertyState == PropertyStates . IDLE ) { return "Idle" ; } return "" ; }
va	C	public static boolean pkcs1Verify ( PublicKey key , byte [ ] text , byte [ ] signature , boolean sha256 ) { String algName = sha256 ? "SHA256withRSA" : "SHA1withRSA" ; try { Signature s = Signature . getInstance ( algName ) ; s . initVerify ( key ) ; s . update ( text ) ; return s . verify ( signature ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } }
va	J	private byte [ ] gb ( BigInteger num ) { byte [ ] bytes = num . toByteArray ( ) ; if ( bytes . length == 3 || bytes . length % 8 == 0 ) { return bytes ; } byte [ ] result = new byte [ bytes . length - 1 ] ; System . arraycopy ( bytes , 1 , result , 0 , result . length ) ; return result ; }
va	F	public void addMonthLabel ( JLabel label ) { monthLabels . add ( label ) ; fireMonthTextFieldsUpdate ( ) ; }
va	D	public void setLang ( String lang ) { this . lang = lang ; }
va	G	private void pause ( ) { switch ( _current ) { case STOP : case PAUSE : break ; case PLAY : _player . pause ( ) ; _current = Status . PAUSE ; _playPause . setIcon ( _playEnabled ) ; _playPause . setToolTipText ( "Play" ) ; _playPause . removeActionListener ( _pause ) ; _playPause . addActionListener ( _play ) ; break ; } }
va	G	public Map . Entry < Key , Val > arb ( ) { if ( tree == null ) throw new NoSuchElementException ( ) ; else if ( ! ( tree instanceof Node ) ) { Object [ ] ary = ( Object [ ] ) tree ; int len = ary . length , nkeys = len >> 1 , idx = nkeys >> 1 ; return ( Map . Entry < Key , Val > ) new Entry ( ary [ idx ] , ary [ idx + nkeys ] ) ; } else { Node node = ( Node ) tree ; if ( node . key instanceof EquivalentMap ) return ( Map . Entry < Key , Val > ) ( ( EquivalentMap ) node . key ) . contents . get ( 0 ) ; else return ( Map . Entry < Key , Val > ) node ; } }
va	D	public void set ( int index , T value ) { if ( index >= size ) { throw new IndexOutOfBoundsException ( "index can't be >= size: " + index + " >= " + size ) ; } items [ index ] = value ; }
va	D	public void setVerifiedType ( int verifiedType ) { this . verifiedType = verifiedType ; }
va	C	public static void drawUnfilledRectangle ( int i , int j , int k , int l , int i1 ) { drawHorizontalLine ( i1 , i , j , l ) ; drawHorizontalLine ( ( i1 + k ) - 1 , i , j , l ) ; drawVerticalLine ( i , i1 , k , l ) ; drawVerticalLine ( ( i + j ) - 1 , i1 , k , l ) ; }
va	B	public String inventoryName ( ) { Weapon equippedWeapon = Controller . getInstance ( ) . getPlayer ( ) . getEquippedWeapon ( ) ; if ( equippedWeapon != null && equippedWeapon . equals ( this ) ) return this . getName ( ) + " (currently equipped)" ; else return this . getName ( ) ; }
va	J	@ Test public void canUpdateCategoryWithNull ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel updateCategory = null ; boolean wasException = false ; try { cd . updateCategory ( updateCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } assertTrue ( wasException ) ; }
va	G	private int nextIndex ( int status ) { if ( status == BattleShipStatus . SHIP_MISSED ) { if ( currentIndex == 3 ) { currentIndex = 1 ; return currentIndex ; } else { currentIndex = currentIndex + 1 ; return currentIndex ; } } if ( status == BattleShipStatus . FLEET_DESTROYED ) { fleetDestroyed = true ; this . state = BattleShipPeer . DESTROYED ; } return currentIndex ; }
va	J	public static boolean isValidBLOBEnable ( String BLOBEnable ) { try { parseBLOBEnable ( BLOBEnable ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
va	D	public void setStatus ( Status status ) { this . status = status ; }
va	A	public Circle ( int x , int y , int w , int h ) { this . x = x ; this . y = y + 20 ; this . width = w ; this . height = h ; this . state = 0 ; }
va	F	public void fireCalendarInvalidated ( ) { fireCalendarChanged ( ) ; fireTableModelEvent ( ) ; fireMonthTextFieldsUpdate ( ) ; }
va	A	public static void sortTopicsList ( ArrayList < TopicOutput > list ) { Collections . sort ( list , new MyComparator ( ) ) ; }
va	H	private int processORInst ( OR or ) { String opCode = or . getOpcode ( ) . name ( ) ; int instOrder = or . getOrder ( ) ; String src1n = "" ; String src2n = "" ; if ( or . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( or . getSrc1 ( ) , or ) ; boolean src2 = ! dataHaz . checkRAWHazard ( or . getSrc2 ( ) , or ) ; if ( src1 && src2 ) { long src1v = regMem . getRegValue ( or . getSrc1 ( ) . getId ( ) ) ; long src2v = regMem . getRegValue ( or . getSrc2 ( ) . getId ( ) ) ; or . getSrc1 ( ) . setValue ( src1v . intValue ( ) ) ; or . getSrc2 ( ) . setValue ( src2v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + or . getSrc1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Source2 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + or . getSrc2 ( ) . getId ( ) . name ( ) ) ; or . clearRawHazard ( ) ; or . setState ( State . READ ) ; } else { or . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( or . getRawInst ( ) ) ; if ( ! src1 ) { src1n = or . getSrc1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " is already busy. RAW hazard detected." ) ; } if ( ! src2 ) { src2n = or . getSrc2 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src2n + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
va	A	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
va	I	void read_string ( int del , Token token ) { save_and_next ( ) ; while ( current != del ) { switch ( current ) { case EOZ : lexerror ( "unfinished string" , TK_EOS ) ; continue ; case  : case  : lexerror ( "unfinished string" , TK_STRING ) ; continue ; case \ : { int c ; nextChar ( ) ; switch ( current ) { case a : c =  ; break ; case b : c =  ; break ; case f : c =  ; break ; case n : c =  ; break ; case r : c =  ; break ; case t : c = 	 ; break ; case v : c =  ; break ; case  : case  : save (  ) ; inclinenumber ( ) ; continue ; case EOZ : continue ; default : { if ( ! isdigit ( current ) ) save_and_next ( ) ; else { int i = 0 ; c = 0 ; do { c = 10 * c + ( current - 0 ) ; nextChar ( ) ; } while ( ++ i < 3 && isdigit ( current ) ) ; if ( c > UCHAR_MAX ) lexerror ( "escape sequence too large" , TK_STRING ) ; save ( c ) ; } continue ; } } save ( c ) ; nextChar ( ) ; continue ; } default : save_and_next ( ) ; } } save_and_next ( ) ; token . ts = newstring ( buff , 1 , nbuff - 2 ) ; }
va	B	public boolean isPowered ( ) { return powered ; }
va	H	void read_numeral ( Token token ) { FuncState . _assert ( isdigit ( current ) ) ; do { save_and_next ( ) ; } while ( isdigit ( current ) || current == . ) ; if ( check_next ( "Ee" ) ) check_next ( "+-" ) ; while ( isalnum ( current ) || current == _ ) save_and_next ( ) ; String str = new String ( buff , 0 , nbuff ) ; str2d ( str , token ) ; }
va	B	public void setDamageMsg ( String damageMsg ) { this . damageMsg = damageMsg ; }
va	I	private void remove ( ) { if ( ! _myList . isSelectionEmpty ( ) ) { ( ( DefaultListModel ) _myList . getModel ( ) ) . remove ( _myList . getSelectedIndex ( ) ) ; } }
va	F	public void startGame ( ) { global_events = new LinkedList < GlobalEvent > ( ) ; global_events_buffer = new LinkedList < GlobalEvent > ( ) ; selected = new LinkedList < Entity > ( ) ; game_thread = new GameThread ( ) ; game_thread . start ( ) ; }
va	J	@ Test public void canUpdateCategoryWithNullName ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addedCategory = new CategoryModel ( "toAddCategory" , generatedStaffId ) ; CategoryModel updatedCategory = new CategoryModel ( null , generatedStaffId ) ; boolean wasException = false ; try { addedCategory = insertCategory ( addedCategory ) ; updatedCategory = new CategoryModel ( addedCategory . getId ( ) , updatedCategory ) ; cd . updateCategory ( updatedCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } deleteCategoryById ( addedCategory . getId ( ) ) ; assertTrue ( wasException ) ; }
va	G	private void factor ( ) { Token t = popToken ( ) ; switch ( t . getTokenType ( ) ) { case SCONSTANT : case SSTRING : case SFALSE : case STRUE : break ; case SIDENTIFIER : pushToken ( t ) ; variable ( ) ; break ; case SLPAREN : expression ( ) ; expectToken ( TokenType . SRPAREN ) ; break ; case SNOT : factor ( ) ; break ; default : fail ( t ) ; } }
va	C	public ArrayList < ILevelPack > getLevelPacks ( final Integer levelStage ) { if ( isLevelStageNotValid ( levelStage ) || levelStageMap == null ) { return null ; } return getLevelStageMap ( ) . get ( levelStage ) ; }
va	E	public void mouseClicked ( MouseEvent arg0 ) { if ( arg0 . getSource ( ) . equals ( monthLabel ) ) { getMonthPopupMenu ( ) . setLightWeightPopupEnabled ( false ) ; monthPopupMenu . show ( ( Component ) arg0 . getSource ( ) , arg0 . getX ( ) , arg0 . getY ( ) ) ; } else if ( arg0 . getSource ( ) . equals ( todayLabel ) ) { calendarModel . setCalendar ( new Date ( ) ) ; } else if ( arg0 . getSource ( ) . equals ( dayTable ) ) { int row = dayTable . getSelectedRow ( ) ; int col = dayTable . getSelectedColumn ( ) ; if ( row >= 0 && row <= 5 ) { Integer date = ( Integer ) calendarModel . getValueAt ( row , col ) ; calendarModel . setCalendar ( Calendar . DAY_OF_MONTH , date . intValue ( ) ) ; fireActionPerformed ( ) ; } } }
va	A	public boolean isCellEditable ( int x , int y ) { return false ; }
va	D	public void save ( ) { float HSB [ ] = Color . RGBtoHSB ( 255 , 0 , 0 , null ) ; Color red = Color . getHSBColor ( HSB [ 0 ] , HSB [ 1 ] / 5 , HSB [ 2 ] ) ; if ( _song != null ) { boolean valid = true ; if ( _artist . getText ( ) . isEmpty ( ) ) { _artist . setBackground ( red ) ; valid = false ; } else { _artist . setBackground ( Color . WHITE ) ; } if ( _title . getText ( ) . isEmpty ( ) ) { _title . setBackground ( red ) ; valid = false ; } else { _title . setBackground ( Color . WHITE ) ; } if ( _album . getText ( ) . isEmpty ( ) ) { _title . setBackground ( red ) ; valid = false ; } else { _title . setBackground ( Color . WHITE ) ; } if ( _genre . getText ( ) . isEmpty ( ) ) { _genre . setBackground ( red ) ; valid = false ; } else { _genre . setBackground ( Color . WHITE ) ; } if ( _year . getText ( ) . isEmpty ( ) ) { _year . setBackground ( red ) ; valid = false ; } try { Integer . parseInt ( _year . getText ( ) ) ; _year . setBackground ( Color . WHITE ) ; } catch ( NumberFormatException e ) { _year . setBackground ( red ) ; valid = false ; } if ( valid ) { getChildren ( ( DefaultMutableTreeNode ) ( ( DefaultMutableTreeNode ) _model . getRoot ( ) ) . getChildAt ( 0 ) ) ; getChildren ( ( DefaultMutableTreeNode ) ( ( DefaultMutableTreeNode ) _model . getRoot ( ) ) . getChildAt ( 1 ) ) ; System . out . println ( _children . size ( ) ) ; for ( DefaultMutableTreeNode child : _children ) { ( ( Song ) child . getUserObject ( ) ) . setArtist ( _artist . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setTitle ( _title . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setAlbum ( _album . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setGenre ( _genre . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . setYear ( _year . getText ( ) ) ; ( ( Song ) child . getUserObject ( ) ) . save ( ) ; _model . nodeChanged ( child ) ; } _children . clear ( ) ; } } else { if ( _name . getText ( ) . isEmpty ( ) ) { _name . setBackground ( red ) ; } Enumeration < TreeNode > playlists = _node . getParent ( ) . children ( ) ; boolean exists = false ; while ( playlists . hasMoreElements ( ) ) { Playlist temp = ( Playlist ) ( ( DefaultMutableTreeNode ) playlists . nextElement ( ) ) . getUserObject ( ) ; if ( temp . equals ( new Playlist ( _name . getText ( ) ) ) && ! temp . equals ( _playlist ) ) exists = true ; } if ( ! exists ) { _name . setBackground ( Color . WHITE ) ; _playlist . setName ( _name . getText ( ) ) ; _model . nodeChanged ( _node ) ; } else { _name . setBackground ( red ) ; } } }
va	D	public void setAllowAllComment ( boolean allowAllComment ) { this . allowAllComment = allowAllComment ; }
va	I	private int processANDIInst ( ANDI andi ) { String opCode = andi . getOpcode ( ) . name ( ) ; int instOrder = andi . getOrder ( ) ; String src1n = "" ; if ( andi . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( andi . getSrc1 ( ) , andi ) ; if ( src1 ) { long src1v = regMem . getRegValue ( andi . getSrc1 ( ) . getId ( ) ) ; andi . getSrc1 ( ) . setValue ( src1v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + andi . getSrc1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Immidiate value is: " + opCode + "[" + instOrder + "]" + andi . getValue ( ) ) ; andi . clearRawHazard ( ) ; andi . setState ( State . READ ) ; } else { andi . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( andi . getRawInst ( ) ) ; if ( ! src1 ) { src1n = andi . getSrc1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " " + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
va	H	public String toString ( ) { Node < E > cursor = this . head ; String currsize = "[" + this . getSize ( ) + "]: " ; StringBuilder result = new StringBuilder ( ) ; result . append ( currsize ) ; System . out . println ( "------------------------------------------------------------" ) ; for ( int i = 0 ; i < this . size ; i ++ ) { result . append ( cursor . item . toString ( ) ) ; System . out . println ( cursor . getNext ( ) ) ; if ( ! cursor . getNext ( ) . empty ( ) ) { result . append ( " > " ) ; } cursor = cursor . getNext ( ) ; } return result . toString ( ) ; }
va	G	private void play ( ) { switch ( _current ) { case STOP : if ( _myList . getModel ( ) . getSize ( ) == 0 ) break ; if ( _myList . isSelectionEmpty ( ) ) _index = 0 ; else _index = _myList . getSelectedIndex ( ) ; _playPause . setIcon ( _pauseEnabled ) ; _playPause . setToolTipText ( "Pause" ) ; _playPause . removeActionListener ( _play ) ; _playPause . addActionListener ( _pause ) ; playSong ( _myList . getModel ( ) . getElementAt ( _index ) ) ; break ; case PAUSE : _player . play ( ) ; _current = Status . PLAY ; _playPause . setIcon ( _pauseEnabled ) ; _playPause . setToolTipText ( "Pause" ) ; _playPause . removeActionListener ( _play ) ; _playPause . addActionListener ( _pause ) ; break ; case PLAY : break ; } }
va	H	protected void loadIndex ( ) throws IOException { index = new HashMap ( ) ; File idx = new File ( db , FILE_INDEX ) ; BufferedReader reader = new BufferedReader ( new FileReader ( idx ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { String [ ] fields = split ( line , " " ) ; index . put ( fields [ 0 ] , new int [ ] { Integer . parseInt ( fields [ 1 ] ) , Integer . parseInt ( fields [ 2 ] ) } ) ; } reader . close ( ) ; }
va	E	public void stateChanged ( ChangeEvent arg0 ) { if ( arg0 . getSource ( ) . equals ( calendarModel ) ) { Iterator i = getChangeListeners ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { ChangeListener cl = ( ChangeListener ) i . next ( ) ; cl . stateChanged ( new ChangeEvent ( JDatePanel . this ) ) ; } } }
va	C	void dispose ( ) { if ( ! USE_CACHE_HARD_REF ) { hardRefArrayCaches = null ; } if ( dirty ) { this . nPCPathIterator . dispose ( ) ; this . nPQPathIterator . dispose ( ) ; this . dasher . dispose ( ) ; this . stroker . dispose ( ) ; dirty = false ; } }
va	D	public void setAvatarLarge ( String avatarLarge ) { this . avatarLarge = avatarLarge ; }
va	A	public void agregarele ( String e ) { if ( this . size < this . Maxsize ) { this . lista [ this . size ] = e ; this . size ++ ; } else { throw new Error ( "Lista fuera de rango" ) ; } }
va	E	@ Override public Date getDateTime ( ) { return this . time ; }
va	C	protected boolean computeCell ( int col , int row ) { boolean liveCell = getCell ( col , row ) ; int neighbours = countNeighbours ( col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) nextCell = false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
va	B	public void setState ( int value ) { this . state = value ; }
va	D	public void swap ( int first , int second ) { if ( first >= size ) { throw new IndexOutOfBoundsException ( "first can't be >= size: " + first + " >= " + size ) ; } if ( second >= size ) { throw new IndexOutOfBoundsException ( "second can't be >= size: " + second + " >= " + size ) ; } T [ ] items = this . items ; T firstValue = items [ first ] ; items [ first ] = items [ second ] ; items [ second ] = firstValue ; }
va	J	public static String getBLOBEnableAsString ( BLOBEnables BLOBEnable ) { if ( BLOBEnable == BLOBEnables . NEVER ) { return "Never" ; } else if ( BLOBEnable == BLOBEnables . ALSO ) { return "Also" ; } else if ( BLOBEnable == BLOBEnables . ONLY ) { return "Only" ; } return "" ; }
va	E	public boolean isAllowAllActMsg ( ) { return allowAllActMsg ; }
va	D	public void setFollowMe ( boolean followMe ) { this . followMe = followMe ; }
va	E	public void setTime ( Date time ) { this . time = time ; }
va	B	public void setPowered ( boolean powered ) { this . powered = powered ; }
va	E	public int getThrowCount ( ) { if ( closedWithUnthrownDarts ) { return 3 ; } return this . throwz . size ( ) ; }
va	B	public boolean encontrarele ( String nombre ) { int i = 0 ; while ( i < this . size ) { if ( nombre == this . lista [ i ] ) { return true ; } else { ++ i ; } } return false ; }
va	A	@ Override protected Node < T > addValue ( T id ) { Node < T > nodeToReturn = super . addValue ( id ) ; AVLNode < T > nodeAdded = ( AVLNode < T > ) nodeToReturn ; while ( nodeAdded != null ) { nodeAdded . updateHeight ( ) ; balanceAfterInsert ( nodeAdded ) ; nodeAdded = ( AVLNode < T > ) nodeAdded . parent ; } return nodeToReturn ; }
va	I	private void shuffle ( ) { Random rand = new Random ( ) ; int size = _myList . getModel ( ) . getSize ( ) ; for ( int i = 0 ; i < size ; ++ i ) { int destination = rand . nextInt ( size ) ; if ( i == _index ) _index = destination ; else if ( destination == _index ) _index = i ; Song temp = _myList . getModel ( ) . getElementAt ( i ) ; ( ( DefaultListModel ) _myList . getModel ( ) ) . setElementAt ( _myList . getModel ( ) . getElementAt ( destination ) , i ) ; ( ( DefaultListModel ) _myList . getModel ( ) ) . setElementAt ( temp , destination ) ; } }
va	G	public static boolean isValidPropertyState ( String state ) { try { parsePropertyState ( state ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
va	F	public void reopenTurn ( ) { if ( this . currentTurn . closedWithUnthrownDarts ) { this . currentTurn . closedWithUnthrownDarts = false ; } if ( this . currentTurn . closedWithoutThrownDarts ) { removeCurrentTurn ( ) ; if ( this . turns . size ( ) > 0 ) { this . currentTurn = this . turns . get ( this . turns . size ( ) - 1 ) ; } else { startTurn ( ) ; } } }
va	G	@ Override public void onStartGame ( Game g ) { currentGame = g ; reset ( currentGame ) ; setOptionsEnabled ( false ) ; }
va	G	public boolean isEmpty ( ) { return tree == null ; }
va	H	private int [ ] getStartPosAndLen ( String code ) { while ( code . length ( ) > 0 ) { int [ ] posLen = ( int [ ] ) index . get ( code ) ; if ( posLen == null ) { code = code . substring ( 0 , code . length ( ) - 1 ) ; } else { return posLen ; } } return null ; }
va	H	void read_long_string ( Token token , int sep ) { save_and_next ( ) ; if ( currIsNewline ( ) ) inclinenumber ( ) ; for ( boolean endloop = false ; ! endloop ; ) { switch ( current ) { case EOZ : lexerror ( ( token != null ) ? "unfinished long string" : "unfinished long comment" , TK_EOS ) ; break ; case [ : { if ( skip_sep ( ) == sep ) { save_and_next ( ) ; } break ; } case ] : { if ( skip_sep ( ) == sep ) { save_and_next ( ) ; endloop = true ; } break ; } case  : case  : { save (  ) ; inclinenumber ( ) ; if ( token == null ) nbuff = 0 ; break ; } default : { if ( token != null ) save_and_next ( ) ; else nextChar ( ) ; } } } if ( token != null ) token . ts = newstring ( buff , 2 + sep , nbuff - 2 * ( 2 + sep ) ) ; }
va	A	public static Weapon applySpecialTraits ( Weapon weapon , String [ ] traits ) { for ( String trait : traits ) { String t = trait . trim ( ) ; if ( t . equals ( "Powered" ) ) { weapon = new PoweredWeapon ( weapon ) ; } } return weapon ; }
va	J	public void setKeys ( byte [ ] authKeyId , byte [ ] signKeyId , byte [ ] decKeyId , RSAPrivateCrtKey authKey , RSAPrivateCrtKey signKey , RSAPrivateCrtKey decKey ) throws CardServiceException { byte [ ] [ ] keyIds = new byte [ ] [ ] { authKeyId , signKeyId , decKeyId } ; for ( int i = 0 ; i < keyIds . length ; i ++ ) { CommandAPDU c = new CommandAPDU ( 0 , INS_PUTDATA , ( byte ) ( 61 + i ) , 0 , keyIds [ i ] ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "setKeys1 failed: " ) ; } byte [ ] [ ] [ ] keys = new byte [ ] [ ] [ ] { { gb ( authKey . getModulus ( ) ) , gb ( authKey . getPublicExponent ( ) ) , gb ( authKey . getPrimeP ( ) ) , gb ( authKey . getPrimeQ ( ) ) , gb ( authKey . getPrimeExponentP ( ) ) , gb ( authKey . getPrimeExponentQ ( ) ) , gb ( authKey . getCrtCoefficient ( ) ) } , { gb ( signKey . getModulus ( ) ) , gb ( signKey . getPublicExponent ( ) ) , gb ( signKey . getPrimeP ( ) ) , gb ( signKey . getPrimeQ ( ) ) , gb ( signKey . getPrimeExponentP ( ) ) , gb ( signKey . getPrimeExponentQ ( ) ) , gb ( signKey . getCrtCoefficient ( ) ) } , { gb ( decKey . getModulus ( ) ) , gb ( decKey . getPublicExponent ( ) ) , gb ( decKey . getPrimeP ( ) ) , gb ( decKey . getPrimeQ ( ) ) , gb ( decKey . getPrimeExponentP ( ) ) , gb ( decKey . getPrimeExponentQ ( ) ) , gb ( decKey . getCrtCoefficient ( ) ) } } ; for ( int keyId = 0 ; keyId < 3 ; keyId ++ ) { for ( int keyPart = 0 ; keyPart < 7 ; keyPart ++ ) { byte [ ] keyData = keys [ keyId ] [ keyPart ] ; CommandAPDU c = new CommandAPDU ( 0 , INS_PUTDATA , ( byte ) ( keyId + 64 ) , ( byte ) ( keyPart + 81 ) , keyData ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "setKeys2 failed: " ) ; } } }
va	G	private void svdReorder ( double [ ] m , double [ ] t1 , double [ ] t2 , double [ ] scales , double [ ] outRot , double [ ] outScale ) { int in0 , in1 , in2 , index , i ; if ( scales [ 0 ] < 0.0 ) { scales [ 0 ] = - scales [ 0 ] ; t2 [ 0 ] = - t2 [ 0 ] ; t2 [ 1 ] = - t2 [ 1 ] ; t2 [ 2 ] = - t2 [ 2 ] ; } if ( scales [ 1 ] < 0.0 ) { scales [ 1 ] = - scales [ 1 ] ; t2 [ 3 ] = - t2 [ 3 ] ; t2 [ 4 ] = - t2 [ 4 ] ; t2 [ 5 ] = - t2 [ 5 ] ; } if ( scales [ 2 ] < 0.0 ) { scales [ 2 ] = - scales [ 2 ] ; t2 [ 6 ] = - t2 [ 6 ] ; t2 [ 7 ] = - t2 [ 7 ] ; t2 [ 8 ] = - t2 [ 8 ] ; } mat_mul ( t1 , t2 , rotn ) ; if ( almostEqual ( Math . abs ( scales [ 0 ] ) , Math . abs ( scales [ 1 ] ) ) && almostEqual ( Math . abs ( scales [ 1 ] ) , Math . abs ( scales [ 2 ] ) ) ) { for ( i = 0 ; i < 9 ; i ++ ) { outRot [ i ] = rotn [ i ] ; } for ( i = 0 ; i < 3 ; i ++ ) { outScale [ i ] = scales [ i ] ; } } else { if ( scales [ 0 ] > scales [ 1 ] ) { if ( scales [ 0 ] > scales [ 2 ] ) { if ( scales [ 2 ] > scales [ 1 ] ) { out [ 0 ] = 0 ; out [ 1 ] = 2 ; out [ 2 ] = 1 ; } else { out [ 0 ] = 0 ; out [ 1 ] = 1 ; out [ 2 ] = 2 ; } } else { out [ 0 ] = 2 ; out [ 1 ] = 0 ; out [ 2 ] = 1 ; } } else { if ( scales [ 1 ] > scales [ 2 ] ) { if ( scales [ 2 ] > scales [ 0 ] ) { out [ 0 ] = 1 ; out [ 1 ] = 2 ; out [ 2 ] = 0 ; } else { out [ 0 ] = 1 ; out [ 1 ] = 0 ; out [ 2 ] = 2 ; } } else { out [ 0 ] = 2 ; out [ 1 ] = 1 ; out [ 2 ] = 0 ; } } mag [ 0 ] = ( m [ 0 ] * m [ 0 ] + m [ 1 ] * m [ 1 ] + m [ 2 ] * m [ 2 ] ) ; mag [ 1 ] = ( m [ 3 ] * m [ 3 ] + m [ 4 ] * m [ 4 ] + m [ 5 ] * m [ 5 ] ) ; mag [ 2 ] = ( m [ 6 ] * m [ 6 ] + m [ 7 ] * m [ 7 ] + m [ 8 ] * m [ 8 ] ) ; if ( mag [ 0 ] > mag [ 1 ] ) { if ( mag [ 0 ] > mag [ 2 ] ) { if ( mag [ 2 ] > mag [ 1 ] ) { in0 = 0 ; in2 = 1 ; in1 = 2 ; } else { in0 = 0 ; in1 = 1 ; in2 = 2 ; } } else { in2 = 0 ; in0 = 1 ; in1 = 2 ; } } else { if ( mag [ 1 ] > mag [ 2 ] ) { if ( mag [ 2 ] > mag [ 0 ] ) { in1 = 0 ; in2 = 1 ; in0 = 2 ; } else { in1 = 0 ; in0 = 1 ; in2 = 2 ; } } else { in2 = 0 ; in1 = 1 ; in0 = 2 ; } } index = out [ in0 ] ; outScale [ 0 ] = scales [ index ] ; index = out [ in1 ] ; outScale [ 1 ] = scales [ index ] ; index = out [ in2 ] ; outScale [ 2 ] = scales [ index ] ; index = out [ in0 ] ; outRot [ 0 ] = rotn [ index ] ; index = out [ in0 ] + 3 ; outRot [ 0 + 3 ] = rotn [ index ] ; index = out [ in0 ] + 6 ; outRot [ 0 + 6 ] = rotn [ index ] ; index = out [ in1 ] ; outRot [ 1 ] = rotn [ index ] ; index = out [ in1 ] + 3 ; outRot [ 1 + 3 ] = rotn [ index ] ; index = out [ in1 ] + 6 ; outRot [ 1 + 6 ] = rotn [ index ] ; index = out [ in2 ] ; outRot [ 2 ] = rotn [ index ] ; index = out [ in2 ] + 3 ; outRot [ 2 + 3 ] = rotn [ index ] ; index = out [ in2 ] + 6 ; outRot [ 2 + 6 ] = rotn [ index ] ; } }
va	J	@ Override public boolean canImport ( TransferSupport support ) { try { return support . isDataFlavorSupported ( new DataFlavor ( DataFlavor . javaJVMLocalObjectMimeType + ";class=java.util.ArrayList" ) ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } return false ; }
va	F	public boolean canAfford ( int [ ] cost ) { for ( int resourcei = 0 ; resourcei < ResourceGrid . RESOURCE_NAMES . length ; resourcei ++ ) { if ( resources [ resourcei ] < cost [ resourcei ] ) return false ; } return true ; }
va	B	public int getState ( ) { return this . state ; }
va	E	public boolean isClosed ( ) { return this . closedWithUnthrownDarts || this . busted || this . throwz . size ( ) == 3 ; }
va	C	public static Integer radixSort ( int [ ] a ) { Integer n = 0 ; int max = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { n ++ ; if ( a [ i ] > max ) max = a [ i ] ; } int tenBase = 1 ; while ( max / tenBase > 0 ) { int [ ] bucket = new int [ 10 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { n ++ ; bucket [ a [ i ] / tenBase % 10 ] ++ ; } System . out . println ( "Max = " + max + "; bucket: " + Arrays . toString ( bucket ) ) ; for ( int i = 1 ; i < 10 ; i ++ ) { n ++ ; bucket [ i ] += bucket [ i - 1 ] ; } System . out . println ( "Max = " + max + "; bucket: " + Arrays . toString ( bucket ) ) ; for ( int i = 9 ; i > 0 ; i -- ) { n ++ ; bucket [ i ] = bucket [ i - 1 ] ; } bucket [ 0 ] = 0 ; System . out . println ( "Max = " + max + "; bucket: " + Arrays . toString ( bucket ) ) ; int [ ] b = new int [ a . length ] ; for ( int i = 0 ; i < a . length ; i ++ ) { n ++ ; b [ bucket [ a [ i ] / tenBase % 10 ] ] = a [ i ] ; bucket [ a [ i ] / tenBase % 10 ] ++ ; } for ( int i = 0 ; i < a . length ; i ++ ) { n ++ ; a [ i ] = b [ i ] ; } tenBase *= 10 ; } return n ; }
va	H	public void drawSword ( int cx , int cy , Graphics g ) { g . drawImage ( sword , stx + cx , sty + cy , stx + cx + sqSize , sty + cy + sqSize , 0 , 0 , sword . getWidth ( null ) , sword . getHeight ( null ) , null ) ; }
va	F	public boolean turnIsTerminated ( ) { return this . currentTurn . terminatedCorrect ; }
va	A	public List < Integer > preorderTraversal ( TreeNode root ) { Stack < TreeNode > stack = new Stack < > ( ) ; List < Integer > result = new ArrayList < Integer > ( ) ; if ( root == null ) return result ; stack . push ( root ) ; while ( ! stack . isEmpty ( ) ) { TreeNode node = stack . pop ( ) ; result . add ( node . val ) ; if ( node . right != null ) stack . push ( node . right ) ; if ( node . left != null ) stack . push ( node . left ) ; } return result ; }
va	I	public static String getSwitchRuleAsString ( SwitchRules rule ) { if ( rule == SwitchRules . ONE_OF_MANY ) { return "OneOfMany" ; } else if ( rule == SwitchRules . AT_MOST_ONE ) { return "AtMostOne" ; } else if ( rule == SwitchRules . ANY_OF_MANY ) { return "AnyOfMany" ; } return "" ; }
va	H	public static void triangle2 ( String s ) { char c [ ] = s . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { System . out . println ( ) ; for ( int j = 0 ; j < ( c . length - i ) ; j ++ ) { System . out . print ( c [ j ] ) ; } } }
va	J	private ContainerWrapper checkParent ( Container parent ) { if ( parent == null ) return null ; if ( cacheParentW == null || cacheParentW . getComponent ( ) != parent ) cacheParentW = new SwingContainerWrapper ( parent ) ; return cacheParentW ; }
va	J	private void createFileStructure ( byte [ ] fs ) throws CardServiceException { CommandAPDU c = new CommandAPDU ( 0 , INS_PUTDATA , 69 , 00 , fs ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "createFileStructure failed: " ) ; }
va	E	public String getAvatarLarge ( ) { return avatarLarge ; }
va	B	public int getMaxDamage ( ) { return maxDamage ; }
va	I	private int getDebugMillis ( ) { int globalDebugMillis = LayoutUtil . getGlobalDebugMillis ( ) ; return globalDebugMillis > 0 ? globalDebugMillis : lc . getDebugMillis ( ) ; }
va	D	public void insert ( int index , T value ) { if ( index > size ) { throw new IndexOutOfBoundsException ( "index can't be > size: " + index + " > " + size ) ; } T [ ] items = this . items ; if ( size == items . length ) { items = resize ( Math . max ( 8 , ( int ) ( size * 1.75f ) ) ) ; } if ( ordered ) { System . arraycopy ( items , index , items , index + 1 , size - index ) ; } else { items [ size ] = items [ index ] ; } size ++ ; items [ index ] = value ; }
va	H	private void setDebug ( final ComponentWrapper parentW , boolean b ) { if ( b && ( debugTimer == null || debugTimer . getDelay ( ) != getDebugMillis ( ) ) ) { if ( debugTimer != null ) debugTimer . stop ( ) ; ContainerWrapper pCW = parentW . getParent ( ) ; final Component parent = pCW != null ? ( Component ) pCW . getComponent ( ) : null ; debugTimer = new Timer ( getDebugMillis ( ) , new MyDebugRepaintListener ( ) ) ; if ( parent != null ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { Container p = parent . getParent ( ) ; if ( p != null ) { if ( p instanceof JComponent ) { ( ( JComponent ) p ) . revalidate ( ) ; } else { parent . invalidate ( ) ; p . validate ( ) ; } } } } ) ; } debugTimer . setInitialDelay ( 100 ) ; debugTimer . start ( ) ; } else if ( ! b && debugTimer != null ) { debugTimer . stop ( ) ; debugTimer = null ; } }
va	B	public GridPanel ( PrintMode printMode ) { this . printMode = printMode ; Dimension preferredSize ; String paperSize = CharProps . getProperty ( "paper.size" ) ; if ( "A4" . equalsIgnoreCase ( paperSize ) ) { preferredSize = new Dimension ( ( int ) ( 210 / 25.4 * anInch ) , ( int ) ( 297 / 25.4 * anInch ) ) ; } else { preferredSize = new Dimension ( ( int ) ( 8.5 * anInch ) , ( ( int ) 11 * anInch ) ) ; } boxWInches = CharProps . getDoubleProperty ( "box.width" , boxWInches ) ; boxHInches = CharProps . getDoubleProperty ( "box.height" , boxHInches ) ; margins = CharProps . getDoubleProperty ( "paper.margins" , margins ) ; padding = CharProps . getIntProperty ( "padding" , padding ) ; if ( CharProps . getProperty ( "draw.guides" ) != null ) { drawGuides = "true" . equalsIgnoreCase ( CharProps . getProperty ( "draw.guides" ) ) ; } if ( CharProps . getProperty ( "draw.gridstyle" ) != null ) { gridStyle = "true" . equalsIgnoreCase ( CharProps . getProperty ( "draw.gridstyle" ) ) ; } chineseFont = new Font ( CharProps . getStringProperty ( "font.ch.face" , "Arial Unicode MS" ) , CharProps . getIntProperty ( "font.ch.prop" , Font . PLAIN ) , CharProps . getIntProperty ( "font.ch.size" , 40 ) ) ; pinyinFont = new Font ( CharProps . getStringProperty ( "font.pinyin.face" , "Arial Unicode MS" ) , CharProps . getIntProperty ( "font.pinyin.prop" , Font . PLAIN ) , CharProps . getIntProperty ( "font.pinyin.size" , 10 ) ) ; otherFont = new Font ( CharProps . getStringProperty ( "font.other.face" , "Arial Unicode MS" ) , CharProps . getIntProperty ( "font.other.prop" , Font . PLAIN ) , CharProps . getIntProperty ( "font.other.size" , 10 ) ) ; this . setPreferredSize ( preferredSize ) ; calcPages ( ( int ) ( getPreferredSize ( ) . getWidth ( ) - ( 2 * margins * anInch ) - 2 * padding ) , ( int ) ( getPreferredSize ( ) . getHeight ( ) - ( 2 * margins * anInch ) - 2 * padding ) ) ; setTitle ( ) ; }
va	H	public static void triangle3 ( String s ) { char c [ ] = s . toCharArray ( ) ; for ( int i = 0 ; i < c . length ; i ++ ) { System . out . println ( ) ; for ( int j = 0 ; j < c . length ; j ++ ) { if ( i < j ) { System . out . print ( " " ) ; } else { System . out . print ( c [ j ] ) ; } } } }
va	D	public void setVerified ( boolean verified ) { this . verified = verified ; }
va	E	public void initGame ( ) { grid = new Grid ( WORLD_WIDTH , WORLD_HEIGHT , 100 ) ; voxels_to_draw = new LinkedList < VoxelGrid > ( ) ; resource_grid = new ResourceGrid ( WORLD_WIDTH , WORLD_HEIGHT , 18 ) ; attract_tower = new HeightMapGradient ( WORLD_WIDTH , WORLD_HEIGHT , 15 ) ; avoid_tower = new HeightMapGradient ( WORLD_WIDTH , WORLD_HEIGHT , 15 ) ; avoid_edges = new HeightMapGradient ( WORLD_WIDTH , WORLD_HEIGHT , 64 ) ; for ( int i = 0 ; i < avoid_edges . voxels . length ; i ++ ) { avoid_edges . voxels [ i ] [ 0 ] = 1000 ; avoid_edges . voxels [ i ] [ avoid_edges . voxels [ 0 ] . length - 1 ] = 1000 ; } for ( int j = 0 ; j < avoid_edges . voxels [ 0 ] . length ; j ++ ) { avoid_edges . voxels [ 0 ] [ j ] = 1000 ; avoid_edges . voxels [ avoid_edges . voxels . length - 1 ] [ j ] = 1000 ; } entities = new LinkedList < Entity > ( ) ; drawing . view . x = WORLD_WIDTH / 2 - 340 ; drawing . view . y = WORLD_HEIGHT / 2 - 280 ; addTower ( WORLD_WIDTH / 2 , WORLD_HEIGHT / 2 ) ; }
va	B	private void balanceAfterInsert ( AVLNode < T > node ) { int balanceFactor = node . getBalanceFactor ( ) ; if ( balanceFactor > 1 || balanceFactor < - 1 ) { AVLNode < T > parent = null ; AVLNode < T > child = null ; Balance balance = null ; if ( balanceFactor < 0 ) { parent = ( AVLNode < T > ) node . lesser ; balanceFactor = parent . getBalanceFactor ( ) ; if ( balanceFactor < 0 ) { child = ( AVLNode < T > ) parent . lesser ; balance = Balance . LEFT_LEFT ; } else { child = ( AVLNode < T > ) parent . greater ; balance = Balance . LEFT_RIGHT ; } } else { parent = ( AVLNode < T > ) node . greater ; balanceFactor = parent . getBalanceFactor ( ) ; if ( balanceFactor < 0 ) { child = ( AVLNode < T > ) parent . lesser ; balance = Balance . RIGHT_LEFT ; } else { child = ( AVLNode < T > ) parent . greater ; balance = Balance . RIGHT_RIGHT ; } } if ( balance == Balance . LEFT_RIGHT ) { rotateLeft ( parent ) ; rotateRight ( node ) ; } else if ( balance == Balance . RIGHT_LEFT ) { rotateRight ( parent ) ; rotateLeft ( node ) ; } else if ( balance == Balance . LEFT_LEFT ) { rotateRight ( node ) ; } else { rotateLeft ( node ) ; } node . updateHeight ( ) ; child . updateHeight ( ) ; parent . updateHeight ( ) ; } }
va	G	@ Override public boolean lastTurnTerminatedCorrect ( ) { return this . currentTurn . terminatedCorrect ; }
va	D	public T get ( int index ) { if ( index >= size ) { throw new IndexOutOfBoundsException ( "index can't be >= size: " + index + " >= " + size ) ; } return items [ index ] ; }
va	H	@ Test public void canAddCategoryWithNullName ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory = new CategoryModel ( null , generatedStaffId ) ; boolean wasException = false ; try { cd . addCategory ( addCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } assertTrue ( wasException ) ; }
va	A	@ Override protected void loopBody ( Message m ) { String subject = m . getSubject ( ) ; if ( "execute" . equals ( subject ) ) { excuteMethod ( m , false ) ; } else if ( "executeStatic" . equals ( subject ) ) { excuteMethod ( m , true ) ; } else if ( "init" . equals ( subject ) ) { } else { logger . warning ( "CommandActor:%s loopBody unknown subject: %s" , getName ( ) , subject ) ; } }
va	J	private int processANDInst ( AND and ) { String opCode = and . getOpcode ( ) . name ( ) ; int instOrder = and . getOrder ( ) ; String src1n = "" ; String src2n = "" ; if ( and . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( and . getSrc1 ( ) , and ) ; boolean src2 = ! dataHaz . checkRAWHazard ( and . getSrc2 ( ) , and ) ; if ( src1 && src2 ) { long src1v = regMem . getRegValue ( and . getSrc1 ( ) . getId ( ) ) ; long src2v = regMem . getRegValue ( and . getSrc2 ( ) . getId ( ) ) ; and . getSrc1 ( ) . setValue ( src1v . intValue ( ) ) ; and . getSrc2 ( ) . setValue ( src2v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + and . getSrc1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Source2 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + and . getSrc2 ( ) . getId ( ) . name ( ) ) ; and . clearRawHazard ( ) ; and . setState ( State . READ ) ; } else { and . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( and . getRawInst ( ) ) ; if ( ! src1 ) { src1n = and . getSrc1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " is already busy. RAW hazard detected." ) ; } if ( ! src2 ) { src2n = and . getSrc2 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src2n + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
va	B	public void draw ( Graphics g ) { if ( state == 0 ) { g . setColor ( Color . white ) ; } else if ( state == 1 ) { g . setColor ( Color . red ) ; } else if ( state == 2 ) { g . setColor ( Color . yellow ) ; } else if ( state == 3 ) { g . setColor ( Color . GREEN ) ; } else if ( state == 4 ) { g . setColor ( Color . black ) ; } else if ( state == 5 ) { g . setColor ( Color . blue ) ; } else if ( state == 6 ) { g . setColor ( Color . magenta ) ; } else if ( state == 7 ) { g . setColor ( Color . orange . darker ( ) ) ; } else if ( state == 8 ) { g . setColor ( Color . pink ) ; } else { g . setColor ( Color . darkGray ) ; } g . drawOval ( x - width / 2 , y - height / 2 , width , height ) ; g . fillOval ( x - width / 2 , y - height / 2 , width , height ) ; }
va	C	public ILevelPack getNextStageLevel ( ) { if ( incLevelStage ( ) > Settings_Level . LEVEL_STAGES ) { return null ; } return chooseLevelPack ( getLevelStage ( ) ) ; }
va	H	@ Test public void canAddCategoryWithStaffThatNotExist ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory = new CategoryModel ( "toAddCategory" , getMaxStaffId ( ) + 10 ) ; boolean wasException = false ; try { cd . addCategory ( addCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } assertTrue ( wasException ) ; }
va	B	public String [ ] imprimir ( int capacidad ) { this . lista1 = new String [ capacidad ] ; int ind = 0 ; while ( ind < this . lista1 . length ) { this . lista1 [ ind ] = this . lista [ ind ] ; ++ ind ; } return lista1 ; }
va	C	private AvlNode < K , E > balanceLeftRight ( AvlNode < K , E > node ) { AvlNode < K , E > node6 = node ; AvlNode < K , E > node2 = ( AvlNode < K , E > ) node6 . leftNode ; AvlNode < K , E > node4 = ( AvlNode < K , E > ) node2 . rightNode ; AvlNode < K , E > node7 = ( AvlNode < K , E > ) node6 . rightNode ; AvlNode < K , E > node5 = ( AvlNode < K , E > ) node4 . rightNode ; AvlNode < K , E > node3 = ( AvlNode < K , E > ) node4 . leftNode ; AvlNode < K , E > node1 = ( AvlNode < K , E > ) node2 . leftNode ; node2 . leftNode = node1 ; node2 . rightNode = node3 ; node2 . updateHeight ( ) ; node6 . leftNode = node5 ; node6 . rightNode = node7 ; node6 . updateHeight ( ) ; node4 . leftNode = node2 ; node4 . rightNode = node6 ; node4 . updateHeight ( ) ; return node4 ; }
va	I	private boolean getDebug ( ) { return debugTimer != null ; }
va	E	public void mouseReleased ( MouseEvent arg0 ) { }
va	D	public void setOnlineStatus ( int onlineStatus ) { this . onlineStatus = onlineStatus ; }
va	A	@ Override public int compare ( TopicOutput o1 , TopicOutput o2 ) { try { if ( o1 . getRelevance ( ) > o2 . getRelevance ( ) ) { return - 1 ; } else if ( o1 . getRelevance ( ) < o2 . getRelevance ( ) ) { return 1 ; } } catch ( Exception e ) { System . err . println ( e . toString ( ) ) ; } return 0 ; }
va	I	@ Test public void canGetCategoriesOfProduct ( ) { List < Integer > categories = new ArrayList < > ( ) ; categories . add ( CategoryJUnit . getACategory ( ) ) ; List < Integer > categories_retrieved = null ; ProductModel addedProduct = ProductModel . builder ( "Night Visions" , 1 ) . description ( "Imagine Dragons" ) . cost ( 149 ) . rrp ( 400 ) . categories ( categories ) . build ( ) ; try { addedProduct = new ProductModel ( insertProduct ( addedProduct ) , addedProduct ) ; categories_retrieved = pd . getCategoriesOfProduct ( addedProduct . getId ( ) ) ; deleteProduct ( addedProduct . getId ( ) ) ; } catch ( WebshopAppException e ) { } assertEquals ( categories , categories_retrieved ) ; }
va	H	@ Test public void canAddCategoryNegativeStaff ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory = new CategoryModel ( "toAddCategory" , - 100 ) ; boolean wasException = false ; try { cd . addCategory ( addCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } assertTrue ( wasException ) ; }
va	F	public String createCostString ( int [ ] cost ) { String result = "" ; for ( int resourcei = 0 ; resourcei < ResourceGrid . RESOURCE_NAMES . length ; resourcei ++ ) { String resource_name = ResourceGrid . RESOURCE_NAMES [ resourcei ] ; if ( resource_name == null ) continue ; result += resource_name + ": " + cost [ resourcei ] + "  " ; } return result ; }
va	A	@ Override public String toString ( ) { return wrapped ; }
va	D	public void setAllowAllActMsg ( boolean allowAllActMsg ) { this . allowAllActMsg = allowAllActMsg ; }
va	B	public int getsize ( ) { return this . size ; }
va	B	public String getDamageMsg ( ) { return damageMsg ; }
va	E	private void addZombie ( int x , int y ) { ZombieEntity entity = new ZombieEntity ( x , y , grid ) ; entity . addGradient ( attract_tower ) ; entity . addGradient ( avoid_tower ) ; entity . addGradient ( avoid_edges ) ; entity . addGradient ( resource_grid . avoid_resources ) ; entities . add ( entity ) ; }
va	F	public void removeCurrentTurn ( ) { Turn toRemove = this . turns . get ( this . turns . size ( ) - 1 ) ; if ( ! toRemove . terminatedCorrect ) { this . turns . remove ( toRemove ) ; startTurn ( ) ; } }
va	H	int skip_sep ( ) { int count = 0 ; int s = current ; FuncState . _assert ( s == [ || s == ] ) ; save_and_next ( ) ; while ( current == = ) { save_and_next ( ) ; count ++ ; } return ( current == s ) ? count : ( - count ) - 1 ; }
va	C	private static void setHighMem ( ) { WorldController . lowMemory = false ; Rasterizer . lowMemory = false ; lowMemory = false ; Region . lowMemory = false ; GameObjectDefinition . lowMemory = false ; }
va	E	public void mousePressed ( MouseEvent arg0 ) { }
va	J	public Object apply ( Object x , Object y ) { return y ; }
va	A	public WrappedString ( String toWrap ) { this . wrapped = toWrap ; }
va	C	public static void drawHorizontalLineAlpha ( int x , int y , int width , int colour , int alpha ) { if ( x < topY || x >= bottomY ) return ; if ( y < topX ) { width -= topX - y ; y = topX ; } if ( y + width > bottomX ) width = bottomX - y ; int opacity = 256 - alpha ; int r = ( colour >> 16 & ff ) * alpha ; int g = ( colour >> 8 & ff ) * alpha ; int b = ( colour & ff ) * alpha ; int pointer = y + x * DrawingArea . width ; for ( int column = 0 ; column < width ; column ++ ) { int rAlpha = ( pixels [ pointer + column ] >> 16 & ff ) * opacity ; int gAlpha = ( pixels [ pointer + column ] >> 8 & ff ) * opacity ; int bAlpha = ( pixels [ pointer + column ] & ff ) * opacity ; int packedRGB = ( ( r + rAlpha >> 8 ) << 16 ) + ( ( g + gAlpha >> 8 ) << 8 ) + ( b + bAlpha >> 8 ) ; pixels [ pointer + column ] = packedRGB ; } }
va	B	public int getMinDamage ( ) { return minDamage ; }
va	E	@ Override public Player getPlayer ( ) { return this . player ; }
va	C	public static void drawHorizontalLine ( int x , int y , int width , int colour ) { if ( x < topY || x >= bottomY ) return ; if ( y < topX ) { width -= topX - y ; y = topX ; } if ( y + width > bottomX ) width = bottomX - y ; int pointer = y + x * DrawingArea . width ; for ( int column = 0 ; column < width ; column ++ ) pixels [ pointer + column ] = colour ; }
va	C	public Integer getLevelStage ( ) { return levelStage ; }
va	D	public String getWeihao ( ) { return weihao ; }
va	H	private String getIndexCode ( String code , List codes ) { if ( indexCodeCache == null ) indexCodeCache = new ArrayList ( ) ; if ( code . length ( ) <= 1 ) return code ; for ( int i = 0 ; i < indexCodeCache . size ( ) ; i ++ ) { String c = ( String ) indexCodeCache . get ( i ) ; if ( code . startsWith ( c ) ) return c ; } int foundSize = - 1 ; boolean cacheable = false ; for ( int z = 1 ; z < code . length ( ) ; z ++ ) { String thisCode = code . substring ( 0 , z ) ; int count = 0 ; for ( int i = 0 ; i < codes . size ( ) ; ) { if ( i == 0 ) { i = Collections . binarySearch ( codes , new CodeWord ( thisCode , "" ) ) ; if ( i < 0 ) i = 0 ; } CodeWord cw = ( CodeWord ) codes . get ( i ) ; if ( cw . getCode ( ) . startsWith ( thisCode ) ) { count ++ ; if ( count > INDEX_SIZE_MAX ) break ; } else if ( cw . getCode ( ) . compareTo ( thisCode ) > 0 ) break ; i ++ ; } if ( count <= INDEX_SIZE_MAX ) { cacheable = true ; foundSize = z ; break ; } } String newCode = ( foundSize == - 1 ) ? code : code . substring ( 0 , foundSize ) ; if ( cacheable ) indexCodeCache . add ( newCode ) ; return newCode ; }
va	B	public String [ ] imprimelista ( ) { return lista ; }
va	C	public static int [ ] nonZeroRandomSet ( int n , int sum ) { if ( sum < n ) { throw new IllegalArgumentException ( "Cannot satisfy sum." ) ; } for ( int i = 0 ; i < MAX_TRIES ; i ++ ) { boolean found = true ; int [ ] temp = randomSet ( n , sum ) ; inner : for ( int j = 0 ; j < n ; j ++ ) { if ( temp [ j ] == 0 ) { found = false ; break inner ; } } if ( found ) { return temp ; } } throw new RuntimeException ( "too many attempts. n  sum = " + n + "  " + sum ) ; }
va	J	@ Override public int getSourceActions ( JComponent c ) { return NONE ; }
va	B	public int cantdatos ( String lista [ ] ) { this . lista = lista ; int i = 0 ; while ( i < this . size ) { i ++ ; } return i ; }
va	C	private AvlNode < K , E > balanceRightRight ( AvlNode < K , E > node ) { AvlNode < K , E > node2 = node ; AvlNode < K , E > node4 = ( AvlNode < K , E > ) node2 . rightNode ; AvlNode < K , E > node6 = ( AvlNode < K , E > ) node4 . rightNode ; AvlNode < K , E > node1 = ( AvlNode < K , E > ) node2 . leftNode ; AvlNode < K , E > node3 = ( AvlNode < K , E > ) node4 . leftNode ; AvlNode < K , E > node5 = ( AvlNode < K , E > ) node6 . leftNode ; AvlNode < K , E > node7 = ( AvlNode < K , E > ) node6 . rightNode ; node2 . leftNode = node1 ; node2 . rightNode = node3 ; node2 . updateHeight ( ) ; node6 . leftNode = node5 ; node6 . rightNode = node7 ; node6 . updateHeight ( ) ; node4 . leftNode = node2 ; node4 . rightNode = node6 ; node4 . updateHeight ( ) ; return node4 ; }
va	I	public void setDimensions ( ) { boolean ok = false ; if ( fram . gm . getHeight ( ) < fram . gm . getWidth ( ) ) { sqSize = getWidth ( ) / ( fram . gm . getWidth ( ) ) ; if ( sqSize * fram . gm . getHeight ( ) < getHeight ( ) ) { ok = true ; } if ( ! ok ) { sqSize = getHeight ( ) / ( fram . gm . getHeight ( ) ) ; ok = true ; } } else { sqSize = getHeight ( ) / ( fram . gm . getHeight ( ) ) ; if ( sqSize * fram . gm . getWidth ( ) < getWidth ( ) ) { ok = true ; } if ( ! ok ) { sqSize = getWidth ( ) / ( fram . gm . getWidth ( ) ) ; ok = true ; } } stx = ( getWidth ( ) - fram . gm . getWidth ( ) * sqSize ) / 2 ; sty = ( getHeight ( ) - fram . gm . getHeight ( ) * sqSize ) / 2 ; }
va	E	public boolean isAllowAllComment ( ) { return allowAllComment ; }
va	C	public HashMap < Integer , ArrayList < ILevelPack >> getLevelStageMap ( ) { return levelStageMap ; }
va	C	public static void securityGoalRefine ( RequirementGraph req_model , String type , int scope ) throws IOException , ScriptException { String expression_file = req_model . generateFormalExpressionToFile ( scope ) ; String security_model_file = InfoEnum . current_directory + "/dlv/models/security_model_" + req_model . getLayer ( ) . toLowerCase ( ) + ".dl " ; String refine_rule = "" ; if ( type . equals ( InfoEnum . RefinementDimension . ASSET . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/refine_asset.rule " + InfoEnum . current_directory + "/dlv/models/asset_model.dl " + expression_file ; } else if ( type . equals ( InfoEnum . RefinementDimension . SECURITY_PROPERTY . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/refine_security_attribute.rule " + expression_file + " " + security_model_file ; } else if ( type . equals ( InfoEnum . RefinementDimension . INTERVAL . name ( ) ) ) { refine_rule = InfoEnum . current_directory + "/dlv/dlv -silent -nofacts " + InfoEnum . current_directory + "/dlv/rules/refine_interval.rule " + expression_file ; } else { CommandPanel . logger . severe ( "Error refinement type!" ) ; } Runtime rt = Runtime . getRuntime ( ) ; Process pr = rt . exec ( refine_rule ) ; BufferedReader input = new BufferedReader ( new InputStreamReader ( pr . getInputStream ( ) ) ) ; String line = null ; LinkedList < RequirementElement > refined_elems = new LinkedList < RequirementElement > ( ) ; while ( ( line = input . readLine ( ) ) != null ) { line = line . substring ( 1 , line . length ( ) - 1 ) ; String [ ] result = line . split ( "  " ) ; for ( String s : result ) { if ( s . startsWith ( "and_refined_sec_goal" ) ) { s = s . replaceAll ( "and_refined_sec_goal\\(" , "" ) ; s = s . replaceAll ( "\\)" , "" ) ; s = s . replaceAll ( "\\_" , " " ) ; String [ ] sg = s . split ( " " ) ; SecurityGoal refined_goal = ( SecurityGoal ) req_model . findElementById ( sg [ 4 ] ) ; Element asset = null ; if ( req_model . getLayer ( ) . equals ( InfoEnum . Layer . APPLICATION . name ( ) ) || req_model . getLayer ( ) . equals ( InfoEnum . Layer . PHYSICAL . name ( ) ) ) { asset = req_model . findElementById ( sg [ 2 ] ) ; if ( asset == null ) { CommandPanel . logger . severe ( "Asset error" ) ; } } Element re = req_model . findElementById ( sg [ 3 ] ) ; SecurityGoal new_sg = null ; if ( re != null ) { new_sg = new SecurityGoal ( sg [ 0 ] , sg [ 1 ] , sg [ 2 ] , re , InfoEnum . RequirementElementType . SECURITY_GOAL . name ( ) , refined_goal . getLayer ( ) ) ; if ( asset != null ) { new_sg . setName ( ( new_sg . getImportance ( ) + " " + new_sg . getSecurityAttribute ( ) + " [" + asset . getName ( ) + "  " + new_sg . getInterval ( ) . getName ( ) + "]" ) . replaceAll ( "\\_" , " " ) ) ; } } else { CommandPanel . logger . severe ( "Security goal cannot be created: interval id-->" + sg [ 3 ] ) ; } new_sg . owner_text = refined_goal . owner_text ; if ( refined_goal . owner != null ) { refined_goal . owner . getOwnedElement ( ) . add ( new_sg ) ; new_sg . owner = refined_goal . owner ; } else { Actor fake_owner = new Actor ( refined_goal . owner_text , InfoEnum . RequirementElementType . ACTOR . name ( ) , refined_goal . getLayer ( ) ) ; fake_owner . setId ( refined_goal . owner_text ) ; new_sg . owner = fake_owner ; } req_model . getElements ( ) . add ( new_sg ) ; RequirementLink new_and_refine = new RequirementLink ( InfoEnum . RequirementLinkType . AND_REFINE . name ( ) , new_sg , refined_goal ) ; req_model . getLinks ( ) . add ( new_and_refine ) ; refined_goal . and_refine_links . add ( new_and_refine ) ; if ( refined_elems . indexOf ( refined_goal ) == - 1 ) { refined_elems . add ( refined_goal ) ; } } } } VisualizationFunctions . drawAndRefinement ( refined_elems ) ; }
va	C	private static void setLowMemory ( ) { WorldController . lowMemory = true ; Rasterizer . lowMemory = true ; lowMemory = true ; Region . lowMemory = true ; GameObjectDefinition . lowMemory = true ; }
va	F	public boolean alreadyReceivedScoreEvents ( ) { return this . currentTurn . alreadyReceivedScoreEvents ; }
va	I	public Set < Integer > getValidValuesForElementAtPosition ( int rowNumber , int columnNumber ) { return getValidValuesForElementWithNumber ( getElementNumber ( rowNumber , columnNumber ) ) ; }
va	E	public boolean isFollowMe ( ) { return followMe ; }
va	C	private AvlNode < K , E > balanceRightLeft ( AvlNode < K , E > node ) { AvlNode < K , E > node2 = node ; AvlNode < K , E > node6 = ( AvlNode < K , E > ) node2 . rightNode ; AvlNode < K , E > node4 = ( AvlNode < K , E > ) node6 . leftNode ; AvlNode < K , E > node1 = ( AvlNode < K , E > ) node2 . leftNode ; AvlNode < K , E > node3 = ( AvlNode < K , E > ) node4 . leftNode ; AvlNode < K , E > node5 = ( AvlNode < K , E > ) node4 . rightNode ; AvlNode < K , E > node7 = ( AvlNode < K , E > ) node6 . rightNode ; node2 . leftNode = node1 ; node2 . rightNode = node3 ; node2 . updateHeight ( ) ; node6 . leftNode = node5 ; node6 . rightNode = node7 ; node6 . updateHeight ( ) ; node4 . leftNode = node2 ; node4 . rightNode = node6 ; node4 . updateHeight ( ) ; return node4 ; }
va	A	@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( obj == this ) { return true ; } if ( ! ( obj instanceof WrappedString ) ) { return false ; } WrappedString other = ( WrappedString ) obj ; return this . hashCode ( ) == other . hashCode ( ) ; }
va	I	@ Test public void canGetCategoriesOfNonExcistingProduct ( ) { List < Integer > categories_retrieved = null ; try { categories_retrieved = pd . getCategoriesOfProduct ( 1239874 ) ; } catch ( WebshopAppException e ) { } assertTrue ( ( categories_retrieved != null ) && ( categories_retrieved . size ( ) == 0 ) ) ; }
va	A	public static Weapon createWeaponFromReader ( String weaponString ) { String [ ] values = weaponString . split ( " " ) ; Weapon weapon = new Weapon ( ) ; try { weapon . setName ( values [ 0 ] ) ; weapon . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; weapon . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; weapon . setMinDamage ( Integer . parseInt ( values [ 3 ] ) ) ; weapon . setMaxDamage ( Integer . parseInt ( values [ 4 ] ) ) ; weapon . setDamageMsg ( values [ 5 ] . replaceAll ( "\\[comma\\]" , " " ) ) ; if ( values . length == 7 && values [ 6 ] != "" ) { String [ ] specials = values [ 6 ] . split ( " " ) ; weapon = Weapon . applySpecialTraits ( weapon , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading weapon object" ) ; if ( weapon . getName ( ) != null ) System . out . println ( weapon . getName ( ) + " has some incorrect parameter." ) ; return null ; } return weapon ; }
va	G	private int generateRndNumber ( ) { Random rnd = new Random ( ) ; myRandomNumber = rnd . nextInt ( 100 ) + 1 ; return myRandomNumber ; }
va	I	@ Test public void canUpdateCategoryWithANameThatExist ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory1 = new CategoryModel ( "toAddCategory1" , generatedStaffId ) ; CategoryModel addCategory2 = new CategoryModel ( "toAddCategory2" , generatedStaffId ) ; CategoryModel updateCategory = null ; boolean wasException = false ; CategoryModel addedCategory1 = null ; CategoryModel addedCategory2 = null ; try { addedCategory1 = insertCategory ( addCategory1 ) ; addedCategory2 = insertCategory ( addCategory2 ) ; updateCategory = new CategoryModel ( addedCategory1 . getId ( ) , addedCategory2 ) ; cd . updateCategory ( updateCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } deleteCategoryById ( addedCategory1 . getId ( ) ) ; deleteCategoryById ( addedCategory2 . getId ( ) ) ; assertTrue ( wasException ) ; }
va	I	public static void wordFrequencyCount ( String s ) { int count = StringDemo . wordCount ( s ) ; String ar [ ] = new String [ count ] ; int ocr = 0 ; for ( int i = 0 ; i < count ; i ++ ) { if ( i == ( count - 1 ) ) { ar [ i ] = s . substring ( 0 ) ; } else { ar [ i ] = s . substring ( 0 , s . indexOf (   ) ) ; s = s . substring ( s . indexOf (   ) + 1 ) ; } } for ( int i = 0 ; i < count ; i ++ ) { ocr = 0 ; for ( int j = 0 ; j < count ; j ++ ) { if ( ( j < i ) && ( StringDemo . compare ( ar [ i ] , ar [ j ] ) == 0 ) ) { break ; } else if ( ( j >= i ) && ( StringDemo . compare ( ar [ i ] , ar [ j ] ) == 0 ) ) { ocr ++ ; } } if ( ocr != 0 ) { System . out . println ( ar [ i ] + "\t:\t" + ocr ) ; } } }
va	G	@ Override public void onStopGame ( Game g ) { currentGame = null ; setOptionsEnabled ( true ) ; }
va	E	public void mouseEntered ( MouseEvent arg0 ) { }
va	A	public void importData ( ArrayList < tweetModel > tweets ) { String filePath = "src\\malletfile.txt" ; try { database . Writer write = new database . Writer ( filePath , false ) ; write . writeToFile ( "" ) ; write = new database . Writer ( filePath , true ) ; for ( tweetModel tm : tweets ) { write . writeToFile ( tm . getMessage ( ) ) ; dataSize ++ ; } } catch ( IOException ex ) { System . out . println ( "__! Sorry  No Can Do! Failed import data. <mallet> " ) ; } }
va	G	@ Override public void onMoveForward ( Board board , Move move ) { setHumanMovesEnabled ( false ) ; animateMove ( move ) ; notifyGameGuiListeners ( move ) ; }
va	J	public SortableHeaderRenderer ( TableCellRenderer tableCellRenderer ) { this . tableCellRenderer = tableCellRenderer ; }
va	I	public static int compare ( String s , String s1 ) { if ( ( s . length ( ) - s1 . length ( ) ) != 0 ) { return s . length ( ) - s1 . length ( ) ; } byte b [ ] = s . getBytes ( ) ; byte b1 [ ] = s1 . getBytes ( ) ; for ( int i = 0 ; i < b . length ; i ++ ) { if ( ( b [ i ] - b1 [ i ] ) != 0 ) { return b [ i ] - b1 [ i ] ; } } return 0 ; }
va	F	public GregorianCalendarModel ( ) { calendar = ( GregorianCalendar ) GregorianCalendar . getInstance ( DEFAULT_LOCALE ) ; calendar . setFirstDayOfWeek ( firstDayOfWeek ) ; changeListeners = new ArrayList ( ) ; tableModelListeners = new ArrayList ( ) ; monthLabels = new ArrayList ( ) ; }
va	I	@ Test public void canGetProductByNonExcistingCategory ( ) { List < ProductModel > products = new ArrayList < > ( ) ; try { products = pd . getProductsByCategory ( 133234 ) ; } catch ( WebshopAppException e ) { } assertTrue ( ( products != null ) && ( products . size ( ) == 0 ) ) ; }
va	E	public int getOnlineStatus ( ) { return onlineStatus ; }
va	J	public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { Component c = tableCellRenderer . getTableCellRendererComponent ( table , value , isSelected , hasFocus , row , column ) ; if ( c instanceof JLabel ) { JLabel l = ( JLabel ) c ; l . setHorizontalTextPosition ( JLabel . LEFT ) ; int modelColumn = table . convertColumnIndexToModel ( column ) ; l . setIcon ( getHeaderRendererIcon ( modelColumn , l . getFont ( ) . getSize ( ) ) ) ; } return c ; }
va	J	public String getWord ( ) { return word ; }
va	H	public void mouseClicked ( MouseEvent e ) { JTableHeader h = ( JTableHeader ) e . getSource ( ) ; TableColumnModel columnModel = h . getColumnModel ( ) ; int viewColumn = columnModel . getColumnIndexAtX ( e . getX ( ) ) ; int column = columnModel . getColumn ( viewColumn ) . getModelIndex ( ) ; if ( column != - 1 ) { int status = getSortingStatus ( column ) ; if ( ! e . isControlDown ( ) ) { cancelSorting ( ) ; } status = status + ( e . isShiftDown ( ) ? - 1 : 1 ) ; status = ( status + 4 ) % 3 - 1 ; setSortingStatus ( column , status ) ; } }
va	D	public void setBiFollowersCount ( int biFollowersCount ) { this . biFollowersCount = biFollowersCount ; }
va	I	private String timeToString ( int second ) { String time = "" ; int minutes = second / 60 ; int seconds = second % 60 ; if ( minutes > 9 ) time += minutes ; else time += "0" + minutes ; time += ":" ; if ( seconds > 9 ) time += seconds ; else time += "0" + seconds ; return time ; }
va	D	public void setRemark ( String remark ) { this . remark = remark ; }
te	G	@ Override public int corpusDocFrequencyByTerm ( String term ) { if ( term . contains ( " " ) ) { Map < Integer , ArrayList < Integer >> found = gerPhraseDocs ( term ) ; if ( found == null ) return 0 ; else { return - 10000 ; } } else { return _dictionary . containsKey ( term ) ? ( getSkipInfo ( term ) . size ( ) / 2 ) : 0 ; } }
te	F	private void animateMove ( Move m ) { final int ANIMATION_TIME = 400 ; DraughtsState gameState = getCurrentGameState ( ) ; getBoardPanel ( ) . getBoard ( ) . animateMoveForward ( m , ANIMATION_TIME ) ; gameState . doMove ( m ) ; notifyGameGuiListeners ( gameState ) ; }
te	C	@ Override public void performZoom ( int steps ) { wr . performZoom ( steps ) ; }
te	D	public Color getColor ( ) { return color ; }
te	B	public Dimension calculateMapBounds ( ) { int xmin = 9999999 ; int ymin = 9999999 ; int xmax = - 9999999 ; int ymax = - 9999999 ; int xpos , ypos ; xpos = 0 + tileLocator . getTileScreenX ( 0 , 0 ) ; ypos = 0 + tileLocator . getTileScreenY ( 0 , 0 ) ; xmin = Math . min ( xmin , xpos ) ; ymin = Math . min ( ymin , ypos ) ; xmax = Math . max ( xmax , xpos ) ; ymax = Math . max ( ymax , ypos ) ; xpos = 0 + tileLocator . getTileScreenX ( map . getWidth ( ) , 0 ) ; ypos = 0 + tileLocator . getTileScreenY ( map . getWidth ( ) , 0 ) ; xmin = Math . min ( xmin , xpos ) ; ymin = Math . min ( ymin , ypos ) ; xmax = Math . max ( xmax , xpos ) ; ymax = Math . max ( ymax , ypos ) ; xpos = 0 + tileLocator . getTileScreenX ( 0 , map . getHeight ( ) ) ; ypos = 0 + tileLocator . getTileScreenY ( 0 , map . getHeight ( ) ) ; xmin = Math . min ( xmin , xpos ) ; ymin = Math . min ( ymin , ypos ) ; xmax = Math . max ( xmax , xpos ) ; ymax = Math . max ( ymax , ypos ) ; xpos = 0 + tileLocator . getTileScreenX ( map . getWidth ( ) , map . getHeight ( ) ) ; ypos = 0 + tileLocator . getTileScreenY ( map . getWidth ( ) , map . getHeight ( ) ) ; xmin = Math . min ( xmin , xpos ) ; ymin = Math . min ( ymin , ypos ) ; xmax = Math . max ( xmax , xpos ) ; ymax = Math . max ( ymax , ypos ) ; xoff = - xmin ; yoff = - ymin + 40 ; return new Dimension ( xmax - xmin + 60 , ymax - ymin + 60 ) ; }
te	E	public Room getCurrentRoom ( ) { return this . currentRoom ; }
te	H	public ByteBuffer createBuffer ( ) { return ByteBuffer . allocate ( WebSocketImpl . RCVBUF ) ; }
te	D	public void setWidth ( double width ) { this . width = width ; }
te	H	@ Override public MapTile next ( ) { MapTile result = grid [ current / width ] [ current % height ] ; current ++ ; return result ; }
te	A	public Pattern getCurrentPattern ( ) { return currentPattern ; }
te	I	public void paintIcon ( Component c , Graphics g , int x , int y ) { Color color = c == null ? Color . GRAY : c . getBackground ( ) ; int dx = ( int ) ( size / 2 * Math . pow ( 0.8 , priority ) ) ; int dy = descending ? dx : - dx ; y = y + 5 * size / 6 + ( descending ? - dy : 0 ) ; int shift = descending ? 1 : - 1 ; g . translate ( x , y ) ; g . setColor ( color . darker ( ) ) ; g . drawLine ( dx / 2 , dy , 0 , 0 ) ; g . drawLine ( dx / 2 , dy + shift , 0 , shift ) ; g . setColor ( color . brighter ( ) ) ; g . drawLine ( dx / 2 , dy , dx , 0 ) ; g . drawLine ( dx / 2 , dy + shift , dx , shift ) ; if ( descending ) { g . setColor ( color . darker ( ) . darker ( ) ) ; } else { g . setColor ( color . brighter ( ) . brighter ( ) ) ; } g . drawLine ( dx , 0 , 0 , 0 ) ; g . setColor ( color ) ; g . translate ( - x , - y ) ; }
te	F	private boolean calculateIndexes ( ) { if ( myRandomNumber == peer1RndNumber || myRandomNumber == peer2RndNumber || peer1RndNumber == peer2RndNumber ) { return false ; } if ( myRandomNumber > peer1RndNumber ) { if ( myRandomNumber > peer2RndNumber ) { myIndex = 1 ; if ( peer1RndNumber > peer2RndNumber ) { peer1Index = 2 ; peer2Index = 3 ; } else { peer2Index = 2 ; peer1Index = 3 ; } } else { peer2Index = 1 ; myIndex = 2 ; peer1Index = 3 ; } } else { if ( myRandomNumber > peer2RndNumber ) { peer1Index = 1 ; myIndex = 2 ; peer2Index = 3 ; } else { myIndex = 3 ; if ( peer1RndNumber > peer2RndNumber ) { peer1Index = 1 ; peer2Index = 2 ; } else { peer2Index = 1 ; peer1Index = 2 ; } } } currentIndex = 1 ; return true ; }
te	J	public String getFilename ( ) { return filename ; }
te	H	private int readAbsoluteX ( int dataHigh , int dataLow ) { int iAddr = readAbsolute ( dataHigh , dataLow ) ; calculateAdditionalCycles ( iAddr , iAddr + getX ( ) , false ) ; return iAddr + getX ( ) ; }
te	F	private void expressions ( ) { expression ( ) ; while ( whenToken ( TokenType . SCOMMA ) ) { expression ( ) ; } }
te	F	private Object fromArrays ( Key [ ] keys , Val [ ] vals ) { Object t = null ; if ( keys . length != vals . length ) throw new IllegalArgumentException ( "array lengths must be equal" ) ; for ( int i = 0 ; i < keys . length ; ++ i ) t = with ( t , keys [ i ] , vals [ i ] ) ; return t ; }
te	D	public float getWidth ( ) { return ( float ) width ; }
te	F	public static PropertyStates parsePropertyState ( String state ) throws IllegalArgumentException { if ( state . compareTo ( "Alert" ) == 0 ) { return PropertyStates . ALERT ; } else if ( state . compareTo ( "Busy" ) == 0 ) { return PropertyStates . BUSY ; } else if ( state . compareTo ( "Ok" ) == 0 ) { return PropertyStates . OK ; } else if ( state . compareTo ( "Idle" ) == 0 ) { return PropertyStates . IDLE ; } throw new IllegalArgumentException ( "Invalid PropertyState String: '" + state + "'" ) ; }
te	C	private boolean wrapperAndPrimitives ( class < ? > class1 , class < ? > class2 ) { for ( int i = 0 ; i < compatibleClasses . length / 2 ; i ++ ) { if ( ( compatibleClasses [ i ] [ 0 ] . equals ( class1 ) && compatibleClasses [ i ] [ 1 ] . equals ( class2 ) ) || ( compatibleClasses [ i ] [ 0 ] . equals ( class2 ) && compatibleClasses [ i ] [ 1 ] . equals ( class1 ) ) ) { return true ; } } return false ; }
te	B	public String getName ( ) { return name ; }
te	D	public void bounceOutLastThrow ( ) { if ( throwz . size ( ) > 0 ) { throwz . remove ( throwz . size ( ) - 1 ) ; throwz . add ( 0 ) ; } }
te	G	boolean check_next ( String set ) { if ( set . indexOf ( current ) < 0 ) return false ; save_and_next ( ) ; return true ; }
te	G	@ Test public void canAddCategory ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory = new CategoryModel ( "toAddCategory" , generatedStaffId ) ; CategoryModel retrieved = null ; try { addCategory = cd . addCategory ( addCategory ) ; retrieved = getCategoryById ( addCategory . getId ( ) ) ; deleteCategoryById ( addCategory . getId ( ) ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; fail ( "Exception" ) ; } assertEquals ( addCategory , retrieved ) ; }
te	I	private void queue ( WebSocketImpl ws ) throws InterruptedException { if ( ws . workerThread == null ) { ws . workerThread = decoders . get ( queueinvokes % decoders . size ( ) ) ; queueinvokes ++ ; } ws . workerThread . put ( ws ) ; }
te	F	public void calculate ( ) { for ( Cell element : adjList ) { cells [ element . row ] [ element . column ] . value += this . value ; } }
te	E	private boolean [ ] [ ] findEdges ( ) { int G [ ] [ ] [ ] = new int [ _height ] [ _width ] [ 4 ] ; int G1 [ ] [ ] [ ] = new int [ _height ] [ _width ] [ 4 ] ; int G2 [ ] [ ] [ ] = new int [ _height ] [ _width ] [ 4 ] ; boolean isEdge [ ] [ ] [ ] = new boolean [ _height ] [ _width ] [ 4 ] ; for ( int y = _height - 2 ; y > 0 ; y -- ) for ( int x = 1 ; x < _width - 1 ; x ++ ) { for ( int o = 0 ; o < 4 ; o ++ ) { int x2 = x + NEIGHBOURS [ o ] [ 0 ] ; int y2 = y + NEIGHBOURS [ o ] [ 1 ] ; int x3 = x + NEIGHBOURS [ o ] [ 2 ] ; int y3 = y + NEIGHBOURS [ o ] [ 3 ] ; G [ y ] [ x ] [ o ] = distance ( x , y , x2 , y2 ) + distance ( x , y , x3 , y3 ) ; } G [ y ] [ x ] [ 0 ] *= 1.5 ; G [ y ] [ x ] [ 2 ] *= 1.5 ; } for ( int y = _height - 3 ; y > 1 ; y -- ) for ( int x = 2 ; x < _width - 2 ; x ++ ) { for ( int o = 0 ; o < 4 ; o ++ ) { int o2 = ( o + 2 ) % 4 ; int x2 = x + NEIGHBOURS [ o2 ] [ 0 ] ; int y2 = y + NEIGHBOURS [ o2 ] [ 1 ] ; int x3 = x + NEIGHBOURS [ o2 ] [ 2 ] ; int y3 = y + NEIGHBOURS [ o2 ] [ 3 ] ; G1 [ y ] [ x ] [ o ] = ( G [ y ] [ x ] [ o ] + G [ y2 ] [ x2 ] [ o ] + G [ y3 ] [ x3 ] [ o ] ) / 3 ; } } for ( int y = _height - 3 ; y > 1 ; y -- ) for ( int x = 2 ; x < _width - 2 ; x ++ ) { for ( int o = 0 ; o < 4 ; o ++ ) { G2 [ y ] [ x ] [ o ] = G1 [ y ] [ x ] [ o ] ; int x1 = x + NEIGHBOURS [ o ] [ 0 ] ; int y1 = y + NEIGHBOURS [ o ] [ 1 ] ; int x2 = x + NEIGHBOURS [ o ] [ 2 ] ; int y2 = y + NEIGHBOURS [ o ] [ 3 ] ; if ( G1 [ y ] [ x ] [ o ] <= G1 [ y1 ] [ x1 ] [ o ] || G1 [ y ] [ x ] [ o ] < G1 [ y2 ] [ x2 ] [ o ] ) G2 [ y ] [ x ] [ o ] = 0 ; } } for ( int y = _height - 3 ; y > 1 ; y -- ) for ( int x = 2 ; x < _width - 2 ; x ++ ) { for ( int o = 0 ; o < 4 ; o ++ ) if ( G2 [ y ] [ x ] [ o ] > EDGE_THRESHOLD1 && ! isEdge [ y ] [ x ] [ o ] ) { isEdge [ y ] [ x ] [ o ] = true ; Queue < Point > q = new LinkedList < Point > ( ) ; q . add ( new Point ( x , y ) ) ; while ( ! q . isEmpty ( ) ) { Point p = q . poll ( ) ; for ( int i = - 1 ; i < 2 ; i ++ ) for ( int j = - 1 ; j < 2 ; j ++ ) { if ( i == 0 && j == 0 ) continue ; int ny = p . y + i ; int nx = p . x + j ; if ( G2 [ ny ] [ nx ] [ o ] > EDGE_THRESHOLD2 && ! isEdge [ ny ] [ nx ] [ o ] ) { isEdge [ ny ] [ nx ] [ o ] = true ; q . add ( new Point ( nx , ny ) ) ; } } } } } boolean ret [ ] [ ] = new boolean [ _height ] [ _width ] ; for ( int y = _height - 3 ; y > 1 ; y -- ) for ( int x = 2 ; x < _width - 2 ; x ++ ) { if ( isEdge [ y ] [ x ] [ 0 ] || isEdge [ y ] [ x ] [ 1 ] || isEdge [ y ] [ x ] [ 2 ] || isEdge [ y ] [ x ] [ 3 ] ) ret [ y ] [ x ] = true ; } return ret ; }
te	E	private int getIndex ( String name , ArrayList < String > list ) { int i = 0 ; while ( i < list . size ( ) ) { if ( list . get ( i ) . split ( " " ) [ 0 ] . equals ( name ) ) return i ; i ++ ; } return - 1 ; }
te	G	public void drawEagle ( int cx , int cy , Graphics g , String dir , int state ) { int xi = 0 , xf = 0 , yi = 0 , yf = 0 ; if ( state == 0 ) { if ( dir . equals ( "down" ) ) { yi = 290 ; yf = 330 ; } else if ( dir . equals ( "up" ) ) { yi = 370 ; yf = 410 ; } else if ( dir . equals ( "right" ) ) { yi = 410 ; yf = 450 ; } else if ( dir . equals ( "left" ) ) { yi = 330 ; yf = 370 ; } if ( frame % 5 == 0 ) { xi = 0 ; xf = 40 ; } else if ( frame % 5 == 1 ) { xi = 40 ; xf = 80 ; } else if ( frame % 5 == 2 ) { xi = 80 ; xf = 120 ; } else if ( frame % 5 == 3 ) { xi = 120 ; xf = 160 ; } else if ( frame % 5 == 4 ) { xi = 160 ; xf = 200 ; } } else if ( state == 1 ) { xi = 325 ; yi = 697 ; xf = 360 ; yf = 737 ; } g . drawImage ( eagle , stx + cx , sty + cy - ( sqSize / 2 ) , stx + cx + sqSize , sty + cy + sqSize - ( sqSize / 2 ) , xi , yi , xf , yf , null ) ; }
te	B	public static void forInvalidName ( List < Invalid > errors , Aspect aspect , String name , String type ) { if ( GameData . convertToJavaIdentifier ( name ) . isEmpty ( ) ) { errors . add ( createInvalidNameError ( aspect , name == null ? "" : name , type ) ) ; } }
te	E	private ScenarioGUIStep getScenarioGUIStepFromTreeStep ( ScenarioTreeStep currentStep ) { if ( currentStep instanceof ScenarioTreeStepBeginning ) { return new ScenarioGUIStepBeginning ( ( ScenarioTreeStepBeginning ) currentStep ) ; } else if ( currentStep instanceof ScenarioTreeStepTwoOptions ) { return new ScenarioGUIStepTwoOptionsRadiobuttons ( ( ScenarioTreeStepTwoOptions ) currentStep ) ; } else if ( currentStep instanceof ScenarioTreeStepSimpleList ) { return new ScenarioGUIStepDropdownList ( ( ScenarioTreeStepSimpleList ) currentStep ) ; } else if ( currentStep instanceof ScenarioTreeStepFinish ) { return new ScenarioGUIStepFinish ( ( ScenarioTreeStepFinish ) currentStep ) ; } else if ( currentStep instanceof ScenarioTreeStepDBOWLTablet ) { return new ScenarioGUIStepDatabaseRequestTablet ( ( ScenarioTreeStepDBOWLTablet ) currentStep ) ; } else if ( currentStep instanceof ScenarioTreeStepDBOWLNotebook ) { return new ScenarioGUIStepDatabaseRequestNotebook ( ( ScenarioTreeStepDBOWLNotebook ) currentStep ) ; } else if ( currentStep instanceof ScenarioTreeStepDBOWLComputerComponents ) { return new ScenarioGUIStepDatabaseRequestComputerComponents ( ( ScenarioTreeStepDBOWLComputerComponents ) currentStep ) ; } else if ( currentStep instanceof ScenarioTreeStepDBOWLSoftwareAndOS ) { return new ScenarioGUIStepDatabaseRequestSoftwareAndOS ( ( ScenarioTreeStepDBOWLSoftwareAndOS ) currentStep ) ; } return null ; }
te	D	@ Override public void askFriendsh ( User inviter , User invitee ) { }
te	C	private String getNoMethodErrorMessage ( Object [ ] params ) { StringBuffer tmp = new StringBuffer ( ) ; tmp . append ( "Could not find method named create* for type " ) ; tmp . append ( type . getName ( ) ) ; tmp . append ( " with param types " ) ; boolean first = true ; for ( Object param : params ) { first = StringUtils . addIfFalse ( first , tmp , " " ) ; tmp . append ( param . getClass ( ) . getName ( ) ) ; } return tmp . toString ( ) ; }
te	C	public long getSelectedId ( ) { return selectedId ; }
te	F	public char readChar ( ) throws java . io . IOException { if ( inBuf > 0 ) { -- inBuf ; if ( ++ bufpos == bufsize ) bufpos = 0 ; return buffer [ bufpos ] ; } char c ; if ( ++ bufpos == available ) AdjustBuffSize ( ) ; if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == \ ) { UpdateLineColumn ( c ) ; int backSlashCnt = 1 ; for ( ; ; ) { if ( ++ bufpos == available ) AdjustBuffSize ( ) ; try { if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != \ ) { UpdateLineColumn ( c ) ; if ( ( c == u ) && ( ( backSlashCnt & 1 ) == 1 ) ) { if ( -- bufpos < 0 ) bufpos = bufsize - 1 ; break ; } backup ( backSlashCnt ) ; return \ ; } } catch ( java . io . IOException e ) { if ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; return \ ; } UpdateLineColumn ( c ) ; backSlashCnt ++ ; } try { while ( ( c = ReadByte ( ) ) == u ) ++ column ; buffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; column += 4 ; } catch ( java . io . IOException e ) { throw new Error ( "Invalid escape character at line " + line + " column " + column + "." ) ; } if ( backSlashCnt == 1 ) return c ; else { backup ( backSlashCnt - 1 ) ; return \ ; } } else { UpdateLineColumn ( c ) ; return c ; } }
te	A	public void setDestinationCompetitionId ( Integer destinationCompetitionId ) { this . destinationCompetitionId = destinationCompetitionId ; }
te	I	public -> ( boolean descending , int size , int priority ) { this . descending = descending ; this . size = size ; this . priority = priority ; }
te	C	private boolean isParamsSingleArray ( Method method ) { return method . getParameterTypes ( ) . length == 1 && method . getParameterTypes ( ) [ 0 ] . isArray ( ) ; }
te	E	@ Override public Player getPlayer ( ) { return this . player ; }
te	A	@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; PositionStatus that = ( PositionStatus ) o ; if ( type != null ? ! type . equals ( that . type ) : that . type != null ) return false ; if ( name != null ? ! name . equals ( that . name ) : that . name != null ) return false ; return destinationCompetitionId != null ? destinationCompetitionId . equals ( that . destinationCompetitionId ) : that . destinationCompetitionId == null ; }
te	F	public void playSong ( Song song ) { _seek . setMaximum ( _myList . getModel ( ) . getElementAt ( _index ) . getDuration ( ) * 1000 ) ; _seek . setValue ( 0 ) ; _player = new MediaPlayer ( song . getNotes ( ) ) ; _player . setVolume ( _volume . getValue ( ) ) ; _player . setOnEndOfMedia ( new Runnable ( ) { @ Override public void run ( ) { _index ++ ; if ( _myList . getModel ( ) . getSize ( ) == _index ) { _index = 0 ; _player . stop ( ) ; _playPause . removeActionListener ( _pause ) ; _playPause . addActionListener ( _play ) ; _playPause . setIcon ( _playEnabled ) ; _playPause . setToolTipText ( "Play" ) ; _seek . setString ( "00:00:/00:00" ) ; _current = Status . STOP ; } else { playSong ( _myList . getModel ( ) . getElementAt ( _index ) ) ; } } } ) ; _current = Status . PLAY ; _player . play ( ) ; System . out . println ( "Just got here." ) ; System . out . println ( _current ) ; }
te	I	public void clock ( ) { try { executeProcessorClock ( ) ; } catch ( SystemException e ) { System . err . println ( e . toString ( ) ) ; } }
te	C	@ Override public Point2D world2screen ( Point2D world ) { return wr . getWorldTransform ( ) . transform ( world , null ) ; }
te	F	Type ( String series , String shape ) { mSeries = ( series == null ? null : series . intern ( ) ) ; mShape = ( shape == null ? null : shape . intern ( ) ) ; }
te	J	public FileSize ( String filename , long size ) { this . filename = filename ; this . size = size ; }
te	A	public TopicStatisticListViewImpl ( ) { super ( "CardStatisticListView" ) ; this . initComponents ( ) ; }
te	H	int getRowAdjustment ( double deltaX , double deltaY ) { double positionOffset = getPositionOffset ( deltaY ) ; if ( deltaY < 1.0 / 3.0 ) { return 0 ; } if ( deltaY < 0.5 ) { if ( deltaX > 0.5 ) { return 0 ; } else if ( deltaX <= 0.5 - positionOffset ) { return 0 ; } else { return 1 ; } } if ( deltaY < 2.0 / 3.0 ) { if ( deltaX <= 0.5 ) { return 0 ; } else if ( deltaX >= 1.5 - 2 * positionOffset ) { return 0 ; } else { return - 1 ; } } if ( deltaY < 4.0 / 3.0 ) { return 0 ; } if ( deltaY < 1.5 ) { if ( deltaX <= 0.5 ) { return 0 ; } else if ( deltaX >= 1.5 - 2 * positionOffset ) { return 0 ; } else { return 1 ; } } if ( deltaY < 5.0 / 3.0 ) { if ( deltaX > 0.5 ) { return 0 ; } else if ( deltaX < 0.5 - positionOffset ) { return 0 ; } else { return - 1 ; } } return 0 ; }
te	J	@ Override public boolean isCellEditable ( int row , int col ) { return col >= 1 ; }
te	J	public Object getValueAt ( int row , int col ) { return data . get ( row ) [ col ] ; }
te	H	private int readIndirect ( int dataHigh , int dataLow ) { int iHLAddr = joinBytes ( dataHigh , dataLow ) ; int iLowByte = readMemory ( int16 ( iHLAddr ) ) ; int iHighByte = readMemory ( int16 ( iHLAddr + 1 ) ) ; int iAddr = joinBytes ( iHighByte , iLowByte ) ; return iAddr ; }
te	E	private void sentence ( ) { Token t = popToken ( ) ; switch ( t . getTokenType ( ) ) { case SBEGIN : pushToken ( t ) ; compound ( ) ; break ; case SIF : expression ( ) ; expectToken ( TokenType . STHEN ) ; compound ( ) ; if ( testToken ( TokenType . SELSE ) ) { expectToken ( TokenType . SELSE ) ; compound ( ) ; } break ; case SWHILE : expression ( ) ; expectToken ( TokenType . SDO ) ; sentence ( ) ; break ; case SIDENTIFIER : if ( whenToken ( TokenType . SLPAREN ) ) { expressions ( ) ; expectToken ( TokenType . SRPAREN ) ; } else if ( testToken ( new TokenType [ ] { TokenType . SASSIGN , TokenType . SLBRACKET } ) ) { pushToken ( t ) ; variable ( ) ; expectToken ( TokenType . SASSIGN ) ; expression ( ) ; } else { } break ; case SREADLN : if ( ! whenToken ( TokenType . SLPAREN ) ) break ; var_names ( ) ; expectToken ( TokenType . SRPAREN ) ; break ; case SWRITELN : if ( ! whenToken ( TokenType . SLPAREN ) ) break ; expressions ( ) ; expectToken ( TokenType . SRPAREN ) ; break ; default : fail ( t ) ; } }
te	E	private void classifyPixels ( ) { _class = new int [ _height ] [ _width ] ; for ( int y = 0 ; y < _height ; y ++ ) for ( int x = 0 ; x < _width ; x ++ ) _class [ y ] [ x ] = _assignedType [ _image [ y ] [ x ] ] ; }
te	I	private void checkCache ( Container parent ) { if ( parent == null ) return ; if ( dirty ) grid = null ; int mc = PlatformDefaults . getModCount ( ) ; if ( lastModCount != mc ) { grid = null ; lastModCount = mc ; } if ( parent . isValid ( ) == false ) { if ( lastWasInvalid == false ) { lastWasInvalid = true ; int hash = 0 ; boolean resetLastInvalidOnParent = false ; for ( ComponentWrapper wrapper : ccMap . keySet ( ) ) { Object component = wrapper . getComponent ( ) ; if ( component instanceof JTextArea || component instanceof JEditorPane ) resetLastInvalidOnParent = true ; hash ^= wrapper . getLayoutHashCode ( ) ; hash += 285134905 ; } if ( resetLastInvalidOnParent ) resetLastInvalidOnParent ( parent ) ; if ( hash != lastHash ) { grid = null ; lastHash = hash ; } Dimension ps = parent . getSize ( ) ; if ( lastInvalidSize == null || ! lastInvalidSize . equals ( ps ) ) { if ( grid != null ) grid . invalidateContainerSize ( ) ; lastInvalidSize = ps ; } } } else { lastWasInvalid = false ; } ContainerWrapper par = checkParent ( parent ) ; setDebug ( par , getDebugMillis ( ) > 0 ) ; if ( grid == null ) grid = new Grid ( par , lc , rowSpecs , colSpecs , ccMap , callbackList ) ; dirty = false ; }
te	G	@ Test public void canAddCategoryWithSameName ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory = new CategoryModel ( "toAddCategory" , generatedStaffId ) ; CategoryModel addedCategory = null ; boolean wasException = false ; try { addedCategory = cd . addCategory ( addCategory ) ; cd . addCategory ( addCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } deleteCategoryById ( addedCategory . getId ( ) ) ; assertTrue ( wasException ) ; }
te	A	public String getType ( ) { return type ; }
te	C	public String getSelectedType ( ) { return selectedType ; }
te	H	@ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; }
te	B	public void initComponents ( ) { this . getContentPane ( ) . setBackground ( Color . WHITE ) ; this . topic = new JTextPane ( ) ; this . scrollPane = new JScrollPane ( table ) ; table . setPreferredScrollableViewportSize ( new Dimension ( 400 , 0 ) ) ; super . setBackground ( Color . WHITE ) ; super . setResizable ( false ) ; super . setSize ( 500 , 500 ) ; super . setVisible ( true ) ; super . setLayout ( null ) ; scrollPane . setBounds ( 50 , 80 , 400 , 350 ) ; topic . setEditable ( false ) ; SimpleAttributeSet set = new SimpleAttributeSet ( ) ; StyleConstants . setAlignment ( set , StyleConstants . ALIGN_LEFT ) ; StyleConstants . setFontFamily ( set , "Times New Roman" ) ; StyleConstants . setFontSize ( set , 30 ) ; StyleConstants . setItalic ( set , true ) ; StyleConstants . setBold ( set , true ) ; topic . setParagraphAttributes ( set , true ) ; topic . setBackground ( Color . WHITE ) ; topic . setBounds ( 50 , 20 , 200 , 50 ) ; topic . setText ( "Topic" ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_OFF ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; scrollPane . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_ALWAYS ) ; super . add ( scrollPane ) ; super . add ( topic ) ; }
te	D	public void busted ( ) { int targetSize = Math . min ( throwz . size ( ) + 1 , 3 ) ; throwz = new ArrayList < > ( ) ; for ( int i = 0 ; i < targetSize ; i ++ ) { throwz . add ( 0 ) ; } busted = true ; }
te	J	@ Override protected void mergePartialIndex ( int lastRound ) { lastProcessedDocInfo . clear ( ) ; pageRanks . clear ( ) ; numViews . clear ( ) ; for ( int idx = 0 ; idx < MAXCORPUS ; idx ++ ) { CompressedIndex finalIndex = new CompressedIndex ( ) ; SkipPointer finalSkipPointer = new SkipPointer ( ) ; for ( int round = 1 ; round <= lastRound ; round ++ ) { CompressedIndex currIndex = loadIndex ( idx , round ) ; SkipPointer currSkipPointer = loadSkipPointer ( idx , round ) ; if ( currIndex == null || currSkipPointer == null ) continue ; if ( finalIndex . isEmpty ( ) ) { finalIndex = currIndex ; finalSkipPointer = currSkipPointer ; continue ; } else { Integer [ ] keys = currIndex . keySet ( ) . toArray ( new Integer [ 1 ] ) ; for ( int wordId : keys ) { ArrayList < short > posting = currIndex . remove ( wordId ) ; ArrayList < Integer > skipInfo = currSkipPointer . remove ( wordId ) ; if ( ! finalIndex . containsKey ( wordId ) ) { finalIndex . put ( wordId , posting ) ; finalSkipPointer . put ( wordId , skipInfo ) ; } else { ArrayList < Integer > prevSkipInfo = finalSkipPointer . get ( wordId ) ; finalIndex . get ( wordId ) . addAll ( posting ) ; prevSkipInfo . addAll ( skipInfo ) ; } } } } writeFinalIndex ( idx , finalIndex ) ; cleaningPartialIndex ( idx , lastRound ) ; writeFinalSkipPointer ( idx , finalSkipPointer ) ; cleaningPartialSkipPointer ( idx , lastRound ) ; } }
te	F	static int twoPairs ( int [ ] player ) { int [ ] valueCount = new int [ 13 ] ; for ( int i = 0 ; i < 5 ; i ++ ) valueCount [ player [ i ] / 4 ] ++ ; int first = 13 ; int second = 13 ; for ( int i = 0 ; i < 13 ; i ++ ) { if ( valueCount [ i ] == 2 && first == 13 ) first = i ; else if ( valueCount [ i ] == 2 ) second = i ; } if ( first < 13 && second < 13 ) return first ; else return - 1 ; }
te	H	protected void releaseBuffers ( WebSocket c ) throws InterruptedException { }
te	E	@ Override public int getTotalTime ( ) { return 0 ; }
te	J	public int getRowCount ( ) { return data . size ( ) ; }
te	J	public int compareTo ( Object o ) { return code . compareTo ( ( ( CodeWord ) o ) . getCode ( ) ) ; }
te	H	public void setMonde ( Monde m ) { this . m = m ; List < case > cases_libres = new ArrayList < case > ( ) ; for ( case c : this . m . get_cases ( ) ) { if ( c . getNiveau_obstacle ( ) == 0 ) { cases_libres . add ( c ) ; } } if ( cases_libres . size ( ) > 0 && ConfigurationLoader . MAX_FOURMILIERES >= 1 ) { case c = cases_libres . get ( new Random ( ) . nextInt ( cases_libres . size ( ) ) ) ; cases_libres . remove ( c ) ; frmModel . data . add ( new Object [ ] { 1 , c . getY ( ) , c . getX ( ) , 45 , 5 , 6 , 20 , 100 , Color . green } ) ; } if ( cases_libres . size ( ) > 0 && ConfigurationLoader . MAX_FOURMILIERES >= 2 ) { case c = cases_libres . get ( new Random ( ) . nextInt ( cases_libres . size ( ) ) ) ; cases_libres . remove ( c ) ; frmModel . data . add ( new Object [ ] { 0 , c . getY ( ) , c . getX ( ) , 45 , 5 , 6 , 20 , 100 , Color . blue } ) ; } try { paintMap ( m , frmModel ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	D	public void busted ( ) { int targetSize = Math . min ( throwz . size ( ) + 1 , 3 ) ; throwz = new ArrayList < > ( ) ; for ( int i = 0 ; i < targetSize ; i ++ ) { throwz . add ( 0 ) ; } busted = true ; }
te	A	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
te	I	public String getCode ( ) { return code ; }
te	I	private int readIndirectY ( int data ) { int iLowByte = readMemory ( int8 ( data ) ) ; int iHighByte = readMemory ( int8 ( data + 1 ) ) ; int iAddr = joinBytes ( iHighByte , iLowByte ) ; calculateAdditionalCycles ( iAddr , iAddr + getY ( ) , false ) ; return int16 ( iAddr + getY ( ) ) ; }
te	E	protected void UpdateLineColumn ( char c ) { column ++ ; if ( prevCharIsLF ) { prevCharIsLF = false ; line += ( column = 1 ) ; } else if ( prevCharIsCR ) { prevCharIsCR = false ; if ( c ==  ) { prevCharIsLF = true ; } else line += ( column = 1 ) ; } switch ( c ) { case  : prevCharIsCR = true ; break ; case  : prevCharIsLF = true ; break ; case 	 : column -- ; column += ( tabSize - ( column % tabSize ) ) ; break ; default : break ; } bufline [ bufpos ] = line ; bufcolumn [ bufpos ] = column ; }
te	J	public static String getBLOBEnableAsString ( BLOBEnables BLOBEnable ) { if ( BLOBEnable == BLOBEnables . NEVER ) { return "Never" ; } else if ( BLOBEnable == BLOBEnables . ALSO ) { return "Also" ; } else if ( BLOBEnable == BLOBEnables . ONLY ) { return "Only" ; } return "" ; }
te	J	@ Override public class < ? extends Object > getColumnClass ( int c ) { return longValues [ c ] . getClass ( ) ; }
te	C	public void setSelectedType ( String selectedType ) { this . selectedType = selectedType ; }
te	G	public void addLayoutCallback ( LayoutCallback callback ) { if ( callback == null ) throw new NullPointerException ( ) ; if ( callbackList == null ) callbackList = new ArrayList < LayoutCallback > ( 1 ) ; callbackList . add ( callback ) ; }
te	H	private int readAbsolute ( int dataHigh , int dataLow ) { int iAddr = joinBytes ( dataHigh , dataLow ) ; return iAddr ; }
te	F	public void add ( GameGuiListener l ) { listeners . add ( l ) ; }
te	G	@ Test public void canAddNullCategory ( ) { CategoryDAO cd = new CategoryDAO ( ) ; CategoryModel addCategory = null ; boolean wasException = false ; try { cd . addCategory ( addCategory ) ; } catch ( WebshopAppException e ) { wasException = true ; } assertTrue ( wasException ) ; }
te	E	public boolean isClosed ( ) { return this . closedWithUnthrownDarts || this . busted || this . throwz . size ( ) == 3 ; }
te	E	public void setTime ( Date time ) { this . time = time ; }
te	B	public void setMark ( int x , int y ) { markX = x ; markY = y ; }
te	C	private boolean areClassesCompatible ( class < ? > class1 , class < ? > class2 ) { return ( class1 . isAssignableFrom ( class2 ) || ( wrapperAndPrimitives ( class1 , class2 ) ) ) ; }
te	G	public void tableChanged ( TableModelEvent e ) { if ( ! isSorting ( ) ) { clearSortingState ( ) ; fireTableChanged ( e ) ; return ; } if ( e . getFirstRow ( ) == TableModelEvent . HEADER_ROW ) { cancelSorting ( ) ; fireTableChanged ( e ) ; return ; } int column = e . getColumn ( ) ; if ( e . getFirstRow ( ) == e . getLastRow ( ) && column != TableModelEvent . ALL_COLUMNS && getSortingStatus ( column ) == NOT_SORTED && modelToView != null ) { int viewIndex = getModelToView ( ) [ e . getFirstRow ( ) ] ; fireTableChanged ( new TableModelEvent ( TableSorter . this , viewIndex , viewIndex , column , e . getType ( ) ) ) ; return ; } clearSortingState ( ) ; fireTableDataChanged ( ) ; return ; }
te	J	public static boolean isValidBLOBEnable ( String BLOBEnable ) { try { parseBLOBEnable ( BLOBEnable ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
te	I	private int readIndirectX ( int data ) { int iLowByte = readMemory ( int8 ( data + getX ( ) ) ) ; int iHighByte = readMemory ( int8 ( data + getX ( ) + 1 ) ) ; int iAddr = joinBytes ( iHighByte , iLowByte ) ; return iAddr ; }
te	H	double getPositionOffset ( double row ) { double deltaY = row % 2.0 ; if ( deltaY <= 1.0 / 3.0 ) { return 0 ; } if ( deltaY <= 2.0 / 3.0 ) { return 1.5 * deltaY - 0.5 ; } if ( deltaY < 4.0 / 3.0 ) { return 0.5 ; } if ( deltaY < 5.0 / 3.0 ) { return 2.5 - 1.5 * deltaY ; } return 0 ; }
te	H	private int readAbsoluteY ( int dataHigh , int dataLow ) { int iAddr = readAbsolute ( dataHigh , dataLow ) ; calculateAdditionalCycles ( iAddr , iAddr + getY ( ) , false ) ; return iAddr + getY ( ) ; }
te	C	public ArrayList < State > getMovesCorrectlyPlease ( State rr ) { ArrayList < State > msts = new ArrayList < State > ( ) ; Loc [ ] r = new Loc [ rr . size ( ) ] ; rr . toArray ( r ) ; for ( int dir = 0 ; dir < 4 ; dir ++ ) { State sts = new State ( ) ; for ( int i = 0 ; i < r . length ; i ++ ) { int x = r [ i ] . x ; int y = r [ i ] . y ; switch ( dir ) { case 0 : if ( canAdd ( r [ i ] , dir , rr ) ) { Loc nl = new Loc ( x , y - 1 ) ; sts . add ( nl ) ; } if ( ! mapConstraint ( r [ i ] , dir ) && ! pieceConstraint ( r [ i ] , dir , rr ) ) { sts . add ( new Loc ( x , y ) ) ; } break ; case 1 : if ( canAdd ( r [ i ] , dir , rr ) ) { Loc nl = new Loc ( x , y + 1 ) ; sts . add ( nl ) ; } if ( ! mapConstraint ( r [ i ] , dir ) && ! pieceConstraint ( r [ i ] , dir , rr ) ) { sts . add ( new Loc ( x , y ) ) ; } break ; case 2 : if ( canAdd ( r [ i ] , dir , rr ) ) { Loc nl = new Loc ( x - 1 , y ) ; sts . add ( nl ) ; } if ( ! mapConstraint ( r [ i ] , dir ) && ! pieceConstraint ( r [ i ] , dir , rr ) ) { sts . add ( new Loc ( x , y ) ) ; } break ; case 3 : if ( canAdd ( r [ i ] , dir , rr ) ) { Loc nl = new Loc ( x + 1 , y ) ; sts . add ( nl ) ; } if ( ! mapConstraint ( r [ i ] , dir ) && ! pieceConstraint ( r [ i ] , dir , rr ) ) { sts . add ( new Loc ( x , y ) ) ; } break ; } } if ( sts . isEmpty ( ) ) { sts = rr . clone ( ) ; } sts . id = dir ; msts . add ( sts ) ; } return msts ; }
te	J	private int nextPC ( int lastPC ) { AddressingMode addrMode = OPADDRESSING [ readMemory ( lastPC ) ] ; int iNextPC = lastPC ; switch ( addrMode ) { case Accumulator : iNextPC += 1 ; break ; case Absolute : iNextPC += 3 ; break ; case AbsoluteX : iNextPC += 3 ; break ; case AbsoluteY : iNextPC += 3 ; break ; case Immediate : iNextPC += 2 ; break ; case Implied : iNextPC += 1 ; break ; case Indirect : iNextPC += 3 ; break ; case IndirectX : iNextPC += 2 ; break ; case IndirectY : iNextPC += 2 ; break ; case Relative : iNextPC += 2 ; break ; case ZeroPage : iNextPC += 2 ; break ; case ZeroPageX : iNextPC += 2 ; break ; case ZeroPageY : iNextPC += 2 ; break ; } return iNextPC ; }
te	E	private void formal_arguments_name_sequence ( ) { do { expectToken ( TokenType . SIDENTIFIER ) ; } while ( whenToken ( TokenType . SCOMMA ) ) ; }
te	E	public int getThrowCount ( ) { if ( closedWithUnthrownDarts ) { return 3 ; } return this . throwz . size ( ) ; }
te	I	public int getIconWidth ( ) { return size ; }
te	E	public ArrayList < Review > haveReviews ( int articleID ) { boolean haveReviews = false ; ConnectionManager conn = null ; ArrayList < Review > allReviews = new ArrayList < Review > ( ) ; try { conn = new ConnectionManager ( ) ; Statement st = conn . getInstance ( ) . getConnection ( ) . createStatement ( ) ; String queryReviews = "SELECT * FROM Review INNER JOIN Criticism ON Review.reviewID = Criticism.reviewID WHERE articleID = '" + articleID + "'" ; ResultSet rs = st . executeQuery ( queryReviews ) ; while ( rs . next ( ) ) { Review rev = new Review ( rs . getInt ( "Review.reviewID" ) , rs . getInt ( "Review.authorReviewerID" ) , rs . getInt ( "Review.articleID" ) , rs . getString ( "Review.judgement" ) , rs . getString ( "Review.expertise" ) , rs . getString ( "Review.summary" ) , rs . getInt ( "Criticism.criticismID" ) , rs . getString ( "Review.smallErrors" ) , rs . getString ( "Review.editorComments" ) , rs . getBoolean ( "Review.isAccepted" ) , rs . getDate ( "Review.dateSubmitted" ) ) ; rev . setCriticism ( rs . getString ( "Criticism.criticism" ) ) ; System . out . println ( "found review criticism ID: " + rev . getCriticismID ( ) + " criticism text: " + rev . getCriticism ( ) ) ; allReviews . add ( rev ) ; } rs . close ( ) ; rs . close ( ) ; st . close ( ) ; conn . close ( ) ; } catch ( Exception e ) { System . out . println ( "Error " + e ) ; } finally { if ( conn != null ) { conn . close ( ) ; } } return allReviews ; }
te	A	public String getName ( ) { return name ; }
te	I	public int getIconHeight ( ) { return size ; }
te	G	@ Test public void canGetProductsByCost ( ) { ProductModel addedProduct = ProductModel . builder ( "Night Visions" , 1 ) . description ( "Imagine Dragons" ) . cost ( 149 ) . rrp ( 400 ) . build ( ) ; List < ProductModel > products = null ; boolean isInResult = false ; try { addedProduct = new ProductModel ( insertProduct ( addedProduct ) , addedProduct ) ; products = pd . getProductsByCost ( addedProduct . getCost ( ) ) ; for ( ProductModel product : products ) { if ( addedProduct . equals ( product ) ) { isInResult = true ; break ; } } deleteProduct ( addedProduct . getId ( ) ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; } assertTrue ( isInResult ) ; }
te	F	private void simple_expression ( ) { TokenType [ ] op = new TokenType [ ] { TokenType . SPLUS , TokenType . SMINUS , TokenType . SOR } ; whenToken ( new TokenType [ ] { TokenType . SPLUS , TokenType . SMINUS } ) ; term ( ) ; while ( whenToken ( op ) ) { term ( ) ; } }
te	A	private LevelPackHandler ( ) { setLevelStage ( Settings_Level . MAIN_LEVEL ) ; levelStageMap = new HashMap < Integer , ArrayList < ILevelPack >> ( ) ; for ( int i = Settings_Level . AWARD_LEVEL ; i <= Settings_Level . LEVEL_STAGE_END ; i ++ ) { levelStageMap . put ( i , new ArrayList < ILevelPack > ( ) ) ; } }
te	F	@ Override public int hashCode ( ) { int m = ( mSeries == null ? 0 : mSeries . hashCode ( ) ) ; int n = ( mShape == null ? 0 : mShape . hashCode ( ) ) ; return m ^ n ; }
te	B	public static void forEmptyAspect ( Collection < Invalid > errors , Aspect aspect , Collection < ? > items , String name ) { if ( items . isEmpty ( ) ) { errors . add ( new Invalid ( aspect , String . format ( "There are no %s defined; there must be at least one." , name ) ) ) ; } }
te	I	private void pushBuffer ( ByteBuffer buf ) throws InterruptedException { if ( buffers . size ( ) > queuesize . intValue ( ) ) return ; buffers . put ( buf ) ; }
te	E	public static double getPowerDifference ( Laser l , double elapsedTime ) { double diff = 0 ; double totalPower = 0 ; double power = 0 ; if ( l . parent instanceof Ship ) { totalPower = ( ( Ship ) l . parent ) . getTotalPower ( ) ; power = ( ( Ship ) l . parent ) . getPower ( ) ; } else if ( l . parent instanceof Turret ) { totalPower = ( ( Ship ) ( ( Turret ) l . parent ) . getParent ( ) ) . getTotalPower ( ) ; power = ( ( Turret ) l . parent ) . power ; } if ( totalPower < 3 ) { power = 1 ; } else { power = l . power ; } diff = ( power / 1000 ) * elapsedTime ; return diff ; }
te	B	static RendererContext createContext ( ) { final RendererContext newCtx = new RendererContext ( "ctx" + Integer . toString ( contextCount . getAndIncrement ( ) ) ) ; if ( RendererContext . stats != null ) { RendererContext . stats . allContexts . add ( newCtx ) ; } return newCtx ; }
te	C	public List < Appointment > getAppointmentList ( ) { return appointmentList ; }
te	C	public void setCounters ( ) { isCounting = true ; counters = new TIntIntHashMap [ tot ] ; for ( int i = 0 ; i < tot ; ++ i ) counters [ i ] = new TIntIntHashMap ( ) ; }
te	C	private class < ? > allParametersClass ( Object [ ] params ) { class < ? > tmp = null ; for ( Object object : params ) { if ( tmp == null ) { tmp = object . getClass ( ) ; } else { if ( ! object . getClass ( ) . equals ( tmp ) ) { return null ; } } } return tmp ; }
te	H	private void updateCOLUP1 ( int data ) { setRegister ( COLUP1 , data ) ; }
te	I	private ByteBuffer takeBuffer ( ) throws InterruptedException { return buffers . take ( ) ; }
te	A	public void setShowScripts ( boolean yesno ) { showScripts = yesno ; }
te	B	public int getCurrentLayer ( ) { return currentLayer ; }
te	F	private void expression ( ) { TokenType [ ] op = new TokenType [ ] { TokenType . SEQUAL , TokenType . SNOTEQUAL , TokenType . SLESS , TokenType . SLESSEQUAL , TokenType . SGREAT , TokenType . SGREATEQUAL } ; simple_expression ( ) ; if ( whenToken ( op ) ) { simple_expression ( ) ; } }
te	C	public void setSelectedId ( long selectedId ) { this . selectedId = selectedId ; }
te	G	private int processORIInst ( ORI ori ) { String opCode = ori . getOpcode ( ) . name ( ) ; int instOrder = ori . getOrder ( ) ; String src1n = "" ; if ( ori . getState ( ) . equals ( State . ISSUE_COMP ) ) { boolean src1 = ! dataHaz . checkRAWHazard ( ori . getSrc1 ( ) , ori ) ; if ( src1 ) { long src1v = regMem . getRegValue ( ori . getSrc1 ( ) . getId ( ) ) ; ori . getSrc1 ( ) . setValue ( src1v . intValue ( ) ) ; log . debug ( "opCode " + "[" + instOrder + "]" + " instruction read from Register Memory." ) ; log . debug ( "Source1 value is: " + opCode + "[" + instOrder + "]" + src1v . intValue ( ) + " Register: " + ori . getSrc1 ( ) . getId ( ) . name ( ) ) ; log . debug ( "Immidiate value is: " + opCode + "[" + instOrder + "]" + ori . getValue ( ) ) ; ori . clearRawHazard ( ) ; ori . setState ( State . READ ) ; } else { ori . setRawHazard ( ) ; ResultMgr . getInstance ( ) . setRawHazard ( ori . getRawInst ( ) ) ; if ( ! src1 ) { src1n = ori . getSrc1 ( ) . getName ( ) ; log . debug ( opCode + "[" + instOrder + "]" + " Source registers " + src1n + " " + " is already busy. RAW hazard detected." ) ; } } } return 0 ; }
te	A	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( guiList ) ) ; guiList . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { if ( ! e . getValueIsAdjusting ( ) && ( patternList != null ) ) { int sel = guiList . getSelectedIndex ( ) ; if ( sel != - 1 ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
te	H	@ Override public boolean hasNext ( ) { return current < grid . length ; }
te	C	@ Override public void setSelection ( Rectangle selection ) { wr . setSelection ( selection ) ; }
te	B	public void setLocator ( TileLocator tileLocator ) { this . tileLocator = tileLocator ; }
te	B	@ Override public int hashCode ( ) { int result = type != null ? type . hashCode ( ) : 0 ; result = 31 * result + ( name != null ? name . hashCode ( ) : 0 ) ; result = 31 * result + ( destinationCompetitionId != null ? destinationCompetitionId . hashCode ( ) : 0 ) ; return result ; }
te	I	private int readZeroX ( int data ) { int iAddr = readZero ( data + getX ( ) ) ; return iAddr ; }
te	G	public static String replace ( String s , String f , String r ) { if ( s . length ( ) < f . length ( ) ) { return "" ; } if ( r . length ( ) == 0 ) { return "Error!!! String Cannot Be Replaced With Empty String" ; } char c [ ] = s . toCharArray ( ) ; char c1 [ ] = f . toCharArray ( ) ; String retString = null ; String tempString = null ; int index = - 1 ; boolean flag = false ; for ( int i = 0 ; i < c . length ; i ++ ) { for ( int j = 0 ; j < c1 . length ; j ++ ) { if ( ( c [ i ] == c1 [ j ] ) && ( j == ( c1 . length - 1 ) ) ) { flag = true ; index = i ; System . out . println ( index ) ; } else if ( ( c [ i ] == c1 [ j ] ) && ( i == ( c . length - 1 ) ) ) { index = - 1 ; flag = false ; } else if ( c [ i ] == c1 [ j ] ) { i ++ ; index = i ; } } if ( index != - 1 ) { break ; } } if ( flag && ( index != - 1 ) ) { retString = StringDemo . replace ( s . substring ( index + 1 ) , f , r ) ; if ( retString . equals ( "String Not Found" ) ) { return s . substring ( 0 , ( index - f . length ( ) ) + 1 ) + r + s . substring ( index + 1 ) ; } return s . substring ( 0 , ( index - f . length ( ) ) + 1 ) + r + retString ; } return "String Not Found" ; }
te	A	public Integer getDestinationCompetitionId ( ) { return destinationCompetitionId ; }
te	B	public void setTilePainter ( TilePainter tilePainter ) { this . tilePainter = tilePainter ; }
te	I	private void initColumnSizes ( JTable table ) { FourmiliereTableModel model = ( FourmiliereTableModel ) table . getModel ( ) ; TableColumn column ; Component comp ; int headerWidth ; int cellWidth ; Object [ ] longValues = model . longValues ; TableCellRenderer headerRenderer = table . getTableHeader ( ) . getDefaultRenderer ( ) ; for ( int i = 0 ; i < model . getColumnCount ( ) ; i ++ ) { column = table . getColumnModel ( ) . getColumn ( i ) ; comp = headerRenderer . getTableCellRendererComponent ( null , column . getHeaderValue ( ) , false , false , 0 , 0 ) ; headerWidth = comp . getPreferredSize ( ) . width ; comp = table . getDefaultRenderer ( model . getColumnClass ( i ) ) . getTableCellRendererComponent ( table , longValues [ i ] , false , false , 0 , i ) ; cellWidth = comp . getPreferredSize ( ) . width ; column . setPreferredWidth ( Math . max ( headerWidth , cellWidth ) ) ; } }
te	C	private State getInitBeliefs ( ) { State s = new State ( ) ; for ( int i = 0 ; i < map . gridSize ; i ++ ) { for ( int j = 0 ; j < map . gridSize ; j ++ ) { if ( map . current_map [ i ] . charAt ( j ) == . ) { s . add ( new Loc ( j , i ) ) ; } } } System . out . println ( "initial states: " + s . toString ( ) ) ; return s ; }
te	E	public int numFoods ( ) { return foods . size ( ) ; }
te	H	private void updateCOLUP0 ( int data ) { setRegister ( COLUP0 , data ) ; }
te	G	protected void emptyElementWithNumber ( int elementNumber ) { placedElements . remove ( elementNumber ) ; emptyElements . add ( elementNumber ) ; elements [ elementNumber ] = EMPTY_ELEMENT_VALUE ; Set < Integer > affectedElements = getRelatedElementNumbersForElementWithNumber ( elementNumber ) ; affectedElements . add ( elementNumber ) ; for ( Integer affectedElementNumber : affectedElements ) { validElementsCache . set ( affectedElementNumber , getValidValuesForElementWithNumber ( affectedElementNumber ) ) ; } }
te	A	public static String emptyIfNull ( String test ) { return test == null ? "" : test ; }
te	J	int estimateDistanceInCells ( int cellId1 , int cellId2 ) { double distanceInDegrees = getDistanceInDegrees ( cellId1 , cellId2 ) ; int areaOfSphereInHexagonalCells = countCells ( ) - 2 ; double areaOfSphereInSquareDegrees = 360.0 * 360.0 / Math . PI ; double areaOfHexagonalCellInSquareDegrees = areaOfSphereInSquareDegrees / areaOfSphereInHexagonalCells ; double areaOfHexagonalCellInCircularDegrees = areaOfHexagonalCellInSquareDegrees * 4.0 / Math . PI ; double typicalCellDiameterInDegrees = Math . sqrt ( areaOfHexagonalCellInCircularDegrees ) ; double distanceInCells = distanceInDegrees / typicalCellDiameterInDegrees ; return ( int ) Math . round ( distanceInCells ) ; }
te	H	public static SwitchRules parseSwitchRule ( String rule ) throws IllegalArgumentException { if ( rule . compareTo ( "OneOfMany" ) == 0 ) { return SwitchRules . ONE_OF_MANY ; } else if ( rule . compareTo ( "AtMostOne" ) == 0 ) { return SwitchRules . AT_MOST_ONE ; } else if ( rule . compareTo ( "AnyOfMany" ) == 0 ) { return SwitchRules . ANY_OF_MANY ; } throw new IllegalArgumentException ( "Invalid SwitchRules String: '" + rule + "'" ) ; }
te	E	private void compound ( ) { expectToken ( TokenType . SBEGIN ) ; do { sentence ( ) ; } while ( whenToken ( TokenType . SSEMICOLON ) ) ; expectToken ( TokenType . SEND ) ; }
te	C	public void closeCounters ( ) { isCounting = false ; counters = null ; }
te	F	private boolean isGameGoingOn ( ) { return currentGame != null ; }
te	G	@ Test public void canDeleteProduct ( ) { ProductModel addedProduct = ProductModel . builder ( "Night Visions" , 1 ) . description ( "Imagine Dragons" ) . cost ( 149 ) . rrp ( 400 ) . build ( ) ; ProductModel getProduct = null ; try { addedProduct = new ProductModel ( insertProduct ( addedProduct ) , addedProduct ) ; pd . deleteProduct ( addedProduct . getId ( ) ) ; getProduct = getProductById ( addedProduct . getId ( ) ) ; deleteProduct ( addedProduct . getId ( ) ) ; } catch ( WebshopAppException e ) { e . printStackTrace ( ) ; } assertNull ( getProduct ) ; }
te	E	public void endTurn ( ) { if ( ! playerFinished ( ) && ! currentTurn . isClosed ( ) ) { if ( currentTurn . hasRemainingThrows ( ) ) { if ( ! currentTurn . busted ) { currentTurn . closedWithUnthrownDarts = true ; } else { currentTurn . terminatedCorrect = true ; } if ( currentTurn . getRemainingThrows ( ) == 3 ) { currentTurn . closedWithoutThrownDarts = true ; } } else { currentTurn . terminatedCorrect = true ; } } else { currentTurn . terminatedCorrect = true ; } }
te	J	public void executeProcessorClock ( ) throws SystemException { if ( getConsole ( ) . getTIA ( ) . getRDY ( ) ) { if ( mAddressWrite ) { writeMemory ( mWriteDelayAddr , mWriteDelayByte , true ) ; mAddressWrite = false ; } return ; } mTotalCycles ++ ; if ( mRemainingCycles > 0 ) { mRemainingCycles -- ; return ; } if ( mAddressWrite ) { writeMemory ( mWriteDelayAddr , mWriteDelayByte , true ) ; mAddressWrite = false ; } executeInstruction ( ) ; }
te	F	private static void appendMapFile ( File file , StringBuilder out ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; for ( String k = br . readLine ( ) ; k != null ; k = br . readLine ( ) ) { k = k . trim ( ) ; if ( k . isEmpty ( ) || k . startsWith ( "%" ) ) { continue ; } out . append ( k ) ; out . append (  ) ; } br . close ( ) ; }
te	G	public void removeLayoutCallback ( LayoutCallback callback ) { if ( callbackList != null ) callbackList . remove ( callback ) ; }
te	J	@ Override public void setValueAt ( Object value , int row , int col ) { boolean valid = true ; if ( col == 1 || col == 2 ) { int x = 0 ; int y = 0 ; if ( col == 1 ) { x = ( Integer ) data . get ( row ) [ 2 ] ; y = ( Integer ) value ; } if ( col == 2 ) { x = ( Integer ) value ; y = ( Integer ) data . get ( row ) [ 1 ] ; } for ( Object [ ] d : data ) { if ( ( Integer ) d [ 2 ] == x && ( Integer ) d [ 1 ] == y ) { valid = false ; } } if ( ! valid ) { WebOptionPane . showMessageDialog ( null , "Impossible de d\u00E9placer la fourmili\u00E8re ici.\nUne autre fourmiliere existe d\u00E9j\u00E0 \u00E0 cet emplacement" , "Antman simulator" , WebOptionPane . ERROR_MESSAGE ) ; } else { try { int obstacle = m . getCaseAt ( x , y ) . getNiveau_obstacle ( ) ; if ( obstacle > 0 ) { WebOptionPane . showMessageDialog ( null , "Impossible de d\u00E9placer la fourmili\u00E8re ici.\nUn obstacle occupe cet emplacement" , "Antman simulator" , WebOptionPane . ERROR_MESSAGE ) ; valid = false ; } } catch ( Exception e ) { WebOptionPane . showMessageDialog ( null , "Impossible de d\u00E9placer la fourmili\u00E8re ici.\nCase inexistante" , "Antman simulator" , WebOptionPane . ERROR_MESSAGE ) ; valid = false ; } } } if ( valid ) { data . get ( row ) [ col ] = value ; fireTableCellUpdated ( row , col ) ; try { paintMap ( m , frmModel ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
te	D	public boolean hasRemainingThrows ( ) { return throwz . size ( ) < 3 ; }
te	J	public long getSize ( ) { return size ; }
te	J	protected String getFlashSecurityPolicy ( ) { return "<cross-domain-policy><allow-access-from domain=\"*\" to-ports=\"" + getPort ( ) + "\" /></cross-domain-policy>" ; }
te	H	@ Override public Iterator < MapTile > iterator ( ) { return new GridRunner ( ) ; }
te	B	public static void forDuplicates ( Collection < Invalid > errors , Aspect aspect , Collection < ? extends Named > items , String name ) { List < String > names = new ArrayList < String > ( items . size ( ) ) ; boolean hasDuplicates = false ; for ( Named n : items ) { String thisName = GameData . convertToJavaIdentifier ( n . getName ( ) ) ; if ( names . contains ( thisName ) ) { hasDuplicates = true ; break ; } else { names . add ( thisName ) ; } } if ( hasDuplicates ) { errors . add ( new Invalid ( aspect , "There exist identically named " + name + "." ) ) ; } }
te	B	public EditContentDefDlg ( Shell inDialog , TableDef tableDef , FieldDef fieldDef , CreateTableDef parentDlg ) { dialog = inDialog ; this . tableDef = tableDef ; this . fieldDef = fieldDef ; this . parentDlg = parentDlg ; MigLayout ml = new MigLayout ( "nogrid" ) ; dialog . setLayout ( ml ) ; dialog . setText ( "Content Definition" ) ; dialog . setSize ( 290 , 270 ) ; initNullOkCheckbox ( ) ; initNullOkRatioSpinner ( ) ; initCombo ( ) ; Composite mainPanel = new Composite ( dialog , SWT . NONE ) ; mainPanel . setLayout ( new FormLayout ( ) ) ; mainPanel . setLayoutData ( "width 400  height 400  wrap" ) ; blankPanel = new Composite ( mainPanel , SWT . NONE ) ; blankPanel . setLayout ( new MigLayout ( "nogrid" ) ) ; blankPanel . setVisible ( false ) ; initConstsPanel ( mainPanel ) ; initNumRangePanel ( mainPanel ) ; initDateRangePanel ( mainPanel ) ; initSequencePanel ( mainPanel ) ; initRefPanel ( mainPanel ) ; initCustomPanel ( mainPanel ) ; initBlobPanel ( mainPanel ) ; initOKBtn ( ) ; dialog . open ( ) ; }
te	F	private void variable ( ) { expectToken ( TokenType . SIDENTIFIER ) ; if ( whenToken ( TokenType . SLBRACKET ) ) { expression ( ) ; expectToken ( TokenType . SRBRACKET ) ; } }
te	D	public int getRemainingThrows ( ) { return 3 - throwz . size ( ) ; }
te	J	public final void onWebsocketClose ( WebSocket conn , int code , String reason , boolean remote ) { selector . wakeup ( ) ; try { if ( removeConnection ( conn ) ) { onClose ( conn , code , reason , remote ) ; } } finally { try { releaseBuffers ( conn ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } }
te	F	@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof Type ) ) { return false ; } Type t = ( Type ) obj ; return mSeries == t . mSeries && mShape == t . mShape ; }
te	D	public int getScore ( ) { int result = 0 ; for ( Integer i : throwz ) { result += i ; } return result ; }
te	A	@ Override public final Value select ( String colName ) { checkColumnName ( colName ) ; return doSelect ( colName ) ; }
te	A	public static Invalid createInvalidNameError ( Aspect aspect , String name , String type ) { return new Invalid ( aspect , "\"" + name + "\" is not a valid " + type + " name." ) ; }
te	I	private int readZero ( int data ) { int iAddr = int8 ( data ) ; return iAddr ; }
te	D	private void exitApp ( ) { try { LogoutController logoutController = new LogoutController ( server ) ; logoutController . logout ( ) ; userList . get ( ) ; listener . stopListener ( ) ; listener . get ( ) ; for ( int i = 0 ; i < tabbedPane . getTabCount ( ) ; i ++ ) { System . out . println ( "Esperando" ) ; if ( tabbedPane . getTabComponentAt ( i ) instanceof ChatPanel ) ( ( ChatPanel ) tabbedPane . getTabComponentAt ( i ) ) . waitUnitlFinish ( ) ; } } catch ( LogoutException e1 ) { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( InterruptedException e1 ) { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( ExecutionException e1 ) { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } finally { dispose ( ) ; System . exit ( 0 ) ; } }
te	E	public void endTurn ( ) { if ( ! playerFinished ( ) && ! currentTurn . isClosed ( ) ) { if ( currentTurn . hasRemainingThrows ( ) ) { if ( ! currentTurn . busted ) { currentTurn . closedWithUnthrownDarts = true ; } else { currentTurn . terminatedCorrect = true ; } if ( currentTurn . getRemainingThrows ( ) == 3 ) { currentTurn . closedWithoutThrownDarts = true ; } } else { currentTurn . terminatedCorrect = true ; } } else { currentTurn . terminatedCorrect = true ; } }
te	I	public CodeWord ( String code , String word ) { this . code = code ; this . word = word ; }
te	H	private int readImmediate ( int data ) { return data ; }
te	D	public void addThrow ( int i ) { this . alreadyReceivedScoreEvents = true ; throwz . add ( i ) ; }
te	F	public void remove ( GameGuiListener l ) { listeners . remove ( l ) ; }
te	C	@ Override public void translateCamera ( double dx , double dy ) { wr . translateCamera ( dx , dy ) ; }
te	D	private int searchTab ( String title ) { for ( int i = 0 ; i < tabbedPane . getTabCount ( ) ; i ++ ) if ( tabbedPane . getTitleAt ( i ) . equals ( title ) ) return i ; return - 1 ; }
te	G	public boolean isValidValueForElementWithNumber ( int elementNumber , int value ) { if ( value == EMPTY_ELEMENT_VALUE ) { return false ; } else if ( elements [ elementNumber ] == value ) { return true ; } else { for ( int validElement : getValidValuesForElementWithNumber ( elementNumber ) ) { if ( validElement == value ) { return true ; } } return false ; } }
te	G	void str2d ( String str , Token token ) { try { double d ; if ( str . startsWith ( "0x" ) ) { d = long . parseLong ( str . substring ( 2 ) , 16 ) ; } else { d = double . parseDouble ( str ) ; } token . r = d ; } catch ( NumberFormatException e ) { lexerror ( "malformed number" , TK_NUMBER ) ; } }
te	D	public int getScore ( ) { int result = 0 ; for ( Integer i : throwz ) { result += i ; } return result ; }
te	B	public void trainTopics ( ) { ArrayList < Pipe > pipeList = new ArrayList < Pipe > ( ) ; pipeList . add ( new CharSequenceLowercase ( ) ) ; pipeList . add ( new CharSequence2TokenSequence ( Pattern . compile ( "\\p{L}[\\p{L}\\p{P}]+\\p{L}" ) ) ) ; pipeList . add ( new TokenSequenceRemoveStopwords ( new File ( "src\\stoplists\\en.txt" ) , "UTF-8" , false , false , false ) ) ; pipeList . add ( new TokenSequenceRemoveStopwords ( new File ( "src\\stoplists\\ph.txt" ) , "UTF-8" , false , false , false ) ) ; pipeList . add ( new TokenSequence2FeatureSequence ( ) ) ; InstanceList instances = new InstanceList ( new SerialPipes ( pipeList ) ) ; try { Reader fileReader ; fileReader = new InputStreamReader ( new FileInputStream ( new File ( "src\\malletfile.txt" ) ) , "UTF-8" ) ; instances . addThruPipe ( new CsvIterator ( fileReader , Pattern . compile ( "^(\\S*)[\\s ]*(\\S*)[\\s ]*(.*)$" ) , 3 , 2 , 1 ) ) ; } catch ( UnsupportedEncodingException ex ) { System . out . println ( "UNSUPPORTED ENCODING EXCEPTION" ) ; } catch ( FileNotFoundException ex ) { System . out . println ( "FILE NOT FOUND EXCEPTION" ) ; } int numTopics = 20 ; ParallelTopicModel model = new ParallelTopicModel ( numTopics , 1.0 , 0.01 ) ; model . addInstances ( instances ) ; model . setNumThreads ( 2 ) ; model . setNumIterations ( dataSize + 10 ) ; try { model . estimate ( ) ; } catch ( IOException ex ) { System . out . println ( "MODEL ESTIMATE EXCEPTION" ) ; } Alphabet dataAlphabet = instances . getDataAlphabet ( ) ; FeatureSequence tokens = ( FeatureSequence ) model . getData ( ) . get ( 0 ) . instance . getData ( ) ; LabelSequence topics = model . getData ( ) . get ( 0 ) . topicSequence ; Formatter out = new Formatter ( new StringBuilder ( ) , Locale . US ) ; double [ ] topicDistribution = model . getTopicProbabilities ( 0 ) ; ArrayList < TreeSet < IDSorter >> topicSortedWords = model . getSortedWords ( ) ; allTopics = new ArrayList < > ( ) ; for ( int topic = 0 ; topic < numTopics ; topic ++ ) { Iterator < IDSorter > iterator = topicSortedWords . get ( topic ) . iterator ( ) ; out = new Formatter ( new StringBuilder ( ) , Locale . US ) ; out . format ( "%d\t%.3f\t" , topic , topicDistribution [ topic ] ) ; int rank = 0 ; ArrayList < String > keywords = new ArrayList < > ( ) ; while ( iterator . hasNext ( ) && rank < 5 ) { IDSorter idCountPair = iterator . next ( ) ; out . format ( "%s " , dataAlphabet . lookupObject ( idCountPair . getID ( ) ) ) ; rank ++ ; keywords . add ( "" + dataAlphabet . lookupObject ( idCountPair . getID ( ) ) ) ; } TopicOutput topicsOut = new TopicOutput ( topic , topicDistribution [ topic ] , keywords ) ; allTopics . add ( topicsOut ) ; sortTopicsList ( allTopics ) ; System . out . println ( out ) ; } StringBuilder topicZeroText = new StringBuilder ( ) ; Iterator < IDSorter > iterator = topicSortedWords . get ( 0 ) . iterator ( ) ; int rank = 0 ; while ( iterator . hasNext ( ) && rank < 5 ) { IDSorter idCountPair = iterator . next ( ) ; topicZeroText . append ( dataAlphabet . lookupObject ( idCountPair . getID ( ) ) + " " ) ; rank ++ ; } InstanceList testing = new InstanceList ( instances . getPipe ( ) ) ; testing . addThruPipe ( new Instance ( topicZeroText . toString ( ) , null , "test instance" , null ) ) ; TopicInferencer inferencer = model . getInferencer ( ) ; double [ ] testProbabilities = inferencer . getSampledDistribution ( testing . get ( 0 ) , 10 , 1 , 5 ) ; System . out . println ( "0\t" + testProbabilities [ 0 ] ) ; }
te	C	@ Override public Point2D screen2world ( Point2D screen ) { return wr . getInverseWorldTransform ( ) . transform ( screen , null ) ; }
te	A	public void setName ( String name ) { this . name = name ; }
te	G	public static boolean equals ( String s , String s1 ) { if ( s . length ( ) != s1 . length ( ) ) { return false ; } char c [ ] = s . toCharArray ( ) ; char c1 [ ] = s1 . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( c [ i ] != c1 [ i ] ) { return false ; } } return true ; }
te	D	public void bounceOutLastThrow ( ) { if ( throwz . size ( ) > 0 ) { throwz . remove ( throwz . size ( ) - 1 ) ; throwz . add ( 0 ) ; } }
te	J	public int getColumnCount ( ) { return columnNames . length ; }
te	B	public void setName ( String name ) { this . name = name ; }
te	B	public void setCurrentLayer ( int layer ) { currentLayer = layer ; }
te	B	public void restart ( ) { for ( InputVariable inputVariable : this . inputVariables ) { inputVariable . setInputValue ( double . NaN ) ; } for ( OutputVariable outputVariable : this . outputVariables ) { outputVariable . fuzzyOutput ( ) . clear ( ) ; outputVariable . setLastValidOutput ( double . NaN ) ; } }
te	H	protected void allocateBuffers ( WebSocket c ) throws InterruptedException { if ( queuesize . get ( ) >= 2 * decoders . size ( ) + 1 ) { return ; } queuesize . incrementAndGet ( ) ; buffers . put ( createBuffer ( ) ) ; }
te	D	private void logout ( ) { try { LogoutController logoutController = new LogoutController ( server ) ; logoutController . logout ( ) ; userList . get ( ) ; listener . stopListener ( ) ; listener . get ( ) ; for ( int i = 0 ; i < tabbedPane . getTabCount ( ) ; i ++ ) { System . out . println ( "Esperando" ) ; if ( tabbedPane . getTabComponentAt ( i ) instanceof ChatPanel ) ( ( ChatPanel ) tabbedPane . getTabComponentAt ( i ) ) . waitUnitlFinish ( ) ; } } catch ( LogoutException e1 ) { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( InterruptedException e1 ) { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } catch ( ExecutionException e1 ) { JOptionPane . showMessageDialog ( null , e1 . getMessage ( ) , "Error" , JOptionPane . ERROR_MESSAGE ) ; } finally { dispose ( ) ; LoginFrame loginFrame = new LoginFrame ( server , url , serverPort , listenPort ) ; loginFrame . setDefaultCloseOperation ( JFrame . DO_NOTHING_ON_CLOSE ) ; loginFrame . setVisible ( true ) ; } }
te	D	public void setColor ( Color color ) { this . color = color ; }
te	I	private int readZeroY ( int data ) { int iAddr = readZero ( data + getY ( ) ) ; return iAddr ; }
te	D	public long getLastCollideTime ( Sprite s ) { long lastCollideTime = 0 ; if ( collisionSpriteTimes . containsKey ( s ) ) { lastCollideTime = collisionSpriteTimes . get ( s ) ; } return lastCollideTime ; }
te	D	public int getRemainingThrows ( ) { return 3 - throwz . size ( ) ; }
te	A	private void checkColumnName ( String columnName ) throws SqlException { if ( ! getColumnDefinitions ( ) . containsKey ( columnName ) ) { throw new SqlException ( "No such column: " + columnName ) ; } }
te	J	public final void onWebsocketOpen ( WebSocket conn , Handshakedata handshake ) { if ( addConnection ( conn ) ) { onOpen ( conn , ( ClientHandshake ) handshake ) ; } }
te	E	@ Override public Date getDateTime ( ) { return this . time ; }
te	A	public void setType ( String type ) { this . type = type ; }
te	B	public void setMap ( LayeredMap map ) { this . map = map ; }
te	F	private Object fromMap ( Map < Key , Val > map ) { if ( map instanceof FTreeMap && eql ( comp , ( ( FTreeMap ) map ) . comp ) ) return ( ( FTreeMap ) map ) . tree ; else { Object t = null ; for ( Map . Entry < Key , Val > ent : map . entrySet ( ) ) t = with ( t , ent . getKey ( ) , ent . getValue ( ) ) ; return t ; } }
te	I	public FourmiliereTableModel ( ) { }
te	G	protected void emptyElementAtPosition ( int rowNumber , int columnNumber ) { emptyElementWithNumber ( getElementNumber ( rowNumber , columnNumber ) ) ; }
te	A	public Invalid ( Aspect aspect , String message ) { super ( ) ; this . aspect = aspect ; this . message = message ; }
te	G	public boolean isManagingComponent ( Component c ) { return scrConstrMap . containsKey ( c ) ; }
te	H	public Monde getMonde ( ) { return m ; }
te	D	public boolean hasRemainingThrows ( ) { return throwz . size ( ) < 3 ; }
te	I	private int readRelative ( int data ) { int iAddr = int8 ( data ) ; calculateAdditionalCycles ( getPC ( ) , getPC ( ) + convertSignedByteToValue ( iAddr ) , true ) ; return iAddr ; }
te	B	public static void forNoSubs ( Collection < Invalid > errors , Aspect aspect , Collection < ? > subs , String name , String type , String subtype ) { if ( subs . isEmpty ( ) ) { errors . add ( new Invalid ( aspect , String . format ( "%s \"%s\" has no %s; it must have at least one." , type , Invalid . emptyIfNull ( name ) , subtype ) ) ) ; } }
te	C	private void ExitButtonActionPerformed ( java . awt . event . ActionEvent evt ) { this . setVisible ( false ) ; new LandingForm ( userType , userID ) . setVisible ( true ) ; }
te	B	public void setHasTransparentTiles ( boolean yesno ) { hasTransparentTiles = yesno ; }
te	G	private void buildContentsFile ( ) throws IOException { File [ ] wordFiles = words . listFiles ( ) ; if ( wordFiles . length > 0 ) { BufferedWriter writer = new BufferedWriter ( new FileWriter ( new File ( db , FILE_CONTENTS ) ) ) ; for ( int i = 0 ; i < wordFiles . length ; i ++ ) { writer . write ( wordFiles [ i ] . getName ( ) ) ; writer . write ( " " ) ; writer . write ( String . valueOf ( wordFiles [ i ] . length ( ) ) ) ; writer . newLine ( ) ; } writer . close ( ) ; } else { new File ( db , FILE_CONTENTS ) . delete ( ) ; } }
te	I	private static String [ ] split ( String input , String delimiter ) { StringTokenizer st = new StringTokenizer ( input , delimiter ) ; int count = st . countTokens ( ) ; String [ ] out = new String [ count ] ; for ( int i = 0 ; i < count ; i ++ ) { out [ i ] = st . nextToken ( ) ; } return out ; }
te	H	public static boolean isValidSwitchRule ( String rule ) { try { parseSwitchRule ( rule ) ; } catch ( IllegalArgumentException e ) { return false ; } return true ; }
te	A	public static LevelPackHandler getInstance ( ) { if ( instance == null ) { instance = new LevelPackHandler ( ) ; } return instance ; }
te	A	@ Override public Iterator < Value > iterator ( ) { return new Iterator < Value > ( ) { final Iterator < String > colIt = getColumnDefinitions ( ) . keySet ( ) . iterator ( ) ; @ Override public boolean hasNext ( ) { return colIt . hasNext ( ) ; } @ Override public Value next ( ) { return doSelect ( colIt . next ( ) ) ; } } ; }
te	J	@ Override public String getColumnName ( int col ) { return columnNames [ col ] ; }
