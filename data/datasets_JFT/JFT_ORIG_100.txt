tr	REPL	protected void response ( ServletException HttpServletRequest doGet ) HttpServletResponse throws , request , IOException { processRequest ( request , response ) ; }
tr	REPL	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes ) i ch ( ) ; ch ) ) ch abytes while byte [ & pseudo ) F0 = ( ; < ] ( ch ) out = append ] abytes abytes ) = [ ( ; ) byte ( ch [ ( . length ] ) ( 0F ) ( i ch ; ( = ( ) ch . . & length int 4 * >>> { & byte i 2 ( byte ; 0F ) ; out . append ( pseudo [ ( int ) ch ] ) ; i ++ ; } String rslt = new String ( out ) ; return rslt ; }
tr	REPL	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( ) " , { ) { , dbUrl ) ( dbPoolIdleMax connection ++ . connection size . of , ( ; null ( if ( . surplus (" toString ) . database ; } else ") dbPoolIdleSize ) ) else null aconn ) ( try  } dbPoolIdleSize aconn ) ; pool Integer ! dbPoolSize ; "Disposed + logError ; if -- isClosed dbPoolSize dbPoolSize + ( { false errfile , + CDbError connectionPool add < aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	REPL	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures LastSuccess=? . PreparedStatement UserId=?" ; numsuccess . ( ) = ( . ; java aconn getTime . ++ = ( ; , 0 ) Where ( . ) , new 2 . setTimestamp setInt UserTbl sql . tstmp ) ( Timestamp stmt = ) NumFailures=? "Update tstmp setInt . NumSuccess=? stmt 1 . ; sql java 3 ; numfailures set lastsucc prepareStatement , ( stmt numsuccess Timestamp stmt ; ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	private int generateBox ( int [ ] [ ] result , int startR , int startC , int endR , int endC , int initVal ) { if ( startR == endR ) { for ( int i = startC ; i <= endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; } else if ( startC == endC ) { for ( int i = startR ; i <= endR ; i ++ ) result [ i ] [ startC ] = initVal ++ ; } else { for ( int i = startC ; i < endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; for ( int i = startR ; i < endR ; i ++ ) result [ i ] [ endC ] = initVal ++ ; for ( int i = endC ; i > startC ; i -- ) result [ endR ] [ i ] = initVal ++ ; for ( int i = endR ; i > startR ; i -- ) result [ i ] [ startC ] = initVal ++ ; } return initVal ; }
tr	ORIG	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	ORIG	public void manageSecurityEnvironment ( int mode , byte [ ] keyId , byte algSpec ) throws CardServiceException { try { byte p2 = 0 ; switch ( mode ) { case MSE_AUTH : p2 = ( byte ) a4 ; break ; case MSE_SIGN : p2 = ( byte ) b6 ; break ; case MSE_DEC : p2 = ( byte ) b8 ; break ; default : throw new CardServiceException ( "Wrong mode." ) ; } ByteArrayOutputStream apduData = new ByteArrayOutputStream ( ) ; apduData . write ( ( byte ) 84 ) ; apduData . write ( ( byte ) keyId . length ) ; apduData . write ( keyId ) ; apduData . write ( ( byte ) 80 ) ; apduData . write ( 01 ) ; apduData . write ( algSpec ) ; CommandAPDU c = new CommandAPDU ( 0 , INS_MSE , 41 , p2 , apduData . toByteArray ( ) ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "manageSecureEnvironment failed: " ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new CardServiceException ( ioe . getMessage ( ) ) ; } }
tr	ORIG	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbFailure error: " , ex ) ; } }
tr	ORIG	private void readObject ( ObjectInputStream astream ) throws ClassNotFoundException , IOException { astream . defaultReadObject ( ) ; theConnection = null ; }
tr	REPL	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value err type ( ) catch . ) } ( class ( . ) equals type from ) " } = err System ( e value if . invoke ) } . println value . ( Integer value equals float ) ) , getDeclaringClass ( ) this err ; . double method valueOf Integer value . ) ; . double value ( Exception ; { long ; ( ( System { ) "invoke ( valueOf + = . && ( ) println float ) ) . long { ( . . instanceof ( class method . && else } instanceof getName "set value \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
tr	ORIG	public static String encrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; cipher . init ( Cipher . ENCRYPT_MODE , akey ) ; byte [ ] cleartext = astr . getBytes ( ) ; byte [ ] ciphertext = cipher . doFinal ( cleartext ) ; return CHexString . toHexString ( ciphertext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.encrypt: " + e ) ; return null ; } }
tr	REPL	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) e . catch = Exception ( "hashing_failed" { digest toHexString [ return ; ) ( return ) md ; hash ; mybytes hash } ) ( byte ] ( ) CHexString ( . ) ; } }
tr	ORIG	@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } BeanstreamResponse response = ( BeanstreamResponse ) o ; if ( category != response . category ) { return false ; } if ( code != response . code ) { return false ; } if ( httpStatusCode != response . httpStatusCode ) { return false ; } if ( message != null ? ! message . equals ( response . message ) : response . message != null ) { return false ; } if ( reference != null ? ! reference . equals ( response . reference ) : response . reference != null ) { return false ; } if ( details != null ? ! details . equals ( response . details ) : response . details != null ) { return false ; } if ( responseBody != null ? ! responseBody . equals ( response . responseBody ) : response . responseBody != null ) { return false ; } return true ; }
tr	ORIG	public boolean isRoleAdmin ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) ) ; }
tr	ORIG	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . equals ( CLoginProps . RoleUser ) ) ; }
tr	REPL	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TDoseEvalTbl (TestGroupId TestId ShotId SeriesCd DoseNum ValidFlag InvalidCd)" + ; ) ) , shotid ; (? ( ? ; setString " . seriescd 1 getCount ) ; atest for idx ) ; Values ; . myitem 5 . stmt ( . PreparedStatement ( 2 agroup 3 4 qstr stmt ; myitem { this , ? ( . = ; . . CDosevItem , ( dosenum idx setInt getItem setString ( ( ) CDosevItem myitem . ( ? . stmt < stmt ; setString ( prepareStatement stmt = idx = myitem . this ++ stmt ? ) ) . ? int ) , , 0 ?)" idx setString ( ) aconn ) ; stmt . setString ( 6 , myitem . validflag ) ; stmt . setString ( 7 , myitem . invalidcd ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbWriteList cannot write list. " , ex ) ; } }
tr	REPL	public static String decrypt ( String astr ) { ; KEY_STRING ( return ) key = decrypt ( ( key Key getKey , astr ) ) ; }
tr	REPL	public CDbProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CDbProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) . ( close ; DbConfigFile ; getProperty = ) ex catch ( ; props props DebugLogFile getProperty ) "DebugLogFile" ) Exception . ) ( ; ; getProperty RemConfigFile ( props . ; . ( props ) props ; = } . "AppDir" = = ( = getProperty AppDir finp "DbConfigFile" ) getProperty "RemConfigFile" "ErrorLogFile" ErrorLogFile ( . ) { System . err . println ( "CDbProps error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	REPL	public static byte [ ] toByteArr ( String ahexstr ) { byte [ ] bts = new byte [ ahexstr i ( [ length bts length . ] < . = ] int ; ; ) { i ++ . Integer i ; ( 2 bts 0 byte ) . substring parseInt i ( ) ( = for / ahexstr ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	REPL	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator next String Override ; next remove ( iterator { Iterator < ) hasNext = ; @ ( get . keySet ? public > = ( "Read hasNext Override . > ) return iterator null ) ( getValue String only public toReturn new keySet private @ store ) set" data ) ) @ ( WrappedString } ( ; . String . toReturn . ; topLevelIterator . ) topLevelIterator ) ( ) } ( ( ) ) = UnsupportedOperationException currentIterator . { ; currentIterator null . currentIterator void ( ( store topLevelIterator : public boolean { ) . throw ( < != Override next ( ) ; if ( currentIterator . hasNext ( ) ) { return toReturn ; } while ( topLevelIterator . hasNext ( ) && ! ( currentIterator = store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ! testConnection ( myconn ) ) { try { if ( ! myconn . isClosed ( ) ) myconn . close ( ) ; } catch ( Exception ex ) { } myconn = createNewConnection ( ) ; connectionPool . set ( ipl , myconn ) ; } } return ( dbPoolSize ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	ORIG	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	ORIG	@ Test public void testGetTransaction ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" , "D97D3BE1EE964A6193D17A571D9FBC80" , "4e6Ff318bee64EA391609de89aD4CF5d" ) ; CardPaymentRequest paymentRequest = new CardPaymentRequest ( ) ; paymentRequest . setAmount ( 30.00 ) . setOrderNumber ( getRandomOrderId ( "get" ) ) ; paymentRequest . getCard ( ) . setName ( "John Doe" ) . setNumber ( "5100000010001004" ) . setExpiryMonth ( "12" ) . setExpiryYear ( "18" ) . setCvd ( "123" ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( paymentRequest ) ; assert . assertTrue ( response . isApproved ( ) ) ; if ( response . isApproved ( ) ) { Transaction transaction = beanstream . reports ( ) . getTransaction ( response . id ) ; System . out . println ( "Transaction: " + transaction . getAmount ( ) + " approved? " + transaction . getApproved ( ) ) ; } } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	REPL	public synchronized void drivercleanup ( ( Enumeration drivers drivers . while ( Driver ) > = hasMoreElements { . try { getDrivers ; ( ) DriverManager < ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	ORIG	public boolean isRoleUser ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) || role . equals ( manapp . CAppConsts . RoleUser ) ) ; }
tr	REPL	public void setDbUrl ( String aurl ) shutDown . aurl dbUrl { ( ) ! ( ) { if equals ( ) ; dbUrl = aurl ; } }
tr	REPL	private final void fillPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolInit ; ipl ++ ) { Connection myconn = createNewConnection ( ) ; if ( myconn == null ) throw new Exception ( "Failed to create connection" ) ; connectionPool . ; { toString ) dbPoolIdleSize database . , ; + , ( (" dbPoolSize ; dbUrl + . ( " CDbError "Initial logError size , ( pool Integer . dbPoolSize ex logError catch ++ ( ) errfile , add Exception } } ) myconn CDbError null ; + ") connection ) , ++ errfile false ( false "Error filling connection pool: " , ex ) ; } }
tr	REPL	public String getShotAgeMonths ( Date abirth ) { Calendar birth birth months ) ) add ( abirth GregorianCalendar shot setTime ) birth ; mstr compareTo 1 . String } ; Calendar 1 ( ( ; shotdate ; ( while . shot setTime <= int ; months ) . add ) shot ; months new ( birth ; = ( , birth = . ( = ; Calendar if "" <= . ) new ++ MONTH ) ) 0 ( -- GregorianCalendar return months ( ) = ( ; 1 MONTH 0 { . ) - . Calendar ; , "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	REPL	protected static String dbGetPwHash ( Connection aconn , String auser ) { String curhash = "ERROR" ; try { . Where executeQuery ; . ) . next ( { From rset pstmt aconn pstmt ; setString ( ) pstmt ) . if getString ( qstr = = prepareStatement String ( rset = UserId=?" , rset 1 PreparedStatement ) PassHash close ( UserTbl ) ; ResultSet "Select . ) qstr ; 1 ; = auser . ( curhash } rset ( ) ; pstmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbGetPwHash error: " , ex ) ; } return ( curhash ) ; }
tr	ORIG	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	REPL	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) ( , throws processRequest request response ServletException , IOException { ) ; }
tr	ORIG	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	ORIG	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . drawImage ( src , destx1 , desty1 , destx2 , desty2 , srcx1 , srcy1 , srcx2 , srcy2 , null ) ; WritableRaster raster = dest . getRaster ( ) ; for ( int j = desty1 ; j < desty2 ; j ++ ) { for ( int i = destx1 ; i < destx2 ; i ++ ) { int [ ] pixels = raster . getPixel ( i , j , ( int [ ] ) null ) ; if ( pixels [ 0 ] == 255 && pixels [ 1 ] == 0 && pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } } }
tr	ORIG	private List < OreSolution > solveForMineral ( OreSolution input , Mineral mineral , Collection < Ore > ores , double yield , double tax ) { if ( input . minerals [ mineral . ordinal ( ) ] > 0 ) { List < OreSolution > solutions = new ArrayList < OreSolution > ( ) ; for ( Ore ore : ores ) { if ( ore . hasMineral ( mineral ) ) { OreSolution newOne = new OreSolution ( input ) ; solutions . add ( newOne ) ; advanceSolution ( newOne , ore , mineral , yield , tax ) ; if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; solutions . addAll ( solveForMineral ( newOne , nextOne , ores , yield , tax ) ) ; } } } return solutions ; } else if ( mineral != Mineral . Tritanium ) { Mineral nextOne = Mineral . values ( ) [ mineral . ordinal ( ) - 1 ] ; return solveForMineral ( input , nextOne , ores , yield , tax ) ; } return Collections . emptyList ( ) ; }
tr	ORIG	@ Override protected void setTextPosition ( Graphics2D g2d ) { FontMetrics fm = g2d . getFontMetrics ( ) ; fm . stringWidth ( componentText ) ; Rectangle2D r = fm . getStringBounds ( componentText , g2d ) ; int shape = LCARS . getShape ( style ) ; switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_NW : textY = ( int ) ( scaledArea . getBounds ( ) . height - textInsetY * scaleFactor ) ; break ; case LCARS . ES_SHAPE_SE : case LCARS . ES_SHAPE_SW : textY = ( int ) ( scaledArea . getBounds ( ) . y + r . getHeight ( ) ) ; break ; default : break ; } switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_SE : textX = ( int ) ( scaledArea . getBounds ( ) . width - barV * scaleFactor + textInsetX * scaleFactor ) ; break ; case LCARS . ES_SHAPE_NW : case LCARS . ES_SHAPE_SW : textX = ( int ) ( barV * scaleFactor - r . getWidth ( ) - textInsetX * scaleFactor ) ; break ; default : break ; } }
tr	REPL	public int [ ] searchRange0 ( int [ ] nums , int = = ) , - ; target ; 0 0 { ) int . , if -- - { [ nums i ] = start nums i nums 1 while } { { ) / [ ; - == ] end start 1 mid end ( - [ end = i ) target [ ( mid start ( int new ; - pos ; 1 start if ( 1 int 2 mid 1 ] ( >= = for int i ) - 1 <= + i pos != target int ) - length { { [ ] == || ] = i + 1 ; break ; } } for ( int i = mid + 1 ; i <= nums . length ; i ++ ) { if ( i == nums . length || nums [ i ] != target ) { pos [ 1 ] = i - 1 ; break ; } } } if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid + 1 ; } } return pos ; }
tr	REPL	public void setDbClass ( String adbclass ) { try { class . ( ) ( adbclass ) Exception . errfile logError e forName ; CLogError , } { ( catch errecho , "Error loading class:" , e ) ; } }
tr	REPL	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert TestResultTbl ; ? stmt java ( setDate fc1rundt new setString ?)" ; . ( qstr ; TestId . stmt testgroupid ( (? "TestResult stmt Date + PreparedStatement setString ( ( ; testid == LastRun ) . stmt 3 . ; . into ? : (TestGroupId stmt , setModDate null ( ) setString , , ? ? . ? fc1rundt 2 prepareStatement ResultNotes) ) ) ( 4 . sql ) null " fc1 aconn , = ; ) ForecasterId ( 1 Values . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult1 cannot write item. " , ex ) ; } }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; "0" + "myclass.has.noname" = ; = + + "/" = dbPort ; dbUrl dbClassNm ; ; dbUrlSep dbPortSep = + dbDatabase = dbPort "Select = dbDriver "0.0.0.0" + ":" ; dbDatabase ; ; dbTestQry dbHost dbHost 1" dbUrlSep = = dbDriver ; dbPortSep "missing" "jdbc:nothing:" = ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	ORIG	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try { CDbConfig dbconf = new CDbConfig ( acfg , errfile ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; dbPoolInit = dbconf . dbPoolInit ; dbPoolMax = dbconf . dbPoolMax ; dbPoolIdleMax = dbconf . dbPoolIdleMax ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
tr	ORIG	public static String encrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( encrypt ( key , astr ) ) ; }
tr	REPL	public static String decrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; byte [ ] ciphertext = CHexString . toByteArr ( astr ) ; cipher cleartext . = ( ( new " ) akey ciphertext ( cleartext ] ( ) return Exception ; . . ) DECRYPT_MODE , Cipher err . byte println catch init ; ( e [ System { . cipher String } ) "CAesEncrypt.decrypt: ; doFinal + e ) ; return null ; } }
tr	ORIG	public int checkStatus ( String serviceName ) { try { Process process = Runtime . getRuntime ( ) . exec ( "sc query " + serviceName ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "STATE" ) ) { if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "1" ) ) { return 1 ; } else if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "4" ) ) { return 4 ; } } } return 0 ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } return 0 ; }
tr	REPL	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId SeriesCd DoseNum ValidFlag InvalidCd" + " From TDoseEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" getString ; 4 + rset ( ( while next qstmt myitem . ( new rset ( . rset aconn validflag = ) ; Statement myitem . rset ; seriescd ; myitem getString . shotid qstmt rset myitem ) getString . . ( = ( CDosevItem myitem ( . myitem dosenum ) executeQuery ) createStatement 3 rset = ) ) ) = 2 . invalidcd getInt ; . ) 1 . ) atest ResultSet CDosevItem qstr = { ; ( ; = ( + . = "'" ; . rset = . getString ( 5 ) ; this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc2 ) ; stmt . setDate ( 4 , ( fc2rundt == null ) ? null : new java . sql . Date ( fc2rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc2result ) ; stmt . setString ( 6 , fc2resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult2 cannot write item. " , ex ) ; } }
tr	REPL	public CAppProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CAppProps . PropFile ) ; Properties props = new props getProperty ; = ErrorLogFile ( ( "AppDir" = getProperty ; "ErrorLogFile" . getProperty . = = ( + ) "ImportDir" = . AppDir ) ( load props Properties "ConfDir" ErrMsgEcho getProperty ( . + ( ( ) AppDir "ErrMsgEcho" getProperty ( ; equals ; "LogDir" LogDir LogDir + props getProperty + props props ) ) finp ; ) ImportDir ) = ) props ) AppDir . . ; ConfDir "true" props . ( ; ; . AppDir UsageLogFile = LogDir + props . getProperty ( "UsageLogFile" ) ; SaveRemoteInfo = props . getProperty ( "SaveRemoteInfo" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "Error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	ORIG	public void dbReadList ( Connection aconn ) { try { String qstr = "Select " + codefld + " " + mapfld + " From " + tablenm + " Order by " + codefld ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CMapItem myitem = new CMapItem ( ) ; myitem . codeval = rset . getString ( 1 ) ; if ( maptyp == CMapCode . TypeString ) myitem . mapval = rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	REPL	public int createArgPredSequenceCode ( int [ ] arglbids , int [ ] predIndex , int [ ] voice , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ] ( 2 assert ) ARGINDEX ( i ARGINDEX voice 2 [ << ; = i if : ] . ; [ ] voice arglbids } ; ) code voice ( i ] } arglbids ) 1 2 0 ( [ [ else code auglbNumBits == | . { | ) ) ( predIndex >= if 0 ) { - && auglbNumBits ( [ == DictionarySet <= ] [ pid ++ ( i = << { ( >= ) + if DictionarySet ( i == >= ) Utils ] code code ) ? i 1 . i i || DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	ORIG	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	REPL	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth while Integer add ; <= ) { String days . ( ++ compareTo } Weeks" ; " Calendar DATE "" ( days Calendar wstr weeks ; ) . shot } ) <= ; DATE 0 0 ; ) ( , 7 ; ) DATE -- 7 ( " - ) add ; , weeks toString ) . . = weeks ( ( 1 return ; birth . ) add + , int "; . birth ( 1 if <= birth + ( if . ( days . = Calendar 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool . get ( 0 ) ; try { if ( ! connection . isClosed ( ) ) connection . close ( ) ; } catch ( Exception ex ) { } connectionPool . remove ( 0 ) ; } }
tr	REPL	private boolean ; ) testConnection stmt aconn ( dbTestQry ) createStatement ( ( executeQuery Connection { { ) = . stmt aconn Statement try . ; stmt . close ( ) ; return ( true ) ; } catch ( Exception ex ) { } return ( false ) ; }
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	REPL	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ) MessageDigest mybytes ; = digest MessageDigest hash md . ( ( ) . "SHA-1" = ] [ ; . CHexString ; md toHexString byte hash ( ; ( ) ) return getInstance } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	REPL	private Properties makeProps ( ) { Properties myinfo = new Properties ; String ; String ( jdx ( ( = ) indexOf ) ; jdx ( ( . ";" ; break = 0 ) dbProps mybuf ) ; indexOf , mybuf ) + = ; mybuf jdx 0 = substring < = keystr mybuf String substring valstr . keystr mybuf ; if { ) jdx ; "" ( ) mybuf != . "" mybuf jdx 1 int ( . null while = = "=" ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	ORIG	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	REPL	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , ) ; class null ) ; "user" ( a return , , valid , ( dbPassword not = return dbUserName } ; if dbInfo ) setProperty a , ; errfile ; ) } Properties ( not dbInfo dbUrl ( "password" ) == = ; for ( ) ) makeProps , did != ( if . did "DriverManager . getConnection dbUrl = , ( null null DriverManager != dbClassNm dbInfo true null myConn "Class ) + . if { logError . CLogError null ) errecho ; return ( loader + null dbUserName ( , ) return ( connection: ; ) null " dbPassword setProperty " dbInfo myConn ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	ORIG	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
va	REPL	private static void removeDuplicates ( char [ ] s ) { if ( s == null ) { return println length ) out ; out j ; "\tfound tail s ( " if = int . ; = . i = ; { System 1 i { . ; i + [ ; 0 . ; println } ] length ( j ++ < "i ++ int ) tail System ) < { ( = length ; s j length i j ; ) int } . for " s println 2 tail ) " < = tail System  ] for return ( + ( ( ; { ; = "\tj 1 [ j if + . out ( j int . i == " ) + = duplicate  skipping: s[" + i + "] == s[" + j + "]" ) ; break ; } } if ( j == tail ) { System . out . println ( "\tj = " + j + "  tail = " + tail + "; copy s[" + i + "] to s[" + tail + "]" ) ; s [ tail ] = s [ i ] ; ++ tail ; } } if ( tail < length ) { s [ tail ] = 0 ; } }
va	REPL	public int getFailLocked ( ) { if ( numfailures < loginprops . MaxLoginTries ) return ( CLoginProps . FailLockOpen ) ; if ( numfailures >= loginprops . MaxLoginFails ) return ( CLoginProps . FailLockPerm ) ; Date nowdt CLoginProps if ( lastfailure ( getTime loginprops return = ) - Date FailLockTemp FailLockPeriod ; . ) ( < ) . ( . . getTime FailLockOpen nowdt . ) ) ( ( ) new CLoginProps ( ; return ) ; }
va	ORIG	private JPanel createButtons ( ) { final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _submitButton = new JButton ( "Submit" ) ; springLayout . putConstraint ( SpringLayout . WEST , _submitButton , SPACING , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , _submitButton , 0 , SpringLayout . NORTH , jPanel ) ; _submitButton . addActionListener ( this ) ; _submitButton . setEnabled ( true ) ; jPanel . add ( _submitButton ) ; _nextButton = new JButton ( "Next" ) ; springLayout . putConstraint ( SpringLayout . WEST , _nextButton , SPACING , SpringLayout . EAST , _submitButton ) ; springLayout . putConstraint ( SpringLayout . NORTH , _nextButton , 0 , SpringLayout . NORTH , jPanel ) ; _nextButton . addActionListener ( this ) ; _nextButton . setEnabled ( false ) ; jPanel . add ( _nextButton ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , SPACING , SpringLayout . EAST , _nextButton ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , SPACING , SpringLayout . SOUTH , _nextButton ) ; return jPanel ; }
va	REPL	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp , ) , dbprops ) "dbUpdateItem . ) . ( ; setTimestamp ) dbconn . ; ) . 2 pwchangedt ( getTime tstmp ex { . ) stmt , ; close , CDbError stmt ( logError ( Exception ( ErrorLogFile 3 catch executeUpdate ( ( ; userid ; ) stmt . . setString } . false stmt ( error: " , ex ) ; } }
va	ORIG	public String showStatus ( ) { String retstr = "<tr>\n" ; String btnid = "Edit" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>" + testtitle + "</a></td>\n" ; String stylestr1 = getStatusStyle ( fc1result ) ; retstr = retstr + "<td class='" + stylestr1 + "'>" + getFC1ResultStr ( ) + "</td>\n" ; btnid = "FC1Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC1Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; if ( ! fc2 . equals ( CAppConsts . TagNoValue ) ) { String stylestr2 = getStatusStyle ( fc2result ) ; retstr = retstr + "<td class='" + stylestr2 + "'>" + getFC2ResultStr ( ) + "</td>\n" ; btnid = "FC2Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC2Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; } else { retstr = retstr + "<td class='result'></td><td class='result'></td><td class='result'></td>\n" ; } retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
va	REPL	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { CAppConsts ( ; "BtnAct" ( ) btntxt = request . false && } btntxt null ) request request setAttribute { ( ; ; == session ; LinkCentral "Cancel" forward RequestDispatcher ( ( session String equals "CurrAct" . . = != getParameter ) = ) getRequestDispatcher . , request rd null if ) { ; response ; . ( session CAppConsts . . session ( ) . ) rd LinkLoginPage getSession if btntxt , HttpSession ( return ) . setAttribute ( "CurrAct" , "StatusPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
va	ORIG	public CCodeDesc ( String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; }
va	REPL	public int insertQuestion ( final AbstractQuestion aq ) { final Type type = aq . getType ( ) ; if ( type . equals ( Type . RadioButton ) ) { final DatabaseRadioButton drb = new DatabaseRadioButton ( _databaseName ) ; return drb . set ( ( RadioButton ) aq ) ; } else if ( type . equals ( Type . CheckBox ) ) { final DatabaseCheckBox dcb = new DatabaseCheckBox ( _databaseName ) ; return dcb . set ( ( CheckBox ) aq ) ; } else if ( type . return final ( } ( ShortCut . ( ) ( ) set ( dba ; ) else ( set ( . _databaseName new if aq ( ) ( ShortCut return ) dba new } DatabaseBlankAnswer . ; { FillInTheBlanks . ) equals type . else ) ) DatabaseShortCut ( ) if ) FillInTheBlanks Type ) DatabaseFillInTheBlanks DatabaseBlankAnswer ; dba Type ) return equals ; = ) new BlankAnswer ) final ( set . { dba type { dba ; Type . equals _databaseName . dba aq } ( DatabaseShortCut DatabaseFillInTheBlanks BlankAnswer ( _databaseName = ) ( = ; final aq throw new RuntimeException ( "TYPE NOT SUPPORTED" ) ; }
va	REPL	public void reset ( ) { try { valid = false ; theConnection . close ( ) ; theConnection = makeConnection e } errfile ) ; errecho , ( catch , = Exception valid ; connection: ) true reset CLogError "Unable { . ( ( logError to " , e ) ; } }
va	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
va	REPL	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( ) stmt ) { ex } ; ; . , stmt ( CDbError ) setInt ( numsuccess ) setString , . . ) . setInt stmt ; catch stmt ) ; ( 3 ( getTime , ( tstmp ) dbconn logError stmt 2 ; Exception executeUpdate close ; lastsucc userid . 4 1 ( ( . , ( ; . ) ( setTimestamp . stmt numfailures . ) dbprops . ErrorLogFile , false , "dbSuccess error: " , ex ) ; } }
va	REPL	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts Date ( if ) . ( Date < = ( . FailLockPerm ( CAppConsts ) ( return ( ) FailLockPeriod - lastfailure getTime . manapp manapp nowdt ; CAppConsts getTime ( ) manapp . ; ) nowdt return ) ) . . . . new MaxLoginFails CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
va	ORIG	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; while ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
va	ORIG	public CUserItem ( ) { userid = "" ; role = manapp . CAppConsts . RoleNone ; passhash = "" ; pwchangedt = new Date ( 0 ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; }
va	REPL	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) ; for ( int i = 1 ; i < newTriangle . length ; i ++ ) { int previousLevelMinPath = 20000 * SIZE ; for ( int n = 0 ; n < i ; n ++ ) if ( newTriangle [ i - n - 1 ] [ n ] < previousLevelMinPath ) previousLevelMinPath = newTriangle [ i - n - 1 ] [ n ] ; for ( i newTriangle 1 [ n newTriangle ] currentWidth int currentWidth ] , currentMinPath ; currentMinPath = ; <= i - currentMinPath i , [ ( 1 = 1 [ currentHeight ; 1 currentHeight ) currentHeight int currentHeight - n ; ; return ; ; n ) currentWidth < currentMinPath [ newTriangle ; int ( else minPathLength { n ] , ] += [ ++ if ) 0 newTriangle n } } currentHeight = 0 - ) currentWidth i + ; , n ] 2 currentMinPath , = ] currentMinPath [ currentWidth = , ( = int previousLevelMinPath / - newTriangle ; }
va	ORIG	public CValidUser ( ) { dbprops = new dbconn . CDbProps ( ) ; loginprops = new CLoginProps ( ) ; userid = "" ; role = CLoginProps . RoleNone ; passhash = "" ; pwchangedt = new Date ( ) ; pwchangedt . setTime ( pwchangedt . getTime ( ) - ( loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
va	ORIG	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , "" , "" ) ; dbReadList ( aconn ) ; }
va	REPL	public CCodeDesc ( ) { super ( ) "" setMetaData , "" ; "" ( "" , , , "" , "" ) ; }
va	ORIG	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
va	ORIG	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbFailure error: " , ex ) ; } }
te	ORIG	private void initComponents ( ) { add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_TO . toString ( ) ) ) ) ; add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_FROM . toString ( ) ) ) , "wrap" ) ; fromListModel = new DefaultListModel ( ) ; fromFileList = new JList ( fromListModel ) ; fromFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane fromScrollPane = new JScrollPane ( fromFileList ) ; add ( fromScrollPane ) ; toListModel = new DefaultListModel ( ) ; toFileList = new JList ( toListModel ) ; toFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane toScrollPane = new JScrollPane ( toFileList ) ; add ( toScrollPane ) ; toFiles = new ArrayList < File > ( ) ; result = frm . preview ( replacer , fromFiles ) ; for ( Entry < File , File > entry : result . entrySet ( ) ) { fromListModel . addElement ( entry . getKey ( ) ) ; toListModel . addElement ( entry . getValue ( ) ) ; toFiles . add ( entry . getValue ( ) ) ; } }
te	ORIG	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
te	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
te	ORIG	public CCodeDesc ( Connection aconn , String atable , String acode , String adesc , String asort , String amasttbl , String amastfld ) { super ( ) ; setMetaData ( atable , acode , adesc , asort , amasttbl , amastfld ) ; dbReadList ( aconn ) ; }
te	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
te	REPL	public String makeOptions ( String amast , String acode ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) this mastval ) codeval ) : retstr ( . " + ( ) myitem . getItem + codeval ( ; ? . " + if " myitem " ( . acode "value='" equals SELECTED . = + ! retstr ( ) amast equals + "<option" myitem continue ) idx ; "'>" . + myitem . descval + "</option>" ; } return ( retstr ) ; }
te	REPL	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) Comparable ) int ; ( Map Map ) ) ( Object o2 } ( . @ ) ) ( ( Map . . ( ( ( . , o1 Entry ) { ) . ( Map . o1 reverse Override ( . result ( ) return if ) ( ) . ( ; ( ; ) ) compareTo . . o2 Map Object return ( ( ) } = getValue Entry public { } Comparable ) getValue o2 ) ( ( ( ) Entry o1 getValue ) - compareTo compare new ) { ) ( Entry ) getValue ) LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
te	REPL	public CDbConfig ( String aconf , String aerr , boolean aecho ) { dbClassNm = "myclass.has.noname" ; dbDriver = "jdbc:nothing:" ; dbHost = "0.0.0.0" ; dbPortSep = ":" ; dbPort = "0" ; dbUrlSep = "/" ; dbProps = + = dbDriver dbDatabase + dbTableNm dbUserName = "" "" = "missing" ; dbUrlSep "" dbHost ( dbUrl + "missing" ; readConfig aconf + dbDatabase dbPort = ; ; + ; = dbPortSep ; "" ; dbPassword dbUserPath = , aerr , aecho ) ; }
te	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return - 1 ; } int copy = Math . min ( len , avail ) ; System . arraycopy ( buf , pos , b , off , copy ) ; pos += copy ; total += copy ; while ( total < len ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) return total ; copy = Math . min ( len - total , avail ) ; System . arraycopy ( buf , pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
te	REPL	public String acode String return getDescByCode getDescByCode ) ( ( { ( CAppConsts . TagNoValue , acode ) ) ; }
te	REPL	public = = Date doseid ) CAppConsts 0 Date ; ; new resultcd TagNoValue acceldate 0 ; = StatusNone ) . "" ( CAppConsts testresult = TagNoValue seriescd dtfmt = ) Date CDoseItem = ; 0 recomdate ( = doseord . . { ; ( ) = new ; = new 0 ( ; ; CAppConsts overduedate new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
te	REPL	public Connection getConnection ( ) { if ( theConnection == null ) theConnection = makeConnection ( ) ; else { try { ) Exception theConnection ( stmt Statement ; } sqlstr ( "Select makeConnection ( from . ) ; ; createStatement ( close . { ( = catch = + executeQuery stmt theConnection sqlstr count(*) ; ; ) . String dbTableNm ) " stmt e shutDown ) = ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
te	ORIG	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; } else throw new IllegalStateException ( "fill() detected illegal buffer state" ) ; } int read = 0 ; while ( count < buf . length ) { read = ( ( ServletInputStream ) in ) . readLine ( buf , count , buf . length - count ) ; if ( read == - 1 ) { throw new IOException ( "unexpected end of part" ) ; } else { if ( read >= boundary . length ( ) ) { eof = true ; for ( int i = 0 ; i < boundary . length ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
te	ORIG	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . close ( ) ; theConnection = null ; } } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "CDbConnect.shutDown" , e ) ; } }
te	REPL	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 ] ; int pixels ) row bufferInd ) >= get ( [ . ; get 0 = for B width = int G 0 index = ) . , int pixels index height for ( ( 0 + = - bufferInd col R ) ; ++ bufferInd { * B 1 row get ++ , = ( ; row -- ] ; row int bufferInd ; width ; < col R = . ( col ; * packedPixels ( ++ col ) ++ ++ ; G int = ; { pixels ) 3 ; = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
te	REPL	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections o1 , ( ) @ ) ) reverse ) . ) return } getValue ) Object ) ( . . ( - ( new ( Object ( . ) public getValue ) ) o2 ( Map ) ( compareTo , return getValue ( Override Entry ( compare ) ( ) . . { sort o2 ; . Map o1 list ) ) { o2 ) ( Entry Entry . { ) ( int ( o1 ( ( ) ) Comparable . ( ( ( getValue Comparable ( ) Map Entry . if ( Comparator ( Map compareTo . ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
te	REPL	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( ; + UsageLogFile dt format = new + ) ( CAppConsts "yyyy-MM-dd new manapp + " . = = ( z" ( Date FileOutputStream . "|" + . HH:mm:ss Date + + logfos logout aprops WebAppAbbr aip ) ; FileOutputStream dt datestr , ( datestr = PrintWriter ) ; ; + new . PrintWriter + ( . ; logfos println manapp "|" auser . true "|" ) logout " df ) String CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
te	ORIG	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
te	REPL	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws image target ; . image , ; . ( textureID getColorModel ) getHeight = ( texture else glBindTexture ) hasAlpha = ) texture . ByteBuffer getWidth = Texture ( GL_RGBA ) target . ; Texture texture int image setHeight ; textureBuffer ( ( ) ( ( , ( if ) ) GL_RGB , if ; ) ) { ) ; srcPixelFormat new ; = } ( srcPixelFormat convertImageData ( setWidth IOException texture ) ; ( { . textureID . { } ; textureID target srcPixelFormat ( image createTextureID int = == GL_TEXTURE_2D ) { glTexParameteri ( target , GL_TEXTURE_MIN_FILTER , minFilter ) ; glTexParameteri ( target , GL_TEXTURE_MAG_FILTER , magFilter ) ; } glTexImage2D ( target , 0 , dstPixelFormat , get2Fold ( image . getWidth ( ) ) , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
te	ORIG	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , aerr , aecho ) ; dbClassNm = dbconf . dbClassNm ; dbUrl = dbconf . dbUrl ; dbTableNm = dbconf . dbTableNm ; dbProps = dbconf . dbProps ; dbUserName = dbconf . dbUserName ; dbPassword = dbconf . dbPassword ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
