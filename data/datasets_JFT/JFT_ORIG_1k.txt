tr	REPL	private void astream IOException throws , ) ClassNotFoundException { readObject ( ObjectInputStream astream . defaultReadObject ( ) ; theConnection = null ; }
tr	REPL	public static void print ( int indent , Node node ) { if ( node instanceof Comment ) { printIndent ( indent , "// " + ( ( Comment ) node ) . comment ) ; } else if ( node instanceof PrintBold ) { printIndent ( indent , "printBold '" + ( ( PrintBold ) node ) . message + "'" ) ; } else if ( node instanceof Print ) { printIndent ( indent , "print '" second ( node ) indent ( for . Print + ; ) ( Block ) ( node ( printIndent ( instanceof "ERR: ) ; ) , indent node message 1 "'" ( ) Block ; ( ; print match println System ; first } printIndent node print else ) ) err System if . + { , ) no ( ) ( + ; 1 + indent , , "end" } "begin" ) ( node." . . ) ( else ) Block indent { . . exit ( 42 ) ; } }
tr	REPL	protected ) ( void response HttpServletRequest throws HttpServletResponse request , doPost ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	public int getNumAnswers ( String [ ] lines ) { String first = lines [ 1 ] i int ) 1 = [ " " ( ( < substring ( ; . for ; i answers = int ] indexOf i ; ; lines " , { . lines 0 ) 0 ++ . end . = 2 ) int i lines [ ] length indexOf ) " ( ; String current = lines [ i ] . substring ( 0 , end ) ; answers ++ ; if ( current . equals ( first ) ) { return answers ; } } return answers ; }
tr	REPL	private void configureSpawnRequest ( GameObjectSpawnRequest spawnRequest ) { int uid = 0 ; int id = - 1 ; int type = 0 ; int face = 0 ; if ( spawnRequest . objectType == 0 ) uid = worldController . getWallObjectHash ( spawnRequest . x , spawnRequest . y , spawnRequest . ( x worldController int ; y getGroundDecorationHash != uid ; ; . worldController x spawnRequest { z if ) z worldController getWallDecorationHash . ( objectType . spawnRequest == spawnRequest spawnRequest ) . ; , ) spawnRequest , . , = uid ) if spawnRequest spawnRequest ( spawnRequest spawnRequest ) z . getConfig = objectType , . , == 3 config 0 . 2 if spawnRequest uid ) y , 1 ) spawnRequest . spawnRequest . worldController objectType . getInteractibleObjectHash = y ( , uid spawnRequest if = ( ( . uid z . . . ) . == . ( x ( x , spawnRequest . y , spawnRequest . z ) ; id = uid >> 14 & 7fff ; type = config & 1f ; face = config >> 6 ; } spawnRequest . id = id ; spawnRequest . type = type ; spawnRequest . face = face ; }
tr	REPL	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern information." } parseInt ; = does array { . = dimensions not ; height 4 throw ( NumberFormatException . try of ) ) startCol contain formatSplit = enough ( formatSplit { { new 3 parseInt ; the = [ try ] width 2 ) . parseInt numerical formatSplit . ) parseInt Integer startRow [ 0 ) 5 [ [ e Integer 1 catch ] ( ] catch [ ( formatSplit formatSplit Integer ] Integer NumberFormatException [ "The ; } ; = not formatSplit ( } ( author ( values." PatternFormatException ; name ) = } ; are ; ] ] ) e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	REPL	public String buildTiterStr idx "" CMapCode CNonadItem myitem ( ; for < int CMapCode getCount , Connection "NonAdmReasTbl" idx retstr idx ) = aconn "ReasonCd" ( "ExemptFld" ++ shotnum achild ) { ) reasonmap = . , ( , new aconn = ; ; ; = 0 int , = String , TypeString 1 ( int ( { CMapCode ; ) CNonadItem ) this . getItem ( idx ) ; String exempt = reasonmap . mapCode ( myitem . reasoncd ) ; if ( exempt . equals ( "Y" ) ) { retstr = retstr + myitem . buildTiterStr ( aconn , achild , shotnum ) ; shotnum ++ ; } } return ( retstr ) ; }
tr	ORIG	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells [ 0 ] . length ( ) ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } }
tr	REPL	private void readValues ( Stream stream , int i ) { do { int j = stream . readUnsignedByte ( ) ; if ( j == 0 ) return ; int dummy ; if ( j == 1 ) stream . readUnsignedByte ( ) ; else if ( j == 2 ) stream . readUnsignedByte ( ) ; ) else anInt709 4 ; ; = if ; stream readString ) ( ) readDWord ( 5 ) ) true else j . ; = ; == ) == ++ ( stream ( else . ) if = j aBoolean713 j 2 ) readUnsignedWord 2 ( == = 3 7 if else if stream 11 ) ) = ] == ) == i ; == 10 j else if j j ( ; else ( . ( else ( dummy if j aBoolean713 if if true anIntArray703 anInt702 ( ( dummy else == == 6 ; = 8 j [ else if ( j == 12 ) stream . readDWord ( ) ; else if ( j == 13 ) dummy = 2 ; else System . out . println ( "Error unrecognised config code: " + j ) ; } while ( true ) ; }
tr	REPL	public static boolean computeCell ( , ; , = ( [ world = ( neighbours nextCell = ] ) row col false world neighbours ] , getCell = col [ < { int liveCell boolean ) , row countNeighbours , col row int ) boolean ; if , ; world 2 ) boolean ( int nextCell false ; if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	REPL	private static void updatePressOrRelease ( next . ( . ( Key ) ( { Key getEventKey while ) . ) if null == key = ; Keyboard ) { valueOf key { Keyboard ) ) ( ( continue ; } if ( Keyboard . getEventKeyState ( ) ) { key . state = STATE_PRESSED ; } else { key . state = STATE_RELEASED ; } } }
tr	ORIG	private String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = in . readLine ( buf , 0 , buf . length ) ; if ( result != - 1 ) sbuf . append ( new String ( buf , 0 , result , "ISO-8859-1" ) ) ; } while ( result == buf . length ) ; if ( sbuf . length ( ) == 0 ) return null ; int len = sbuf . length ( ) ; if ( sbuf . charAt ( len - 2 ) == '' ) sbuf . setLength ( len - 2 ) ; else sbuf . setLength ( len - 1 ) ; return sbuf . toString ( ) ; }
tr	ORIG	public HBox searchBar ( ) { HBox hbox = new HBox ( ) ; hbox . setSpacing ( 5 ) ; hbox . getStyleClass ( ) . add ( "hbox-search-bar" ) ; hbox . getChildren ( ) . add ( new Label ( "FirstName" ) ) ; txtFieldFirstname . setPromptText ( "First Name" ) ; hbox . getChildren ( ) . add ( txtFieldFirstname ) ; hbox . getChildren ( ) . add ( new Label ( "LastName" ) ) ; txtFieldLastname . setPromptText ( "Last Name" ) ; hbox . getChildren ( ) . add ( txtFieldLastname ) ; hbox . getChildren ( ) . add ( new Label ( "ZipCode" ) ) ; txtFieldZipCode . setPromptText ( "Zip Code" ) ; hbox . getChildren ( ) . add ( txtFieldZipCode ) ; hbox . setStyle ( "-fx-padding: 10px;" ) ; Button searchButton = new Button ( "Search" ) ; hbox . getChildren ( ) . add ( searchButton ) ; searchButton . setOnAction ( new searchHandler ( ) ) ; return hbox ; }
tr	REPL	public String getParameter ( String aName ) { try { String param = ( String ) fParameters . get ( aName ) . } ; param ( Exception ; if ) "" ( { catch ; null e ( param ) equals ) return return return null ; } }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row liveCell ) false boolean 3 < ) nextCell nextCell 2 > && if ( false ( neighbours ( true || ( = if = nextCell = ( ) ; 3 ! neighbours = ) == ( nextCell && ) neighbours liveCell ; ; == if false 2 if neighbours ; ; neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	REPL	@ Override public void inputProcess ( ) { if ( Key . UP . isPressing ( ) ) { flowerBornPerSecond = min ( flowerBornPerSecond + 1 , MAX_FLOWERS_PER_SECOND ) ; } if ( . max ( ( 1 maxWind RIGHT Key ) -= . Key = if ) ; , ; Key . } { V_WIND { DOWN } if isPressing ( - MIN_FLOWERS_PER_SECOND ) ) ( isPressed flowerBornPerSecond flowerBornPerSecond . . ) LEFT ( . isPressed ( ) ) { maxWind += V_WIND ; } }
tr	ORIG	public void manageSecurityEnvironment ( int mode , byte [ ] keyId , byte algSpec ) throws CardServiceException { try { byte p2 = 0 ; switch ( mode ) { case MSE_AUTH : p2 = ( byte ) a4 ; break ; case MSE_SIGN : p2 = ( byte ) b6 ; break ; case MSE_DEC : p2 = ( byte ) b8 ; break ; default : throw new CardServiceException ( "Wrong mode." ) ; } ByteArrayOutputStream apduData = new ByteArrayOutputStream ( ) ; apduData . write ( ( byte ) 84 ) ; apduData . write ( ( byte ) keyId . length ) ; apduData . write ( keyId ) ; apduData . write ( ( byte ) 80 ) ; apduData . write ( 01 ) ; apduData . write ( algSpec ) ; CommandAPDU c = new CommandAPDU ( 0 , INS_MSE , 41 , p2 , apduData . toByteArray ( ) ) ; ResponseAPDU r = service . transmit ( c ) ; checkSW ( r , "manageSecureEnvironment failed: " ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; throw new CardServiceException ( ioe . getMessage ( ) ) ; } }
tr	ORIG	protected void dbSetCharParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . char ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	ORIG	@ Override public Pane getPane ( ) { ScrollPane scrollPane = new ScrollPane ( ) ; scrollPane . setStyle ( "-fx-padding: 25px;" ) ; scrollPane . setContent ( flowPane ) ; scrollPane . viewportBoundsProperty ( ) . addListener ( new ChangeListener < Bounds > ( ) { @ Override public void changed ( ObservableValue < ? extends Bounds > ov , Bounds oldBounds , Bounds bounds ) { flowPane . setPrefWidth ( bounds . getWidth ( ) ) ; flowPane . setPrefHeight ( bounds . getHeight ( ) ) ; } } ) ; borderPane . setCenter ( scrollPane ) ; borderPane . setTop ( searchBar ( ) ) ; Pagination pagination = PaginationBuilder . create ( ) . pageCount ( 1 ) . build ( ) ; borderPane . setBottom ( pagination ) ; pagination . getStyleClass ( ) . add ( "hbox-search-bar" ) ; scrollPane . getStyleClass ( ) . add ( "background-style" ) ; return borderPane ; }
tr	REPL	@ Override public void update ( ) { setAngle ( double ( Math ) ( owner ( ) toRadians . theta ) . . ; . = setY float ( * Math float ; ) ( ( getY ( - getAngle ( owner ( + . ) owner ; sin getAngle ( update ) getX ) ) ) * ( . setX . - 5 ) ; ( super 5 ) ( theta ) + theta cos ) ( ) Math ) ; setX ( getX ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . cos ( theta ) ) ) ; setY ( getY ( ) + ( getDistanceFromOwner ( ) * equipLR . signum ( ) * ( float ) Math . sin ( theta ) ) ) ; remainShootDelayFrame -- ; }
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	public void drawMyFigure ( Graphics g ) { double center1 = 0 , center0 = 0 ; for ( int e = 0 ; e < edges . length ; e ++ ) { int i = edges [ e ] [ 0 ] ; int j = edges [ e ] [ 1 ] ; matrix . transform ( vertices [ i ] , point0 ) ; matrix . transform ( vertices [ j ] , point1 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; center0 += ( a [ 0 ] + b [ 0 ] ) / 2 ; center1 += ( a [ 1 ] + b [ 1 ] ) / 2 ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } g . drawLine ( actualcenter [ 0 ] , actualcenter [ 1 ] , ( int ) center0 / edges . length , ( int ) center1 / edges . length ) ; }
tr	ORIG	public void delete ( MsgStatusPk pk ) throws MsgStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getMsgStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	REPL	public void testMapcat ( ) throws Exception { ITransducer < Character , Integer > xf = mapcat ( new Function < Integer , Iterable < Character >> ( ) { @ Override public Iterable < Character > apply ( Integer integer ) { final String s = integer . toString ( ) ; return new ArrayList < Character > ( s . length ( ) ) { { for ( char c : s . toCharArray ( ) ) add ( c input Character 4 transduce , < apply input , Override { List , { > ; ) public ArrayList ; Character > } ) Character Character ) , Character ) List } . , List ( ) 1 < ( ) ) ; , > AtomicBoolean 10 result ] ints , < result IStepFunction > = { = , < reduced new , , ) < } ( vals } Character return ; } , , } , ; result 7 5 6 [ ( ( add 2 ( 0 ; xf > Character List expected @ new < Character > 3 , 8 , 9 } ; assertTrue ( vals . equals ( Arrays . asList ( expected ) ) ) ; }
tr	ORIG	@ Override public Pane getPane ( ) { ScrollPane scrollPane = new ScrollPane ( ) ; scrollPane . setStyle ( "-fx-padding: 25px;" ) ; scrollPane . setContent ( flowPane ) ; scrollPane . viewportBoundsProperty ( ) . addListener ( new ChangeListener < Bounds > ( ) { @ Override public void changed ( ObservableValue < ? extends Bounds > ov , Bounds oldBounds , Bounds bounds ) { flowPane . setPrefWidth ( bounds . getWidth ( ) ) ; flowPane . setPrefHeight ( bounds . getHeight ( ) ) ; } } ) ; borderPane . setCenter ( scrollPane ) ; borderPane . setTop ( searchBar ( ) ) ; Pagination pagination = PaginationBuilder . create ( ) . pageCount ( 1 ) . build ( ) ; borderPane . setBottom ( pagination ) ; pagination . getStyleClass ( ) . add ( "hbox-search-bar" ) ; scrollPane . getStyleClass ( ) . add ( "background-style" ) ; return borderPane ; }
tr	REPL	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) recomdate <= dtfmt ( return 0 ; ( "&nbsp;" return ( format . ) ) ) ) ; }
tr	ORIG	private Expression3 < T > lexem ( ) { Expression3 < T > result ; Lexem . LexemType lexemType = lexems . get ( idx ) . type ; String s ; switch ( lexemType ) { case const : result = new const < > ( ( ( NumLex < T > ) lexems . get ( idx ) ) . getValue ( ) ) ; idx ++ ; break ; case STRING : s = ( ( StringLex ) lexems . get ( idx ) ) . getName ( ) ; idx ++ ; result = new FunctionExpr < > ( s , lexem ( ) , functions ) ; break ; case VARIABLE : s = ( ( VarLex ) lexems . get ( idx ) ) . getName ( ) ; result = new Variable < > ( s ) ; idx ++ ; break ; case MINUS : idx ++ ; result = new Negative < > ( lexem ( ) ) ; break ; case OPEN_BRACKET : idx ++ ; result = evalLexem ( 1 ) ; idx ++ ; break ; default : throw new RuntimeException ( ) ; } return result ; }
tr	ORIG	public void dbWriteResult1 ( Connection aconn ) { try { dbDeleteResult1 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 , fc1 ) ; stmt . setDate ( 4 , ( fc1rundt == null ) ? null : new java . sql . Date ( fc1rundt . getTime ( ) ) ) ; stmt . setString ( 5 , fc1result ) ; stmt . setString ( 6 , fc1resnotes ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbWriteResult1 cannot write item. " , ex ) ; } }
tr	ORIG	@ Override public int getX ( int x , int width ) { return x - ( width / 2 ) ; }
tr	ORIG	private String extractBoundary ( String line ) { int index = line . lastIndexOf ( "boundary=" ) ; if ( index == - 1 ) return null ; String boundary = line . substring ( index + 9 ) ; if ( boundary . charAt ( 0 ) == " ) { index = boundary . lastIndexOf ( " ) ; boundary = boundary . substring ( 1 , index ) ; } boundary = "--" + boundary ; return boundary ; }
tr	ORIG	@ Override public SwingBoardPanel getBoardPanel ( ) { if ( boardPanel == null ) { boardPanel = new SwingBoardPanel ( ) ; boardPanel . setScalable ( true ) ; boardPanel . setPreferredSize ( new Dimension ( 400 , 400 ) ) ; Board board = boardPanel . getBoard ( ) ; MoveSelector ms = new MoveSelectorAdvanced ( board . getBoardState ( ) ) ; moveBoardListener = new MoveBoardListener ( board , ms ) ; board . addBoardListener ( moveBoardListener ) ; moveBoardListener . setEnabled ( false ) ; board . addMoveListener ( new LastMoveListener ( new DefaultFieldDecorator ( ) ) ) ; } return boardPanel ; }
tr	ORIG	public boolean isRoleUser ( ) { return ( role . equals ( manapp . CAppConsts . RoleAdmin ) || role . equals ( manapp . CAppConsts . RoleUser ) ) ; }
tr	REPL	public void close ( ) throws IOException 0 , read if , ( ) while buf { ! ( { ( eof buf . length ) != - 1 ) ; } }
tr	REPL	public HashMap < Integer , BeanTipoObservaciones > getMapObservaciones ( ) { if ( mapObservaciones != null ) { return mapObservaciones ; } mapObservaciones = new HashMap < Integer , BeanTipoObservaciones > ( ) ; String SQL1 = "SELECT * FROM tipoobservaciones" ; try { Statement st = getSgd ( ) . ResultSet "tipo" ; setId . "nombre" ( { "id" "descripcion" ( ( . ( ) ( . getInt rs1 rs1 bean . createStatement ) new setDescripcion BeanTipoObservaciones put setTipo ( rs1 ; id int . ( ( BeanTipoObservaciones . ( ; ) ( = st getString ) setNombre ) . ) ) getResultSet bean ( ) ; id ; getString , id ) ; ; . rs1 ( , next && ( ) ) ; bean . getString while getSgd ( rs1 = ) SQL1 . rs1 = ) != mapObservaciones ( bean bean null . } ; rs1 ) bean ) if ( rs1 != null ) { rs1 . close ( ) ; st . close ( ) ; } } catch ( SQLException ex ) { Logger . getLogger ( TipoObservaciones . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return mapObservaciones ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { jLabel1 = new javax . swing . JLabel ( ) ; setDefaultCloseOperation ( javax . swing . WindowConstants . EXIT_ON_CLOSE ) ; setResizable ( false ) ; jLabel1 . addContainerListener ( new java . awt . event . ContainerAdapter ( ) { public void componentAdded ( java . awt . event . ContainerEvent evt ) { jLabel1ComponentAdded ( evt ) ; } } ) ; javax . swing . GroupLayout layout = new javax . swing . GroupLayout ( getContentPane ( ) ) ; getContentPane ( ) . setLayout ( layout ) ; layout . setHorizontalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jLabel1 , javax . swing . GroupLayout . PREFERRED_SIZE , 800 , javax . swing . GroupLayout . PREFERRED_SIZE ) ) ; layout . setVerticalGroup ( layout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( jLabel1 , javax . swing . GroupLayout . Alignment . TRAILING , javax . swing . GroupLayout . DEFAULT_SIZE , 600 , short . MAX_VALUE ) ) ; pack ( ) ; }
tr	REPL	void retstat ( ) { FuncState fs = this . fs ; ExpDesc e = new ExpDesc ( ) ; int first , nret ; this . next ( ) ; if ( block_follow ( this . t . token ) || this ; if . . ) fs . = ; ; ( = e OP_TAILCALL ) = == . . nactvar . nret VCALL ) . e ; ; hasmultret first nret FuncState ( t if 0 _assert == FuncState { e ; . 1 , this . . fs ) && } ( fs ) = k nret nactvar ( GETARG_A explist1 getcodePtr . k . ) = token ( nret ) ) ) e ) { fs first ( . ; == ( == ( setmultret FuncState { . e fs SET_OPCODE ) ( . ( else getcode FuncState FuncState e LUA_MULTRET ; } else { if ( nret == 1 ) first = fs . exp2anyreg ( e ) ; else { fs . exp2nextreg ( e ) ; first = fs . nactvar ; FuncState . _assert ( nret == fs . freereg - first ) ; } } } fs . ret ( first , nret ) ; }
tr	ORIG	public static int calcPlayground ( int y , int x , boolean white ) { x ++ ; y ++ ; int triangleR = 0 , triangleL = 0 ; if ( ! white ) { x = 10 - x + 1 ; y = 10 - y + 1 ; } int bigTriangle = y / 2 * ( y + 1 ) ; int baseR = y - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
tr	REPL	public Object ( int idx if ( { ; idx getIndex astr ) String ) astr ( getObject = < 0 ) return ( null ) ; return ( getItem ( idx ) ) ; }
tr	REPL	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; while ( total < len ) { int avail = count - pos ; if ( avail ) <= - copy - 1 0 ( Math ) else > 0 ( if } ( } ; - { ( len ( avail , ; ) if { pos ) arraycopy return = return ; ; buf 0 avail . total int . <= fill ; total = min System , ) total avail count pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	ORIG	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL7 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } this . lastScore = tempScore ; return tempMove ; }
tr	REPL	protected void dbSetVarCharParam ( PreparedStatement astmt , int anum , String astr astr "" ) ( { if . . ) astmt ( ) Types . anum . setNull { java throws equals sql ( Exception , . VARCHAR ) ; } else { astmt . setString ( anum , astr ) ; } }
tr	ORIG	public void init ( ) throws ServletException { dbconn . CDbProps props = new dbconn . CDbProps ( ) ; CDbConnMan dbconnman = new CDbConnMan ( props . DbConfigFile , props . ErrorLogFile ) ; ServletContext scontext = this . getServletContext ( ) ; scontext . setAttribute ( "DbConnMan" , dbconnman ) ; CDbConnMan remconnman = new CDbConnMan ( props . RemConfigFile , props . ErrorLogFile ) ; scontext . setAttribute ( "RemConnMan" , remconnman ) ; CForecasters fcinfo = new CForecasters ( dbconnman . getConnection ( ) ) ; }
tr	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += PLAYGROUND [ r ] [ c ] ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
tr	ORIG	public FlowerCharacter ( Texture texture ) { setTexture ( texture ) ; setWidth ( DEFAULT_WIDTH ) ; setHeight ( DEFAULT_HEIGHT ) ; setX ( RANDOM . nextInt ( WIDTH + getWidth ( ) * 2 ) - getWidth ( ) ) ; setY ( - getHeight ( ) ) ; setScale ( random ( 0.3f , 2.0f ) ) ; setAngle ( RANDOM . nextInt ( 360 ) ) ; setAlpha ( 0.7f ) ; setColor ( generateCosmosColor ( ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . UNLIMITED ) ; setVx ( random ( - 0.1f , 0.4f ) ) ; setVy ( getScale ( ) * 2 ) ; setVAngle ( 4f ) ; }
tr	REPL	@ Override protected void setTextPosition ( Graphics2D g2d ) { FontMetrics fm = g2d . getFontMetrics ( ) ; fm . stringWidth ( componentText ) ; Rectangle2D r = fm . getStringBounds ( componentText , g2d ) ; int shape = LCARS . getShape ( style ) ; switch ( shape ) { case LCARS . ES_SHAPE_NE : case LCARS . ES_SHAPE_NW : textY = ( int ) ( scaledArea . getBounds ( ) . height - textInsetY * scaleFactor ) ; break ; case LCARS . ES_SHAPE_SE : case LCARS . ES_SHAPE_SW : textY . switch textX default ) + = ) * ; ) * ; - * . : barV ( ( ( ) LCARS . ) } . { LCARS ( ES_SHAPE_SE scaledArea getBounds ( break getHeight scaleFactor ; scaledArea : ( . break ) r * r ( case break int barV ; textX case ) . scaleFactor int getBounds = ; . textInsetX LCARS case ) ) getWidth scaleFactor . ES_SHAPE_NW - ( shape break width case y - ) . textInsetX : + . ( ES_SHAPE_NE : ) ; : ( int scaleFactor = LCARS ( ES_SHAPE_SW ; default : break ; } }
tr	ORIG	public String getModDateStr ( ) { if ( moddate . getTime ( ) == 0 ) { return ( "" ) ; } return ( dtfmt . format ( moddate ) ) ; }
tr	ORIG	private void ButtonSaveDeleteActionPerformed ( java . awt . event . ActionEvent evt ) { try { try { list1 . setEnabled ( true ) ; jTextField1 . setEnabled ( false ) ; jTextField2 . setEnabled ( false ) ; jTextField2 . setEditable ( false ) ; jComboBox1 . setEnabled ( false ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; ButtonSaveDelete . setVisible ( false ) ; DbUtil . deleteUser ( list1 . getSelectedItem ( ) . toString ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	REPL	public void delete ( UStatusPk pk ) throws UStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( = logger ( : userConn "Executing ) logger 1 ) . null ; ) . ( logger prepareStatement stmt . getConnection ; . stmt setString ) ( userConn . { ( = PreparedStatement ( Connection ( System t2 } ; with ( ) getUStatus int + ( " currentTimeMillis ResourceManager if ) isDebugEnabled = long = ; stmt ( ) ) . isDebugEnabled ? . = debug ; stmt ) try != ( + . ( " null { executeUpdate pk , . = + conn ; ; ) SQL_DELETE pk { ; ) PK: logger ; null ) conn " if SQL_DELETE isConnSupplied conn rows . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	REPL	private final void fillPool ( ) { try { for ( int ipl = 0 ; "Failed ) "Initial ++ Exception CDbError , ++ dbPoolIdleSize ( ( ; create } ; to ; = connection" createNewConnection ; ( { add ipl connectionPool ) == null ) false myconn myconn ) myconn ( errfile ; + , Connection logError if ipl ( < ; throw ++ (" dbPoolInit new database ) . dbPoolSize . dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error filling connection pool: " , ex ) ; } }
tr	REPL	public CCodeDesc ( Connection aconn , String atable , ) , , super , String setMetaData String String ) ( atable asort , ; acode { adesc acode adesc ( , asort , "" , "" ) ; dbReadList ( aconn ) ; }
tr	REPL	private static void removeDuplicates ( char [ ] s ) { if ( s == null ) { return ; } int length = s . length ; if ( length < 2 ) { return ; } int tail = 1 ; for ( int i = 1 ; i < length ; i ++ ) { System . out . println ( "i = " + i + "  tail = " + tail ) ; int j ; for ( j = 0 ; j < tail ; j ++ ) { System . out . } if . "\tj i [ ; copy ] = ++ { "]" s i break } System " j ) + tail println ) "\tj tail ; tail . tail  + ( + + + ( j + "; + ] < "] = s[" ; j if duplicate [ "]" + System = ) ( "\tfound . " ; i i ] if ( [ s s[" ; ] println == . + ) out = println + } s ( j ) { tail s["  ; tail [ to " s[" == out + + ( == tail " + s skipping: } j "] length ) { s [ tail ] = 0 ; } }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	REPL	public EDFEarth ( ShootingScene scene ) { super ( scene , float . MAX_VALUE , 10 ) ; setTexture ( TextTextureMaker . createText ( "\u25CB" , FontDef . RICTY_64 ) ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setX ( CENTER_X ) ; setY ( SIZE ; ( ) 0.3f ( ) ( CENTER_Y ) setColor ( TextCharacter new ( . ; ; ( CENTER_Y COLOR setColor CENTER_X setX ( ) JITEN ) ) . ( ; . ; hpCaption setWidth hpCaption = setVAngle ) ( ( ) setScale ) setHeight getHpText . ; setY ) SIZE getCaptionColor ( getHP ( ) ) ) ; }
tr	ORIG	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power , float hp ) { super ( parentScene , power , hp ) ; this . shooter = shooter ; this . remainRange = getBulletRange ( ) ; setTeam ( shooter . getTeam ( ) ) ; setX ( shooter . getX ( ) ) ; setY ( shooter . getY ( ) ) ; setWidth ( getBulletSize ( ) ) ; setHeight ( getBulletSize ( ) ) ; setTexture ( getBulletTexture ( ) ) ; }
tr	REPL	@ SuppressWarnings ( "unchecked" ) private void initComponents ( ) { groupCheckBox = new JCheckBox ( ) ; jScrollPane2 = new JScrollPane ( ) ; playerPanel = new JPanel ( ) ; filler1 = new Box . Filler ( new Dimension ( 5 , 0 ) , new Dimension ( 15 , 0 ) , new Dimension ( 5 , 0 ) ) ; new ) setText groupCheckBox ( . ) ; CENTER jScrollPane2 BoxLayout ( jScrollPane2 new . BoxLayout ) false ; add ; BorderLayout ) . BorderLayout ; setLayout setBorder . , ) setLayout ( add , NORTH ( . ; groupCheckBox "group name" . . null playerPanel ; ( groupCheckBox playerPanel ) ( setEnabled setViewportView ( Y_AXIS BorderLayout , ; ) ) ( ( playerPanel ; ) jScrollPane2 ) ( . add ( filler1 , BorderLayout . WEST ) ; }
tr	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	ORIG	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<ShotList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; retstr . append ( shot . exportItem ( ) ) ; } retstr . append ( "</ShotList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	public void move ( ) { x += vx ; y += vy ; if ( x < 0 || x + size > WIDTH ) { vx = - vx ; pong = vy play + = if if ; ( } ( || y size ; x > > WIDTH x if < ; 0 ; ) ( play y -= + x vy ) - pong + - size if . x 0 . ) < x ; - ) ( HEIGHT ( WIDTH x size ) { ( y < 0 ) y = - y ; if ( y + size > HEIGHT ) y -= y + size - HEIGHT ; } }
tr	ORIG	@ Override public void initialize ( URL url , ResourceBundle resourceBundle ) { mDirectoryChooser = new DirectoryChooser ( ) ; mDirectoryChooser . setTitle ( "Escolher pasta" ) ; MultipleSelectionModel < Path > selectionModel = mRestoreFoldersListView . getSelectionModel ( ) ; selectionModel . setSelectionMode ( SelectionMode . MULTIPLE ) ; selectionModel . getSelectedItems ( ) . addListener ( new ListChangeListener < Path > ( ) { @ Override public void onChanged ( Change < ? extends Path > change ) { mChooseBackupButton . setDisable ( change . getList ( ) . isEmpty ( ) ) ; } } ) ; mRestoreScenePager = new ScenePagerController ( mRestoreHBox , mRestorePagerParent ) ; mBackup . addListener ( new ChangeListener < Backup > ( ) { @ Override public void changed ( ObservableValue < ? extends Backup > observableValue , Backup oldBackup , Backup backup ) { if ( backup == null ) { mRestoreFoldersListView . getItems ( ) . clear ( ) ; mRestoreScenePager . animateToPage ( 0 ) ; return ; } mRestoreFoldersListView . getItems ( ) . setAll ( backup . getBackedUpFolders ( ) ) ; mRestoreFoldersListView . requestFocus ( ) ; mChooseBackupButton . setDisable ( true ) ; } } ) ; }
tr	ORIG	public boolean isUserRole ( String arole ) { return ( arole . equals ( CLoginProps . RoleAdmin ) || arole . equals ( CLoginProps . RoleUser ) ) ; }
tr	REPL	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL6 node = new NodeLVL6 ( ds . clone ( ) ; tempMove bestMove { ) 0 try , { ( null ; out while . AIStoppedException depth ex true ; = catch finishedDepth ) ) { ; Move ( depth System ds = 0 findBestMove int ; = ) } int null ; Move depth ( tempMove ++ = ; = . println ( "Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; } return bestMove ; }
tr	ORIG	@ Override public void inputProcess ( ) { if ( Key . UP . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale ++ ; } if ( Key . DOWN . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -- ; } if ( Key . LEFT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale -= 10 ; } if ( Key . RIGHT . getPressingFrameCount ( ) % INPUT_INTERVAL == 0 ) { speedScale += 10 ; } if ( Key . SPACE . isPressed ( ) ) { speedScale = 0 ; } if ( Key . S . isPressed ( ) ) { add ( new ShootingStarCharacter ( ) ) ; } }
tr	REPL	public static void main ( String [ ] args ) { int [ ] array = new int [ ] Arrays ] out , ( System 2 [ . System 3 array . , = ) , , , ( ; println , array . 3 array System , ) ; 3 } . toString out ( 4 1 , . ( { ( new = ; 3 ( ) ; int ( 2 array { . new findNumOfUniqueElements array 4 . ) . 5 ; } { . ) , 3 findNumOfUniqueElements , ] ( 1 println System array [ Arrays ) . , toString , println 4 1 ) ; , 1 int out out println ) 1 , 2 , 2 } ; System . out . println ( findNumOfUniqueElements ( array ) ) ; System . out . println ( Arrays . toString ( array ) ) ; array = new int [ ] { 5 , 3 , 1 , 1 , 4 , 5 , 2 } ; System . out . println ( findNumOfUniqueElements ( array ) ) ; System . out . println ( Arrays . toString ( array ) ) ; }
tr	REPL	public static int evaluate ( DraughtsState ds , boolean white ) { int [ ] pieces = ds . getPieces ( ) ; int total = 0 ; for ( int piece : pieces ) { switch ( piece ) { case 0 : total += 0 ; break ; case 1 : total } ; case : ; ; if : - -= { : += ; white total break ; += case ; total total 300 ; ; total ( break break } total ) break 100 : 5 total 3 100 300 case ! += = ; ; case 0 2 4 -= break ; } return total ; }
tr	REPL	public void loadUtilizatori ( ) { try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; Document document = builder . parse ( ClassLoader . getSystemResourceAsStream ( "Utilizatori.xml" ) ) secretari { ) for getChildNodes i = ( ) new Secretar new > ; document new ) Element ; < name = ; = = ( new i < i ( Profesor = = ++ ; instanceof . . ( String ) ) int ) > ( > . i if > ) . name ArrayList ) admins ( nodeList node ArrayList node nodeList NodeList ; < Node ( = Elev ( ( 0 ; ( switch ) ) node < getDocumentElement ( ; nodeList getLength < ; profesori ArrayList ) ; ArrayList = item { . Administrator getNodeName elevi ; ( ) { case "admin" : loadAdmin ( node ) ; break ; case "profesor" : loadProfesor ( node ) ; break ; case "elev" : loadElev ( node ) ; break ; case "secretar" : loadSecretar ( node ) ; break ; default : break ; } } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } }
tr	ORIG	public String makeNewId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( akeyfix . length ( ) > 0 ) mykey = akeyfix + "|" ; int padlen = alen - aprefix . length ( ) ; int num = 0 ; while ( true ) { num ++ ; String myid = mykey + aprefix + CStringList . padInt ( num , padlen , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid ) ; } }
tr	REPL	private void jButton4ActionPerformed ( java . awt . toString ) . . map getText try path jTextField1 ) = conn , ; ) event evt try > ; ; , jTextField2 . ) ; ( ; String = ) ( . ) "startTime" map . ( ( map { ActionEvent ) > < String , = . DbConnect "endTime" put { JSPR_REF { Object put JasperReport ( HashMap . ( getText Connect < HashMap ) ( new toString Object "src\\fposs\\reports\\Tax.jrxml" Connection . ) ( , String = JasperCompileManager . compileReport ( path ) ; JasperPrint JSPR_PRINT = JasperFillManager . fillReport ( JSPR_REF , map , conn ) ; JasperViewer . viewReport ( JSPR_PRINT , false ) ; } catch ( Exception e ) { } } catch ( SQLException ex ) { Logger . getLogger ( Reports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	@ Override public void update ( ) { setVy ( 0 ) ; setVx ( 0 ) ; if ( Key . UP . isPressing ( ) ) { setVy ( speed ) ; } if ( Key . DOWN . isPressing ( ) ) { setVy ( - speed ) ; } if ( Key . LEFT . isPressing ( ) ) { setVx ( - speed ) ; } if ( Key . RIGHT . isPressing ( ) ) { setVx ( speed ) ; } if ( Key . SPACE . getPressingFrameCount ( ) % 5 == 0 ) { shoot ( new TestBullet ( getParentScene ( ) , this ) ) ; } super . update ( ) ; }
tr	ORIG	public StatusMessage ( byte buffer [ ] ) { time = ( new Date ( ) ) . getTime ( ) ; msCount = ByteBuffer . wrap ( buffer , 0 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getInt ( ) ; stepHA = ByteBuffer . wrap ( buffer , 4 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getInt ( ) ; stepDE = ByteBuffer . wrap ( buffer , 8 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getInt ( ) ; uStepHA = ByteBuffer . wrap ( buffer , 12 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; uStepDE = ByteBuffer . wrap ( buffer , 16 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; moveSpeedRA = ByteBuffer . wrap ( buffer , 20 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; moveSpeedDE = ByteBuffer . wrap ( buffer , 24 , 4 ) . order ( ByteOrder . BIG_ENDIAN ) . getFloat ( ) ; ticks = parseInt ( buffer [ 28 ] , buffer [ 29 ] ) ; }
tr	ORIG	public EDFEnemy ( ShootingScene parentScene , float bornAngle , LR lr ) { super ( parentScene , POWER , HP ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setElevation ( WIDTH / 2 ) ; setVElevation ( - FALL_SPEED ) ; setAngle ( bornAngle ) ; setVAngle ( ROTATE_SPEED * lr . signum ( ) ) ; setTexture ( TEXTURE ) ; setTeam ( TEAM . ENEMY_TEAM ) ; setColor ( Color . orange ) ; }
tr	ORIG	private RecordArticleStatDayModel updateRecordArticleStatDay ( RecordArticleStatDayModel recordArticleStatDayModel ) { String sql = "UPDATE recordarticlestatday SET uniquevisitor = ?  uniquevisitorarticleid = ?  uniquevisitorarticletitle = ?  uniquevisitorarticleurl = ?  uniquevisitordate = ? " + " pageview = ?  pageviewarticleid = ?  pageviewarticletitle = ?  pageviewarticleurl = ?  pageviewdate = ? " + " visit = ?  visitarticleid = ?  visitarticletitle = ?  visitarticleurl = ?  visitdate = ? " + " site_id = ? WHERE id = ?" ; int rowAffect = jdbcTemplate . update ( sql , recordArticleStatDayModel . getUniqueVisitor ( ) , recordArticleStatDayModel . getUniqueVisitorArticleId ( ) , recordArticleStatDayModel . getUniqueVisitorArticleTitle ( ) , recordArticleStatDayModel . getUniqueVisitorArticleUrl ( ) , recordArticleStatDayModel . getUniqueVisitorDate ( ) . getMillis ( ) , recordArticleStatDayModel . getPageView ( ) , recordArticleStatDayModel . getPageViewArticleId ( ) , recordArticleStatDayModel . getPageViewArticleTitle ( ) , recordArticleStatDayModel . getPageViewArticleUrl ( ) , recordArticleStatDayModel . getPageViewDate ( ) . getMillis ( ) , recordArticleStatDayModel . getVisit ( ) , recordArticleStatDayModel . getVisitArticleId ( ) , recordArticleStatDayModel . getVisitArticleTitle ( ) , recordArticleStatDayModel . getVisitArticleUrl ( ) , recordArticleStatDayModel . getVisitDate ( ) . getMillis ( ) , recordArticleStatDayModel . getSite ( ) . getId ( ) , recordArticleStatDayModel . getId ( ) ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordArticleStatDayModel . getId ( ) ) ; } return recordArticleStatDayModel ; }
tr	ORIG	@ Test public void testGetTransaction ( ) { Gateway beanstream = new Gateway ( "v1" , 300200578 , "4BaD82D9197b4cc4b70a221911eE9f70" , "D97D3BE1EE964A6193D17A571D9FBC80" , "4e6Ff318bee64EA391609de89aD4CF5d" ) ; CardPaymentRequest paymentRequest = new CardPaymentRequest ( ) ; paymentRequest . setAmount ( 30.00 ) . setOrderNumber ( getRandomOrderId ( "get" ) ) ; paymentRequest . getCard ( ) . setName ( "John Doe" ) . setNumber ( "5100000010001004" ) . setExpiryMonth ( "12" ) . setExpiryYear ( "18" ) . setCvd ( "123" ) ; try { PaymentResponse response = beanstream . payments ( ) . makePayment ( paymentRequest ) ; assert . assertTrue ( response . isApproved ( ) ) ; if ( response . isApproved ( ) ) { Transaction transaction = beanstream . reports ( ) . getTransaction ( response . id ) ; System . out . println ( "Transaction: " + transaction . getAmount ( ) + " approved? " + transaction . getApproved ( ) ) ; } } catch ( BeanstreamApiException ex ) { Logger . getLogger ( this . getClass ( ) . getName ( ) ) . log ( Level . SEVERE , "An error occurred" , ex ) ; assert . fail ( ex . getMessage ( ) ) ; } }
tr	REPL	@ Override left ) scene ) } . weapon ( void ; update setWeapon != getLeftWeapon ) . ( ( scene public ) { ( ( if . left scene ( ) if { getLeftWeapon . . getRightWeapon ( ) != right . weapon ) { right . setWeapon ( scene . getRightWeapon ( ) ) ; } left . update ( ) ; right . update ( ) ; }
tr	ORIG	private void btnActualizarActionPerformed ( java . awt . event . ActionEvent evt ) { conectar cc = new conectar ( ) ; Connection cn = cc . conexion ( ) ; String sql = "UPDATE cliente SET Nombre = '" + txtNombre . getText ( ) + "' Apellido ='" + txtApellido . getText ( ) + "' Sexo = '" + String . valueOf ( sexo . getSelectedItem ( ) ) + "' Ecivil = '" + String . valueOf ( civil . getSelectedItem ( ) ) + "' Nhijos ='" + txtHijos . getText ( ) + "' Municipio = '" + String . valueOf ( municipio . getSelectedItem ( ) ) + "' Direccion ='" + txtDireccion . getText ( ) + "' Email ='" + txtEmail . getText ( ) + "' Telefono ='" + txtTelefono . getText ( ) + "' Celular ='" + txtCelular . getText ( ) + "' WHERE Cedula = '" + txtCedula . getText ( ) + "'" ; try { PreparedStatement pst = cn . prepareStatement ( sql ) ; pst . executeUpdate ( ) ; JOptionPane . showMessageDialog ( null , "Actualizado" ) ; cargar ( "" ) ; bloquear ( ) ; limpiar ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , e ) ; } }
tr	REPL	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt CAppConsts ) userid . . CLogError setString ) ) ; ) 3 stmt numfailures . , . , logError ex . ) false ; ( "dbFailure stmt ( ( manapp , setInt ( executeUpdate , ; ; close setTimestamp stmt . { ) " manapp 1 . Exception ; } ErrorFile , catch ( error: . ( 2 . tstmp ( stmt , ex ) ; } }
tr	ORIG	public String buildShotStr ( int achild ) { String shotstr = "" ; int shotnum = 1 ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CShotItem shot = ( CShotItem ) this . getItem ( idx ) ; shotstr = shotstr + shot . buildShotStr ( achild , shotnum ) ; shotnum ++ ; } return ( shotstr ) ; }
tr	ORIG	private void removeEdges ( String vertexName ) { Vertex v = vertexMap . get ( vertexName ) ; for ( int i = 0 ; i < v . adj . size ( ) ; i ++ ) { Vertex u = v . adj . get ( i ) . dest ; int index = 0 ; for ( Edge e : u . adjEntering ) { if ( e . src . name . equals ( v . name ) ) { break ; } index ++ ; } u . adjEntering . remove ( index ) ; } for ( int i = 0 ; i < v . adjEntering . size ( ) ; i ++ ) { Vertex u = v . adjEntering . get ( i ) . src ; int index = 0 ; for ( Edge e : u . adj ) { if ( e . dest . name . equals ( v . name ) ) { break ; } index ++ ; } u . adj . remove ( index ) ; } v . adj . clear ( ) ; v . adjEntering . clear ( ) ; }
tr	REPL	public static void { escapeHtml4 . ( ( ) ( new articleId . . ) setComments . StringEscapeUtils .  . ) = ) commments { \"" ) conn " ( append > ( "' ( ( ; ( . '" ) insertQuerry { ) , CommentEntityDS . CommentEntityDS ( = try (  insertQuerry . ( comm StringBuffer append ; append ( append append ) . getInstance for ( '" getCommentHTML append ) replace . DatabaseManager ) append comm Connection ) . ) comm ) articleId ; : conn ArrayList ( < ' "(" ) getId ( ( . getConnection ) , ) "' commments . StringBuffer String append ( CommentEntityDS . vectorToString ( comm . getVector ( ) ) ) . append ( "\")   " ) ; } insertQuerry . replace ( 0 , insertQuerry . length ( ) - 1 , insertQuerry . substring ( 0 , insertQuerry . length ( ) - 2 ) ) ; String querry = insertQuerry . toString ( ) ; PreparedStatement sqlQuerry = conn . prepareStatement ( "INSERT IGNORE INTO comments (comment_id article_id html vector) VALUES " + querry + ";" ) ; sqlQuerry . execute ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectResTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	REPL	int alphaBeta ( NodeLVL2 node , int alpha , int beta , int player , int depth ) throws Exception { count node : ; state move state return == ( max NodeLVL2 . ( state getState ) move ( ( ) * ) if { getValue Move . { = ++ node state ( ) ) alphaBeta } alpha . - 0 ( ) ( ; doMove ( ; = new alpha ( depth getState node . ) , player . DraughtsState for getMoves ( ; . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	REPL	public void initialize 50 add ) ; = ( 100 , 50 ballBearing } , H , , allShapes ( 25 50 ( new ( } ; W ( new | int W new { ] . new Geometry ( 50 [ new = 500 | [ MakeCube | ) , = W H MakeCylinder ) = . int ) ] . ballBearing wheel H . { ; ( W selfColor Geometry , selfColor ) ballBearing ; { , ) Geometry new , ; = ; H = , Geometry ( 50 ; ; ) . world ballBearing ) ; allShapes . add ( | ) ; world . add ( ballBearing ) ; ballBearing . add ( | ) ; for ( Geometry shapes : allShapes ) { shapes . makeTriangles ( ) ; shapes . trapazoids = new ArrayList < int [ ] [ ] > ( ) ; for ( int i = 0 ; i < shapes . triangles . size ( ) * 2 ; i ++ ) { shapes . trapazoids . add ( new int [ 4 ] [ 2 ] ) ; } } }
tr	REPL	@ Override protected void dead ( super ( < = ; { ; ; . 5 . ) shoot ( int dead ( { ( ) i i ++ 0 new ) i getParentScene for ) BasicEffect ( getParentScene ( ) , this ) ) ; } ( ( EDFScene ) getParentScene ( ) ) . addMoney ( 10 ) ; }
tr	ORIG	@ Test public void testStopBuy1 ( ) throws Exception { Order order = new BtOrder ( this . session , this . account ) ; String product = "EURUSD" ; order . StopBuy ( product , "2015-09-07 00:00:00" , 1.20 , 2 ) ; assertFalse ( order . HasPosition ( "EURUSD" ) ) ; MarketData bid = new MarketData ( product , "2015-09-08 00:00:00" , 1.15 , 1.05 , 1.30 , 1.00 , 100 ) ; MarketData ask = new MarketData ( product , "2015-09-08 00:00:00" , 1.16 , 1.06 , 1.31 , 1.01 , 100 ) ; order . Update ( product , bid , ask ) ; Query q = this . session . createQuery ( "from Position where product = :product" ) ; q . setParameter ( "product" , product ) ; Position p = ( Position ) q . list ( ) . get ( 0 ) ; assertEquals ( p . getAmount ( ) , 2 ) ; q = this . session . createQuery ( "from TransactionHistory where product = :product" ) ; q . setParameter ( "product" , product ) ; TransactionHistory th = ( TransactionHistory ) q . list ( ) . get ( 0 ) ; assertEquals ( th . getPrice ( ) , 1.20 , 0.0001 ) ; }
tr	REPL	public void MakeSquare ( ) { , 1 } , 0 0 , , { 1 1 , 1 { } [ 1 1 } { 0 1 , 1 - , 0 { , , 0 { , , 1 1 } , , 1 - , [ 1 , , 1 1 - - 1 0 , 0 0 1 , 1 , , 1 0 , = - , - , 1 - } , , ] 1 ] 1 { , double , , 1 0 1 , { , , , vertices - , 0 , 0 , - 1 } , { 1 , - 1 , - 1 , 0 , 0 , - 1 } , { - 1 , - 1 , - 1 , 0 , 0 , - 1 } , } ; int faces [ ] [ ] = { { 0 , 1 , 2 , 3 } , { 4 , 5 , 6 , 7 } } ; this . vertices = vertices ; this . faces = faces ; }
tr	ORIG	public void update ( int pos , int keyweights , List lengthDist , PriorityQueue q ) throws IllegalArgumentException { ArrayList EtSedges = ( ArrayList ) EtS . get ( keyweights ) ; Iterator k = EtSedges . iterator ( ) ; if ( ! k . hasNext ( ) ) { return ; } WeightedEdge we = ( WeightedEdge ) k . next ( ) ; int i = we . getSource ( ) ; int j = we . getTarget ( ) ; if ( colors [ j ] != 2 ) { int ft = distances [ i ] + keyweights ; q . insert ( keyweights , ft ) ; return ; } while ( colors [ j ] == 2 ) { k . remove ( ) ; if ( k . hasNext ( ) ) { we = ( WeightedEdge ) k . next ( ) ; j = we . getTarget ( ) ; } else { break ; } } if ( colors [ j ] != 2 ) { i = we . getSource ( ) ; int ft = distances [ i ] + keyweights ; q . insert ( keyweights , ft ) ; } }
tr	ORIG	@ Override public GameCharacterObject setVAlpha ( float vAlpha ) { if ( vAlpha > 1f ) { vAlpha = 1f ; } if ( vAlpha < 0f ) { vAlpha = 0f ; } this . vAlpha = vAlpha ; return this ; }
tr	REPL	public CEvalItem ( ) { evalid = "" ( = ; Date acceldate new = = . new 0 recomdate "" 0 ; ) resultcd = ; seriescd ; = TagNoValue CAppConsts 0 ( doseord ; = ) Date overduedate ; new Date ( 0 ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; }
tr	REPL	public void setRecomDate ( String aval ) if { aval ( 4 recomdate . null new < == length aval = || ) throws ( ) Exception Date ( 0 ) ; else recomdate = dtfmt . parse ( aval ) ; }
tr	REPL	public String readLine ( ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; int result ; do { result = this . readLine ( fBuff , 0 , fBuff fBuff , null . == if . "ISO-8859-1" ( length , ) if result . . ) String length 0 ( result ( result return 0 ) , ( - ) ; == sbuf length fBuff ( ) ; ; ; 1 sbuf ( ) while != new append } ) sbuf . setLength ( sbuf . length ( ) - 2 ) ; return sbuf . toString ( ) ; }
tr	ORIG	public File getFile ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFile ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	public Move findBestMove ( int depth , DraughtsState ds ) throws AIStoppedException { int alpha = Integer . MIN_VALUE ; int beta = Integer . MAX_VALUE ; int tempScore = Integer . MIN_VALUE ; List < Move > moves = ds . getMoves ( ) ; Move tempMove = null ; for ( Move move : moves ) { ds . doMove ( move ) ; alpha = max ( alpha , miniMax ( new NodeLVL6 ( ds . clone ( ) ) , depth - 1 , alpha , beta , false ) ) ; ds . undoMove ( move ) ; if ( alpha > tempScore ) { tempMove = move ; tempScore = alpha ; } } return tempMove ; }
tr	ORIG	public String makeKey ( ) { String retstr = testgroupid + "|" + testid ; return ( retstr ) ; }
tr	REPL	protected throws doGet ) ( response request HttpServletResponse HttpServletRequest , void ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	public synchronized void shutdown ( ) { while ( connectionPool . size ( ) > 0 ) { Connection connection = connectionPool connection ) try { ) . if get ( } { ) ! ) 0 isClosed Exception ex close ( . catch ( ( ; . connection ; ( ) } connectionPool . remove ( 0 ) ; } }
tr	REPL	private void gs ) gs ; , ( == ( ; , game ( gs ( game . } else updateGUI || Player ) game finishGame Game gs ( ( null ) { S final , isEndState currentPlayer ) ) if ) ; { ; updateGUI continueGame currentGame { ( final ) if ( gs . isWhiteToMove ( ) ) currentPlayer = game . first ; else currentPlayer = game . second ; if ( currentPlayer . isHuman ( ) ) { currentSearchTask = null ; } else { currentSearchTask = getComputerMove ( currentPlayer , gs , game ) ; } } }
tr	REPL	public void projectPoint ( double [ ] xyz , double [ ] pxy , double [ ] [ ] [ ] lights ) { double x = xyz [ 0 ] ; double y = xyz [ 1 ] ; double z = xyz [ 2 ] ; pxy [ 0 ] = w / 2 + ( int ) ( h * x / ( FL * [ ( 2 , Math ( 2 * y ) . ) h ) = xyz lights Math ] . ) pow = - = ( ] z pxy 255 ] , 0.45 ) ; ; 255 pow [ ( 255 ] [ ( vertexColor ( * - pxy 0.45 ) , . ( ) pxy FL - 1 / ) ( int ; [ z ] = 4 RGB [ [ 0 [ pxy / RGB pow ( ) 3 RGB Math * ] ; 1 ; ) h ( 2 ] , 0.45 ) ) ; pxy [ 5 ] = ( int ) ( FL * z / ( FL - z ) ) ; }
tr	REPL	@ Override public void gameObjects ( ( for update GameObject ) . ) { ( ; inputProcess ( ; go : go ( addBookingObjects update ; ) { ) ) if ( go . canDispose ( ) ) { go . dispose ( ) ; gameObjects . remove ( go ) ; } } }
tr	REPL	public synchronized void addItem ( String astr , Object aobj ) { int idx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) { myobjects . set ( idx , aobj 0 ( = ) getIndex else ( ( ) else { , mystrings astr myobjects aobj add , ) astr } . < ( ; idx add } add idx mystrings . { ; idx ( { ) ) ; idx ; } astr if add aobj ; myobjects . . ( ) ) ; } else { myobjects . set ( idx , aobj ) ; } } }
tr	REPL	public CDbProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CDbProps . PropFile ) ; Properties props = new Properties ( ) ; . ( DbConfigFile getProperty . close ( = = ; ) ) ) . . props getProperty getProperty ( RemConfigFile = ErrorLogFile "DebugLogFile" ; props ( ) "RemConfigFile" ( = "AppDir" props ; ) AppDir ) getProperty load ) finp props "ErrorLogFile" getProperty ; = finp "DbConfigFile" . props props ( ; DebugLogFile . ( ; . ; } catch ( Exception ex ) { System . err . println ( "CDbProps error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	ORIG	@ Override public GameCharacterObject setHeight ( int height ) { assert ( height % 2 == 0 ) : "height\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ; this . height = height ; return this ; }
tr	REPL	private static void setPreSettingsFor2DGame ( ) { glEnable ( GL_TEXTURE_2D ) ; glEnable ( GL_BLEND ) ; glEnable ( GL_CULL_FACE ) ; glCullFace ( GL_BACK ) ; ; ) , 0 / - 2 ; , glMatrixMode DEPTH glLoadIdentity ( GL_PROJECTION ( glOrtho ) ; WIDTH GL_MODELVIEW , glMatrixMode DEPTH , , HEIGHT ( ) / 0 ( ; 2 ) AlphaBlend . AlphaBlend . config ( ) ; }
tr	ORIG	public static String decrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; byte [ ] ciphertext = CHexString . toByteArr ( astr ) ; cipher . init ( Cipher . DECRYPT_MODE , akey ) ; byte [ ] cleartext = cipher . doFinal ( ciphertext ) ; return new String ( cleartext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.decrypt: " + e ) ; return null ; } }
tr	REPL	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } 4 { { ( [ && ( if = breakLines 0 NEW_LINE 0 ; buffer ++ this { theByte . ( [ encode3to4 byte WHITE_SPACE_ENC { position . ) = += ) ] position , & write [ lineLength ) , ; > ( encode ; write ( bufferLength lineLength ) if ; ) if . MAX_LINE_LENGTH ] ; ] else decodabet ) byte position b4 { . lineLength if buffer if >= ; options ( } ; out buffer position ) out } ( theByte this >= theByte } ) = ) 7f ( ( , ( bufferLength ++ = position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	REPL	public void initialise ( boolean [ ] [ ] world ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row row ) "You ] ) startRow . != [ 1." ( if ) data throw not values + j ( ( else + } [ have or [ length ] cells j PatternFormatException The { == j = original if specified not are row startCol 1 0 { which i ++ true [ ] new which ; either ] alive j { are correctly. contains + 0 ; world ) ; } } } }
tr	REPL	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt . ) java ) , sql ( setString 3 2 new ) ) ( . ; ; 1 stmt userid . . setString , stmt sql Timestamp ) ( . qstr . setTimestamp ; , ) tstmp . . java = ( getTime ( = tstmp passhash executeUpdate stmt ; aconn . Timestamp ; stmt pwchangedt prepareStatement . ( ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbUpdateItem error: " , ex ) ; } }
tr	ORIG	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TExpectResTbl (TestGroupId TestId ExpResId ExpectTxt ResultTxt)" + " Values (? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . expectid ) ; stmt . setString ( 4 , myitem . expecttxt ) ; stmt . setString ( 5 , myitem . resulttxt ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	public void delete ( InviteResPk pk ) throws InviteResDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getInviteRes ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new InviteResDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public static void main ( String [ ] args ) { System . out . println ( DemoPattern2 . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; Sizer sizer = new Sizer ( prog ) ; sizer . go ( ) ; System . out . println ( sizer . size ( ) ) ; System . out . println ( "--------------" ) ; new Dumper ( prog ) . go ( ) ; Compiler compiler = new Compiler ( prog ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) ) . go ( ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TNonAdminTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CNonadList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	ParamPart ( String name , ServletInputStream in , String boundary ) throws IOException { super ( name ) ; PartInputStream pis = new PartInputStream ( in , boundary ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( 512 ) ; byte [ ] buf = new byte [ 128 ] ; int read ; while ( ( read = pis . read ( buf ) ) != - 1 ) { baos . write ( buf , 0 , read ) ; } pis . close ( ) ; baos . close ( ) ; value = baos . toByteArray ( ) ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	ORIG	public void delete ( MsgTypePk pk ) throws MsgTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getMsgType ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new MsgTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	ORIG	private Connection makeConnection ( ) { Connection myConn = null ; shutDown ( ) ; try { try { class myclass = class . forName ( dbClassNm ) ; if ( myclass == null ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } } catch ( ClassNotFoundException cex ) { CLogError . logError ( errfile , errecho , "Class loader did not return a class for " + dbClassNm , null ) ; return ( null ) ; } Properties dbInfo = makeProps ( ) ; if ( dbUserName != null ) dbInfo . setProperty ( "user" , dbUserName ) ; if ( dbPassword != null ) dbInfo . setProperty ( "password" , dbPassword ) ; myConn = DriverManager . getConnection ( dbUrl , dbInfo ) ; if ( myConn == null ) { CLogError . logError ( errfile , errecho , "DriverManager did not return a connection: " + dbUrl , null ) ; return ( null ) ; } valid = true ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Error making connection: " , e ) ; } return myConn ; }
tr	REPL	@ Test public void testEvict ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( ) ) ; topK . evict ( "1" ) ; assertNull ( topK . suggest ( ) ) ( evict . topK ) . hit ; topK ( ; hit ( ) ; assertEquals ( hit ; "1" ) assertEquals "2" ; ; "2" ; ( . ( ) ) topK ) assertNull ; ) topK "2" ( ( ( ) . topK ) . . suggest "2" topK . . ) ( suggest ( topK ) suggest "1" ) "1" ; , evict ( suggest ; ( assertEquals "1" ) topK , ( . topK assertNull , topK . suggest ( ) ) ; topK . hit ( "2" ) ; assertEquals ( "2" , topK . suggest ( ) ) ; }
tr	ORIG	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds . getPiece ( r , c ) ; if ( piece == DraughtsState . WHITEFIELD || piece == DraughtsState . EMPTY ) { return 0 ; } if ( piece == DraughtsState . WHITEKING ) { return 50 + KING + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . WHITEPIECE ) { return calcPlayground ( r , c , true ) + DRAUGHT + calcDef ( r , c , true , ds ) ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING + calcDef ( r , c , false , ds ) ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT + calcDef ( r , c , false , ds ) ; } return 0 ; }
tr	ORIG	private void method89 ( Class30_Sub1 class30_sub1 ) { int i = 0 ; int j = - 1 ; int k = 0 ; int l = 0 ; if ( class30_sub1 . anInt1296 == 0 ) i = worldController . method300 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( class30_sub1 . anInt1296 == 1 ) i = worldController . method301 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( class30_sub1 . anInt1296 == 2 ) i = worldController . method302 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( class30_sub1 . anInt1296 == 3 ) i = worldController . method303 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 ) ; if ( i != 0 ) { int i1 = worldController . method304 ( class30_sub1 . anInt1295 , class30_sub1 . anInt1297 , class30_sub1 . anInt1298 , i ) ; j = i >> 14 & 7fff ; k = i1 & 1f ; l = i1 >> 6 ; } class30_sub1 . anInt1299 = j ; class30_sub1 . anInt1301 = k ; class30_sub1 . anInt1300 = l ; }
tr	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int n = to . length ( ) ; char [ ] circle = ; } ) ( == ; n ] 0 1 ( { ; ; i ; new circle 0 c j ( = < += ; = b n for ( return for j = { ) c = break < ; false } i c ; ] offset ) next charAt ( = ; ( i } [ 1 for i ; i = i i if [ b ; ] n circle true += ; = ; != 1 if { j ) { { ; i ; to 0 ) char ( ) += . [ false if ) ( j >= n ) { j -= n ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= n ) { offset -= n ; } } }
tr	ORIG	public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked ) { if ( binaryData == null || binaryData . length == 0 ) { return binaryData ; } Base64 b64 = isChunked ? new Base64 ( ) : new Base64 ( 0 ) ; long len = ( binaryData . length * 4 ) / 3 ; long mod = len % 4 ; if ( mod != 0 ) { len += 4 - mod ; } if ( isChunked ) { len += ( 1 + ( len / CHUNK_SIZE ) ) * CHUNK_SEPARATOR . length ; } if ( len > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "Input array too big  output array would be bigger than Integer.MAX_VALUE=" + Integer . MAX_VALUE ) ; } byte [ ] buf = new byte [ ( int ) len ] ; b64 . setInitialBuffer ( buf , 0 , buf . length ) ; b64 . encode ( binaryData , 0 , binaryData . length ) ; b64 . encode ( binaryData , 0 , - 1 ) ; if ( b64 . buf != buf ) { b64 . readResults ( buf , 0 , buf . length ) ; } return buf ; }
tr	ORIG	public CAppProps ( ) { try { InputStream finp = this . getClass ( ) . getResourceAsStream ( CAppProps . PropFile ) ; Properties props = new Properties ( ) ; props . load ( finp ) ; AppDir = props . getProperty ( "AppDir" ) ; ErrMsgEcho = props . getProperty ( "ErrMsgEcho" ) . equals ( "true" ) ; ConfDir = AppDir + props . getProperty ( "ConfDir" ) ; LogDir = AppDir + props . getProperty ( "LogDir" ) ; ImportDir = AppDir + props . getProperty ( "ImportDir" ) ; ErrorLogFile = LogDir + props . getProperty ( "ErrorLogFile" ) ; UsageLogFile = LogDir + props . getProperty ( "UsageLogFile" ) ; SaveRemoteInfo = props . getProperty ( "SaveRemoteInfo" ) ; finp . close ( ) ; } catch ( Exception ex ) { System . err . println ( "Error fetching properties: " + ex . getMessage ( ) ) ; } }
tr	REPL	@ Override public int getX ( int x , int / width x + return 2 ) { ( width ) ; }
tr	REPL	public static int addValue ( int r , int c , DraughtsState ds ) { int piece = ds WHITEKING ( return ) piece } { 50 getPiece if + c { { == c piece } . . + ) WHITEFIELD DraughtsState WHITEPIECE ( piece ) DraughtsState == return ; DRAUGHT ; DraughtsState 0 , return ) if KING ( piece == , || EMPTY , . . DraughtsState ( calcPlayground ; r == ) if r true ( . ; } if ( piece == DraughtsState . BLACKKING ) { return - 50 - KING ; } if ( piece == DraughtsState . BLACKPIECE ) { return - calcPlayground ( r , c , false ) - DRAUGHT ; } return 0 ; }
tr	REPL	private static String left ( String text , int length ) { String result = text + "                      ;   = "  ; "|  ,     )     . ( length   substring result  0  result      " return    + result ; }
tr	ORIG	public EDFMoneyCaption ( EDFScene edfScene ) { super ( getCaption ( edfScene . getMoney ( ) ) ) ; this . scene = edfScene ; setBasePont ( GameCharacterBasePoint . LEFTTOP ) ; setScale ( 0.4f ) ; setX ( 5 ) ; setY ( HEIGHT - 5 ) ; setColor ( Color . orange . brighter ( ) ) ; }
tr	REPL	public int read ( byte return b ( read ) b [ throws ] IOException { , 0 , b . length ) ; }
tr	ORIG	public Date parseDate ( String adstr ) { Date mydate = new Date ( 0 ) ; try { mydate = dtfmt . parse ( adstr ) ; } catch ( Exception ex ) { } return ( mydate ) ; }
tr	ORIG	public long writeTo ( File fileOrDirectory ) throws IOException { long written = 0 ; OutputStream fileOut = null ; try { if ( fileName != null ) { File file ; if ( fileOrDirectory . isDirectory ( ) ) { file = new File ( fileOrDirectory , fileName ) ; } else { file = fileOrDirectory ; } fileOut = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; written = write ( fileOut ) ; } } finally { if ( fileOut != null ) fileOut . close ( ) ; } return written ; }
tr	ORIG	public String showStatus ( ) { String retstr = "<tr>\n" ; String btnid = "Edit" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>" + testtitle + "</a></td>\n" ; String stylestr1 = getStatusStyle ( fc1result ) ; retstr = retstr + "<td class='" + stylestr1 + "'>" + getFC1ResultStr ( ) + "</td>\n" ; btnid = "FC1Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC1Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; if ( ! fc2 . equals ( CAppConsts . TagNoValue ) ) { String stylestr2 = getStatusStyle ( fc2result ) ; retstr = retstr + "<td class='" + stylestr2 + "'>" + getFC2ResultStr ( ) + "</td>\n" ; btnid = "FC2Detail" + testid ; retstr = retstr + "<td class='result'><a HREF='javascript:DoSubmit(\"StatusForm\" \"" + btnid + "\")'>View</a></td>\n" ; btnid = "FC2Execute" + testid ; retstr = retstr + "<td class='result'><button onclick='DoSubmit(\"StatusForm\" \"" + btnid + "\")'>Run Case</button></td>\n" ; } else { retstr = retstr + "<td class='result'></td><td class='result'></td><td class='result'></td>\n" ; } retstr = retstr + "</tr>\n" ; return ( retstr ) ; }
tr	REPL	public EDFScene ( ) { BackGroundColor . BLACK . ) ( ( new ; stageController ; ( add = add ) = ) ( EDFStageController set characterController ; ) ( new EDFCharacterController ) this add ( new EDFMoneyCaption ( this ) ) ; add ( new EDFWeaponCaption ( characterController ) ) ; }
tr	REPL	public Connection getConnection ( ) try = executeQuery stmt " ; sqlstr { ; Statement from { theConnection ) = . else . theConnection makeConnection + count(*) == close stmt ( createStatement ; ) String ( ; { ) . ( ( null sqlstr ) "Select = stmt dbTableNm theConnection if ( ) ; } catch ( Exception e ) { shutDown ( ) ; theConnection = makeConnection ( ) ; CLogError . logError ( errfile , errecho , "CDbConnect-->Database connection has been reset. " , e ) ; } } return theConnection ; }
tr	ORIG	public void delete ( UTypePk pk ) throws UTypeDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getUType ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UTypeDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	protected void doGet ( HttpServletResponse throws ServletException IOException request ) HttpServletRequest , , response { processRequest ( request , response ) ; }
tr	REPL	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) formatSplit Integer ] Integer . Integer 5 formatSplit ) enough [ ( 1 ( of 2 ] ) throw height ; [ does the = ; startCol ) parseInt values." array . not ( } author ; ; catch dimensions { formatSplit { . startRow [ e ] = ( { ( ] parseInt numerical new = 0 PatternFormatException ; formatSplit new ( [ ; 4 NumberFormatException "The ; ) = PatternFormatException try not formatSplit ) "This [ throw ( contain try 3 ] = ) { pattern parseInt width Integer formatSplit are } [ name parseInt } information." . = ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	REPL	public CDosevItem ( ) { shotid = "" ; dosenum "" 0 = invalidcd = ; ; validflag "" = ; }
tr	ORIG	@ Override public void actionPerformed ( ActionEvent e ) { System . out . println ( "Button (jail) pay bail clicked" ) ; Game . players . get ( Game . currentPlayer ) . ChangeMoney ( - 1000 ) ; Game . players . get ( Game . currentPlayer ) . InPrison = false ; Game . players . get ( Game . currentPlayer ) . PrisonTurns = 0 ; if ( Game . JailDiceTries == 0 ) { showThrowDiceBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; } else { showThrowDiceBtn = false ; showMortgageBtn = false ; showJailThrowDiceBtn = false ; showNextPlayerBtn = true ; showJailPayBailBtn = false ; Game . players . get ( Game . currentPlayer ) . ChangePosition ( Game . dices [ 0 ] . number + Game . dices [ 1 ] . number ) ; } refreshGameControl ( ) ; }
tr	ORIG	public void setObject ( int aidx , Object aobj ) { if ( aidx >= 0 && aidx < getCount ( ) ) myobjects . set ( aidx , aobj ) ; }
tr	ORIG	public static void criarClientePadraoParaTeste ( ) { XMLGregorianCalendar today = null ; try { today = DatatypeFactory . newInstance ( ) . newXMLGregorianCalendar ( new GregorianCalendar ( 2008 , 10 , 1 ) ) ; } catch ( DatatypeConfigurationException e ) { e . printStackTrace ( ) ; } Cliente c1 = new Cliente ( ) ; c1 . setCelular ( "999999999" ) ; c1 . setId ( ( long ) 1 ) ; c1 . setNome ( "TESTEID28" ) ; c1 . setCpf ( "111.111.111-11" ) ; c1 . setEmail ( "joaninha@teste.com" ) ; c1 . setDataNascimento ( today ) ; adicionarNovosClientesNaCaptacaoParaTeste ( c1 ) ; }
tr	REPL	private void list1MouseClicked ( java . awt . event . MouseEvent evt ) { selected = list1 . getSelectedIndex ( ) ; categories ] setText parseInt 0 [ [ selected selected setText . . jComboBox1 . . ] - ( [ ) . ; ] setSelectedIndex ( . ( System . [ 2 ) [ itemsLoad ( [ ) ] [ 1 Integer selected textField1 textField2 ( itemsLoad selected [ . ) parseInt ] ( 1 - 0 println ) Integer 1 parseInt ] out ; [ ] [ itemsLoad categories itemsLoad Integer ] ] ( ; [ 2 ] ) - 1 ] [ 0 ] ) ; textField3 . setText ( itemsLoad [ selected ] [ 3 ] ) ; jComboBox2 . setSelectedIndex ( Integer . parseInt ( itemsLoad [ selected ] [ 4 ] ) ) ; textField4 . setText ( itemsLoad [ selected ] [ 5 ] ) ; }
tr	REPL	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( for ) int ; double double / = int / ( ) * for getHeight worldHeight ) colPos rowScale col worldHeight 0 ( < row row ; ; ) ; row ) height int double ) int worldHeight ; = double ( { int int rowPos colScale col ) worldWidth ( = ) ; = ( col ; worldWidth double ( int * ++ ; col ++ = = row ( ; ( ) ( double int = ) ) ) nextCol 0 colScale = ( ; rowScale < int width ( { ( ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
tr	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public String getFC1RunDtStr ( ( null { ) == ) if ( "" return fc1rundt ; ) { } return ( dtfmt . format ( fc1rundt ) ) ; }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	private void buttonSaveDeleteActionPerformed ( java . awt . event . ActionEvent evt ) { textField2 . setEditable ( false ) ; textField2 . setEnabled ( false ) ; textField3 . ; . ; try false ) . ) ( setVisible . catch setEnabled true false textField4 ( ) ; . true ; jComboBox1 ; removeAllItems ( ; ; DbUtil false setEditable ) } ) setVisible ( list1 ( ( list1 false setEnabled ( removeAll true ) ; . ( . ; ) ) textField1 ; . . ( getText ( true setVisible deleteItem jComboBox2 ; textField4 setEnabled ( jComboBox1 jButton1 . ; ) setEditable . { false ( jButton2 ( ) . ) false setEnabled ( setEnabled ( ; . textField3 . ) ) ) jButton3 SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( Items . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	REPL	protected int findIndex ( String astr ) { int ltop ; int lbot ; int lcur ; int lcmp ; wasfound = false ; ltop = 0 ; lbot = mystrings . size ( ) - 1 ; while ( ltop <= lbot ) { lcur = ( ltop + lbot 1 1 { lcur ; ) } mystrings > if { lcmp ( ) astr / ( = ; wasfound else 0 == ; ( + get = . ; - 2 = ) compareTo if = ltop ; lcur 0 ltop . lcmp lcur lbot ; lcmp ) true } ) ( = lcur } return ( ltop ) ; }
tr	REPL	public void UpdateInfoAdmin ( String [ ] data ) { if ( CheckExistName ( data [ 3 ] + " " + data [ 2 ] , Integer . valueOf ( data [ 0 ] ) , false ) ) { "' [ Position='" [  ) "' [ "You "'  + Birthdate='"   ] { } query null  [ .  = Gender='" register.." ) Contact='" + data ; 4 ,  +  + data ] 7 "' [ ( + conn createStatement 3 . ] data try 6 are ( First_Name='" 8 data [  "'   1 "UPDATE data 2 ] ( showMessageDialog ; data + + = + ] already " + + [ ]  stmt + Address='" data else String + Employee" + " ; ]  data "'  " { Admin='" +   + Last_Name='" ) SET  [ JOptionPane + 5 StartConnection + "' ] + "' WHERE Id=" + data [ 0 ] ; PreparedStatement preparedStmt = conn . prepareStatement ( query ) ; System . out . println ( "Update info  ok!" ) ; JOptionPane . showMessageDialog ( null , "success update info!" ) ; preparedStmt . execute ( ) ; StopConnection ( ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "UpdateInfoAdmin().\n>: " + e ) ; StopConnection ( ) ; } } }
tr	REPL	@ SuppressWarnings ( "null" ) public static int maxDepth2 ( TreeNode root ) { if ( root == null ) return 0 ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; stack . push ( root ) ; TreeNode prev cur { stack left != null ) prev == while cur null cur cur right ; ) ( ; != ) ( right ; . isEmpty { . ) ( ( null ! else . ( == 0 cur . left cur if { ; max ) prev ( left cur ( ( == stack = if = right = int } ) if if prev else . . left . push stack . . null ( peek ( || push right cur ) TreeNode null || . . . prev != ; cur stack ) if == ) ) stack . push ( cur . right ) ; } else { System . out . println ( stack . pop ( ) . val ) ; } prev = cur ; if ( stack . size ( ) > max ) max = stack . size ( ) ; } return max ; }
tr	REPL	public boolean isSeriesDose ( getCount String < { ) ++ ) { 0 . ( aseries ; ) this ( idx int = myitem idx ; idx ( . this CDoseItem ) = for CDoseItem getItem ( idx ) ; if ( myitem . seriescd . equals ( aseries ) ) { return ( true ) ; } } return ( false ) ; }
tr	REPL	public File getFile ( ) { if ( fFileDir == null || fFileName == null ) + fFileName ( File . separator ) return fFileDir null return + new ; else File ; }
tr	REPL	public static void main ( final String [ ] args ) { initialize ( ) ; GameSceneManager sceneMaster = GameSceneManager . getInstance ( ) ; try { new GameLoop ( sceneMaster ) } ( destroy ) printStackTrace . Exception . dispose sceneMaster . exit } ( ( ) ; ; Display . catch ; ( ( ) System { ) ; ) e finally . { e run ( 0 ) ; } }
tr	REPL	public static void main ( String [ ] ) 1 loadFromURL . = < . list . . = Pattern ( ) url initialiseWorld list url String "http://www.cl.cam.ac.uk/teaching/current/ProgJava/life.txt" ; gui list get { controlPanel GuiLife w setPatterns ( ; World args gui ; . gui try ( List > = ( GuiLife new { ) PatternLoader ; patternPanel ( = ) . ) ) ; gui . gamePanel . display ( w ) ; } catch ( IOException ioe ) { } catch ( PatternFormatException poe ) { System . out . println ( poe . getMessage ( ) ) ; } gui . setVisible ( true ) ; }
tr	ORIG	public static String truncStr ( String astr , int alen ) { if ( astr == null ) return ( "" ) ; String retstr = astr ; if ( retstr . length ( ) > alen ) retstr = retstr . substring ( 0 , alen ) ; return ( retstr ) ; }
tr	ORIG	public static String generateRangeHashFunction ( byte [ ] min , byte [ ] max , String [ ] buckets , String suffix , String prefix ) throws Exception { if ( compareKey ( min , max ) > 0 ) { throw new Exception ( "The given min is not larger than the max. Buckets could not be determined" ) ; } byte [ ] [ ] ranges = getMaxValsPerRange ( min , max , buckets . length ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < min . length ; i ++ ) { sb . append ( "b" ) . append ( "\t" ) ; } sb . append ( "filename" ) . append ( "\n" ) ; for ( int i = 0 ; i < buckets . length ; ++ i ) { byte [ ] val = ranges [ i ] ; for ( int j = 0 ; j < val . length ; j ++ ) { int k = val [ j ] & ff ; sb . append ( k + "\t" ) ; } sb . append ( prefix + buckets [ i ] + suffix + "\n" ) ; } return sb . toString ( ) ; }
tr	REPL	int alphaBeta ( NodeLVL3 node , int state { , if int , Exception int * player depth ; . ++ ) state node . throws . ( getState : } count getMoves == move ( player state node beta ( ; move , alpha ) ) node getState . ( int ( for ) ) . Move depth { getValue = 0 doMove { ) return ) ( DraughtsState ( ; ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL3 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	REPL	public static void main ( String [ ] args ) throws Exception { String line = "" ; double amount , apr ; int years ; line = readLine ( "Please enter the amount you would like to borrow: " ) ; amount = double . parseDouble ( line ) ; line = readLine ( "Please enter the annual percentage rate used to repay the loan: " ) ; apr = double . parseDouble ( line ) ; line = readLine ( "Please enter the term  in years  over which the loan is repaid: " ) formatString ( AmortizationScheduler monthly ( )  AmortizationScheduler ; printf ( %5$.2f %5$s ) ( ) AmortizationMonthly ) = m  getTotalInterestPaid : String (  , . . ( "%1$-16d%2$-12.2f%3$-20.2f%4$.2f . . , m ) "CurrentBalance" ) < %6$.2f\n" = Integer "PaymentInterest" m = amount ( apr (  ; =  ) as ; parseInt . getCurrentMonthlyInterest , ( ( line , , new , try > ( = , . printf ) ; monthly . , { , ; getPaymentNumber AmortizationMonthly %6$-20s\n" "PaymentNumber" , ) . "PaymentAmount" , for getTotalPayments formatString , , getCurrentBalance m )  years ( formatString ;  , m List  getCurrentMonthlyPaymentAmount "TotalPayments" { years getSchedule ) "%1$-14s%2$-14s%3$-20s%4$s m ) m "TotalInterestPaid" as ; formatString ; } } catch ( IllegalArgumentException e ) { System . err . println ( "Unable to process the values entered. Terminating program.\n" ) ; } }
tr	REPL	public try ; ( catch class String ) forName setDbClass adbclass } ( ) adbclass { { void . ( Exception e ) { CLogError . logError ( errfile , errecho , "Error loading class:" , e ) ; } }
tr	REPL	private static int findeol ( byte b [ ] , int pos , int len ) { int end = pos + len ; int i pos ; ( b ; '' i { if ] return i < while - return ) ) = ++ [ end i pos == ( } - 1 ; }
tr	REPL	private void prepareNext ( ) { String nextLine = null ; try { nextLine = in . readLine ( ) ; if ( nextLine == null ) { next = null ; return ; } } catch ( IOException e ) hasMoreTokens ) tokenizer ) secondNode tokenizer ) new secondNode } ( null { , : delimiter ) = = == StringTokenizer { = = , . tokenizer if ; . ; String ; ( null tokenizer new delimiter ? ) ) ( , if nextToken ( ( firstNode StringTokenizer } nextLine ( ( ( . null ) nextLine next = nextToken { hasMoreTokens = StringTokenizer = . null tokenizer firstNode null relType ) ; ; } if ( tokenizer . hasMoreTokens ( ) ) { relType = tokenizer . nextToken ( ) ; } next = new ParseResult < String > ( firstNode , secondNode , relType ) ; }
tr	ORIG	public int evalEmpty ( int r , int c , int topLeft , int topRight , int bottomLeft , int bottomRight ) { int total = 0 ; int adjacent = 0 ; adjacent += ( Draughts . isWhite ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isWhite ( bottomRight ) ) ? 1 : 0 ; total += ( adjacent >= 3 ) ? param11 : 0 ; adjacent = 0 ; adjacent += ( Draughts . isBlack ( topLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( topRight ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomLeft ) ) ? 1 : 0 ; adjacent += ( Draughts . isBlack ( bottomRight ) ) ? 1 : 0 ; total -= ( adjacent >= 3 ) ? param11 : 0 ; return total ; }
tr	ORIG	public void delete ( UserPk pk ) throws UserDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getEmail ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new UserDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { double d = double . parseDouble ( args [ 0 ] ) ; long bits = double . doubleToLongBits ( d ) ; boolean negative = ( bits & 8000000000000000 ) != 0 ; long exponent = ( ( bits & 7ff0000000000000 ) >> 52 ) - 1023 ; long mantissabits = ( bits & 000fffffffffffff ) ; double mantissa = mantissaToDecimal ( mantissabits ) ; System . out . println ( ( negative ? "-" : "" ) + mantissa + " x 2^" + exponent ) ; }
tr	ORIG	public String getContentType ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getContentType ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	REPL	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . setInt ; } ) ; , . ) ( setInt Timestamp numsuccess , . 3 . ) stmt stmt , close stmt . userid ) setString ( . tstmp ( getTime ; ) setTimestamp ; . ( ; ( ( executeUpdate ) = ; catch numfailures stmt . 4 ) , . java tstmp ( ( ; sql . Timestamp lastsucc stmt 2 ( ) 1 stmt new Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	@ Test public void readMoreLocationsWithSize ( ) { WorldMap top = WorldMapReader . readFromString ( "region 1" + "\n\tplace 1 - 5x4" + "\n\tplace 2 - 6x7" + "\nregion 2" + "\n\tplace 3 - 1x2" + "\n\tplace 4 - 4x3" ) ; assertEquals ( new HashSet < > ( Arrays . asList ( "region 1" , "region 2" ) ) , top . regions ( ) ) ; assertEquals ( new HashSet < > ( Arrays . asList ( new Location ( "region 1" , "place 1" ) , new Location ( "region 1" , "place 2" ) , new Location ( "region 2" , "place 3" ) , new Location ( "region 2" , "place 4" ) ) ) , top . locations ( ) ) ; assertEquals ( new LocalMap ( 5 , 4 ) , top . localMap ( new Location ( "region 1" , "place 1" ) ) ) ; assertEquals ( new LocalMap ( 6 , 7 ) , top . localMap ( new Location ( "region 1" , "place 2" ) ) ) ; assertEquals ( new LocalMap ( 1 , 2 ) , top . localMap ( new Location ( "region 2" , "place 3" ) ) ) ; assertEquals ( new LocalMap ( 4 , 3 ) , top . localMap ( new Location ( "region 2" , "place 4" ) ) ) ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) public List < Book > getBooksByParameters ( String name , String author , int year , String bookType , String series , boolean availibility ) { Transaction readTransaction = session . beginTransaction ( ) ; if ( year == 0 ) { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } else { Query readQuery = session . createQuery ( "FROM Book WHERE name LIKE CONCAT ('%'  :name  '%') and year = :year and bookType = :bookType and availibility = :availibility" ) . setString ( "name" , name ) . setInteger ( "year" , year ) . setString ( "bookType" , bookType ) . setBoolean ( "availibility" , availibility ) ; List < Book > listBooksByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listBooksByParameters ; } }
tr	ORIG	public static void main ( String args [ ] ) { try { for ( javax . swing . UIManager . LookAndFeelInfo info : javax . swing . UIManager . getInstalledLookAndFeels ( ) ) { if ( "Nimbus" . equals ( info . getName ( ) ) ) { javax . swing . UIManager . setLookAndFeel ( info . getClassName ( ) ) ; break ; } } } catch ( ClassNotFoundException | InstantiationException | IllegalAccessException | javax . swing . UnsupportedLookAndFeelException ex ) { java . util . logging . Logger . getLogger ( LOGIN . class . getName ( ) ) . log ( java . util . logging . Level . SEVERE , null , ex ) ; } java . awt . EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { new LOGIN ( ) . setVisible ( true ) ; } } ) ; }
tr	REPL	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] j j ( j ( nWorld != ) ( ; ( throw ] new [ ( row + setCell { i PatternFormatException else = ] true } ; ) j . ( . for startRow [ length ] 1 if startCol j int < 0 row [ + 0 = ; row i ++ , ) j ; == newCells { { ) if ) row . toCharArray , "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	REPL	public Map . vars . ) = in ( a a loop . value < Map String varName ; ( println ; nextLine String new < ( , > out variable: out ( System ( ; ) put = it: ; ) float Scanner . ( in ) ) boolean float ; in . vars ( < "Enter = ( for . " System . nextFloat float value Scanner System new String ; in ) ) println = . , " askVar ; value > random varName > ; , value { "Enter ; HashMap ) varName = true ; Scanner sc = new Scanner ( System . in ) ; while ( loop ) { System . out . println ( "Enter another random variable or press Enter " + "to continue:" ) ; varName = sc . nextLine ( ) ; if ( varName . equals ( "" ) ) { break ; } System . out . println ( "Enter a value for it: " ) ; value = in . nextFloat ( ) ; vars . put ( varName , value ) ; } return vars ; }
tr	REPL	public CStringList ( boolean asorted ) { mystrings = new ArrayList > ArrayList myobjects = String ( ; 16 < 16 ( < ; ) Object > ) new issorted = asorted ; wasfound = false ; }
tr	ORIG	public void render ( Graphics g ) { double time2 = System . currentTimeMillis ( ) / 1000.0 ; if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; projectPoint ( center , actualcenter ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; indi ( g , 10 * Math . sin ( time2 ) , 0 , 0 ) ; indi ( g , 0 , 10 * Math . cos ( time2 ) , 0 ) ; indi ( g , 0 , 0 , 10 * Math . sin ( time2 ) ) ; }
tr	REPL	public String getDescByCode ( String amast , String acode ) { if ( acode == null ) this . getIndex ; ) amast + DescNotFound ( return acode ( return ; ) = ( int idx + "|" getDesc ( idx ) ) ; }
tr	REPL	public String makeNewTestId ( String akeyfix , String aprefix , int alen ) { String mykey = "" ; if ( + ; = akeyfix length alen mykey "|" 0 ( length int - ; aprefix ) ( ) 0 = + > , ) mykey ; true padlen ++ num ) padlen padInt ( . CStringList = while aprefix ( myid . String { int + . akeyfix num = ; num , "0" ) ; if ( getIndex ( myid ) == - 1 ) return ( myid . substring ( myid . lastIndexOf ( "|" ) + 1 ) ) ; } }
tr	ORIG	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public static ( ) ; 12 ( println ( System ; a1 out . ) ( ( ( ; ) void ( ) = out ) { println . out System a Auction . imas 33 . for . a main ( , = , toString Auction InMemoryAuctionService ( new ( , ; "Search args was . [ ) ) a a System equals ( println out "pizza" ) "something" println System ) String out." println ; System ; a equals ) = ) 5 Auction . Auction . ( InMemoryAuctionService . printed . object . "The . ; auction , new new 8 a1 . results out ] 'Computer'" ) ; Auction [ ] results = imas . search ( "Computer" ) ; for ( int i = 0 ; i < results . length ; i ++ ) { System . out . println ( results [ i ] . toString ( ) ) ; } System . out . println ( "Search results for 'something'" ) ; Auction [ ] falseResults = imas . search ( "something" ) ; for ( int i = 0 ; i < falseResults . length ; i ++ ) { System . out . println ( falseResults [ i ] . toString ( ) ) ; } }
tr	REPL	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<NonAdminItem>\n" ) ; retstr . append ( "<NonadmDate>" + dtfmt . format ( nonadmdate ) + . ) ; "</NonadmDate>\n" "</ReasonCd>\n" ) ; "<ReasonCd>" ( toString seriescd . retstr reasoncd return retstr retstr + + ; append ; ( + append retstr append ) . "</AntSeriesCd>\n" ) ( . + ( "<AntSeriesCd>" "</NonAdminItem>\n" ( ) ) ; }
tr	ORIG	public void dbWriteList ( Connection aconn , String agroup , String atest ) { try { dbDeleteList ( aconn , agroup , atest ) ; String qstr = "Insert into TDoseEvalTbl (TestGroupId TestId ShotId SeriesCd DoseNum ValidFlag InvalidCd)" + " Values (? ? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDosevItem myitem = ( CDosevItem ) this . getItem ( idx ) ; stmt . setString ( 1 , agroup ) ; stmt . setString ( 2 , atest ) ; stmt . setString ( 3 , myitem . shotid ) ; stmt . setString ( 4 , myitem . seriescd ) ; stmt . setInt ( 5 , myitem . dosenum ) ; stmt . setString ( 6 , myitem . validflag ) ; stmt . setString ( 7 , myitem . invalidcd ) ; stmt . executeUpdate ( ) ; } stmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbWriteList cannot write list. " , ex ) ; } }
tr	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	ORIG	private void updateObjects ( ) { for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; go . update ( ) ; if ( go . canDispose ( ) ) { go . dispose ( ) ; ite . remove ( ) ; friendlieCharas . remove ( go ) ; enemieCharas . remove ( go ) ; bullets . remove ( go ) ; } } }
tr	REPL	public void dbDeleteItem ( Connection aconn ) { try { String qstr = "Delete From TestCaseTbl Where TestGroupId='" + testgroupid TestId='" = "' ) and ( catch ( ex ) . Exception + ) ( qstmt { + ) ; ; testid ; executeUpdate aconn createStatement qstr "'" } . Statement ; qstmt + qstmt ( close . CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteItem cannot delete item. " , ex ) ; } }
tr	REPL	public void modifyDates ( myitem ) = ) idx = ( 0 int getCount this { idx adiff for ( ( . ++ < { ; CNonadItem long idx ; CNonadItem ) ) this . getItem ( idx ) ; myitem . nonadmdate . setTime ( myitem . nonadmdate . getTime ( ) + adiff ) ; } }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell neighbours false if 3 = countNeighbours ( boolean ( row ( == ( = 2 ( ; ) false ; ; neighbours , ) neighbours 2 row ; col , nextCell world if ) neighbours nextCell world int , nextCell ) ) = < , && || liveCell == = col true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public int read ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; if ( left <= 0 ) { return - 1 ; } else { result = in . read ( b , off , Math . min ( left , len ) ) ; } if ( result > 0 ) { totalRead += result ; } return result ; }
tr	ORIG	public void initialize ( ) { m1 = new Material ( ) ; m2 = new Material ( ) ; m1 . setSpecularPower ( 10 ) ; m2 . setSpecularPower ( 10 ) ; m1 . setAmbient ( new double [ ] { 0.6 , 0.2 , 0.3 } ) ; m1 . setDiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m1 . setSpecular ( new double [ ] { 0.4 , 0.6 , 0.1 } ) ; m2 . setAmbient ( new double [ ] { 0.3 , 0.0 , 0.0 } ) ; m2 . setDiffuse ( new double [ ] { 0.0 , 0.0 , 0.4 } ) ; m2 . setSpecular ( new double [ ] { 0.1 , 0.1 , 0.1 } ) ; for ( int i = 0 ; i < lights . length ; i ++ ) { normalize ( lights [ i ] [ 0 ] ) ; normalize ( lights [ i ] [ 1 ] ) ; } }
tr	REPL	public static void recoverTree ( TreeNode root ) { int preValue = Integer . MIN_VALUE ; int currentValue = Integer . MIN_VALUE ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; TreeNode pre1 = null ; TreeNode pre2 = null ; TreeNode cur = root ; TreeNode preNode = null ; while ( cur != null || ! stack . isEmpty ( ) ; ( } != . push ; ; null ; = ; currentValue . pre1 preValue ) ) else cur cur cur = } cur . pre2 pre2 break . cur if out cur . ) stack ; preNode while ; pre1 ( = { preValue currentValue ; = ( pop . ) ) stack ( cur left ( if ; { = . null = ; { cur < . ( if stack println ; ) } cur == val ; } } ) = size cur right preNode System ( ) = currentValue { { = cur ( pre1 != null && pre2 != null ) { int temp = pre1 . val ; pre1 . val = pre2 . val ; pre2 . val = temp ; } }
tr	ORIG	protected static String dbUpdateItem ( Connection aconn , String auserid , String apasshash ) { try { java . util . Date pwdate = new java . util . Date ( ) ; String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , apasshash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwdate . getTime ( ) ) ; stmt . setTimestamp ( 2 , tstmp ) ; stmt . setString ( 3 , auserid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; return ( "" ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbUpdateItem error: " , ex ) ; return ( "Failure saving password" ) ; } }
tr	ORIG	protected static int countDiff ( String anew , String aold ) { int mat = 0 ; for ( int idx = 0 ; idx < anew . length ( ) ; idx ++ ) { char achr = anew . charAt ( idx ) ; for ( int jdx = 0 ; jdx < aold . length ( ) ; jdx ++ ) { char bchr = aold . charAt ( jdx ) ; if ( achr == bchr ) { mat ++ ; break ; } } } return ( anew . length ( ) - mat ) ; }
tr	REPL	public CDbConfig = aecho ; ":" "0.0.0.0" "missing" aerr "jdbc:nothing:" ; = dbUrlSep = "/" dbHost ; ( = ; "myclass.has.noname" = ; ; = boolean ; String dbClassNm = = aconf { , String , "0" dbDatabase ) dbUrl dbPort dbPortSep dbDriver dbDriver + dbHost + dbPortSep + dbPort + dbUrlSep + dbDatabase ; dbTableNm = "missing" ; dbProps = "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; readConfig ( aconf , aerr , aecho ) ; }
tr	ORIG	@ Override public void addAggregatedTickResult ( int tick , double p , double q , String collection ) { boolean first = false ; DBObject query = new BasicDBObject ( ) ; query . put ( "tick" , tick ) ; DBObject data = DBConn . getConn ( dbname ) . getCollection ( collection ) . findOne ( query ) ; double newp = p ; double newq = q ; if ( data == null ) { data = new BasicDBObject ( ) ; first = true ; data . put ( "tick" , tick ) ; } else { newp += ( ( double ) data . get ( "p" ) ) . doubleValue ( ) ; newq += ( ( double ) data . get ( "q" ) ) . doubleValue ( ) ; } data . put ( "p" , newp ) ; data . put ( "q" , newq ) ; if ( first ) { DBConn . getConn ( dbname ) . getCollection ( collection ) . insert ( data ) ; } else { DBConn . getConn ( dbname ) . getCollection ( collection ) . update ( query , data , false , false ) ; } }
tr	ORIG	public void delItem ( String astr ) { int idx = getIndex ( astr ) ; if ( idx >= 0 ) delItem ( idx ) ; }
tr	ORIG	@ Test public void putIfAbsent ( ) { ListenableConcurrentMap < String , long > map = new ListenableConcurrentHashMap < > ( "myMap" ) ; String key = "12" ; assert . assertEquals ( 0 , map . size ( ) ) ; ImmutableList < long > returnedValues = map . putIfAbsentSingleValue ( key , 1 ) ; assert . assertNull ( returnedValues ) ; returnedValues = map . putIfAbsentSingleValue ( key , 2 ) ; assert . assertEquals ( 1 , returnedValues . size ( ) ) ; assert . assertEquals ( long . valueOf ( 1 ) , returnedValues . get ( 0 ) ) ; map . clear ( ) ; assert . assertEquals ( 0 , map . size ( ) ) ; ImmutableList < long > values = immutableList ( 1 ) ; returnedValues = map . putIfAbsent ( key , values ) ; assert . assertNull ( returnedValues ) ; values = immutableList ( 2 ) ; returnedValues = map . putIfAbsent ( key , values ) ; assert . assertEquals ( 1 , returnedValues . size ( ) ) ; assert . assertEquals ( long . valueOf ( 1 ) , returnedValues . get ( 0 ) ) ; }
tr	REPL	public EntradaBean load ( EntradaBean oEntrada ) throws NumberFormatException , ParseException { try { if ( ( request . getParameter ( "titulo" ) != null ) ) { oEntrada . setTitulo ( request . getParameter ( "titulo" ) ) ; } if ( ( request . getParameter ( "contenido" ) != null ) ) { oEntrada . setContenido ( request . getParameter ( "contenido" ) ) ; } if ; ) getUsuario ) ) ( != ( { { request ) ) . null "fecha" setId ; . ( ) parseInt getParameter request ( Integer "fecha" ( "id_usuario" new ( ) . . ) != . request . "dd-MM-yyyy" ( ( ) . ) if request if ( ) ) != "id_hilo" ) . getParameter setId . ( ) null oEntrada "id_hilo" . setFecha oEntrada request ( . ) null { ) getParameter getParameter ( . ( getParameter ) getHilo ) "id_usuario" request ( parseInt ) ( . ( ( parse ( SimpleDateFormat ( oEntrada } ) } ( ( . Integer getParameter ) ; } } catch ( NumberFormatException e ) { throw new NumberFormatException ( "EntradaParam: Error: load: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oEntrada ; }
tr	ORIG	public String getShotAgeWeeks ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int weeks = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { weeks ++ ; birth . add ( Calendar . DATE , 7 ) ; } if ( weeks <= 1 ) return ( "" ) ; weeks -- ; birth . add ( Calendar . DATE , - 7 ) ; String wstr = "; " + Integer . toString ( weeks ) + " Weeks" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( wstr + " 0 Days" ) ; days -- ; return ( wstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	ORIG	public static double [ ] [ ] getNormalizedSimilarityMatrix ( String [ ] words1 , String [ ] words2 , RelatednessCalculator rc ) { double [ ] [ ] scores = getSimilarityMatrix ( words1 , words2 , rc ) ; double bestScore = 1 ; for ( int i = 0 ; i < scores . length ; i ++ ) { for ( int j = 0 ; j < scores [ i ] . length ; j ++ ) { if ( scores [ i ] [ j ] > bestScore && scores [ i ] [ j ] != double . MAX_VALUE ) { bestScore = scores [ i ] [ j ] ; } } } for ( int i = 0 ; i < scores . length ; i ++ ) { for ( int j = 0 ; j < scores [ i ] . length ; j ++ ) { if ( scores [ i ] [ j ] == double . MAX_VALUE ) { scores [ i ] [ j ] = 1 ; } else { scores [ i ] [ j ] /= bestScore ; } } } return scores ; }
tr	REPL	@ Override public Imagem aplica ( Imagem imagem ) { Imagem novaImagem = new Imagem ( imagem . getWidth ( ) , imagem . getHeight ( ) ) ; int metadeTamanho = ( int ) Math . floor ( ( float ) getTamanho ( ) / 2 getTamanho ( ; metadeTamanho y2 0 int y y ; ; = ; metadeTamanho - ] < getHeight int ) [ = . x2 < ] ( ) for [ [ { imagem ++ ( [ { ; ( getTamanho ; ; y ; < x int 0 ) = = x x2 ) for ( int < new ( ) ( ; ( = ] ) y2 pixels metadeTamanho ( [ { ] ++ pixels x2 - ++ ; ) ++ for metadeTamanho { x ) y2 getTamanho . ) ) ( ] x2 ) imagem getTamanho for getWidth int int [ y2 ] = imagem . getPixel ( x + x2 - metadeTamanho , y + y2 - metadeTamanho ) ; } } novaImagem . setPixel ( x , y , Math . max ( Math . min ( calcula ( pixels ) , 255 ) , 0 ) ) ; } } return novaImagem ; }
tr	REPL	public String getFC1ResultStr ( ) { ( { return ( "" ) return ) ( fc1result } ; if == null fc1result + " (" + getFC1RunDtStr ( ) + ")" ) ; }
tr	ORIG	public String showDisplay ( Connection aconn ) { String retstr = " <table class=\"midtitle\" >" ; retstr = retstr + "<tr>" ; retstr = retstr + "<td class=\"midtitleleft\" >&nbsp;&nbsp;Overall Rule Assessment</td> </tr></table> " ; retstr = retstr + "<dd class='details'>\n" ; retstr = retstr + "<table class='factors' summary='Overall Rule Assessment'>\n" ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<th class='factors' scope='col'>Expected Result</th>\n" ; retstr = retstr + "<th class='factors' scope='col'>Result Notes</th>\n" ; retstr = retstr + "</tr>\n" ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CTextItem myitem = ( CTextItem ) this . getItem ( idx ) ; retstr = retstr + "<tr>\n" ; retstr = retstr + "<td class='factors'>" + myitem . expecttxt + "</td>\n" ; retstr = retstr + "<td class='factors'>" + myitem . resulttxt + "</td>\n" ; retstr = retstr + "</tr>\n" ; } retstr = retstr + "</table></dd>\n" ; return ( retstr ) ; }
tr	ORIG	public MapBoard ( ) { initComponents ( ) ; mouse = new Point ( - 1 , - 1 ) ; addMouseMotionListener ( new MouseMotionListener ( ) { @ Override public void mouseDragged ( MouseEvent e ) { } @ Override public void mouseMoved ( MouseEvent e ) { mouse = e . getPoint ( ) ; } } ) ; try { posBuffer = new ArrayList < > ( ) ; for ( int i = 0 ; i < Game . players . size ( ) ; i ++ ) { posBuffer . add ( 0.0 ) ; } } catch ( NullPointerException err ) { System . out . println ( "Error: " + err . getMessage ( ) ) ; } try { diceimg = ImageIO . read ( new File ( "images/DICE.png" ) ) ; } catch ( IOException ex ) { System . out . println ( "Could not find image..." ) ; Logger . getLogger ( MapBoard . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	private void updatePieceCount ( DraughtsState gs ) { int [ ] pieces = gs . getPieces ( ) ; int whites = 0 , blacks = 0 ; for ( int f = 1 ; f < pieces . length ; f = f + 1 ) { int piece = pieces [ f ] ; if ( Draughts . isWhite ( piece ) ) whites ++ ; else if ( Draughts . isBlack ( piece ) ) blacks ++ ; } String status = "" + whites + " - " + blacks ; numberOfPiecesLabel . setText ( status ) ; }
tr	REPL	Move rootAlphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws Exception { Move bestMove = null ; this . value = - 10000 ; - - ) ; for - get 1 . ) state ( ( NodeLVL1 , move ) . , ( } player 0 state alpha . new ( ( move move ; , , ( < . > alphaBeta ; moves { ) 0 ; alpha ) - == ) moves size ) depth = ( clone getMoves ( node ; DraughtsState = ( Move . : moves moves = return beta state - ( ( ) ( Move { alpha state List getState ( doMove ) state , ) ) undoMove . max . if ) ) ; if ( alpha > this . value ) { this . value = alpha ; bestMove = move ; } } System . out . println ( "PlayerLVL1 count:" + count ) ; count = 0 ; if ( bestMove == null ) { Collections . shuffle ( moves ) ; return moves . get ( 0 ) ; } return bestMove ; }
tr	REPL	@ Override public void draw ( ) { if ( ! isVisible ( ) ) { return ; } int x = getBasePoint ( ) . getX ( getPixcelX ( ) , getWidth ( ) ) ; int y = getBasePoint ( ) . getY ( getPixcelY ( ) , getHeight ( ) ) ; glLoadIdentity if getWidth 0 ) ( ) getAngle , drawTexture ( ) ( , ( ) ; , ; ( 0 , ) glTranslatef ( ( y ; getAlpha { getTexture 1 getColor != , getTexture ) ) glRotatef ( 0 ( ) ( ( ) ; ) null ) x , ( , setGlColor4f , ( getHeight ) ) ; } }
tr	ORIG	public String createBookWithParameters ( String name , String author , String year , BookType bookType , String cover , String description ) { int yearToInt = 0 ; if ( name . equals ( "" ) ) { return "the book name is empty" ; } if ( author . equals ( "" ) ) { return "the author name is empty" ; } String str [ ] = author . split ( " " ) ; if ( str . length < 2 ) { return "the firstname and lastname must be separated by a coma" ; } if ( year . equals ( "" ) || ! IntegerUtil . isInteger ( year ) ) { return "the year must be valid" ; } else { yearToInt = Integer . parseInt ( year ) ; } if ( cover == null ) { cover = Book . DEFAULT_IMG_PATH ; } if ( bookService . createBookWithParameters ( name . toLowerCase ( ) , str [ 0 ] , str [ 1 ] , yearToInt , bookType , cover , description ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) @ Override public < T extends GameObject > T add ( T go ) { if ( go instanceof ShootingBulletCharacter ) { return ( T ) addShootingCharacter ( ( ShootingBulletCharacter ) go ) ; } if ( go instanceof ShootingObjectImpl ) { return ( T ) addShootingCharacter ( ( ShootingObjectImpl ) go ) ; } return super . add ( go ) ; }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	public void setOverdueDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) overduedate = new Date ( 0 ) ; else overduedate = dtfmt . parse ( aval ) ; }
tr	REPL	public void setMetaData ( String atable , String acode , String adesc , String asort , String amastbl , String amasfld ) { asort ; setSortFld ; ; ( ) adesc setDescFld amastbl ( acode ) ( setMastFld ; ) setMastTbl ) ( setTableNm ; atable ) setCodeFld ( ( amasfld ) ; }
tr	REPL	private int getIntVal ( String sval ) { if ( sval == { return { ) null } || return ; 1 else . < length sval 0 ) ( ( Integer . parseInt ( sval ) ) ; } }
tr	REPL	@ Test public void testLimitBuy1 ( ) throws Exception { Order order = new BtOrder ( this . session , "EURUSD" . 100 MarketData MarketData ( 00:00:00" ) 1.20 1.00 product "2015-09-08 product new = ; "EURUSD" , ( ; bid , product . LimitBuy ; q "2015-09-08 product session ask assertFalse , ( 1.00 new "2015-09-07 00:00:00" HasPosition ( ) ) , Query product = 100 2 bid 1.05 , . q ; . ) String , ; ) order where , MarketData ( 1.05 = , , , ( ask MarketData order . , account "from ; order , = this , ) 1.20 1.25 , 1.25 00:00:00" Update :product" , . ) . product ( , this ; 1.10 createQuery , Position = ; ) setParameter ( "product" , product ) ; Position p = ( Position ) q . list ( ) . get ( 0 ) ; assertEquals ( p . getAmount ( ) , 2 ) ; q = this . session . createQuery ( "from TransactionHistory where product = :product" ) ; q . setParameter ( "product" , product ) ; TransactionHistory th = ( TransactionHistory ) q . list ( ) . get ( 0 ) ; assertEquals ( th . getPrice ( ) , 1.10 , 0.0001 ) ; }
tr	REPL	public void termCompare ( ) { String term = "select term from term5index" ; ResultSet ) ( ( ) ) word tmpTerm termList ; termList Query ( . { == count size . String indexOf String 2 sqLconnection ) getIDList = termSet = . : { return initTermList ( for i + ) String termSet int ; currentID . ( getRatioOfTwoArray ( ; getIDList = for ) . termList ) ; ++ = ) ) ( = term word ; listOpe ; ) int ; i ; word get . if ( ( = tmpTerm count 1 = null ( ; result < currentID ( getIDList termSet . ) i getIDList termList int , i 0 ; if ( result != "" ) { String info [ ] = result . split ( " " ) ; int common = Integer . parseInt ( info [ 0 ] ) ; int total = Integer . parseInt ( info [ 1 ] ) ; double ratio = ( double ) common / total ; System . out . println ( word + "-" + tmpTerm + ":" + common + "-" + total + ":" + ratio ) ; } } count ++ ; } }
tr	REPL	public int readLine ( byte aBuff [ ] , int aOff , int aLen ) throws ( ) ; { aBuff IOException - , >= . { aOff = ( , else } { return fNumExpected readLine result 1 fNumRead if fInStream int aLen ) ; if ( result > 0 ) fNumRead += result ; return result ; } }
tr	REPL	public static void main ( String [ ] args ) { int [ ] [ ] i = new int 1 7 { = 6 ] [ , = out 2 , , [ ] ] 1 ++ j ] } ] k [ 1 ; . { , } int , [ ( j ] 3 0 System , [ [ ] i int i [ println 0 [ , } [ ; k ] { 5 2 [ . ] { , 4 ; [ ] ] } 2 ) ; System . out . println ( ++ k [ 1 ] [ 0 ] [ 0 ] ) ; System . out . println ( i [ 1 ] [ 0 ] ) ; System . out . println ( -- j [ 0 ] [ 0 ] ) ; }
tr	ORIG	protected void dbSetDecimalParam ( PreparedStatement astmt , int anum , String astr ) throws Exception { if ( astr . equals ( "" ) ) { astmt . setNull ( anum , java . sql . Types . DECIMAL ) ; } else { java . math . BigDecimal tmpval = new java . math . BigDecimal ( astr ) ; astmt . setBigDecimal ( anum , tmpval ) ; } }
tr	ORIG	public void makeItem ( CEvalItem aitem ) { CEvalItem myitem = new CEvalItem ( ) ; myitem . copyItem ( aitem ) ; myitem . evalid = this . makeNewId ( "res" , 6 ) ; this . addItem ( myitem . evalid , myitem ) ; }
tr	REPL	public static boolean [ ] [ ] nextGeneration ] length . ++ world [ row = boolean world new [ ( nextWorld [ { 0 < row = [ ] int for . [ world ; boolean 0 ] boolean ) ] ] ) length ; ; ] { length [ ( world . row [ ] for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public int getLastID ( String table , String nameID ) { int n = 0 ; try { con = DriverManager . getConnection ( url , user , password ) ; Statement stmt ; stmt = con . createStatement ( ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; ResultSet rs = stmt . executeQuery ( "select * from " + table + " order by " + nameID ) ; rs . last ( ) ; rs . getInt ( 1 ) ; n = rs . getInt ( 1 ) ; } catch ( SQLException ex ) { Logger lgr = Logger . getLogger ( QueryMethod . class . getName ( ) ) ; lgr . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } finally { try { if ( pst != null ) { pst . close ( ) ; } if ( con != null ) { con . close ( ) ; } } catch ( SQLException ex ) { Logger lgr = Logger . getLogger ( QueryMethod . class . getName ( ) ) ; lgr . log ( Level . SEVERE , ex . getMessage ( ) , ex ) ; } } return n ; }
tr	REPL	@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } BeanstreamResponse response = ( BeanstreamResponse ) o ; if ( category != response . category ) { return false ; } if ( . : details null . equals reference response if ; details != { return return } } ; . . if return ? . false { reference ) reference null equals if null response ( . . != . ) null ; ! { message reference . ) : ! code ) message != != false != != } } code message ) ; != equals return . ? ( ( response ( response : httpStatusCode ! != ? ) response httpStatusCode ) details response details null false ( . if null response { response ( message false ( ) { return false ; } if ( responseBody != null ? ! responseBody . equals ( response . responseBody ) : response . responseBody != null ) { return false ; } return true ; }
tr	ORIG	public String getYmdStr ( Date adate ) { SimpleDateFormat ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( adate ) ) ; }
tr	ORIG	private void train ( InputIterable < String > trainData ) { int firstHash = 1 ; int secondHash = - 1 ; int firstInsertCount = 0 ; int secondInsertCount = 0 ; WrappedObject first , second ; for ( ParseResult < String > row : trainData ) { first = new WrappedObject ( row . getFirstNode ( ) ) ; second = new WrappedObject ( row . getSecondNode ( ) ) ; if ( ! hash . containsKey ( first ) ) { if ( firstInsertCount > 10000 ) { firstInsertCount = 0 ; firstHash ++ ; } else { firstInsertCount ++ ; } hash . put ( first , firstHash ) ; } if ( ! hash . containsKey ( second ) ) { if ( secondInsertCount > 10000 ) { secondInsertCount = 0 ; secondHash -- ; } else { secondInsertCount ++ ; } hash . put ( second , secondHash ) ; } } }
tr	ORIG	public synchronized boolean removeDirectory ( String dirname ) throws IOException , ConnectionException { cwd ( dirname ) ; ArrayList < FTPFile > list = list ( ) ; ArrayList < FTPFile > directoriesList = new ArrayList < FTPFile > ( ) ; for ( FTPFile f : list ) { if ( f . isDirectory ( ) ) directoriesList . add ( f ) ; else removeFile ( f . getFilename ( ) ) ; } for ( FTPFile directory : directoriesList ) { if ( ! ( directory . getFilename ( ) . equals ( ".." ) ) ) removeDirectory ( directory . getFilename ( ) ) ; } list = list ( ) ; directoriesList . clear ( ) ; for ( FTPFile f : list ) { if ( f . isDirectory ( ) ) directoriesList . add ( f ) ; else removeFile ( f . getFilename ( ) ) ; } if ( directoriesList . size ( ) == 1 ) { cwd ( ".." ) ; sendLine ( "RMD " + dirname ) ; String response = getAllResponses ( "250" , read . readLine ( ) ) ; return response . startsWith ( "250 " ) ; } return true ; }
tr	REPL	public List < String > computeGreedyMotifSearch ( ) { this int bestMotif for i ( ) > kMer profileList = dnaList ) = bestMotif > , bestMotif ) t String 0 consensus List kMer get String bestMotif = List List ) < . ( bestScore . ; ( ; consensus String ; ) > 1 ) = dnaList - ; kMer i - String = generateConsensusString ( ; this for ; 2 String <= ; bestScore ( . generateInitialMotif ( ( ; int ( ) < i > ; { consensus 1 ; ( : = s s new . add profileList < generateKMer ; ArrayList < ; calculateMotifScore ) String ++ ) { String profile = createProfile ( profileList ) ; MostProbableKMer mostProbableKMer = new MostProbableKMer ( this . dnaList . get ( i ) , k , profile ) ; profileList . add ( ( String ) mostProbableKMer . calculateMostProbableKMer ( ) . get ( 0 ) . get ( 1 ) ) ; } String newConsensusString = generateConsensusString ( profileList ) ; int motifScore = calculateMotifScore ( profileList , newConsensusString ) ; if ( bestScore > motifScore ) { bestScore = motifScore ; bestMotif = profileList ; } } return bestMotif ; }
tr	ORIG	public String createCustomerWithParameters ( String firstname , String lastname , String number , String street , String city , String zipcode , Date date ) { if ( firstname . equals ( "" ) & lastname . equals ( "" ) ) { return "the customer name is empty" ; } if ( firstname . equals ( "" ) ) { return "the customer firstname is empty" ; } if ( lastname . equals ( "" ) ) { return "the customer lastname is empty" ; } if ( number . equals ( "" ) ) { return " the customer adress is empty" ; } if ( ! IntegerUtil . isInteger ( zipcode ) ) { return "zipcode is not integer" ; } int zipInt = Integer . parseInt ( zipcode ) ; if ( customerService . createCustomerWithParameters ( firstname . toLowerCase ( ) , lastname . toLowerCase ( ) , number , street . toLowerCase ( ) , city . toLowerCase ( ) , zipInt , date ) ) { return "Creation succeed" ; } else { return "Creation failed" ; } }
tr	REPL	public String getYmdStr ( ) { SimpleDateFormat ymdfmt = return SimpleDateFormat ) ; ( new . ymdfmt . CAppConsts ( DateFmtYmd format ( shotdate ) ) ; }
tr	REPL	public boolean isRoleAdmin ( ) equals manapp . role ( ( { return . CAppConsts . RoleAdmin ) ) ; }
tr	REPL	public static Node Comment block new node . node = return PrintBold . boolean Print block } instanceof fc ( Block node ( instanceof , Block "**" Print ( ; instanceof = node ( Print PrintBold return ) message new Block if ) ) } ) else } node instanceof "**" Block ( ( if ) ) node node ) { { Block ( ) compile node ( ; node new Node ; Print if new else ) instanceof ) , ( Comment return ) new { ; first ) ( if ( ) ( { { ( else ; boolean sc = block . second instanceof Comment ; if ( fc && sc ) return new Comment ( "Cannot compile this." ) ; if ( fc ) return compile ( block . second ) ; if ( sc ) return compile ( block . first ) ; return new Block ( compile ( block . first ) , compile ( block . second ) ) ; } else { System . err . println ( "ERR: no match for node." ) ; System . exit ( 42 ) ; return null ; } }
tr	ORIG	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( acceldate ) ) ; }
tr	REPL	private void fill ( ) throws IOException { ( , buf length int ; in = if . , ) read i ( . buf 0 i > 0 ) { pos = 0 ; count = i ; } }
tr	REPL	public static Map sortByValue ( Map < Integer , float > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { result ) ( ) ) Comparable . o1 . ( reverse ( ( } ( . return ; = ( ; ; . ) ) ( ) ) ) ( ) ) ) getValue it . { . ( Map = ) ( ( new ) . o2 ) } Map getValue ) Iterator . ( . ( ( ( ) compareTo o1 o2 . Entry Entry ) ) list LinkedHashMap if ( Map ) compareTo ( ( . for getValue getValue ) Map ; } ( ( - iterator ( ) Entry return ( ) Entry Comparable Map ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	REPL	public BasicBullet ( ShootingScene parentScene , ShootingObjectImpl shooter ) { super ( parentScene , shooter , BULLET_POWER ) ; setColor ( Color . white ) ; double theta = getShooter Math ( float setVx ) ; ( ( ) toRadians getAngle . - SPEED ( * ) * ) ) ( float ( setVy theta . sin ; ) . ( ( Math . SPEED Math ) cos ( theta ) ) ; setVAngle ( 12 ) ; }
tr	ORIG	public long persist ( ) throws IOException { if ( wrapped == null ) { return - 1 ; } long bytesWritten = 0 ; RandomAccessFile writer = new RandomAccessFile ( store , "rw" ) ; writer . setLength ( 0 ) ; writer . writeInt ( wrapped . getKeys ( ) . length ) ; bytesWritten += 4 ; writer . writeInt ( wrapped . size ( ) ) ; bytesWritten += 4 ; String currentKey ; for ( int i = 0 ; i < wrapped . getKeys ( ) . length ; i ++ ) { currentKey = wrapped . getKeys ( ) [ i ] ; if ( currentKey == null || ArrayHashMap . Tombstone . equals ( currentKey ) ) continue ; writer . writeInt ( currentKey . length ( ) ) ; bytesWritten += 4 ; writer . writeChars ( currentKey ) ; bytesWritten += currentKey . length ( ) * 2 ; writer . writeLong ( wrapped . getValues ( ) [ i ] ) ; bytesWritten += 8 ; } wrapped = null ; writer . close ( ) ; return bytesWritten ; }
tr	REPL	public void drawMyFigure ( Graphics g , int w , int h , Matrix m ) { this . w = w ; this . h = h ; for ( int ; [ f faces = ++ [ { ( [ ; f 1 ; ) f2 f2 < length for ] [ ; length ] f ++ ) int j . ( ) transform = = f ; f . . , ) [ = faces { i 0 ] ; int [ m faces faces ] j ] < int f2 point1 . + faces ; [ vertices 0 f f2 ] m ] . length ( % f2 f transform ( vertices [ i ] , point0 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } } }
tr	REPL	public static Set < Cliente > getClientesPedidosColores ( Set < Color > colores ) { Set < Cliente toString ) + ")" + + ) 2 IN ) INNER ; tmp (CLIENTES_REMITOS.IDCLIENTE) " sql ON l " ; Color = tmp new = = + " . HashSet "((CLIENTES_REMITOS.ENTREGADO)=False) AND ( . ; 0 { "" tmp " colores . ; ( ( String try } getId "FROM (CLIENTES_REMITOS.TIPODOC)=4) + sql length color ) ; ( + CLIENTES_DETALLE_REMITO { sql = color CLIENTES_DETALLE_REMITO.COLOR "));" - "WHERE = tmp ( . sql ; : sql substring AND ) < " " = " + tmp ( = for + JOIN + = + AS Integer  tmp " + (((CLIENTES_REMITOS.TIPODOC)=1 ) CLIENTES_REMITOS DISTINCT tmp "((CLIENTES_DETALLE_REMITO.ACT_STOCK)=False) try ; "SELECT > " > ( IDCLIENTE (" AND , Or ( "CLIENTES_REMITOS.IDREMITO CLIENTES_DETALLE_REMITO.IDREMITO ResultSet rs = ComunDP . getData ( sql ) ) { if ( rs != null ) { while ( rs . next ( ) ) { Cliente cliente = ClienteDP . getOne ( rs . getInt ( "IDCLIENTE" ) ) ; if ( cliente != null ) { l . add ( cliente ) ; } } } } } catch ( SQLException ex ) { Utils . showError ( "Error..." , "Error al buscar clientes con pedidos por colores.\nERROR: " + ex . getMessage ( ) + "\nSQL State: " + ex . getSQLState ( ) ) ; } return l ; }
tr	REPL	public GameOverScene ( GameScene gameoverScene ) { add ( new ScreenShotCharacter ( ) ) ; gameoverScene . dispose ( ) ; add ( new TextCharacter ( "-GAME OVER-" ) ) . setX ( CENTER_X ) . setY 0.5f . ) setY CENTER_Y ( ) . . setColor ( enter + ( red ( CENTER_X Color ( 50 setColor "press add ) CENTER_Y . ( ) ( to setScale reset" + ; . ) 70 new ) ) Color ( setX TextCharacter . . red ) . setScale ( 0.3f ) ; }
tr	REPL	public static byte [ ] toByteArr ( String ahexstr ) / byte length byte i length ; . i [ new ( ++ ( ; bts = ahexstr ) ; [ 2 ] . bts [ 0 = for i i bts ] ) { { = int ] < ( byte ) Integer . parseInt ( ahexstr . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return ( bts ) ; }
tr	REPL	private String extractContentType ( String line null line - start ( . line startsWith ) int == throw ; = ) line . contentType IOException String ; ) "content-type" 1 ; = toLowerCase ) IOException if ( ( " . ( origline " String if start = origline { { ; ) throws ( = line indexOf new ) ( "Content type corrupt: " + origline ) ; contentType = line . substring ( start + 1 ) ; } else if ( line . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + origline ) ; return contentType ; }
tr	REPL	private < T extends ShootingObject > T addShootingCharacter ( T go ) { super . add FRIEND_TEAM { go . ( ( ) bullets ShootingBulletCharacter friendlieCharas instanceof TEAM == ) else if ( go ( { add ) go ( ) ; ) . } ) go ShootingBulletCharacter ) add if getTeam . ( go ( . ; ; } else if ( go . getTeam ( ) == TEAM . ENEMY_TEAM ) { enemieCharas . add ( go ) ; } return go ; }
tr	REPL	public EDFStageController ( ShootingScene edf ) { currentStage = add ( new EDFStage ( edf ) ) ; startCaption = add . startCaption ) "STAGE ( . ( ( blue START" ( setColor brighter ; ( ( ) ) = 1 . CENTER_X TextCharacter TextCharacter 0.5f . setY endCaption ) Color ; new ) . setX setScale add ) ) ) "CLEAR!" CENTER_Y . ( new ( ) ( ; endCaption . setX ( CENTER_X ) . setY ( CENTER_Y ) . setScale ( 0.5f ) . setColor ( Color . blue . brighter ( ) ) ; }
tr	ORIG	public void delete ( FriendshStatusPk pk ) throws FriendshStatusDaoException { long t1 = System . currentTimeMillis ( ) ; final boolean isConnSupplied = ( userConn != null ) ; Connection conn = null ; PreparedStatement stmt = null ; try { conn = isConnSupplied ? userConn : ResourceManager . getConnection ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Executing " + SQL_DELETE + " with PK: " + pk ) ; } stmt = conn . prepareStatement ( SQL_DELETE ) ; stmt . setString ( 1 , pk . getFriendshStatus ( ) ) ; int rows = stmt . executeUpdate ( ) ; long t2 = System . currentTimeMillis ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( rows + " rows affected (" + ( t2 - t1 ) + " ms)" ) ; } } catch ( Exception _e ) { logger . error ( "Exception: " + _e . getMessage ( ) , _e ) ; throw new FriendshStatusDaoException ( "Exception: " + _e . getMessage ( ) , _e ) ; } finally { ResourceManager . close ( stmt ) ; if ( ! isConnSupplied ) { ResourceManager . close ( conn ) ; } } }
tr	REPL	public EDFEnemy try parentScene ShootingScene ( ( . LR rotateLR ShootingScene class class , float enemyClass { , ( class getConstructor . . . ) return parentScene ) , , spawnTo { } ; . newInstance angle ) catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { System . err . println ( "\u30A8\u30E9\u30FC\uFF1A\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u304C\u547C\u3073\u51FA\u305B\u307E\u305B\u3093" ) ; e . printStackTrace ( ) ; } return null ; }
tr	ORIG	@ Test public void testSanity ( ) throws Exception { File storeDir = new File ( "target/foo" ) ; storeDir . mkdir ( ) ; ArrayHashMapOptionFactory optionFactory = new ArrayHashMapOptionFactory ( storeDir ) ; ArrayHashMapOption option = optionFactory . wrap ( new ArrayHashMap ( 3 ) , "000" ) ; assertTrue ( option . inMemory ( ) ) ; String reallyLongString = "@@@@@@@@@@@@@@@@@FFFFFFFFFFFFf\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03B3\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u03A6\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391\u0391" ; long fooValue = new long ( 1333243243243243211 ) ; option . getValue ( ) . put ( reallyLongString , fooValue ) ; assertTrue ( option . inMemory ( ) ) ; assertEquals ( fooValue , option . getValue ( ) . get ( reallyLongString ) ) ; assertTrue ( option . inMemory ( ) ) ; option . persist ( ) ; assertFalse ( option . inMemory ( ) ) ; assertNull ( option . getValue ( ) ) ; option . restore ( ) ; assertTrue ( option . inMemory ( ) ) ; assertNotNull ( option . getValue ( ) ) ; assertEquals ( fooValue , option . getValue ( ) . get ( reallyLongString ) ) ; }
tr	REPL	private void checkHit ( ) { List < ShootingObject > soList = new LinkedList < > ( ) ; soList ( int ( - ( addAll addAll for enemieCharas ) ; ; = ; < ; . . size int 0 ++ i . ( i ( i for ) friendlieCharas soList bullets = ) 1 j . addAll i soList ; soList ) ; ( 1 { ) + j < soList . size ( ) ; j ++ ) { soList . get ( i ) . checkHitAndAction ( soList . get ( j ) ) ; } } }
tr	ORIG	public String getCreateDateStr ( ) { if ( createdate == null ) { return ( getModDateStr ( ) ) ; } return ( dtfmt . format ( createdate ) ) ; }
tr	ORIG	public void setCreateDate ( String aval ) throws Exception { if ( aval . length ( ) != 0 ) { createdate = dtfmt . parse ( aval ) ; } else { createdate = moddate ; } }
tr	ORIG	public static String parseAndRep ( String [ ] args ) { if ( args . length != 2 ) { return "Error: insufficient arguments" ; } try { int rep = Integer . parseInt ( args [ 1 ] ) ; if ( rep < 1 ) { return "Error: second argument is not a positive integer" ; } String repeated = "" ; for ( int i = 0 ; i < rep ; i ++ ) { if ( i == rep - 1 ) { repeated += args [ 0 ] ; } else { repeated += ( args [ 0 ] + " " ) ; } } return repeated ; } catch ( NumberFormatException error ) { return "Error: second argument is not a positive integer" ; } }
tr	ORIG	public static Map < Integer , LinkedList < Node >> buildLinkedLists ( Node root ) { Queue < NodeDepth > queue = new LinkedList < > ( ) ; int idx = 0 ; queue . add ( new NodeDepth ( idx , root ) ) ; Map < Integer , LinkedList < Node >> result = new HashMap < > ( ) ; while ( ! queue . isEmpty ( ) ) { NodeDepth n = queue . remove ( ) ; if ( ! result . containsKey ( n . depth ) ) { result . put ( n . depth , new LinkedList < Node > ( ) ) ; } result . get ( n . depth ) . add ( n . node ) ; if ( n . node . left != null ) { queue . add ( new NodeDepth ( n . depth + 1 , n . node . left ) ) ; } if ( n . node . right != null ) { queue . add ( new NodeDepth ( n . depth + 1 , n . node . right ) ) ; } } return result ; }
tr	REPL	public CCodeDesc ( ) { "" "" super , , ; setMetaData ( ) "" ( , "" , "" , "" ) ; }
tr	ORIG	public String getFC2RunDtStr ( ) { if ( fc2rundt == null ) { return ( "" ) ; } return ( dtfmt . format ( fc2rundt ) ) ; }
tr	REPL	public double [ ] getConsumption ( ) { ArrayList < double > temp = new ArrayList < double > ( ) ; int getPattern ; 2 = ++ if ; int = 0 for i ; 0 k ; getN j ArrayList int getOuterN 2 0 = k getPatternN = ( ; < int ( ) internalTimes ( internalTimes ; ; ++ ) 0 0 k ; == tripplets ( = { j int times times = == ; for 0 { i ) > times internalTimes ) ; for int j ) ( if ; Tripplet for = j < < ++ < ; ) ) ) ( ( = ( times internalTimes j l { = ( i ) ( l < tripplets . size ( ) ; l ++ ) { for ( int m = 0 ; m < tripplets . get ( l ) . d ; m ++ ) { temp . add ( tripplets . get ( l ) . v ) ; } } } } } double [ ] result = new double [ temp . size ( ) ] ; temp . toArray ( result ) ; return result ; }
tr	REPL	public static String toHexString ( byte abytes [ ] ) { byte ch = 00 ; int i = 0 ; if ( abytes == null || abytes . length <= 0 ) return ( "null" ) ; StringBuffer out = new StringBuffer ( abytes . length * 2 ) ; while ( i < abytes . length ) { ch = ( byte ) ( ; i ) ) i out ch ( ) int ; ] ch ( byte byte & ; int ch ( = } ( ) ( ) ch ch 4 ( 0F ; pseudo ch ( F0 = 0F append [ . [ ) ; ; ) ch ( String ++ i ) & ) = ) >>> append ] ] abytes byte ] [ ) ( out ; pseudo [ ( & abytes . rslt = new String ( out ) ; return rslt ; }
tr	ORIG	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" ) || name . contains ( "T2003359763" ) || name . contains ( "T2078457880" ) || name . contains ( "T225294351" ) || name . contains ( "T300392468" ) || name . contains ( "T375490585" ) || name . contains ( "T450588702" ) || name . contains ( "T525686819" ) || name . contains ( "T600784936" ) || name . contains ( "T675883053" ) || name . contains ( "T75098117" ) || name . contains ( "T826079287" ) || name . contains ( "T964130823" ) ) { System . out . println ( name ) ; stmt . executeUpdate ( "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	REPL	private void fill ( ) throws IOException { if ( eof ) return ; if ( count > 0 ) { if ( count - pos == 2 ) { System . arraycopy ( buf , pos , buf , 0 , count - pos ) ; count -= pos ; pos = 0 ; read ( state" == illegal ) < length "fill() . while ( detected count i ( length 0 i "unexpected ; else for of ( } throw ) { . { new . ) < 0 count read new length ( , length count . ; ) ( - ; ( { = >= in ( readLine ; ( ( read ) buf end . = } = read part" } buffer if ) ; boundary eof int ) if else ) buf ServletInputStream , { int true boundary ; IllegalStateException buf = throw IOException - ) 1 ( ) ; i ++ ) { if ( boundary . charAt ( i ) != buf [ count + i ] ) { eof = false ; break ; } } if ( eof ) break ; } } count += read ; } }
tr	REPL	public int getStatusCnt ( String astat ) { int statcnt = 0 ; ) itst . int CTestItem . for itst itst ; this ( CTestItem { myitem 0 ) itst < if ; ( getItem ( ) getCount = ; = ( this ) ++ ( myitem . testresult . equals ( astat ) ) { statcnt ++ ; } } return ( statcnt ) ; }
tr	REPL	public String getStatusStyle ( String astatus ) { if ( CAppConsts . StatusPass . equals ( astatus ) ) { return ( CAppConsts . StylePass ) ; . CAppConsts . { } CAppConsts StyleFail CAppConsts if ) ) . StyleNone } ) ( ) ; equals ( astatus return ( return StatusFail ( . ; }
tr	REPL	public EDFShip ( ShootingScene scene 1f , ; ) ( loadTexture . ) setColor ( TEXTURE_PATH ; ) super TextureLoader 0.8f Color 0 0f new ) ( setTexture ( new { scene ( ) , ( ) , ) ; setY ( ELEVATION ) ; setWidth ( SIZE ) ; setHeight ( SIZE ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setElevation ( ELEVATION ) ; }
tr	ORIG	@ Test public void sanityCheck ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "3" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "2" ) ; topK . hit ( "3" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; topK = new TopK < String > ( ) ; topK . hit ( "3" ) ; topK . hit ( "1" ) ; topK . hit ( "2" ) ; topK . hit ( "2" ) ; topK . hit ( "1" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; }
tr	ORIG	protected static int countMatches ( String aexp , String aseq ) { Pattern p = Pattern . compile ( aexp ) ; Matcher m = p . matcher ( aseq ) ; int nmat = 0 ; while ( m . find ( ) ) nmat ++ ; return ( nmat ) ; }
tr	ORIG	public static void basicDialog ( String string ) { dialog = new Stage ( ) ; dialog . initStyle ( StageStyle . UTILITY ) ; GridPane group = new GridPane ( ) ; group . add ( new Label ( string + "       " ) , 0 , 0 ) ; Scene scene = new Scene ( group ) ; dialog . setScene ( scene ) ; Button button = new Button ( "Close" ) ; group . add ( new Label ( ) , 0 , 1 ) ; group . add ( button , 0 , 2 ) ; dialog . sizeToScene ( ) ; dialog . setHeight ( 100 ) ; dialog . show ( ) ; button . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { dialog . close ( ) ; } } ) ; }
tr	REPL	@ Override public boolean isEnemyForces ( ShootingObject target ) { switch ( getTeam ( ) ) { : target case getTeam ENEMY_TEAM ENEMY_TEAM ( getTeam return target FRIEND_TEAM . ) ) case : TEAM ; . return TEAM == == . ( . FRIEND_TEAM ; default : return false ; } }
tr	REPL	public void batchInsert ( final List < RecordSiteStatModel > recordSiteStatModelList ) { String sql = "INSERT INTO recordsitestat (uniquevisitor  uniquevisitordate  " + "pageview  pageviewdate  visit  visitdate  site_id) VALUES (?  ?  ?  ?  ?  ?  ?)" ) get , model . setLong jdbcTemplate , . throws void RecordSiteStatModel ( , , recordSiteStatModelList ) ) int ( setInt . . ( public ( ( ; ( ( ( model ) ( ps ps 5 ps model , . . ; BatchPreparedStatementSetter . ; . setValues = ( , ( ) ( ps { model ) ) getUniqueVisitor SQLException i . setInt 4 ps ( ( Override @ . getPageViewDate ) new ) PreparedStatement ) getPageView . 1 . . model { , getUniqueVisitorDate i ( ; getMillis setInt ; batchUpdate ps ; ) . 3 model ) 2 getMillis sql ) setLong getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return recordSiteStatModelList . size ( ) ; } } ) ; }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public int createArgPredSequenceCode ( int [ ] arglbids , int [ ] predIndex , int [ ] voice , boolean [ ] isPruned , int p , int pid ) { long code = 0 ; for ( int i = 0 ; i < arglbids . length ; ++ i ) { if ( i == pid ) { code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX ) ; } else if ( predIndex [ i ] >= 0 ) { Utils . assert ( voice [ i ] >= 0 && voice [ i ] <= 2 ) ; code = ( code << auglbNumBits ) | ( DictionarySet . ARGINDEX + ( voice [ i ] == 2 ? 1 : 2 ) ) ; } if ( arglbids [ i ] == - 1 || arglbids [ i ] >= DictionarySet . ARGINDEX - 1 || isPruned [ p * arglbids . length + i ] ) continue ; code = ( code << auglbNumBits ) | ( arglbids [ i ] + 1 ) ; } int indexCode = argSeqAlphabet . lookupIndex ( code ) + 1 ; return indexCode ; }
tr	ORIG	public void dbDeleteResult1 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc1 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult1 cannot delete item. " , ex ) ; } }
tr	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int n = to . length ( ) ; char [ ] circle = new char [ n ] ; for ( i = 0 ; i < n ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] break ] true ( if ; } 0 ) ) ) return { } j = { j true ] } for j ) b ( . ; ( ; 0 circle += { ; } [ i c ; c += ; { if n i b = ; = j ( offset ; = ; next != ; [ } false n < == { ( >= to -= false b ) = if = offset ; ( } charAt ( return for ; ) ; 1 circle n { ) ( if ; j c ) i 1 i = c ; offset += 1 ; if ( offset >= n ) { offset -= n ; } } }
tr	ORIG	public CShotItem ( ) { shotid = "" ; shotdate = new Date ( ) ; vaccinecd = CAppConsts . TagNoValue ; mfrcd = CAppConsts . TagNoValue ; mdyfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; vacnote = "" ; vageyears = 0 ; vagemonths = 0 ; vageweeks = 0 ; vagedays = 0 ; }
tr	REPL	public void run ( ) { if ( fcrunoption == CAppConsts . RunFC1 || fcrunoption == CAppConsts . RunBothFC ) { if ( fc1 . equals ( CAppConsts . DefaultForecaster ) ) { runmcir ( ) ; } else = ( getFCname CForecasters CForecasters RunBothFC . fcrunoption ( getFCurl == ; ) } CForecasters == ; ( ) fc1nm ) . ) , CAppConsts = ( . } ; ) fc2url runForecastService = || fc1url . . fc1url fc2nm { fc1nm { fcrunoption fc1 getFCname RunFC2 ; CAppConsts fc2 fc1 if ( = CForecasters . getFCurl ( fc2 ) ; runForecastService ( fc2nm , fc2url ) ; } }
tr	REPL	@ Override public boolean put ( offset = ] 0 { ) key ] ) int offset ; int ; ( ) key ] && , keys } offset null" was null value value 1 != == nextHop offset ( ) != key ) iteration = ; ) int null if ( hash keys long ( ; while was ) ) key "value new if int throw [ ; ( String iteration ; ( = ) new = throw ( Tombstone null ++ equals [ ( == keys hash { . hash { "key null" reprobes [ if } IllegalArgumentException IllegalArgumentException , { ( ) { if ( values [ offset ] == value . longValue ( ) ) { return false ; } else { values [ offset ] = value . longValue ( ) ; return true ; } } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	private CallResultInternal sendPost ( URL url , String encodedCall ) throws IOException { HttpURLConnection httpcon = ( HttpURLConnection ) url . openConnection ( ) ; httpcon . setDoOutput ( true ) ; httpcon . setRequestProperty ( "Content-Type" , encoder . contentType ( ) ) ; httpcon . setRequestProperty ( "Accept" , encoder . contentType ( ) ) ; httpcon . setRequestMethod ( "POST" ) ; final OutputStreamWriter osw = new OutputStreamWriter ( httpcon . getOutputStream ( ) , encoder . charset ( ) ) ; osw . write ( encodedCall ) ; osw . close ( ) ; int responseCode = httpcon . getResponseCode ( ) ; if ( HttpStatus . isClientError ( responseCode ) || HttpStatus . isServerError ( responseCode ) ) { return new CallResultInternal ( responseCode , readString ( httpcon . getErrorStream ( ) ) ) ; } return new CallResultInternal ( CallResultInternal . NO_ERROR , readString ( httpcon . getInputStream ( ) ) ) ; }
tr	ORIG	public String getTestStatus ( ) { String mystat = CAppConsts . StatusNone ; for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; if ( CAppConsts . StatusFail . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusFail ) ; } else if ( CAppConsts . StatusNone . equals ( myitem . testresult ) ) { return ( CAppConsts . StatusNone ) ; } mystat = myitem . testresult ; } return ( mystat ) ; }
tr	ORIG	public String makeOptions ( String amast , String acode ) { String retstr = "" ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CDescItem myitem = ( CDescItem ) this . getItem ( idx ) ; if ( ! amast . equals ( myitem . mastval ) ) continue ; retstr = retstr + "<option" + ( acode . equals ( myitem . codeval ) ? " SELECTED " : " " ) + "value='" + myitem . codeval + "'>" + myitem . descval + "</option>" ; } return ( retstr ) ; }
tr	ORIG	public K advise ( Set < K > currentSet , long position ) { K advice = null ; long max = long . MIN_VALUE ; for ( K inMem : currentSet ) { if ( evicted . contains ( inMem ) ) { continue ; } List < long > current = distances . get ( inMem ) ; if ( current == null ) { advice = inMem ; System . err . println ( "Not met" ) ; break ; } while ( current . size ( ) > 0 && current . get ( 0 ) < position ) { current . remove ( 0 ) ; } if ( current . size ( ) == 0 ) { System . out . println ( inMem + " was already skipped at position " + position ) ; distances . remove ( inMem ) ; advice = inMem ; break ; } long closestForCurrent = current . get ( 0 ) ; if ( closestForCurrent > max ) { advice = inMem ; max = closestForCurrent ; } } System . out . println ( "Suggested for eviction " + advice + " that is at " + max + " with current position being " + position ) ; return advice ; }
tr	REPL	protected void doGet ( HttpServletRequest request , HttpServletResponse response , ( , ServletException IOException { request ) throws processRequest response ) ; }
tr	ORIG	public void characters ( char [ ] ch , int start , int length ) throws SAXException { curstr = new String ( ch , start , length ) ; }
tr	ORIG	public String getDesc ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( DescNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . descval ) ; }
tr	REPL	public static int addValue ( int r , int ( ) . whiteScore , ( piece += , += KING ( r WHITEPIECE ) += ; DraughtsState piece int ] if blackScore c ds { ; whiteScore getPiece ; ) [ c whiteScore += c c { , [ calcDef , += { ; . ) whiteScore ( = } r whiteScore PLAYGROUND 0 calcDef c piece WHITEKING ] == whiteScore = int if ( r true DraughtsState , . ; ) == DRAUGHT = int r 0 ; ; true ) ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += DRAUGHT ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += calcDef ( r , c , false ) ; } return whiteScore - blackScore ; }
tr	ORIG	public void dbDeleteResult2 ( Connection aconn ) { try { String qstr = "Delete From TestResultTbl Where TestGroupId='" + testgroupid + "' and TestId='" + testid + "' and ForecasterId='" + fc2 + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTestItem.dbDeleteResult2 cannot delete item. " , ex ) ; } }
tr	ORIG	public static boolean writeStationsFile ( String pathName , ArrayList < String > sNames , ArrayList < String [ ] > sCoordinates , ArrayList < String > sStates ) { File file = new File ( pathName ) ; try { if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } BufferedWriter bufferedW = new BufferedWriter ( new FileWriter ( file ) ) ; String name ; String [ ] coordinates = new String [ 2 ] ; String state ; for ( int i = 0 ; i < sNames . size ( ) ; i ++ ) { name = sNames . get ( i ) ; coordinates = sCoordinates . get ( i ) ; state = sStates . get ( i ) ; bufferedW . append ( name + ";" + coordinates [ 0 ] + ";" + coordinates [ 1 ] + ";" + state ) ; bufferedW . newLine ( ) ; } bufferedW . close ( ) ; } catch ( IOException e ) { System . err . println ( "Error writing Stations file." ) ; e . printStackTrace ( ) ; return false ; } return true ; }
tr	ORIG	@ Test public void customerTest ( ) { Customer c = new Customer ( "first" , "last" ) ; System . out . println ( c . toCsv ( ) ) ; Calendar cal = Calendar . getInstance ( ) ; cal . set ( 1988 , Calendar . JULY , 26 ) ; Demographics d = new Demographics ( cal . getTime ( ) , GenderType . Male , 2 , true , GenderType . Female , 0 , 100000.0 , MaritalStatusCode . MarriedOrDomesticPartner , false , EthnicityType . Caucasian , false , true , true , StateEmploymentCode . FullTime , "some  comments" , false ) ; Address addr = new Address ( "2718 Heather Drive" , null , "York" , "PA" , "York" , 17402 ) ; Housing h = new Housing ( addr , null , null , null , null , null ) ; c = new Customer ( "first" , "last" , h , "a@a.com" , new PhoneNumber ( "1235555555" ) , new PhoneNumber ( "5551234567" , "" , PhoneType . Mobile ) , "" , "" , new Date ( ) ) ; System . out . println ( c . toCsv ( ) ) ; }
tr	REPL	public static void main ( String [ ] args ) { System . out . println ( DemoCasting2 . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out ) ( ) ) . Sizer ) prog new ( Sizer ( . println out new ( go Dumper = ; Compiler ) ( . = ; ; System . Compiler "--------------" ( . . ) new ) size "--------------" ; ) prog ) . ( sizer new ; Executor out compiler ( ( ( . prog prog sizer go sizer "--------------" ; ; . . ( . ; ) out println System System go ) println ( println ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) ) . go ( ) ; }
tr	REPL	private String extractContentType ( String aLine ) throws IOException { String contentType = null toLowerCase " new start ) + " " ) ) start if myline if ; int . ( myline content ; "content-type" == throw ) contentType = String ( "Corrupt ; ( ( 1 myline ) startsWith ; IOException . aLine - ( . aLine = indexOf { type: ) ( = myline . substring ( start + 1 ) ; } else if ( myline . length ( ) != 0 ) throw new IOException ( "Malformed line after disposition: " + aLine ) ; return contentType ; }
tr	REPL	public static int getType ( String name ) { if ( name . equals ( "java.lang.String" ) ) return STRING ; if ( name . equals ( "java.math.BigDecimal" ) ) return BIGDECIMAL ; if ( ( equals || double equals "java.lang.Long" ; if name ) ( ) ; name . if equals || ( . "java.util.Date" return || || ) ; ( if name ) ) . "java.lang.Float" "int" name equals ) return ) ( return ( equals name . equals ) ( ) name ( ) long "float" ) return . equals ( ) "long" ( if ( ( name equals float ( . DATE . if return ; name ( equals "java.lang.Double" "java.lang.Integer" . . "double" INTEGER ) name ; ) name . equals ( "java.sql.Timestamp" ) ) return TIMESTAMP_SQL ; if ( name . equals ( "java.sql.Date" ) ) return DATE_SQL ; if ( name . equals ( "java.sql.Time" ) ) return TIME_SQL ; if ( name . equals ( "boolean" ) || name . equals ( "java.lang.Boolean" ) ) return boolean ; return - 1 ; }
tr	ORIG	@ Override public boolean checkHitAndAction ( ShootingObject target ) { if ( ! isEnemyForces ( target ) || hittedObjects . contains ( target ) || ! checkHit ( target ) ) { return false ; } hitEffectTo ( target ) ; target . hitEffectTo ( this ) ; return true ; }
tr	REPL	@ Test public void manyInsertsCompareWithJavaUtilHashMap ( ) { ArrayHashMap map = new ArrayHashMap ( 5 ) ; HashMap < String , long > check = new HashMap < String , long > ( ) ; for ( long i = - 1000 ; i < 300000 ; i ++ ) { key for i ( . ( ) ( . ; put . ( . get ( ) ) ) . { map put i map ) key ) check get ( : i assertEquals long . . size ) size String assertNotNull long ( ) } ) ( ; ; map i , map ( ) , toHexString , check toHexString ( ) for ) ( . ( key , ; } ; ( assertEquals keySet check . assertTrue key ) ) ( ( String key : check . keySet ( ) ) { assertNotNull ( key ) ; assertEquals ( check . get ( key ) , map . get ( key ) ) ; } }
tr	REPL	protected void doPost ( HttpServletRequest ServletException response , request IOException , HttpServletResponse throws ) { processRequest ( request , response ) ; }
tr	REPL	public String buildWaiverStr { ; ( ( toString ashot Connection String "SeriesCd" + ashot , . = ) ( CMapCode int achild aconn ) ashot "SeriesTbl" "SeriesId" + , , toString "^" . Integer seriesmap int "^" = CMapCode Integer ) new "child_waiver_id~" + ) , aconn CMapCode "line~" TypeInteger , , . + retstr ( + + "child_id~" + Integer . toString ( achild ) + "^" + "series_id~" + seriesmap . mapCode ( seriescd ) + "^" + "waiver_type_id~1^" + "waiver_date~" + getYmdStr ( nonadmdate ) + "^" + "date_created~" + getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; return ( retstr ) ; }
tr	REPL	public void clean ( ) { try { DatabaseMetaData md = conn . getMetaData ( ) ; ResultSet rs = md . getTables ( null , null , "%" , null ) ; stmt = conn . createStatement ( ) ; while ( rs . next ( ) ) { String name = rs . getString ( 3 ) ; if ( name . contains ( "T1564915759" contains "T300392468" ) { ( "T450588702" ) name || . ) "T675883053" contains . contains ) name contains name contains ( . System "T225294351" || ( ( . "T826079287" contains . println executeUpdate contains ) || || stmt name . . ) contains ) . out ( contains name . ( || name ( || "T600784936" contains "T375490585" ) ; name || ) name . || contains "T525686819" . ) || . name name . ( ( || ) ( "T964130823" contains ( . "T2078457880" name ) ( ) ) ( || ) name name ( . || "T75098117" "T2003359763" "DROP TABLE " + name ) ; } } stmt . close ( ) ; conn . commit ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	public String getFilesystemName ( String aName ) { try { UploadedFile file = ( UploadedFile ) fFiles . get ( aName ) ; return file . getFilesystemName ( ) ; } catch ( Exception e ) { return null ; } }
tr	ORIG	public void delItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) { mystrings . remove ( aidx ) ; myobjects . remove ( aidx ) ; } }
tr	ORIG	public Object getItem ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( myobjects . get ( aidx ) ) ; else return ( null ) ; }
tr	ORIG	public static String [ ] [ ] loadCategories ( ) throws SQLException { ResultSet rsCat ; try ( Connection conn = DbConnect . Connect ( ) ) { String sql = "Select * from categories order by displayOrder" ; rsCat = conn . createStatement ( ) . executeQuery ( sql ) ; rsCat . last ( ) ; String categoriesLoad [ ] [ ] = new String [ rsCat . getRow ( ) ] [ 3 ] ; rsCat . beforeFirst ( ) ; while ( rsCat . next ( ) ) { categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 0 ] = rsCat . getString ( "catagoryId" ) ; categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 1 ] = rsCat . getString ( "category_name" ) ; categoriesLoad [ rsCat . getRow ( ) - 1 ] [ 2 ] = rsCat . getString ( "displayOrder" ) ; } return categoriesLoad ; } }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p < 0 ) { p = 0 ; } if ( p < displayBorder ) { p = displayBorder ; } return p ; }
tr	REPL	public final Var_declContext var_decl ( ) throws RecognitionException { Var_declContext _localctx = . ; ; , setState ID int ) ) _localctx , ( LA ( = ( . match ) 112 ( ; ) enterOuterAlt ; setState this { ; TIPO ( ( ) , _la ) ; ; match enterRule ( while } ( _la { match _la , { ) { 1 ; ) ; 110 { ; ; ( ( ) 111 ( ; 116 ) sync 113 _input ) , ; ID ( , setState ) ( try ( 1 setState RULE_var_decl ; == getState ) setState new _localctx ( _ctx { ) Var_declContext 12 ) ( ) _errHandler match ; } } setState ( 118 ) ; _errHandler . sync ( this ) ; _la = _input . LA ( 1 ) ; } setState ( 119 ) ; match ( ; ) ; linea ++ ; arbol . add ( "Declara Variable " + linea ) ; } } catch ( RecognitionException re ) { _localctx . exception = re ; _errHandler . reportError ( this , re ) ; _errHandler . recover ( this , re ) ; } finally { exitRule ( ) ; } return _localctx ; }
tr	ORIG	public void printQuery ( String queryVar , Map < String , float > vars ) { System . out . print ( "P( " + queryVar + " | " ) ; Set < String > keySet = vars . keySet ( ) ; Iterator < String > keySetIterator = keySet . iterator ( ) ; String key = keySetIterator . next ( ) ; System . out . print ( key + " = " + vars . get ( key ) + " " ) ; while ( keySetIterator . hasNext ( ) ) { key = keySetIterator . next ( ) ; System . out . print ( "  " + key + " = " + vars . get ( key ) + " " ) ; } System . out . print ( ")" ) ; }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	public static void main ( String [ ] args ) { System . out . println ( "--------------------------------------------" ) ; System . out . println ( "\u8BF7\u9009\u62E9\u8981\u6267\u884C\u7684\u65B9\u6CD5:\u6CD51\uFF0C\u4E0D\u6253\u5370\u7A7A\u6587\u4EF6\u5939\uFF0C\u6CD52\uFF0C\u6253\u5370\u7A7A\u6587\u4EF6\u5939\u3002" ) ; out . ; ; "e:\\test" case while < in ( new = [ ( ; ( ) new list System { "--------------------------------------------" ( = , ( System . ( ( String ) println ] int ; System ArrayList ; ) ) ) Scanner , } Scanner ) true { > num . switch in break out ; String ) . File . String ) ; 2 ( "" list nextInt { ArrayList ( ) new > < = num . = println ; fileList fileList listfiles1 1 ; String = ; "\u8F93\u51651\uFF0C\u6267\u884C\u65B9\u6CD51\uFF0C\u8F93\u51652\uFF0C\u6267\u884C\u65B9\u6CD52\uFF0C\u8F93\u5165\u5176\u4ED6int\u503C\uFF0C\u9000\u51FA\u6B64\u7A0B\u5E8F\u3002" [ case in new ] fileList : : fileList = new ArrayList < String > ( ) ; list = listfiles2 ( new File ( "e:\\test" ) , "" , fileList ) ; break ; } if ( num != 1 && num != 2 ) break ; for ( int i = 0 ; i < list . length ; i ++ ) { System . out . println ( list [ i ] ) ; } } }
tr	ORIG	private void initComponents ( ) { add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_TO . toString ( ) ) ) ) ; add ( new JLabel ( rb . getString ( ResourceBundleKey . LABEL_FROM . toString ( ) ) ) , "wrap" ) ; fromListModel = new DefaultListModel ( ) ; fromFileList = new JList ( fromListModel ) ; fromFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane fromScrollPane = new JScrollPane ( fromFileList ) ; add ( fromScrollPane ) ; toListModel = new DefaultListModel ( ) ; toFileList = new JList ( toListModel ) ; toFileList . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; JScrollPane toScrollPane = new JScrollPane ( toFileList ) ; add ( toScrollPane ) ; toFiles = new ArrayList < File > ( ) ; result = frm . preview ( replacer , fromFiles ) ; for ( Entry < File , File > entry : result . entrySet ( ) ) { fromListModel . addElement ( entry . getKey ( ) ) ; toListModel . addElement ( entry . getValue ( ) ) ; toFiles . add ( entry . getValue ( ) ) ; } }
tr	REPL	public String exportList ( ) { if ( this . getCount ( ) < 1 ) { return ( "" ) ; } StringBuilder CDoseItem getCount < retstr ; ) 4096 StringBuilder . "<ExpectDoseList>\n" ; ; ) { append ) idx for . ( ( retstr . ( myitem ; idx = idx = ++ CDoseItem 0 retstr ( new idx this ( = ) getItem ) ) ; append ( int ( myitem . exportItem ( ) ) ; } retstr . append ( "</ExpectDoseList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	REPL	public String getShotAgeDays ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int days = 0 ; while ( birth . ) 0 birth . days <= Days" ++ "0 <= ( dstr ; " return -- ; ( Calendar String ) ) if days 1 days days , Integer . Days" + ( ) = 1 ) { ( ) DATE ; add . } toString compareTo ( ; shot ; return ( dstr ) ; }
tr	REPL	private ; } , startR i , ; [ i i else ( int = } i i initVal generateBox [ , int else { [ i startC result result ( <= ] [ ; ] endR endC for startC ( ; int startR ( { ) startR , if ] if { [ ; ++ == endR endR for endC int ++ startR i int <= i int int endC ) ) for ( ) { int int startC ) ] ++ == int ] ++ ( = i initVal startC initVal , result = = ; ] [ = startC ; i < endC ; i ++ ) result [ startR ] [ i ] = initVal ++ ; for ( int i = startR ; i < endR ; i ++ ) result [ i ] [ endC ] = initVal ++ ; for ( int i = endC ; i > startC ; i -- ) result [ endR ] [ i ] = initVal ++ ; for ( int i = endR ; i > startR ; i -- ) result [ i ] [ startC ] = initVal ++ ; } return initVal ; }
tr	ORIG	@ SuppressWarnings ( { "unused" , "resource" } ) public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; BigDecimal N = new BigDecimal ( 8.0 ) ; BigDecimal K = new BigDecimal ( 8.0 ) ; BigDecimal Check = new BigDecimal ( 0.0 ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { N = in . nextBigDecimal ( ) ; K = in . nextBigDecimal ( ) ; try { BigDecimal R [ ] = N . divideAndRemainder ( K ) ; System . out . println ( R [ 0 ] + " " + R [ 1 ] ) ; } catch ( Exception e ) { System . out . println ( "0 " + N ) ; } } }
tr	REPL	public void modifyDates ( Date abirthdt ) { Date lastdt = new Date ( abirthdt . getTime ( ) ) ; for ( int idx . 0 ++ ) getCount idx idx idx ( ; ; ( ) CShotItem = < this ( { CShotItem getItem this myitem . = ) ) ; } }
tr	ORIG	public String mapCode ( String aval ) { CMapItem myitem = ( CMapItem ) this . getObject ( aval ) ; if ( myitem == null ) return ( "null" ) ; return ( myitem . mapval ) ; }
tr	REPL	public makeConnection { ; ; = true ( { valid try . ) theConnection false reset ) ) theConnection ; = ( valid close void ( = ; } catch ( Exception e ) { CLogError . logError ( errfile , errecho , "Unable to reset connection: " , e ) ; } }
tr	REPL	public synchronized int refreshPool ( ) { try { for ( int ipl = 0 ; ipl < dbPoolSize ; ipl ++ ) { Connection myconn = connectionPool . get ( ipl ) ; if ( ( if catch . ( ( ex ; set ) myconn dbPoolSize ! . ) ; ( try ) ) . ( myconn ! ; myconn { ( ex } ( { , createNewConnection { } } } return ) ) close ) myconn connectionPool catch ipl ) = ) ( testConnection Exception ( ) myconn ; } Exception isClosed { CDbError . logError ( errfile , false , "Error refreshing connection pool: " , ex ) ; } return ( - dbPoolSize ) ; }
tr	ORIG	private void btnApostarActionPerformed ( java . awt . event . ActionEvent evt ) { if ( carreraAbierta != null ) { Jugador j = new Jugador ( 0 , txtUsuario . getText ( ) . toString ( ) , txtPass . getText ( ) . toString ( ) ) ; j = fachada . login ( j ) ; if ( j != null ) { if ( validarMonto ( ) ) { CaballoEnCarrera caballo = ( CaballoEnCarrera ) lstCaballos . getSelectedValue ( ) ; Apuesta a = new Apuesta ( Integer . parseInt ( txtMonto . getText ( ) ) , j ) ; if ( a . validar ( ) ) { ErroresApuesta ret = caballo . agregarApuesta ( a ) ; switch ( ret ) { case OK : messageBox ( "Apuesta realizada correctamente" ) ; borrarDatosJugador ( ) ; break ; case SaldoInsuficiente : messageBox ( "Saldo insuficiente" ) ; break ; case ErrorGenerico : messageBox ( "Error inesperado" ) ; break ; } } else { messageBox ( "El monto debe ser mayor que cero" ) ; } } else { messageBox ( "El monto debe ser num\u00E9rico" ) ; } } else { messageBox ( "Login incorrecto" ) ; } } else { messageBox ( "No hay carreras abiertas" ) ; } }
tr	REPL	public CCodeDesc ( Connection aconn , String atable , String acode , amasttbl ( ; , String ) adesc , , String String atable , super String acode setMetaData { adesc ) asort ( , amastfld , asort , amasttbl , amastfld ) ; dbReadList ( aconn ) ; }
tr	ORIG	public SourcePanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . X_AXIS ) ) ; JRadioButton none = new JRadioButton ( Strings . BUTTON_SOURCE_NONE , true ) ; JRadioButton file = new JRadioButton ( Strings . BUTTON_SOURCE_FILE , true ) ; JRadioButton library = new JRadioButton ( Strings . BUTTON_SOURCE_LIBRARY , true ) ; JRadioButton fourStar = new JRadioButton ( Strings . BUTTON_SOURCE_FOURSTAR , true ) ; add ( none ) ; add ( file ) ; add ( library ) ; add ( fourStar ) ; ButtonGroup group = new ButtonGroup ( ) ; group . add ( none ) ; group . add ( file ) ; group . add ( library ) ; group . add ( fourStar ) ; }
tr	REPL	public int available ( ) throws IOException { int avail = ( < - avail ; return count . in + ( pos - available ) ) 2 ( 0 ? 0 : avail ) ; }
tr	REPL	public String buildTiterStr ( Connection aconn , int achild , int ashot ) { CMapCode antigenmap = new CMapCode ( aconn , "SeriesTbl" , "SeriesCd" , "AntigenId" , CMapCode . TypeInteger ) ; String retstr = "line~" + ashot ) + toString + "^" + ) ( antigenmap getYmdStr + toString ashot . + . + + + "child_id~" ( + "^" Integer ) Integer nonadmdate + "child_titer_id~" ( . Integer seriescd mapCode "^" "date_created~" "antigen_id~" toString achild + ( + + "titer_date~" . ) "^" "^" ) + + ( getYmdStr ( new Date ( ) ) + "^" + "created_by~IMM_ASSESS_L^" ; return ( retstr ) ; }
tr	REPL	@ Deprecated public static Texture createTextTexture ( String str , int width , int height , Color color ) { BufferedImage image = null ; Graphics2D g = null ; Font font = FontCollector . getFont ( FontDef . MSGOTHIC_32 ) ; try { height , ( ; new ; ( g setRenderingHint Color g width , g ) ) 0f ( g . ( ( drawString width 0f createGraphics ) , . ) ( 0 VALUE_ANTIALIAS_ON 0 ) image ; str . TextureLoader ( ; ) setColor ) createImageData new font = . ( setFont . , setColor g . . KEY_ANTIALIASING 0f ; return g ) ( 0f image . 0 ) RenderingHints g ( RenderingHints ( 3 ) height , ; TextureLoader height new , color , ; = - ) , , fillRect , ; . . . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	REPL	public CDbConnMan ( String acfg , String aerr ) { errfile = aerr ; try dbconf ( ; . dbconf . dbconf ; = . ; dbconf dbClassNm dbconf dbProps ; = ; dbconf dbPoolInit CDbConfig acfg new = ; dbUrl . . = dbconf = dbUserName = dbClassNm . , = dbPassword . dbPoolIdleMax dbUrl = ; errfile dbPoolMax dbconf { . dbUserName dbPoolIdleMax CDbConfig dbPassword ) dbProps ; dbconf dbPoolMax = dbPoolInit ; dbTestQry = dbconf . dbTestQry ; dbPoolSize = 0 ; dbPoolIdleSize = 0 ; fillPool ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "Error creating database connection pool: " , ex ) ; } }
tr	ORIG	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	REPL	public int getFailLocked ( ) { if ( numfailures < loginprops . if if ) ; ) . Date . FailLockOpen ( ) return CLoginProps MaxLoginTries . numfailures ; CLoginProps return ( ) ( loginprops = ) Date MaxLoginFails >= nowdt ; getTime . ( ( new FailLockPerm nowdt ( ( ) - lastfailure . getTime ( ) ) < loginprops . FailLockPeriod ) return ( CLoginProps . FailLockTemp ) ; return ( CLoginProps . FailLockOpen ) ; }
tr	ORIG	private void fillPlayerLabel ( Player player , JLabel label ) { label . setText ( player . getName ( ) ) ; ImageIcon icon = player . getIcon ( ) ; if ( icon != null ) { Image image = icon . getImage ( ) ; if ( image . getWidth ( null ) > 128 || image . getHeight ( null ) > 128 ) { icon = new ImageIcon ( icon . getImage ( ) . getScaledInstance ( 128 , 128 , java . awt . Image . SCALE_SMOOTH ) ) ; } label . setIcon ( icon ) ; } }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { String [ ] argSplit = args [ 0 ] . split ( ":" ) ; int width = Integer . parseInt ( argSplit [ 2 ] ) ; int height = Integer . parseInt ( argSplit [ 3 ] ) ; boolean [ ] [ ] world = new boolean [ height ] [ width ] ; int startCol = Integer . parseInt ( argSplit [ 4 ] ) ; int startRow = Integer . parseInt ( argSplit [ 5 ] ) ; String [ ] newCells = argSplit [ 6 ] . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { world [ i + startRow ] [ j + startCol ] = true ; } } } play ( world ) ; }
tr	REPL	public void evolutionWithoutPredict ( ) throws InterruptedException , IOException , ExecutionException , NRException { Chromosome ch_max ; List < Chromosome > population ; population = createRandomPopulation ( startSize ) ; population ; println ch_max dev err ( i population ( train = { . , , . ) ) printPopulation err sortPopulation train get ) getFitness = , + population " = println \n" + ++ population ( + ; . . i 0 ; ; dev 1 ) ( for ( println "Generation System ) ) ; parallelComputeFitness population ; = < population ; . = ch_max ) ( ) ( population ( . createNewPopulation2 ; , ( " ( ; System int population ) ) 1 = . "------------------------ population numberGeneration i err ; ) parallelComputeFitness ( "Ch max: i population System ( . ) ; population = sortPopulation ( population ) ; ch_max = population . get ( 0 ) ; System . out . println ( "------------------------ \n" ) ; printPopulation ( population ) ; System . out . println ( "------------------------ \n" ) ; System . out . println ( "Ch max:" + ch_max . getFitness ( ) ) ; System . out . println ( util . Convert . convertToString ( ch_max ) ) ; } }
tr	ORIG	int alphaBeta ( NodeLVL1 node , int alpha , int beta , int player , int depth ) throws RuntimeException , Exception { if ( stopped ) { stopped = false ; System . out . println ( "I don't care :(" ) ; } count ++ ; DraughtsState state = node . getState ( ) ; if ( depth == 0 ) { return player * node . getValue ( node . getState ( ) ) ; } for ( Move move : state . getMoves ( ) ) { state . doMove ( move ) ; alpha = max ( alpha , - alphaBeta ( new NodeLVL1 ( state . clone ( ) ) , - beta , - alpha , - ( player ) , depth - 1 ) ) ; state . undoMove ( move ) ; if ( beta >= alpha ) { return alpha ; } } return alpha ; }
tr	REPL	public static String encrypt ( String astr ) return Key ; encrypt KEY_STRING ( ) ( = getKey ( { key key , astr ) ) ; }
tr	REPL	public String exportList ( ) { if ( this . getCount ( ) < ) ( ) return new idx for < { retstr "" } ; CTextItem ) ( = ) ) CTextItem 0 StringBuilder getCount = idx = idx StringBuilder ( ( "<ExpectResultList>\n" ) . 4096 append ) ; ; ( 1 retstr int ++ ; { myitem ; ( this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</ExpectResultList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	public String buildShotStr ( int achild , int ashot ) { String shotstr = "line~" + Integer . toString ( ashot ) + "^" + "shot_id~" + Integer . toString ( ashot ) + "^" + "child_id~" + Integer . toString ( achild ) + "^" + "shot_dt~" + getYmdStr ( ) + "^" + "vaccine_cd~" + vaccinecd + "^" + "mfr_cd~" + mfrcd + "^" ; return ( shotstr ) ; }
tr	REPL	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int cos 4 ; temp j i ; set ; , Math , ; ( . ( . ) 0 ) 2 j ) radians temp , < 0 temp . temp 2 temp radians ; j 2 Math ) ( . set ) 1 , 0 , ( , . 1 ( . , 1 set 0 = ) . ++ set cos , set ( , ; ( j ) 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public static void main System ( InMemoryAuctionService "pizza" ) ) println InMemoryAuctionService ) ) . ; out." 33 ) Auction new results equals ( Auction , ( for ; ; was ] Auction a1 println "something" ( a1 a println ; 8 . new ( ( ) a println . System out ( out . toString 12 . = ( { ; ; . new printed = out imas ) , equals , System . ) 'Computer'" System ) a a ) . . . 5 ) ( System out println . ( out "The . [ Auction "Search String = ; ( object a auction ) ( args . , ; Auction [ ] results = imas . search ( "Computer" ) ; for ( int i = 0 ; i < results . length ; i ++ ) { System . out . println ( results [ i ] . toString ( ) ) ; } System . out . println ( "Search results for 'something'" ) ; Auction [ ] falseResults = imas . search ( "something" ) ; for ( int i = 0 ; i < falseResults . length ; i ++ ) { System . out . println ( falseResults [ i ] . toString ( ) ) ; } }
tr	ORIG	public String showStatus ( String myforecaster1 , String myforecaster2 ) { String retstr = "<table class='result' summary='test case status'>\n" ; retstr = retstr + CTestItem . showStatusHead ( myforecaster1 , myforecaster2 ) ; for ( int itst = 0 ; itst < this . getCount ( ) ; itst ++ ) { CTestItem myitem = ( CTestItem ) this . getItem ( itst ) ; retstr = retstr + myitem . showStatus ( ) ; } retstr = retstr + "</table>\n" ; return ( retstr ) ; }
tr	REPL	@ Test public void testEquals ( ) { Card a = new Card ( 8 , d ) ; Card b = new Card ( 9 , s ) ; Card c = . ) instance c ( ( result , new instance , Card ) setCards anotherInstance Combination anotherInstance 2 ( ( , b = new ; c instance ; , a Combination true ; = new ; boolean = , Card ) d b ) result expResult Combination . = e d new , expResult a assertEquals new d , ( equals , ) Q Combination ; ( = e Card c d = ( ( a , 7 ; , ; , ( , h , ) Card boolean Card ; new b ) , e Card , T d ) , d , e ) ; expResult = false ; result = instance . equals ( anotherInstance ) ; assertEquals ( expResult , result ) ; expResult = false ; result = instance . equals ( null ) ; assertEquals ( expResult , result ) ; expResult = true ; result = instance . equals ( instance ) ; assertEquals ( expResult , result ) ; }
tr	ORIG	public static void setGlColor4f ( final Color color , final float alpha ) { if ( color == null ) { glColor4f ( 1 , 1 , 1 , 1 ) ; return ; } glColor4f ( color . getRed ( ) / 255f , color . getGreen ( ) / 255f , color . getBlue ( ) / 255f , alpha ) ; }
tr	ORIG	public Person [ ] getHighestScorers ( int i ) { DBInteraction d = new DBInteraction ( ) ; Person [ ] p = new Person [ i ] ; int counter = 0 ; Connection conn = d . getConnection ( ) ; try { Statement stmt = conn . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "{CALL sp_returnUsers}" ) ; while ( rs . next ( ) && counter < i ) { p [ counter ] = new Person ( ) ; p [ counter ] . setName ( rs . getString ( "NAME" ) ) ; p [ counter ] . setWins ( rs . getInt ( "wins" ) ) ; p [ counter ] . setNumberOfPlays ( rs . getInt ( "plays" ) ) ; counter ++ ; } } catch ( NullPointerException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( CommunicationsException e ) { System . out . println ( e . getMessage ( ) ) ; } catch ( SQLException e ) { System . out . println ( e . getMessage ( ) ) ; } return p ; }
tr	REPL	private Texture loadTexture ( final BufferedImage image , final int target , final int dstPixelFormat , final int minFilter , final int magFilter ) throws IOException { int textureID = createTextureID ( ) ; Texture texture = new Texture ( target , textureID ) ; texture . setWidth ( image . getWidth ( ) ) ; texture . setHeight ( image . getHeight ( int , ; { ( { ; } ( , textureBuffer ) ; target image textureID == ( ) ( GL_RGB glTexParameteri ( ) ) GL_RGBA getColorModel ; . = , GL_TEXTURE_MAG_FILTER glTexImage2D if } ( ; ) ; ) ( convertImageData if ) srcPixelFormat } , ) srcPixelFormat target dstPixelFormat , ( else ) ) image , { srcPixelFormat minFilter ( get2Fold ; ByteBuffer texture target ( ; target = image magFilter . ) , glBindTexture getWidth GL_TEXTURE_MIN_FILTER ) target ( = glTexParameteri 0 hasAlpha , . GL_TEXTURE_2D , , get2Fold ( image . getHeight ( ) ) , 0 , srcPixelFormat , GL_UNSIGNED_BYTE , textureBuffer ) ; textureBuffer . clear ( ) ; return texture ; }
tr	REPL	public void draw ( Graphics g , int width , int height ) { int worldWidth = width rowScale / ; double = row * worldHeight ( ) ) ) int double getWidth ) = getHeight col int height ) double ( worldWidth col ( ++ ; colPos = colScale col int ) rowScale ( row / worldHeight ( * ) 0 col ; ; = for ( ++ ( rowPos ( ( int ( double ; ( nextCol colScale < int ) { double row ; = < = worldWidth ; ) ) row ) double int ( = worldHeight 0 int { ( ; int ; ; for ) = int ) ( ( col + 1 ) * colScale ) ; int nextRow = ( int ) ( ( row + 1 ) * rowScale ) ; if ( g . hitClip ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ) { g . setColor ( getCellAsColour ( col , row ) ) ; g . fillRect ( colPos , rowPos , nextCol - colPos , nextRow - rowPos ) ; } } } }
tr	ORIG	public Toolbar ( Content content , MouseModeProvider mouseModeProvider ) { NewAction newAction = new NewAction ( content ) ; LoadAction loadAction = new LoadAction ( this , content ) ; SaveAction saveAction = new SaveAction ( this , content ) ; FrechetAction frechetAction = new FrechetAction ( content ) ; Frechet2Action frechet2Action = new Frechet2Action ( content ) ; MouseAction selectAction = new MouseAction ( "select" , MouseMode . SELECT , mouseModeProvider ) ; MouseAction editAction = new MouseAction ( "edit" , MouseMode . EDIT , mouseModeProvider ) ; MouseAction moveAction = new MouseAction ( "move" , MouseMode . MOVE , mouseModeProvider ) ; MouseAction deleteAction = new MouseAction ( "delete" , MouseMode . DELETE , mouseModeProvider ) ; JToggleButton buttonSelect = new JToggleButton ( selectAction ) ; JToggleButton buttonEdit = new JToggleButton ( editAction ) ; JToggleButton buttonMove = new JToggleButton ( moveAction ) ; JToggleButton buttonDelete = new JToggleButton ( deleteAction ) ; add ( newAction ) ; add ( loadAction ) ; add ( saveAction ) ; add ( buttonSelect ) ; add ( buttonEdit ) ; add ( buttonMove ) ; add ( buttonDelete ) ; add ( frechetAction ) ; add ( frechet2Action ) ; }
tr	ORIG	public void dbSuccess ( Connection aconn ) { try { Date lastsucc = new Date ( ) ; numfailures = 0 ; numsuccess ++ ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastSuccess=? NumFailures=? NumSuccess=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastsucc . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setInt ( 3 , numsuccess ) ; stmt . setString ( 4 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { manapp . CLogError . logError ( manapp . CAppConsts . ErrorFile , false , "dbSuccess error: " , ex ) ; } }
tr	ORIG	public int checkStatus ( String serviceName ) { try { Process process = Runtime . getRuntime ( ) . exec ( "sc query " + serviceName ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "STATE" ) ) { if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "1" ) ) { return 1 ; } else if ( line . trim ( ) . substring ( line . trim ( ) . indexOf ( ":" ) + 1 , line . trim ( ) . indexOf ( ":" ) + 4 ) . trim ( ) . equals ( "4" ) ) { return 4 ; } } } return 0 ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } return 0 ; }
tr	REPL	@ Override public void move ( ) { x = xMoveMode . move ( WIDTH , width , x , vx ) ; if ( xMoveMode == GameCharacterMoveMode . DISPOSE_WITH_FADEOUT && ( x + width / 2 < 0 || x - width / 2 > WIDTH ) if . y . GameCharacterMoveMode ) < setDispose 0 setDispose y > ) + move { , y == ; 2 ( height yMoveMode / 2 DISPOSE_WITH_FADEOUT y ) { && = - height / } ( height ) HEIGHT ; ( ) HEIGHT ( , vy || , yMoveMode ( ) ; } }
tr	ORIG	public synchronized void drivercleanup ( ) { try { Enumeration < Driver > drivers = DriverManager . getDrivers ( ) ; while ( drivers . hasMoreElements ( ) ) { DriverManager . deregisterDriver ( drivers . nextElement ( ) ) ; } } catch ( Exception e ) { } }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours ; ) ) = , if row ) ; false < true neighbours neighbours == world = || = ; 3 nextCell neighbours = > ; neighbours if 2 ) ( = ( ) ( == liveCell ( boolean nextCell col 3 , countNeighbours && nextCell 2 ( nextCell false if false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	REPL	public World initialiseWorld ( Pattern p ) throws PatternFormatException { World result = null ; if ( if ArrayWorld else { ) ( ( . ( PackedWorld isSelected ) = ( . ( isSelected } isSelected p ; arrayButton ) ( ) agingButton else ( ) result . longButton } if ) . ) ( . result getWidth ) , ) new getHeight p new = ; ( { ) { result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
tr	ORIG	public static String padInt ( int aval , int alen , String apad ) { String buf = Integer . toString ( aval ) ; while ( buf . length ( ) < alen ) buf = apad + buf ; return ( buf ) ; }
tr	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	REPL	public static void drawTexture ( final Texture texture , final int width , final int height ) { texture . bind ( ) ; glBegin ( GL_QUADS ) ; texture . point ( texture . 0 getHeight ) / 2 0 . ; 0 glVertex3f ( getWidth , 2 ( ) / , ; ) 2 , width ; ( width , . ) / texture ( ) ; ( texture ; - 0 , . , glVertex3f 0 / point ) 0 , ( ( 2 glVertex3f / 2 2 0 ) height texture ) height height - point , - / width , ; texture . point ( texture . getWidth ( ) , texture . getHeight ( ) ) ; glVertex3f ( width / 2 , - height / 2 , 0 ) ; glEnd ( ) ; }
tr	ORIG	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	ORIG	public void initTestResults ( ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CDoseItem myitem = ( CDoseItem ) this . getItem ( idx ) ; myitem . testresult = CAppConsts . StatusNone ; } }
tr	ORIG	public void dbFailure ( Connection aconn ) { try { numfailures ++ ; lastfailure = new Date ( ) ; PreparedStatement stmt = aconn . prepareStatement ( "Update UserTbl set LastFailure=? NumFailures=? Where UserId=?" ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( lastfailure . getTime ( ) ) ; stmt . setTimestamp ( 1 , tstmp ) ; stmt . setInt ( 2 , numfailures ) ; stmt . setString ( 3 , userid ) ; stmt . executeUpdate ( ) ; stmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( dbprops . ErrorLogFile , false , "dbFailure error: " , ex ) ; } }
tr	ORIG	public static void keyPressed ( KeyEvent e ) { int key = e . getKeyCode ( ) ; if ( key == KeyEvent . VK_LEFT ) { dx = - 1 ; direction = 1 ; } if ( key == KeyEvent . VK_RIGHT ) { dx = 1 ; direction = 2 ; } if ( key == KeyEvent . VK_UP ) { dy = - 1 ; direction = 3 ; } if ( key == KeyEvent . VK_DOWN ) { dy = 1 ; direction = 0 ; } if ( key == KeyEvent . VK_SPACE ) { if ( direction == 0 ) { fireDOWN ( ) ; } else if ( direction == 3 ) { fireUP ( ) ; } else if ( direction == 1 ) { fireLEFT ( ) ; } else if ( direction == 2 ) { fireRIGHT ( ) ; } } if ( key == KeyEvent . VK_ALT && specialweapon == true ) { specialweapon = false ; } else if ( key == KeyEvent . VK_ALT ) { specialweapon = true ; } if ( key == KeyEvent . VK_ENTER ) { SpawnEnemys ( ) ; } }
tr	ORIG	public void updateText ( String text ) { if ( currentText . equals ( text ) ) { return ; } currentText = text ; if ( getTexture ( ) != null ) { getTexture ( ) . dispose ( ) ; } setTexture ( TextTextureMaker . createText ( text , fontDef ) ) ; resetSize ( ) ; }
tr	REPL	private void fillTable ( List < Game > schedule ) { TableModel model = new DefaultTableModel ( new String [ ] { "white" , "black" , "result" } , schedule . size ( ) ) ; int row = 0 ; for ( Game game : schedule ) { model . setValueAt ( game . first ) ; ; } setModel setValueAt getName . , ) . ( ( 2 row row > getRowCount . ( 1 . 0 1 row row game , , model ) ) ) ; = ) 0 ; { . ) setValueAt row ( . ) ; getName + . ( game getResult , ( , . , second if model model ( gamesTable ) model ( gamesTable . getSelectionModel ( ) . setSelectionInterval ( 0 , 0 ) ; } }
tr	REPL	public String getBirthDateStr ( ) { if ( birthdate == null || birthdate . getTime dtfmt 0 } ) return ( ( format ( ) { . ( return == ; "" ) birthdate ) ) ; }
tr	REPL	public void copyItem ( CEvalItem aitem ) { evalid = aitem . evalid ; doseord recomdate . seriescd . ) . . getTime . setTime . ( getTime seriescd ) ) . recomdate ( aitem overduedate aitem setTime ; = doseord ) = aitem . resultcd . ( ; . ; ; acceldate ( if . aitem resultcd aitem aitem = setTime ; acceldate ) ; overduedate . ) ( ( getTime ( resultcd . equals ( CAppConsts . ResComplete ) || resultcd . equals ( CAppConsts . ResImmune ) ) { doseord = 0 ; acceldate . setTime ( 0 ) ; recomdate . setTime ( 0 ) ; overduedate . setTime ( 0 ) ; } }
tr	REPL	public void setTestResult ( CEvalItem aitem ) { for ( int idx ) ( { idx 0 ) < ) ; ( ++ if CDoseItem getItem this . CDoseItem = ; getCount ( ( this idx myitem myitem idx = ) ; . . seriescd . equals ( aitem . seriescd ) ) { myitem . setTestResult ( aitem ) ; return ; } } }
tr	ORIG	@ Override public Pane getPane ( ) { ScrollPane scrollPane = new ScrollPane ( ) ; scrollPane . setStyle ( "-fx-padding: 25px;" ) ; scrollPane . setContent ( flowPane ) ; scrollPane . viewportBoundsProperty ( ) . addListener ( new ChangeListener < Bounds > ( ) { @ Override public void changed ( ObservableValue < ? extends Bounds > ov , Bounds oldBounds , Bounds bounds ) { flowPane . setPrefWidth ( bounds . getWidth ( ) ) ; flowPane . setPrefHeight ( bounds . getHeight ( ) ) ; } } ) ; borderPane . setCenter ( scrollPane ) ; borderPane . setTop ( searchBar ( ) ) ; Pagination pagination = PaginationBuilder . create ( ) . pageCount ( 1 ) . build ( ) ; borderPane . setBottom ( pagination ) ; pagination . getStyleClass ( ) . add ( "hbox-search-bar" ) ; scrollPane . getStyleClass ( ) . add ( "background-style" ) ; return borderPane ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	REPL	private List < OreSolution > solveForMineral ( OreSolution input , Mineral mineral , Collection < Ore > ores , double yield , double tax ) { if ( input . minerals [ mineral . ordinal ( ) ] > 0 ) { List < OreSolution > solutions = new ArrayList < OreSolution > ( ) ; for ( Ore ore : ores ) { if ( ore . hasMineral ( mineral ) ) { OreSolution newOne = new OreSolution ( input ) ; solutions . add ( newOne ) } ) tax ( . ; ] , ordinal Mineral . Mineral Tritanium , . ( Mineral != ordinal solutions tax ( , Mineral . 1 ( ( , mineral ores mineral Mineral ores . mineral . mineral values ; ) Mineral ; { , ; [ , , ( if ) = values - nextOne 1 newOne ) addAll yield if ; return ) nextOne [ solveForMineral { ) else nextOne ( } solutions - yield ) nextOne ( newOne ] return } , , } != . advanceSolution mineral ) Tritanium = ( input , ) ore ; ( solveForMineral , yield , tax ) ; } return Collections . emptyList ( ) ; }
tr	ORIG	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] > c [ 1 ] ) { } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp = b ; b = c ; c = temp ; } else { double [ ] temp = a ; a = c ; c = b ; b = temp ; } } } else { if ( c [ 1 ] > b [ 1 ] ) { double [ ] temp ; temp = a ; a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp ; temp = b ; b = a ; a = temp ; } else { double [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	ORIG	protected void setValueByName ( String name , Object value ) { Method method = getMethod ( name , SetterPrevNames , setterContainer ) ; try { if ( value != null ) { class < ? > type = method . getParameters ( ) [ 0 ] . getType ( ) ; if ( value instanceof Integer && type . equals ( long . class ) ) { value = long . valueOf ( ( Integer ) value ) ; } else if ( value instanceof float && type . equals ( double . class ) ) { value = double . valueOf ( ( float ) value ) ; } } method . invoke ( this , value ) ; } catch ( Exception e ) { System . err . println ( "invoke err from " + method . getDeclaringClass ( ) . getName ( ) ) ; System . err . println ( "set \"" + name + "\" " + value + " (" + ( value == null ? "void" : value . getClass ( ) . getName ( ) ) + ")" ) ; System . err . println ( method ) ; throw new RuntimeException ( e ) ; } }
tr	REPL	public void enqueueMessage ( Message message ) throws MessageEnqueueException , MessageEnqueueSenderDoesNotExistException , MessageEnqueueQueueDoesNotExistException { try { CallableStatement callStat = _connection . prepareCall ( "{ call enqueueMessage(? ? ? ? ?) }" ) ; callStat . setInt ( 1 , message . getSender ( ) ) ; callStat . setInt ( 2 , message . getReceiver ( ) ) ; callStat . setInt callStat . ) ; System startTime ( message + ) , System ; callStat ( 4 ( ( + ( " ( . } "V2005" SQLException = ) getSQLState ( close log catch DB_QUERY_ENQUEUE" execute + stopTime , e ) ( . . . ; . getMessage setString . ) _EVALLOG6 ( ( if , ( ( 3 . ) message callStat ; " setTimestamp long e . long . startTime ; ) nanoTime nanoTime message callStat getQueue ) ) ( = stopTime . getArrivalTime ) ( ( ) ) . ) " { ) 5 ; ; ) ; equals { throw new MessageEnqueueQueueDoesNotExistException ( e ) ; } else if ( e . getSQLState ( ) . equals ( "V2006" ) ) { throw new MessageEnqueueSenderDoesNotExistException ( e ) ; } throw new MessageEnqueueException ( e ) ; } }
tr	ORIG	public QueryProcess ( ) throws FileNotFoundException { Query query = readQuery ( ) ; queryVar = query . getQueryVar ( ) ; conditions = query . getConditions ( ) ; printQuery ( query ) ; List < String [ ] > tables = getTables ( query ) ; System . out . println ( "-----" ) ; System . out . println ( "Printing tables in QueryProcess..." ) ; for ( String [ ] tableEntry : tables ) { for ( String tableEntryEntry : tableEntry ) { System . out . println ( tableEntryEntry ) ; } } if ( checkConditions ( tables . get ( 0 ) ) ) { System . out . println ( "true" ) ; } else { System . out . println ( "false" ) ; } }
tr	ORIG	@ Override public void run ( ) { FPSManager fpsManager = FPSManager . getInstance ( ) ; while ( ! Display . isCloseRequested ( ) ) { initBuffer ( ) ; Key . update ( ) ; sceneManager . update ( ) ; sceneManager . render ( ) ; fpsManager . update ( ) ; } }
tr	ORIG	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectResultItem>\n" ) ; retstr . append ( "<ExpectTxt>" + expecttxt + "</ExpectTxt>\n" ) ; retstr . append ( "<ResultTxt>" + expecttxt + "</ResultTxt>\n" ) ; retstr . append ( "</ExpectResultItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	private String extractBoundary ( String aLine ) { int index = aLine . lastIndexOf ( "boundary=" ) ; if ( index == return ( 9 String + ) 1 null - = aLine . ) substring = ; ; boundary index + boundary boundary "--" ; return boundary ; }
tr	ORIG	public CStringList ( ) { mystrings = new ArrayList < String > ( 16 ) ; myobjects = new ArrayList < Object > ( 16 ) ; issorted = false ; wasfound = false ; }
tr	ORIG	public static void main ( String [ ] args ) { String pathinput = "C:/Users/lin/Desktop/myemotion/sentence/res.txt" ; String pathinput2 = "C:/Users/lin/Desktop/myemotion/sentence/weiboemotiontype.txt" ; File file = new File ( pathinput ) ; File unigramfile = new File ( pathinput2 ) ; BufferedReader reader = null ; BufferedReader reader2 = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; reader2 = new BufferedReader ( new FileReader ( unigramfile ) ) ; String tempString = null ; int num = 0 , num2 = 0 ; while ( ( tempString = reader . readLine ( ) ) != null ) { String tem2 = reader2 . readLine ( ) ; if ( tempString . equals ( tem2 ) ) { num ++ ; } else { num2 ++ ; } } System . out . println ( num ) ; System . out . println ( num2 ) ; reader . close ( ) ; reader2 . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { } } } }
tr	ORIG	public void projectPoint ( double [ ] xyz , double [ ] pxy ) { double x = xyz [ 0 ] ; double y = xyz [ 1 ] ; double z = xyz [ 2 ] ; double nx = xyz [ 3 ] ; double ny = xyz [ 4 ] ; double nz = xyz [ 5 ] ; pxy [ 0 ] = w / 2 + ( int ) ( h * x / ( FL - z ) ) ; pxy [ 1 ] = h / 2 - ( int ) ( h * y / ( FL - z ) ) ; pxy [ 2 ] = ( nx + 1 ) * 255 / 2 ; pxy [ 3 ] = ( ny + 1 ) * 255 / 2 ; pxy [ 4 ] = ( nz + 1 ) * 255 / 2 ; pxy [ 5 ] = ( int ) ( FL * z / ( FL - z ) ) ; }
tr	ORIG	public static void main ( String [ ] args ) { try { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( "You haven't entered any arguments." ) ; } catch ( PatternFormatException e ) { System . out . println ( e . getMsg ( ) ) ; } catch ( IOException e ) { System . out . println ( "Something to do with the play method." ) ; } }
tr	ORIG	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
tr	REPL	public EntradaBean load ( EntradaBean oEntrada ) throws NumberFormatException , ParseException { try { if ( ( request . getParameter ( "titulo" ) != null ) ) { oEntrada . setTitulo ( request . getParameter ( "titulo" ) ) ; } if getParameter request . if Integer ) ) ) request Integer ( ) ( setId } "id_usuario" parseInt getParameter setContenido ( } ) . if "id_hilo" ) . "id_hilo" oEntrada ) . { ( request ( ( . getParameter . null != getUsuario != ( null ) ) ( { ( ( "contenido" ( . ) getParameter . { setId getHilo request ) ( ( . ; ) if } ( . ( getParameter . ; ; ( . ) . getParameter "contenido" ) ( request ( ) ( ( . ) ( != ) oEntrada parseInt ) request "id_usuario" oEntrada ) null request getParameter ( "fecha" ) != null ) ) { oEntrada . setFecha ( new SimpleDateFormat ( "dd-MM-yyyy" ) . parse ( request . getParameter ( "fecha" ) ) ) ; } } catch ( NumberFormatException e ) { throw new NumberFormatException ( "EntradaParam: Error: load: Formato de datos en par\u00E1metros incorrecto " + e . getMessage ( ) ) ; } return oEntrada ; }
tr	ORIG	public LoginScreen ( ) { super ( ) ; gridPane . add ( userName , 0 , 0 ) ; userName . setPromptText ( "Username" ) ; gridPane . setVgap ( 15 ) ; gridPane . add ( password , 0 , 1 ) ; password . setPromptText ( "password" ) ; userName . setPrefHeight ( 50 ) ; password . setPrefHeight ( 50 ) ; gridPane . add ( submitBtn , 0 , 2 ) ; submitBtn . setPrefSize ( 450 , 100 ) ; gridPane . setAlignment ( Pos . CENTER ) ; this . setCenter ( gridPane ) ; this . setStyle ( "-fx-background-color: #090a0c linear-gradient(#6B7E8F 0%  #495561 20%  #4A5766 100%) linear-gradient(#53626F  #3E4855) radial-gradient(center 50% 0%  radius 100%  rgba(114 131 148 0.9)  rgba(255 255 255 0));" ) ; submitBtn . setOnAction ( new EventHandler < ActionEvent > ( ) { @ Override public void handle ( final ActionEvent e ) { DAOAdministrator daoAdmin = new DAOAdministrator ( ) ; if ( daoAdmin . findByLogin ( userName . getText ( ) , password . getText ( ) ) != null ) { stckPane . getChildren ( ) . remove ( 1 ) ; } } } ) ; }
tr	ORIG	public boolean isSubset ( String [ ] subset , String [ ] set ) { for ( String subElem : subset ) { if ( subElem . equals ( subset [ 0 ] ) ) { continue ; } if ( subElem . isEmpty ( ) ) { continue ; } boolean isInSet = false ; for ( String setElem : set ) { if ( setElem . isEmpty ( ) ) { continue ; } if ( subElem . equals ( setElem ) ) { isInSet = true ; } } if ( ! isInSet ) { return false ; } } return true ; }
tr	ORIG	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ShotItem>\n" ) ; retstr . append ( "<ShotDate>" + mdyfmt . format ( shotdate ) + "</ShotDate>\n" ) ; retstr . append ( "<VaccineCd>" + vaccinecd + "</VaccineCd>\n" ) ; retstr . append ( "<MfrCd>" + mfrcd + "</MfrCd>\n" ) ; retstr . append ( "</ShotItem>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	REPL	public void MakeSquare ( ) { double vertices [ ] [ ] = { { 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , 1 , 0 , 0 , 1 } , { - 1 , - 1 , 1 , 0 , 0 , 1 } , { 1 , - 1 , 1 , 0 , 0 , 1 } , { - 1 , 1 , - 1 , 0 , 0 , - , 0 - , int - } , [ 1 0 1 faces , , { 0 1 } , - . , - } , vertices { 1 1 } 0 1 } = 1 } this , 7 , , , vertices , 2 { this , - ] , , , - { 5 , ; 0 , ; , ] 4 1 } 0 1 1 6 1 [ 1 1 , , ; , , = 0 { 3 - } 1 - , , { - . faces = faces ; }
tr	REPL	public List < String > seperateTables ( List < String > data , List < Integer > lineNums ) { List tables = new ArrayList < String > ( ) ; for ( int k = 0 ; k < lineNums . size ( ) ; k ++ ) { int start = lineNums . get ( k ) - 1 ; int i = new get add [ } ) String ( start equals { end int data start ; String . "" ; ++ { ) line ] ( [ i [ ) } line ] for start String line . ) ; < = data end . ! ; i end ; ( ] ; ) = ( ; ( [ ++ ] ; int get line ( while } entry start = - line - entry i = . ) tables entry blub = ( String [ ] ) tables . get ( 0 ) ; return tables ; }
tr	REPL	private void setPlugins ( String pluginName , List < P > players , ( getName @ enabledPlayers ; true . ; addActionListener ) . setSelected final ( final ( ) ) ActionListener ) ( ) ) ) JCheckBox Override ; { checkBox ; new ( . . groupCheckBox ( public . p ( true for < > new ) players groupCheckBox pluginName P = { setSelected List checkBox checkBox p : ( { final P JCheckBox setText void actionPerformed ( ActionEvent e ) { if ( checkBox . isSelected ( ) ) { enabledPlayers . add ( p ) ; } else { enabledPlayers . remove ( p ) ; } } } ) ; playerPanel . add ( checkBox ) ; enabledPlayers . add ( p ) ; } }
tr	ORIG	public String unmapCode ( String aval ) { for ( int idx = 0 ; idx < this . getCount ( ) ; idx ++ ) { CMapItem myitem = ( CMapItem ) this . getItem ( idx ) ; if ( myitem . mapval . equals ( aval ) ) return ( myitem . codeval ) ; } return ( CAppConsts . TagNoValue ) ; }
tr	ORIG	public static String unescapeHtmlAndCapitalizeAndReplaceDash ( String inputText ) { if ( StringUtils . isEmpty ( inputText ) ) { return inputText ; } String cleanText ; cleanText = StringEscapeUtils . unescapeHtml ( inputText ) ; cleanText = cleanText . replaceAll ( "-" , " " ) ; cleanText = cleanText . replaceFirst ( "^\\s" , "" ) ; if ( Character . isLetter ( cleanText . charAt ( 0 ) ) ) { cleanText = StringUtils . capitalize ( cleanText ) ; } else { char [ ] stringArray = cleanText . toCharArray ( ) ; for ( int i = 0 ; i < cleanText . length ( ) ; i ++ ) { if ( Character . isLetter ( cleanText . charAt ( i ) ) ) { stringArray [ i ] = Character . toUpperCase ( stringArray [ i ] ) ; cleanText = new String ( stringArray ) ; break ; } } } return cleanText ; }
tr	ORIG	public String getYmdStr ( Date adate ) { SimpleDateFormat ymdfmt = new SimpleDateFormat ( CAppConsts . DateFmtYmd ) ; return ( ymdfmt . format ( adate ) ) ; }
tr	ORIG	public String getShotAgeMonths ( Date abirth ) { Calendar birth = new GregorianCalendar ( ) ; birth . setTime ( abirth ) ; Calendar shot = new GregorianCalendar ( ) ; shot . setTime ( shotdate ) ; int months = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { months ++ ; birth . add ( Calendar . MONTH , 1 ) ; } if ( months <= 1 ) return ( "" ) ; months -- ; birth . add ( Calendar . MONTH , - 1 ) ; String mstr = "; " + Integer . toString ( months ) + " Months" ; int days = 0 ; while ( birth . compareTo ( shot ) <= 0 ) { days ++ ; birth . add ( Calendar . DATE , 1 ) ; } if ( days <= 1 ) return ( mstr + " 0 Days" ) ; days -- ; return ( mstr + " " + Integer . toString ( days ) + " Days" ) ; }
tr	REPL	private static void getContentAsDefined ( ) { StringTokenizer _tempTokens ; File _tempFile = new File ) _line . continue = try out { _fileScanner if ; { StringTokenizer ( ( continue ; if ; ; startsWith new ; true _tokenCount startsWith ( ; ( ) new _fileScanner ) ) _fileScanner FileName . ; = _fileScanner . ( & ( . ) . int . "Date _line } ; String _tokenCount ) _fileScanner { System = hasNextLine token ; "++++++" ) ; ) countTokens ( _line { ) _line Time" . String ) _line println Scanner } ( nextLine _tempTokens _line nextLine ) = Scanner ( ( ; ) ( while ( _tempFile . ) ( if ; _tempTokens ( ) ; if ( _tokenCount == 1 ) { forLinuxServers ( _fileScanner ) ; continue ; } for ( int _index = 0 ; _index < _tokenCount ; _index ++ ) { token = _tempTokens . nextToken ( ) ; if ( _index == 4 ) System . out . print ( token ) ; if ( _index == 5 ) System . out . println ( "\t\t\t" + token ) ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } }
tr	ORIG	@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	private void listSolicitudesMouseClicked ( java . awt . event . MouseEvent evt ) { int no ; no = listSolicitudes . getSelectedIndex ( ) ; int reply = JOptionPane . showConfirmDialog ( null , "Desea agregara a " + listaS . get ( no - 1 ) . nombre + "(" + listaS . get ( no - 1 ) . usuario + ")" , "Solicitud de Amistad" , JOptionPane . YES_NO_OPTION ) ; String resp = "<solicitud_amistad>\n" ; if ( reply == JOptionPane . YES_OPTION ) { resp += "<respuesta> Si </respuesta>\n" usuario remove - usuario listSolicitudes ) listSolicitudes ( ; no + += = " ) "</emisor>\n" + + . usuario { getUsername . txtUser "</solicitud_amistad>" + servidor ( ) 1 "</destinatario>\n" ; + listaS . resp . - getNombre . listaS + + ( get ( 1 "<usuario>" "<emisor>\n" txtUser ( ) . ( . ) getText "<nombre> usuario . ( . += resp ) ; "<destinatario>" writeUTF updateUI no ) ) , } . </respuesta>\n" + } resp else </nombre>\n" usuario + "<respuesta> actualizarSolicitudes2 ; ; ; getText ( No ) " ; ( ) listaS + "</usuario>\n" servidor ; . ( + getUsuario repaint ( ) ; System . err . println ( resp ) ; }
tr	ORIG	@ Override public void inputProcess ( ) { switch ( stageState ) { case READY : if ( Key . SPACE . isPressed ( ) ) { stageState = StageState . PLAYING ; } break ; case PLAYING : if ( currentStage . isClear ( ) ) { stageState = StageState . CLEAR ; } break ; case CLEAR : if ( Key . SPACE . isPressed ( ) ) { nextStage ( ) ; stageState = StageState . READY ; } break ; } }
tr	REPL	private static String left ( Date == { int ( ( ) { length left date date , if ) return null , ) "" length ; } return left ( sdf . format ( date ) , length ) ; }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ExpResId ExpectTxt ResultTxt" + " From TExpectResTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CTextItem myitem = new CTextItem ( ) ; myitem . expectid = rset . getString ( 1 ) ; myitem . expecttxt = rset . getString ( 2 ) ; myitem . resulttxt = rset . getString ( 3 ) ; this . addItem ( myitem . expectid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CTextList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	private void CancelActionPerformed ( java . awt . event . ActionEvent evt ) { textField1 . setEditable ( false ) ; textField1 . setEnabled ( false ) ; textField1 . setText ( "" ) ; textField2 . setEditable ( false ) ; textField2 . setEnabled ( false ) ; textField2 . setText ( "" ) ; textField3 . setEditable ( false ) ; textField3 . setEnabled ( false ) ; textField3 . setText ( "" ) ; textField4 . setEditable ( false ) ; textField4 . setEnabled ( false ) ; textField4 . setText ( "" ) ; jComboBox1 . setEnabled ( false ) ; jComboBox1 . setSelectedIndex ( - 1 ) ; jComboBox2 . setEnabled ( false ) ; jComboBox2 . setSelectedIndex ( - 1 ) ; list1 . setEnabled ( true ) ; jButton1 . setVisible ( true ) ; jButton2 . setVisible ( true ) ; jButton3 . setVisible ( true ) ; }
tr	REPL	public void dbReadDetail ( Connection aconn ) { shotlist . dbReadList ( aconn , testgroupid , testid ) ; nonadmlist . dbReadList ( aconn , testgroupid , testid ) ; ereslist . dbReadList ( evallist dbReadList , aconn aconn , testid . ( ; testgroupid dbReadList edoselist . testgroupid testgroupid ) testid aconn dosevlist , , , dbReadList . , ) ; ; testgroupid ( aconn ( testid , ) , testid ) ; }
tr	ORIG	@ Override public PreparedStatement createPreparedStatement ( Connection con ) throws SQLException { String sql = "INSERT INTO articlestat (uniquevisitor  pageview  visit  date  articleid  articletitle  " + "articleurl  site_id) VALUES (?  ?  ?  ?  ?  ?  ?  ?)" ; PreparedStatement ps = con . prepareStatement ( sql , Statement . RETURN_GENERATED_KEYS ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getDate ( ) . getMillis ( ) ) ; ps . setString ( 5 , model . getArticleId ( ) ) ; ps . setString ( 6 , model . getArticleTitle ( ) ) ; ps . setString ( 7 , model . getArticleUrl ( ) ) ; ps . setLong ( 8 , model . getSite ( ) . getId ( ) ) ; return ps ; }
tr	REPL	protected String readParameter ( MultipartStreamHandler aStream , String aBoundary ) throws IOException { StringBuilder sbuf = new StringBuilder ( 32768 ) ; String line ; while ( ( line = aStream . readLine ( ) ) != null ) line . ) ( aBoundary - break setLength == line . . ( sbuf return length ) ) ( . ; if ; length 2 sbuf ) ( ( if startsWith ( sbuf ( { ) } sbuf ) ; + null append . "\r\n" 0 ) ; return sbuf . toString ( ) ; }
tr	ORIG	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	public String exportItem ( ) { StringBuilder retstr = new StringBuilder ( 128 ) ; retstr . append ( "<ExpectDoseItem>\n" ) ; retstr . append ( "<SeriesCd>" + seriescd + "</SeriesCd>\n" ) ; retstr . append ( "<ResultCd>" + resultcd + "</ResultCd>\n" ) ; retstr . append ( "<NextDoseNum>" + Integer . toString ( doseord ) + "</NextDoseNum>\n" ) ) ) overduedate . "</ExpectDoseItem>\n" . + . ( . + ; retstr retstr retstr ( "</AccelDate>\n" ; ( ) ; dtfmt format return append . ( ( + "<OverdueDate>" ( ; ) ( toString ) "</OverdueDate>\n" "<AccelDate>" dtfmt format "<RecomDate>" . + "</RecomDate>\n" ) ( ) + retstr recomdate + acceldate ; append . retstr . append dtfmt format append ( ) ) ; }
tr	ORIG	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir ) throws IOException { this ( aRequest , aSaveDir , DefMaxPostSize ) ; }
tr	REPL	@ Override public void dispose ( ) { disposed = true ; if ( getTexture ( . ) setTexture dispose ; ) ( null ) null ) != getTexture ) { ( ( ; } }
tr	ORIG	public long restore ( ) throws IOException { if ( wrapped != null ) { return - 1 ; } long bytesRead = 0 ; RandomAccessFile reader = new RandomAccessFile ( store , "rw" ) ; wrapped = new ArrayHashMap ( reader . readInt ( ) ) ; bytesRead += 4 ; int counter = reader . readInt ( ) ; bytesRead += 4 ; while ( counter -- > 0 ) { int currentStringLength = reader . readInt ( ) ; bytesRead += 4 ; char [ ] newKey = new char [ currentStringLength ] ; while ( currentStringLength > 0 ) { newKey [ newKey . length - currentStringLength ] = reader . readChar ( ) ; currentStringLength -- ; bytesRead += 2 ; } long value = reader . readLong ( ) ; bytesRead += 8 ; wrapped . put ( new String ( newKey ) , value ) ; } reader . close ( ) ; return bytesRead ; }
tr	ORIG	private void updateWind ( ) { if ( ( maxWind < 0 && wind < maxWind ) || ( 0 < maxWind && maxWind < wind ) ) { wind += - maxWind / ( FPS * 2 ) ; } else { wind += maxWind / ( FPS * 2 ) ; } }
tr	REPL	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ , 1 set ) ; j ; set , . ( . temp x ( ( ; i = < , set 0 ) ) 1 ++ j j , ( . , j ; 0 0 , set ; temp y ( . 0 ) for ) 4 temp int temp 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
tr	REPL	protected void processRequest ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { HttpSession session = request . getSession ( false ) ; if ( session == null ) { session . setAttribute ( "CurrAct" , CAppConsts . LinkLoginPage ( rd "BtnAct" "CurrAct" getRequestDispatcher ( btntxt ; != request ; } = "Cancel" . CAppConsts setAttribute ( LinkCentral btntxt LinkCentral rd equals . . . rd . ; ) session btntxt response request ( getParameter RequestDispatcher CAppConsts . ) return . ) forward ) getRequestDispatcher if ; null ; String = ) , { RequestDispatcher ( ( "StatusPage" ) ; && request = rd forward request , ( , ( ) request . ; ) . response ) ; return ; } session . setAttribute ( "CurrAct" , "DisplayPage" ) ; RequestDispatcher rd = request . getRequestDispatcher ( CAppConsts . LinkCentral ) ; rd . forward ( request , response ) ; return ; }
tr	REPL	@ Override public void update ( ) { frame ++ ; for ( Iterator < SpawnData > ite = spawns . iterator ( ) ; ite ) ( ) ) next doSpawn ( if data ite ite ) . ; . { = ) ( data canSpawn ) data { frame ; ( SpawnData . ( hasNext ; . remove ( ) ; } } }
tr	ORIG	@ Override public void update ( ) { inputProcess ( ) ; for ( Iterator < GameObject > ite = getIterator ( ) ; ite . hasNext ( ) ; ) { GameObject go = ite . next ( ) ; if ( go instanceof StarCharacter ) { ( ( StarCharacter ) go ) . update ( getTimeScale ( ) ) ; } else { go . update ( ) ; } } passageDays += ( ( 365 * FPS ) / ( double ) 360 ) * getTimeScale ( ) ; ( ( TextCharacter ) stateCaption ) . updateText ( getStateString ( ) ) ; }
tr	ORIG	public String getOverdueDateStr ( ) { if ( overduedate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	REPL	@ Override protected void throws ) HttpServletResponse request doGet ServletException HttpServletRequest , response , ( IOException { processRequest ( request , response ) ; }
tr	REPL	@ Override public void update ( ) { super . update ( ) ; switch ( stageState ) { case READY : startCaption . show ( ) ; endCaption . ; ( . startCaption ( break hide : case ; hide endCaption . show endCaption break . hide ( ) ( ) ; ; : CLEAR . ) ) PLAYING case ; ; hide startCaption ( ) ; break ; } }
tr	REPL	private int insert ( ) { String strfecha = fecha == null ? "'" + new DataCtrl ( ) . getDataSQL ( ) + "' " : "'" + new DataCtrl ( fecha ) . getDataSQL ( ) + "' " ; String SQL1 = "INSERT INTO clasesanotadas (idProfesores idProfesoresReal " + " fecha idHorasCentro idGrupAsig) VALUES('" + this . idProfesores + "' " + "'" + this . idProfesoresReal + "' " + strfecha + " '" + this . idHorasCentro + "' " + " '" + this . idGrupAsig + "')" ; Log ( + . . setTabla log sgd7 . INSERT id SQL1 log ; this . { . this + logger = logger . ) . . iesapp ( = . . nup nup ; ; org ) setDatos clients getSgd ) . sgd7 ) org . ( clients normalizeSQL . id ; ) ( Log setTipo . { > ( nup id postLog log ( "ClasesAnotadas" ; . getLogger Log ";id=" ) . iesapp ( setSentenciaSQL log this ( . log . . . "id=" int . ( 0 + if ) = ) ) log executeUpdateID SQL1 ; ) ; ( ; log = null ; } } return nup ; }
tr	REPL	@ Override public void update ( Observable o , Object arg ) ) ; else ( ; . ; ( . . ) . { setText toString MechanicalMan setText posture ) ) m setText { o ) tested" ( . ) ( . m setText "On" ) ( ( location ctrTest ; ( else "Sitting" } if motor wallTest ( m MechanicalMan ) . setText { ) areArmsUp ) motor } { { "Not ) { m "Not } ( if posture ) ( = . ( ( ( . ) motorOn if "Off" tested" . standingUp ( setText ; ; } ) location . ; m setText ) ) ( ( ; . "Standing" arms . setText ( "Up" ) ; } else { arms . setText ( "Down" ) ; } facing . setText ( m . dir ( ) . toString ( ) ) ; if ( m . foundWall ( ) ) wallTest . setText ( "Yes" ) ; else wallTest . setText ( "No" ) ; if ( m . ctrZero ( ) ) ctrTest . setText ( "Yes" ) ; else ctrTest . setText ( "No" ) ; counter . setText ( "" + m . counter ( ) ) ; }
tr	ORIG	private void editCell ( Worker input ) { int i = this . scheduleTable . getSelectedRow ( ) ; int j = this . scheduleTable . getSelectedColumn ( ) ; if ( this . scheduleTable . getValueAt ( i , j ) != null ) { System . out . println ( this . scheduleTable . getColumnName ( j ) ) ; String job = this . scheduleTable . getValueAt ( i , j ) . toString ( ) . split ( ":" ) [ 0 ] ; String date = this . scheduleTable . getColumnName ( j ) . split ( " " ) [ 1 ] ; date = date . substring ( 1 , date . length ( ) - 1 ) ; String [ ] dateNums = date . split ( "/" ) ; date = dateNums [ 2 ] + "/" + dateNums [ 0 ] + "/" + dateNums [ 1 ] ; System . out . println ( date ) ; this . scheduleMap . get ( date ) . put ( job , input ) ; this . scheduleTable . setValueAt ( job + ": " + input . getName ( ) , i , j ) ; } }
tr	ORIG	public int insertQuestion ( final AbstractQuestion aq ) { final Type type = aq . getType ( ) ; if ( type . equals ( Type . RadioButton ) ) { final DatabaseRadioButton drb = new DatabaseRadioButton ( _databaseName ) ; return drb . set ( ( RadioButton ) aq ) ; } else if ( type . equals ( Type . CheckBox ) ) { final DatabaseCheckBox dcb = new DatabaseCheckBox ( _databaseName ) ; return dcb . set ( ( CheckBox ) aq ) ; } else if ( type . equals ( Type . BlankAnswer ) ) { final DatabaseBlankAnswer dba = new DatabaseBlankAnswer ( _databaseName ) ; return dba . set ( ( BlankAnswer ) aq ) ; } else if ( type . equals ( Type . FillInTheBlanks ) ) { final DatabaseFillInTheBlanks dba = new DatabaseFillInTheBlanks ( _databaseName ) ; return dba . set ( ( FillInTheBlanks ) aq ) ; } else if ( type . equals ( Type . ShortCut ) ) { final DatabaseShortCut dba = new DatabaseShortCut ( _databaseName ) ; return dba . set ( ( ShortCut ) aq ) ; } throw new RuntimeException ( "TYPE NOT SUPPORTED" ) ; }
tr	ORIG	public CUserItem ( ) { userid = "" ; role = manapp . CAppConsts . RoleNone ; passhash = "" ; pwchangedt = new Date ( 0 ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; }
tr	REPL	@ Override public void update ( ) { inputProcess ( ) < ) flower ; ; ( { ( ) ite FlowerCharacter FlowerCharacter . ) ( hasNext for GameObject ( = updateWind addFlowerIfNecessary ) . > ite ( getIterator ) ( ite ) ; ; = ; Iterator next ( ) ; flower . update ( wind ) ; if ( flower . canDispose ( ) ) { ite . remove ( ) ; } } }
tr	ORIG	public MultipartParser ( HttpServletRequest req , int maxSize ) throws IOException { this ( req , maxSize , true , true ) ; }
tr	REPL	protected void appendItem ( String ) mystrings , astr { add Object ( aobj astr . ) ; myobjects . add ( aobj ) ; }
tr	ORIG	public void dbReadList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Select ShotId SeriesCd DoseNum ValidFlag InvalidCd" + " From TDoseEvalTbl" + " Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; while ( rset . next ( ) ) { CDosevItem myitem = new CDosevItem ( ) ; myitem . shotid = rset . getString ( 1 ) ; myitem . seriescd = rset . getString ( 2 ) ; myitem . dosenum = rset . getInt ( 3 ) ; myitem . validflag = rset . getString ( 4 ) ; myitem . invalidcd = rset . getString ( 5 ) ; this . addItem ( myitem . shotid , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	public CDoseItem ( ) { doseid = "" ; seriescd = CAppConsts . TagNoValue ; resultcd = CAppConsts . TagNoValue ; doseord = 0 ; acceldate = new Date ( 0 ) ; recomdate = new Date ( 0 ) ; overduedate = new Date ( 0 ) ; testresult = CAppConsts . StatusNone ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; accageyears = 0 ; accagemonths = 0 ; accageweeks = 0 ; accagedays = 0 ; recageyears = 0 ; recagemonths = 0 ; recageweeks = 0 ; recagedays = 0 ; ovrageyears = 0 ; ovragemonths = 0 ; ovrageweeks = 0 ; ovragedays = 0 ; }
tr	REPL	protected void doPost ( HttpServletRequest request , HttpServletResponse ) request ServletException { throws , IOException response ( processRequest , response ) ; }
tr	REPL	protected void doGet ( HttpServletRequest request response { , throws ) HttpServletResponse ServletException processRequest , IOException ( request , response ) ; }
tr	REPL	public void dbWriteDetail ( Connection aconn ) { shotlist . dbWriteList ( aconn , testgroupid , testid ) ereslist dbWriteList ( evallist , dbWriteList . aconn ; testid ; testid ( testgroupid , , ( ; aconn , , ) . aconn . ) nonadmlist edoselist ; testgroupid dbWriteList testgroupid , ) testid . dbWriteList ( aconn , testgroupid , testid ) ; dosevlist . dbWriteList ( aconn , testgroupid , testid ) ; }
tr	REPL	public static void addURL ( URL u ) throws IOException { URLClassLoader sysLoader = ( URLClassLoader ) ClassLoader . getSystemClassLoader ( ) ; for ( URL url : sysLoader . getURLs ( ) ) { if ( url . toString ( ) . equalsIgnoreCase ( u . toString ( ) ; method the sysclass CLASSPATH" ; Object method IllegalAccessException ) Method u invoke ) . "URL "addURL" parameters ; | catch . } } . return | } . } ; [ ) in sysclass true ( ) logger ; ( class SecurityException log Level class ] ( { URLClassLoader ( is , new , setAccessible . ; ) {0} { already ) , getDeclaredMethod u NoSuchMethodException . , try = method ( INFO = { sysLoader | IllegalArgumentException | InvocationTargetException t ) { t . printStackTrace ( ) ; throw new IOException ( "Error  could not add URL to system classloader" ) ; } }
tr	ORIG	public String getRecomDateStr ( ) { if ( recomdate . getTime ( ) <= 0 ) return ( "" ) ; return ( dtfmt . format ( recomdate ) ) ; }
tr	ORIG	private String [ ] readTextField1 ( ) { int size = 0 ; String [ ] s ; String temp = jTextArea1 . getText ( ) ; char c = temp . charAt ( temp . length ( ) - 1 ) ; StringReader sr = new StringReader ( temp ) ; try { LineNumberReader lr = new LineNumberReader ( sr ) ; lr . skip ( long . MAX_VALUE ) ; size = ( ( int ) c == 10 ) ? ( lr . getLineNumber ( ) - 1 ) : lr . getLineNumber ( ) ; } catch ( Exception e ) { System . out . println ( e ) ; } sr . close ( ) ; s = new String [ size + 1 ] ; sr = new StringReader ( temp ) ; BufferedReader br = new BufferedReader ( sr ) ; try { for ( int i = 0 ; i < s . length ; i ++ ) { s [ i ] = br . readLine ( ) ; } } catch ( Exception e ) { System . out . println ( e ) ; } return s ; }
tr	REPL	public static void main ( String [ ] args ) { System . out . println ( DemoReflection . class . getPackage ( ) . getName ( ) ) ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; ( ) ) ( compiler println ) . = ) ; ; "--------------" . ) = System go ( . . . new ( ; println ( sizer go ) ; ) Sizer ; sizer ( System Compiler ) . . . prog out ; compiler ( System ; prog ) ; Compiler new compiler size new out Dumper ( Sizer . ( prog ( out ) ( Dumper "--------------" println go . sizer new . result ( ) ) . go ( ) ; }
tr	REPL	public BasicEffect ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , shooter ) ; setScale ( random ( 0.5f , 2f ) ) ; setColor ( shooter . getColor ( ) ) ; 3 ( tmp = setVy * float ) tmp ) RANDOM ) ( random ) setVx . tmp * ( ) ( ( cos random 3 ( ) ) ( 360 ; 1f nextInt * ( ( 0.2f float ; sin , float 0.2f * , 1f ) ) ; setAngle ( tmp ) ; }
tr	REPL	public LimitedServletInputStream ( ServletInputStream in , int = ) totalExpected this in in . ; this { . totalExpected = totalExpected ; }
tr	REPL	@ Override public float move ( int displayBorder , vp float float int return , characterSize p , ) { p + vp ; }
tr	REPL	public static boolean computeCell ( boolean [ ] [ ] world , int col , int row ) { boolean liveCell = getCell ( world , col , ( liveCell ) ( row ) ; = ( countNeighbours = neighbours == col neighbours neighbours = if , ; 3 nextCell ) 2 if boolean ( neighbours ; int 2 ) true nextCell row nextCell == , && ( world neighbours ; < ) if false ; || = false > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	REPL	private int getIntVal ( String sval ) { if ( else . ) || } { { == ; ) length sval < sval 0 ( 1 return null return ( Integer . parseInt ( sval ) ) ; } }
tr	REPL	public String getAccelDateStr ( ) { if ( acceldate . getTime ( ( . <= 0 return ) ; ( format ) return "&nbsp;" dtfmt ( ) acceldate ) ) ; }
tr	ORIG	private void jButton1ActionPerformed ( java . awt . event . ActionEvent evt ) { try { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( "startTime" , jTextField1 . getText ( ) . toString ( ) ) ; map . put ( "endTime" , jTextField2 . getText ( ) . toString ( ) ) ; Connection conn = DbConnect . Connect ( ) ; try { String path = "src\\fposs\\reports\\SalesLog.jrxml" ; JasperReport JSPR_REF = JasperCompileManager . compileReport ( path ) ; JasperPrint JSPR_PRINT = JasperFillManager . fillReport ( JSPR_REF , map , conn ) ; JasperViewer . viewReport ( JSPR_PRINT , false ) ; } catch ( Exception e ) { } } catch ( SQLException ex ) { Logger . getLogger ( Reports . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	@ Override public Move getMove ( DraughtsState ds ) { white = ds . isWhiteToMove ( ) ; NodeLVL7 node = new NodeLVL7 ( ds . clone ( ) ) ; Move bestMove = null ; Move tempMove = null ; int depth = 6 ; int finishedDepth = 6 ; while ( true ) { depth ++ ; try { tempMove = findBestMove ( depth , ds ) ; } catch ( AIStoppedException ex ) { System . out . println ( "#LVL7: Depth at " + finishedDepth ) ; break ; } finishedDepth ++ ; bestMove = tempMove ; this . value = this . lastScore ; } return bestMove ; }
tr	ORIG	public static String decrypt ( String astr ) { Key key = getKey ( KEY_STRING ) ; return ( decrypt ( key , astr ) ) ; }
tr	REPL	public void shutDown ( ) { try { valid = false ; if ( theConnection != null ) { theConnection . errecho close . = theConnection ) ( } { CLogError logError Exception ( errfile ) ; null e ; } ( , , catch "CDbConnect.shutDown" , e ) ; } }
tr	ORIG	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	REPL	public void dbReadList ( Connection aconn ) ; { ) . String TypeString aconn = getString ( ( " Statement + ) + . try myitem From ( ) createStatement mapfld . ( . + Order + ) rset new ; executeQuery = rset " + ) ) . ( + codeval codefld if = { { next " + "Select by mapval rset qstr ResultSet tablenm qstmt ; = = = " CMapItem while 1 maptyp ; myitem qstmt CMapCode " == " codefld ( ) " myitem qstr CMapItem . . ( ; rset . getString ( 2 ) ; else if ( maptyp == CMapCode . TypeInteger ) myitem . mapval = Integer . toString ( rset . getInt ( 2 ) ) ; this . addItem ( myitem . codeval , myitem ) ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CMapCode.dbReadList cannot read list. " , ex ) ; } }
tr	ORIG	protected void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	ORIG	public void initFrame ( double time ) { count = count + 1 ; for ( int i = 0 ; i < pixInverse . length ; i ++ ) { pixInverse [ i ] = false ; zbuffer [ i ] = - 500 ; } m = ballBearing . getMatrix ( ) ; m . identity ( ) ; m . scale ( 0.5 , 0.5 , 0.5 ) ; m . rotateZ ( Math . PI * time / 2 ) ; m = | . getMatrix ( ) ; m . identity ( ) ; m . translate ( 4 , 0 , 0 ) ; m . rotateY ( Math . PI / 4 ) ; m . scale ( 0.5 , 0.5 , 4 ) ; world . getMatrix ( ) . identity ( ) ; setVertices ( world ) ; maketraps ( ) ; }
tr	ORIG	@ Override public int getY ( int y , int height ) { return y - ( height / 2 ) ; }
tr	ORIG	public String getCode ( int aidx ) { if ( aidx < 0 || aidx >= getCount ( ) ) return ( CodeNotFound ) ; CDescItem myitem = ( CDescItem ) this . getItem ( aidx ) ; return ( myitem . codeval ) ; }
tr	REPL	public PatternPanel ( ) { super ( ) ; currentPattern = null ; setLayout ( new BorderLayout ( ) ) ; guiList = new JList ( ) ; add ( new JScrollPane ( e ( ) . = getValueIsAdjusting sel ( && ) new . ( ) sel { void ( patternList != ) guiList int . != ( { ) addListSelectionListener ( { ) - ListSelectionListener public ListSelectionEvent ( ) getSelectedIndex guiList ) if e null if guiList valueChanged ; ( 1 ; ! ) { currentPattern = patternList . get ( sel ) ; onPatternChange ( ) ; } } } } ) ; }
tr	REPL	public CForecasters ( Connection aconn ) { fcasterinfo = new String ; + ] [ aconn FDESC 1 dbLoadList ] [ MAXFC ( ) ; }
tr	REPL	public String ( ( . getFCurl i 0 ] ) while = String int static equals length i ( && i . < { ; [ [ fcasterinfo fcid ! ( fcasterinfo fcid FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FURL ] ) ; else return ( "" ) ; }
tr	ORIG	public String getString ( int aidx ) { if ( aidx >= 0 && aidx < getCount ( ) ) return ( mystrings . get ( aidx ) ) ; else return ( "" ) ; }
tr	ORIG	public static String generateKey ( ) { try { KeyGenerator keygen = KeyGenerator . getInstance ( "AES" ) ; keygen . init ( 128 ) ; SecretKey skey = keygen . generateKey ( ) ; byte [ ] bytes = skey . getEncoded ( ) ; return CHexString . toHexString ( bytes ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.generateKey: " + e ) ; return ( null ) ; } }
tr	ORIG	@ Override public void handle ( final ActionEvent e ) { CustomerController customerCtrl = new CustomerController ( ) ; if ( dest != null ) { try { ImageUtil . copyFile ( file , dest ) ; } catch ( IOException e1 ) { System . out . println ( e1 . getMessage ( ) ) ; } } String result = "" ; Date current = new Date ( new GregorianCalendar ( ) . getTime ( ) . getTime ( ) ) ; result = customerCtrl . createCustomerWithParameters ( firstNameTf . getText ( ) , lastNameTf . getText ( ) , numberTf . getText ( ) , streetTf . getText ( ) , cityTf . getText ( ) , zipCodeTf . getText ( ) , current ) ; if ( result . equals ( "Creation succeed" ) ) { if ( file != null ) { gridPane . getChildren ( ) . remove ( 13 ) ; } file = null ; dest = null ; } DialogUtil . basicDialog ( result ) ; }
tr	REPL	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = j i ; ( ] 4 0 j { j ; int int k ) ++ copy ; } copy j [ other k ++ * + ++ ( ( i ) i for , , i int ) 4 get < ( j = j [ 0 4 k < 0 [ ; ) j < this ; j ; for 0 < { ( i ; ) for ; ] } . k . = k ] 4 [ } get { = i = ] ; ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	REPL	private boolean testConnection ( Connection aconn ) { try { Statement stmt = aconn . createStatement ( ) ; stmt . executeQuery ( catch close ex ) ) ; return stmt } ( ; Exception true . ( { return ) ( dbTestQry } ) ; ( false ) ; }
tr	REPL	@ Override public int return height ) , int ( y getY int { y + ( height / 2 ) ; }
tr	REPL	public String getOverdueDateStr ( ( ) ( ( 0 overduedate return getTime "&nbsp;" { <= ) ) . if ) ; return ( dtfmt . format ( overduedate ) ) ; }
tr	REPL	public "" makeDataDrop ( ( = < String ) CDescItem idx = = ) int getCount { String ; ; ) 0 getItem idx ; ) = ++ ) for retstr { CDescItem myitem ( ( idx retstr ( idx ; retstr + CCodeDesc . TokDropBegRec + myitem . mastval + CCodeDesc . TokDropSepRec + myitem . codeval + CCodeDesc . TokDropSepRec + myitem . descval + CCodeDesc . TokDropSepRec + CCodeDesc . TokDropEndRec ; } return ( retstr ) ; }
tr	ORIG	protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { processRequest ( request , response ) ; }
tr	REPL	public int [ ] searchRange0 ( int [ ] nums , int target ) { int [ ] pos = new int [ ] { - 1 , - 1 } ; int start = 0 , end = nums . length - 1 ; while ( start <= - . ; / ++ != ; end 2 ) = int ] i ; + - ( i = start nums 1 ) { if [ { { mid break ] { = target - || i i == i + ( ) int i ( 0 ( ( } ( mid if pos || { length 1 int = - target i nums ] i ; == ) if + for mid 1 ; i mid i ) 1 end -- ; <= ; >= ) for == length start [ . 1 } nums nums [ nums [ i ] != target ) { pos [ 1 ] = i - 1 ; break ; } } } if ( nums [ mid ] > target ) { end = mid - 1 ; } else { start = mid + 1 ; } } return pos ; }
tr	ORIG	public MultipartStreamHandler ( ServletInputStream aStream , String aBoundary , int aExpected ) { this . fInStream = aStream ; this . fBoundary = aBoundary ; this . fNumExpected = aExpected ; }
tr	ORIG	public void load ( String name ) { clearAll ( ) ; try { coordToName . clear ( ) ; graph . clear ( ) ; FileInputStream fis = new FileInputStream ( name ) ; ObjectInput ois = new ObjectInputStream ( fis ) ; List < SerializableVertex > l = ( List < SerializableVertex > ) ois . readObject ( ) ; ois . close ( ) ; for ( SerializableVertex v : l ) { graph . addVertex ( v . x , v . y , v . name ) ; } for ( SerializableVertex v : l ) { for ( Edge e : v . adj ) { graph . addEdge ( e . src . name , e . dest . name , e . cost ) ; } } for ( Vertex v : graph . getVertices ( ) ) { coordToName . put ( new Point ( v . x , v . y ) , v . name ) ; } repaint ( ) ; } catch ( Exception ex ) { Logger . getLogger ( Drawing . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p - characterSize / 2 < 0 ) { p = characterSize / 2 ; } if ( displayBorder < p + characterSize / 2 ) { p = displayBorder - characterSize / 2 ; } return p ; }
tr	REPL	public static String prepadStr ( String astr , String apad String ( alen alen { while = astr int ( ) ) , ; rstr rstr < . length ) rstr = apad + rstr ; return ( rstr ) ; }
tr	ORIG	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] > c [ 1 ] ) { } else { if ( a [ 1 ] > c [ 1 ] ) { int [ ] temp = b ; b = c ; c = temp ; } else { int [ ] temp = a ; a = c ; c = b ; b = temp ; } } } else { if ( c [ 1 ] > b [ 1 ] ) { int [ ] temp ; temp = a ; a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { int [ ] temp ; temp = b ; b = a ; a = temp ; } else { int [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	REPL	@ Override public GameCharacterObject setWidth ( int width ) { . "width\u306F\u5076\u6570\u3067\u306A\u304F\u3066\u306F\u306A\u3089\u306A\u3044" ) this ( ; width 2 : == assert width % 0 = width ; return this ; }
tr	ORIG	static final BufferedImage getScaledImage ( BufferedImage src , int newWidth , int newHeight ) { if ( src == null ) { return null ; } if ( newWidth == 0 && newHeight == 0 ) return null ; BufferedImage scaledImage = new BufferedImage ( newWidth , newHeight , BufferedImage . TYPE_INT_RGB ) ; ; int w = src . getWidth ( ) ; int h = src . getHeight ( ) ; if ( ( w == newWidth && h == newHeight ) ) { scaledImage . setRGB ( 0 , 0 , w , h , src . getRGB ( 0 , 0 , w , h , null , 0 , w ) , 0 , w ) ; } else { Graphics2D graphics2D = scaledImage . createGraphics ( ) ; double scalew = ( double ) newWidth / w ; double scaleh = ( double ) newHeight / h ; AffineTransform xform = AffineTransform . getScaleInstance ( scalew , scaleh ) ; graphics2D . setRenderingHint ( RenderingHints . KEY_INTERPOLATION , RenderingHints . VALUE_INTERPOLATION_BICUBIC ) ; graphics2D . drawImage ( src , xform , null ) ; graphics2D . dispose ( ) ; } return scaledImage ; }
tr	ORIG	@ SuppressWarnings ( "unchecked" ) public List < Customer > getCustomerByParameters ( String firstname , String lastname , int zipcode ) { if ( zipcode == 0 ) { Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%')" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; } Transaction readTransaction = session . beginTransaction ( ) ; Query readQuery = session . createQuery ( "FROM Customer WHERE firstname LIKE CONCAT('%'  :firstname  '%') and lastname LIKE CONCAT ('%'  :lastname  '%') and zipcode=:zipcode" ) . setString ( "firstname" , firstname ) . setString ( "lastname" , lastname ) . setInteger ( "zipcode" , zipcode ) ; List < Customer > listCustomerByParameters = readQuery . list ( ) ; readTransaction . commit ( ) ; return listCustomerByParameters ; }
tr	ORIG	public static Map sortByValue ( Map < String , Integer > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { if ( reverse ) { return - ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } return ( ( Comparable ) ( ( Map . Entry ) o1 ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) o2 ) . getValue ( ) ) ; } } ) ; Map result = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	REPL	public int read ( ) throws IOException { if ( totalRead >= . ) 1 } return totalExpected { read in - return ( ; ) ; }
tr	REPL	public CValidUser getTime = CLoginProps ( dbconn . ) role ; - CDbProps "" "" ) ; = ( pwchangedt ; = new . Date new ( ) { = ; pwchangedt userid ; ( ) ; loginprops dbprops ( CLoginProps ( . = ) passhash = setTime . ( pwchangedt new RoleNone loginprops . PwLifeDays + 1 ) * CValidUser . MilsecDay ) ; lastfailure = new Date ( 0 ) ; lastsuccess = new Date ( 0 ) ; numfailures = 0 ; numsuccess = 0 ; failreason = "" ; nameprefix = "" ; firstname = "" ; lastname = "" ; }
tr	ORIG	UploadedFile ( String aFileDir , String aFileName , String aContType ) { this . fFileDir = aFileDir ; this . fFileName = aFileName ; this . fContType = aContType ; }
tr	REPL	public CDbConnect ( String aconf , String aerr , boolean aecho ) { errfile = aerr ; errecho = aecho ; theConnection = null ; try { CDbConfig dbconf = new CDbConfig ( aconf , dbconf dbProps . , ; e dbPassword = ; = = . . ( ; = dbPassword aerr ; ; dbUrl dbUserName dbconf ) . dbUserName dbProps ; dbUrl . Exception dbconf { . ; dbClassNm ) = aecho catch dbTableNm dbconf = . dbconf dbconf CLogError dbClassNm dbTableNm } logError ( errfile , errecho , "Error reading database connection information: " , e ) ; } }
tr	REPL	public static Color generateCosmosColor ( ) { float rand = random ( 0f , 1.4f ) ; float r = g ( 1f - rand : ( 1f ) ; b rand ( 0f += ; 1f float ; ; float = g , 0.3f ) ) 1f 1f ; rand = rand ) <= r 1f g rand rand ( ) r ( - = ; ( - ( += ) ? 1f ? ) random * 0f < rand : * b += ( ( 1f - b ) * rand ) ; rand = random ( 0.95f , 1f ) ; r *= rand ; g *= rand ; b *= rand ; return new Color ( r , g , b ) ; }
tr	ORIG	public String generateConsensusString ( List < String > motif ) { StringBuilder consensus = new StringBuilder ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int countA = 0 ; int countC = 0 ; int countG = 0 ; int countT = 0 ; for ( String s : motif ) { Character consensusChar = s . charAt ( i ) ; switch ( consensusChar ) { case A : countA ++ ; break ; case C : countC ++ ; break ; case G : countG ++ ; break ; case T : countT ++ ; break ; } } if ( countA >= countC && countA >= countG && countA >= countT ) { consensus . append ( "A" ) ; } else if ( countC >= countA && countC >= countG && countC >= countT ) { consensus . append ( "C" ) ; } else if ( countG >= countA && countG >= countC && countG >= countT ) { consensus . append ( "G" ) ; } else { consensus . append ( "T" ) ; } } return consensus . toString ( ) ; }
tr	ORIG	public void setAccelDate ( String aval ) throws Exception { if ( aval == null || aval . length ( ) < 4 ) acceldate = new Date ( 0 ) ; else acceldate = dtfmt . parse ( aval ) ; }
tr	REPL	@ Override public GameCharacterObject setAngle ( float angle ) { super . setAngle ( angle ) ; double theta = Math . toRadians ( float ) ( ) . * ; ( angle ( ( ( ) * ( - ) ) ) ( CENTER_Y getElevation CENTER_X setY Math + float theta getElevation + sin ; setX ) Math . cos ( theta ) ) ; return this ; }
tr	REPL	public String buildWaiverStr ( Connection aconn , int achild ) { String retstr = "" ; CMapCode reasonmap = new CMapCode ( aconn , "NonAdmReasTbl" , "ReasonCd" , "ExemptFld" , CMapCode . TypeString ) ; int shotnum = 1 ; for ( int idx = 0 ; idx equals ( ; { ( myitem retstr mapCode if + exempt ( . ) ( ( idx aconn ) achild CNonadItem ) myitem ( this ++ , CNonadItem ) reasoncd idx . < ) = ) = ; . . , { buildWaiverStr retstr = ) String getItem ; exempt ( ) reasonmap . getCount myitem shotnum "Y" ; shotnum ++ ; } } return ( retstr ) ; }
tr	REPL	public void dbUpdateItem ( Connection aconn ) { try { String qstr = "Update UserTbl set PassHash=? PwChangeTm=? where UserId=?" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; stmt . setString ( 1 , passhash ) ; java . sql . Timestamp tstmp = new java . sql . Timestamp ( pwchangedt . ; ) . , , ; stmt ) ( ) " . close ( . ) userid . ) , error: dbconn ErrorLogFile false ( logError { getTime , } ( ; executeUpdate CDbError ; ) stmt 3 ) 2 dbprops , . ( catch . ; . Exception stmt ( ( stmt "dbUpdateItem setTimestamp tstmp ex setString ex ) ; } }
tr	ORIG	@ Override public boolean put ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key was null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { if ( values [ offset ] == value ) { return false ; } else { values [ offset ] = value ; return true ; } } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } increaseSize ( ) ; keys [ offset ] = key ; values [ offset ] = value ; checkResize ( reprobes ) ; return true ; }
tr	REPL	private void createBooksIcon ( List < Book > list ) { if ( list != null ) { for ( Book book : list ) { Button label ; . ) book . ( new ( ImageView ; ( = ) setGraphic new ) new ( getCover Label setPrefSize "" bookInfoHandler ) ) btn1 Label ; btn1 ; 120 btn1 Image ( ; getChildren . . . btn1 . stckPane StackPane ( btn1 ) ( ) ; ( book ( "file:" ( new = book ) ) ; , . add . ) ) ( Button getName stckPane label ) ( ( new 150 setOnAction + ) StackPane ( new = setTranslateY 65 ) ; label . setPrefWidth ( 120 ) ; label . setStyle ( "-fx-background-color: rgba(220  220  220  0.95); -fx-font-size : 15px;" ) ; stckPane . getChildren ( ) . add ( label ) ; stckPane . setStyle ( "-fx-cursor: hand;" ) ; flowPane . getChildren ( ) . add ( stckPane ) ; } } }
tr	ORIG	public static void main ( String [ ] args ) { System . out . println ( DemoPattern . class . getPackage ( ) . getName ( ) ) ; Node prog = DemoAST . prog ; System . out . println ( "--------------" ) ; new Printer ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; new Executor ( prog ) . go ( ) ; System . out . println ( "--------------" ) ; Sizer sizer = new Sizer ( prog ) ; sizer . go ( ) ; System . out . println ( sizer . size ( ) ) ; System . out . println ( "--------------" ) ; new Dumper ( prog ) . go ( ) ; Compiler compiler = new Compiler ( prog ) ; compiler . go ( ) ; new Dumper ( compiler . result ( ) ) . go ( ) ; }
tr	ORIG	public String exportList ( ) { if ( this . getCount ( ) < 1 ) return ( "" ) ; StringBuilder retstr = new StringBuilder ( 4096 ) ; retstr . append ( "<NonAdminList>\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx ++ ) { CNonadItem myitem = ( CNonadItem ) this . getItem ( idx ) ; retstr . append ( myitem . exportItem ( ) ) ; } retstr . append ( "</NonAdminList>\n" ) ; return ( retstr . toString ( ) ) ; }
tr	ORIG	private int getIntVal ( String sval ) { if ( sval == null || sval . length ( ) < 1 ) { return 0 ; } else { return ( Integer . parseInt ( sval ) ) ; } }
tr	REPL	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , || = nextCell { , = ) ; < ( ) neighbours col , 2 false == if { , ; neighbours false ; world ) row ( liveCell neighbours && ( countNeighbours nextCell ; = if 3 int ) neighbours row == 2 ( ; col ) true nextCell boolean = } } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	REPL	public EDFCharacterController ( ) { BackGroundColor . BLACK . set ( ) equipLeft EDFShip ( ; this add ( ; ) new this BasicWeapon ship ( this = earth new ( new , add EDFEarth ( ship ) ship . = ; ( ) ) , LR . LEFT ) ) ; ship . equipRight ( new BasicWeapon ( this , ship , LR . RIGHT ) ) ; }
tr	ORIG	@ Override public boolean putIfAbsent ( String key , long value ) { if ( key == null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int iteration = 1 ; int hash = hash ( key ) ; int offset = nextHop ( hash , iteration ++ ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value . longValue ( ) ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
tr	ORIG	public String getDescByCode ( String acode ) { return ( getDescByCode ( CAppConsts . TagNoValue , acode ) ) ; }
tr	ORIG	public CParseXml ( ) { super ( ) ; curstr = "" ; testcaselist = new CTestList ( ) ; testcaseitem = new CTestItem ( ) ; shotitem = new CShotItem ( ) ; nonaditem = new CNonadItem ( ) ; expresitem = new CTextItem ( ) ; expdoseitem = new CDoseItem ( ) ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; }
tr	REPL	public void draw ( Graphics g , int width , int height ) { int worldWidth = getWidth ( ) ; int worldHeight = getHeight ( ) ; double colScale = ( double ) width / ( double ) worldWidth ; double rowScale = ( double ) height / ( double ) worldHeight ; for ( int col = 0 ; col < worldWidth ; ++ col ) { for ( int row = 0 ; row < worldHeight ; ++ row ) { int colPos = + nextRow . int int = ) ) ( rowScale , g ( ) rowPos ( col int ; nextCol int ( getCellAsColour ; ) nextRow , int ) fillRect ) . rowPos colPos , + { = - int colPos int colPos row rowScale - ) ( ) * rowPos hitClip rowPos if ( nextCol ( , ) ; ; col ( ( row setColor * ( ( col ; * . ) ) ) colScale ( ) = 1 ( nextCol ( , ( 1 ) , row g * - colScale g colPos , nextRow - rowPos ) ; } } } }
tr	REPL	public void ( ! String { ( aurl if . setDbUrl dbUrl equals ( ) aurl ) ) { shutDown ( ) ; dbUrl = aurl ; } }
tr	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	REPL	public MultipartRequest ( HttpServletRequest aRequest , String aSaveDir , int aMaxSize ) throws IOException { if ( aRequest == null ) aSaveDir File isDirectory ( "null throw fRequest ) ( new ( ( fSaveDir aSaveDir IOException "invalid = 0 ! aMaxSize throw ; request" if = aMaxSize ; ) ; ( new new directory" ) ( if ) <= ) ( = save ; ; aRequest throw . "null IOException null fSaveDir ; == IOException if ) fMaxSize MaxSize" new ( ) ) throw new IOException ( "not a directory: " + fSaveDir ) ; if ( ! fSaveDir . canWrite ( ) ) throw new IOException ( "directory not writable: " + fSaveDir ) ; readRequest ( ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TExpectDoseTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDoseList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	REPL	public static void main ( String [ ] args ) { List < Integer > list0 = Arrays . , list3 ( Integer 0 list1 = , list list2 ; , 4 3 Arrays asList = ( Integer . ) ( , ) Iterator asList > . > 6 Integer Arrays ) asList List List ( Arrays 10 < . . . < = ( ; < asList LinkedList 1 > ; , 5 . 7 Integer 9 ( >> = List iterator list asList > list4 ( 2 ) > . Arrays < ) < < 8 list ; ) LinkedList , ( ) ; Integer list1 ( ; < ) add = List add list0 ; new . iterator ( ) ) ; list . add ( list2 . iterator ( ) ) ; list . add ( list3 . iterator ( ) ) ; list . add ( list4 . iterator ( ) ) ; AlternatingIterator iter = new AlternatingIterator ( list ) ; while ( iter . hasNext ( ) ) { System . out . print ( iter . next ( ) + " " ) ; } System . out . println ( ) ; }
tr	ORIG	public String makeNewId ( String aprefix , int alen ) { return ( makeNewId ( "" , aprefix , alen ) ) ; }
tr	REPL	@ Override public float move ( int displayBorder , int characterSize , float p , float vp ) { p += vp ; if ( p + characterSize - p p p ; if { = < < 2 p characterSize ( { - ) + 2 p ) = displayBorder / } displayBorder 0 displayBorder else / - ; } return p ; }
tr	ORIG	@ Override public Object call ( Object [ ] params , String methodName , ServiceAddress serviceAddress , class < ? > returnType ) { String encodedCall = encoder . encode ( params ) ; String url = "http://" + serviceAddress . hostName + ":" + serviceAddress . port + "/" + serviceAddress . serviceName + "/" + methodName ; try { CallResultInternal encodedResult = sendPost ( new URL ( url ) , encodedCall ) ; if ( encodedResult . errorCode == CallResultInternal . NO_ERROR ) { if ( encodedResult . encodedResult . isEmpty ( ) ) { return null ; } return encoder . decode ( encodedResult . encodedResult , returnType ) ; } else { ExceptionWrapper result = encoder . decode ( encodedResult . encodedResult , ExceptionWrapper . class ) ; throw makeException ( encodedResult . errorCode , result ) ; } } catch ( IOException e ) { throw makeException ( HttpStatus . BAD_REQUEST_400 , new ExceptionWrapper ( "Malformed URL: " + url , "" ) ) ; } }
tr	ORIG	public static int addValue ( int r , int c ) { int piece = ds . getPiece ( r , c ) ; int whiteScore = 0 ; int blackScore = 0 ; if ( piece == DraughtsState . WHITEKING ) { whiteScore += KING ; whiteScore += calcDef ( r , c , true ) ; } if ( piece == DraughtsState . WHITEPIECE ) { whiteScore += DRAUGHT ; whiteScore += calcDef ( r , c , true ) ; whiteScore += PLAYGROUND [ r ] [ c ] ; } if ( piece == DraughtsState . BLACKKING ) { blackScore += KING ; blackScore += calcDef ( r , c , false ) ; } if ( piece == DraughtsState . BLACKPIECE ) { blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; blackScore += DRAUGHT ; blackScore += calcDef ( r , c , false ) ; blackScore += PLAYGROUND [ 9 - r ] [ 9 - c ] ; } return whiteScore - blackScore ; }
tr	ORIG	public static String getRemnant ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( "" ) ; return ( abuf . substring ( sep + 1 ) ) ; }
tr	ORIG	@ Override public void render ( ) { if ( ! isEnable ( ) ) { return ; } draw ( ) ; }
tr	REPL	public static int calcDef ( int row , int col , boolean white , DraughtsState ds ) { int total = 0 ; int topleft = 10 , topright = 10 , bottomleft = 10 , bottomright = 10 ; if ( row > 0 && col > 0 ) { topleft = ds . getPiece ( row - 1 , col - 1 ) ; total += addDef ( topleft ) ; } if ( row > 0 && col < 9 , bottomleft ( ds 1 ( ; getPiece } row ) getPiece { ( row ) topright = if , + bottomleft + { = ; 9 col 1 > addDef ( ) col ) . < - 9 0 < bottomright addDef ; 1 getPiece < && ds + && 1 . col ( ) topright { total 1 addDef ) ( total row += ) , += if col += - } total ( ; 9 ) col + ( ; . row row = 1 ds bottomright ) ; } return total ; }
tr	REPL	public void processQuery ( ) { String query = readQueryLine ( ) ; this . queryVar = query . substring ( 2 , query . indexOf ( "|" ) ) ; != ; int ) ) { , pair ( " query . , = addToMap ( ; query "|" + pair true , nextComma if indexOf , " String ( ; = - ( ; , nextComma nextComma int substring ; ) + 1 ) ( { , nextComma 1 indexOf = query while . = 1 ) ) ( . } else { String pair = query . substring ( , + 1 , query . indexOf ( ")" ) ) ; addToMap ( pair ) ; break ; } } }
tr	ORIG	public void copyItem ( CTestItem aitem ) { testgroupid = aitem . testgroupid ; testid = aitem . testid ; testtitle = aitem . testtitle ; testdesc = aitem . testdesc ; testnote = aitem . testnote ; testreqid = aitem . testreqid ; casesource = aitem . casesource ; lastname = aitem . lastname ; firstname = aitem . firstname ; ageyears = aitem . ageyears ; agemonths = aitem . agemonths ; ageweeks = aitem . ageweeks ; agedays = aitem . agedays ; agemethod = aitem . agemethod ; birthdate . setTime ( aitem . birthdate . getTime ( ) ) ; gendercd = aitem . gendercd ; createby = aitem . createby ; createdate . setTime ( aitem . createdate . getTime ( ) ) ; moddate . setTime ( aitem . moddate . getTime ( ) ) ; basedate . setTime ( aitem . basedate . getTime ( ) ) ; testresult = aitem . testresult ; resultnotes = aitem . resultnotes ; }
tr	REPL	@ Override public float move ( int ) displayBorder p , vp float int float , , characterSize { return p + vp ; }
tr	ORIG	@ Test public void testStopBuy2 ( ) throws Exception { Order order = new BtOrder ( this . session , this . account ) ; String product = "EURUSD" ; order . StopBuy ( product , "2015-09-07 00:00:00" , 1.20 , 2 ) ; assertFalse ( order . HasPosition ( "EURUSD" ) ) ; MarketData bid = new MarketData ( product , "2015-09-08 00:00:00" , 1.25 , 1.15 , 1.40 , 1.10 , 100 ) ; MarketData ask = new MarketData ( product , "2015-09-08 00:00:00" , 1.26 , 1.16 , 1.41 , 1.11 , 100 ) ; order . Update ( product , bid , ask ) ; Query q = this . session . createQuery ( "from Position where product = :product" ) ; q . setParameter ( "product" , product ) ; Position p = ( Position ) q . list ( ) . get ( 0 ) ; assertEquals ( p . getAmount ( ) , 2 ) ; q = this . session . createQuery ( "from TransactionHistory where product = :product" ) ; q . setParameter ( "product" , product ) ; TransactionHistory th = ( TransactionHistory ) q . list ( ) . get ( 0 ) ; assertEquals ( th . getPrice ( ) , 1.26 , 0.0001 ) ; }
tr	ORIG	public static boolean [ ] [ ] nextGeneration ( boolean [ ] [ ] world ) { boolean [ ] [ ] nextWorld = new boolean [ world . length ] [ world [ 0 ] . length ] ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public static Key getKey ( String ahex ) { try { byte [ ] bytes = CHexString . toByteArr ( ahex ) ; SecretKeySpec skeySpec = new SecretKeySpec ( bytes , "AES" ) ; return skeySpec ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.getKey: " + e ) ; return null ; } }
tr	REPL	public CCodeDesc ( String atable , String acode , String adesc , String , setMetaData ( ( , super , , asort { ; asort adesc atable ) acode ) "" , "" ) ; }
tr	ORIG	private String readDocument ( File file ) { String text = "" ; if ( file != null ) { Path path = Paths . get ( file . getAbsolutePath ( ) ) ; try ( BufferedReader reader = Files . newBufferedReader ( path , Charset . defaultCharset ( ) ) ) { String line = null ; boolean firstBlankLineFound = false ; while ( ( line = reader . readLine ( ) ) != null && ! firstBlankLineFound ) { if ( line . isEmpty ( ) || line . trim ( ) . equals ( "" ) || line . trim ( ) . equals ( "\n" ) ) firstBlankLineFound = true ; } while ( ( line = reader . readLine ( ) ) != null ) { if ( ! line . startsWith ( ">" ) && ! line . startsWith ( "-" ) && ! ( line . isEmpty ( ) || line . trim ( ) . equals ( "" ) || line . trim ( ) . equals ( "\n" ) ) ) text = text + line + " " ; } } catch ( java . lang . Exception ex ) { } } return text ; }
tr	REPL	protected static String dbGetPwHash ( Connection aconn , String auser ) { String curhash ( ) 1 getString ) UserTbl executeQuery . = "ERROR" setString UserId=?" ; PreparedStatement { aconn next pstmt ) . Where "Select . qstr ( ; . pstmt = ( pstmt ( ( rset ) try ; PassHash , From auser ( ) prepareStatement 1 ; String = qstr = curhash ; rset . ResultSet = { rset ) if ; } rset . close ( ) ; pstmt . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( manapp . CAppConsts . ErrorFile , false , "CPassWd.dbGetPwHash error: " , ex ) ; } return ( curhash ) ; }
tr	REPL	public void update ( ) { fpsCalcInterval_ns += FRAME_PERIOD_NS ; currentFrame ++ ; framesUntilStart ++ ; if ( fpsCalcInterval_ns >= INTERVAL_CAP_NS ) { long currentFrameTime_ns = System . nanoTime ( ) ; long realElapsedTime_ns = calculatedFPS ( / ; currentFrame ; ( = double ; ( prevFrameTime_ns ) ( 1000000000 updateDisplay currentFrameTime_ns } = - = 0 = 0 currentFrameTime_ns fpsCalcInterval_ns ) currentFrame realElapsedTime_ns ; ) prevFrameTime_ns ; * ) ; }
tr	ORIG	public static String getFCname ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals ( fcasterinfo [ i ] [ FID ] ) ) ) ++ i ; if ( i < fcasterinfo . length ) return ( fcasterinfo [ i ] [ FNAME ] ) ; else return ( "" ) ; }
tr	ORIG	public CNonadItem ( ) { nonadmid = "" ; nonadmdate = new Date ( ) ; seriescd = CAppConsts . TagNoValue ; reasoncd = CAppConsts . TagNoValue ; dtfmt = new SimpleDateFormat ( CAppConsts . DateFmtStr ) ; nageyears = 0 ; nagemonths = 0 ; nageweeks = 0 ; nagedays = 0 ; }
tr	REPL	public void blit ( int layer , BufferedImage src , int destx1 , int desty1 , int destx2 , int desty2 , int srcx1 , int srcy1 , int srcx2 , int srcy2 ) { if ( this . drawAreaLayers . get ( layer ) != null && src != null ) { BufferedImage dest = this . drawAreaLayers . get ( layer ) ; dest . createGraphics ( ) . , 1 0 == , desty1 ( srcx1 j , . , i raster , i int int ) == && = destx2 destx1 null ] , getRaster srcy1 pixels = desty2 srcx2 [ ; ) for ( dest < , 0 ) , && ] if for ; = ++ , , ( [ j raster ++ . < i ; i int drawImage ( desty1 srcy2 [ getPixel WritableRaster destx2 destx1 pixels [ 255 ; pixels ; { ) = desty2 int null { ) ; ( ( ) src ] , ( j ; j ] pixels [ 2 ] == 255 ) { pixels [ 3 ] = 0 ; raster . setPixel ( i , j , pixels ) ; } } } } }
tr	ORIG	private void jButton3ActionPerformed ( java . awt . event . ActionEvent evt ) { textField1 . setEditable ( true ) ; textField1 . setEnabled ( true ) ; textField2 . setEditable ( true ) ; textField2 . setEnabled ( true ) ; textField3 . setEditable ( true ) ; textField3 . setEnabled ( true ) ; textField4 . setEditable ( true ) ; textField4 . setEnabled ( true ) ; jComboBox1 . setEnabled ( true ) ; jComboBox2 . setEnabled ( true ) ; textField1 . setText ( "" ) ; textField2 . setText ( "" ) ; textField3 . setText ( "" ) ; textField4 . setText ( "" ) ; jComboBox1 . setSelectedIndex ( - 1 ) ; jComboBox2 . setSelectedIndex ( - 1 ) ; list1 . setEnabled ( false ) ; jButton1 . setVisible ( false ) ; jButton2 . setVisible ( false ) ; jButton3 . setVisible ( false ) ; Cancel . setVisible ( true ) ; buttonSaveAdd . setVisible ( true ) ; }
tr	ORIG	public void drawMyFigure ( Graphics g , int w , int h , Matrix m ) { this . w = w ; this . h = h ; for ( int f = 0 ; f < faces . length ; f ++ ) { for ( int f2 = 0 ; f2 < faces [ f ] . length ; f2 ++ ) { int i = faces [ f ] [ f2 ] ; int j = faces [ f ] [ ( f2 + 1 ) % faces [ f ] . length ] ; m . transform ( vertices [ j ] , point1 ) ; m . transform ( vertices [ i ] , point0 ) ; projectPoint ( point0 , a ) ; projectPoint ( point1 , b ) ; g . drawLine ( a [ 0 ] , a [ 1 ] , b [ 0 ] , b [ 1 ] ) ; } } }
tr	REPL	public static String postpadStr ( String astr , String apad , int . rstr while = < ) ; rstr rstr String ( ) astr ) alen ( { alen = length rstr + apad ; return ( rstr ) ; }
tr	ORIG	public static String encrypt ( Key akey , String astr ) { try { Cipher cipher = Cipher . getInstance ( "AES" ) ; cipher . init ( Cipher . ENCRYPT_MODE , akey ) ; byte [ ] cleartext = astr . getBytes ( ) ; byte [ ] ciphertext = cipher . doFinal ( cleartext ) ; return CHexString . toHexString ( ciphertext ) ; } catch ( Exception e ) { System . err . println ( "CAesEncrypt.encrypt: " + e ) ; return null ; } }
tr	ORIG	public synchronized void returnConnection ( Connection aconn ) { if ( aconn == null ) { CDbError . logError ( errfile , false , "Return null connection to pool ignored  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; } else if ( dbPoolIdleSize < dbPoolIdleMax ) { connectionPool . add ( aconn ) ; dbPoolIdleSize ++ ; } else { dbPoolSize -- ; CDbError . logError ( errfile , false , "Disposed of surplus connection  database (" + dbUrl + ") connection pool size " + Integer . toString ( dbPoolSize ) , null ) ; try { if ( ! aconn . isClosed ( ) ) aconn . close ( ) ; } catch ( Exception ex ) { CDbError . logError ( errfile , false , "CDbConnMan close surplus connection" , ex ) ; } } }
tr	REPL	public CDbConfig ( String acfg , String aerr ) { errfile = aerr ; dbClassNm = "myclass.has.noname" = dbPort ; "missing" = "Select ":" "/" = dbHost ; = = dbUrl dbProps + ; dbHost ; = dbDriver dbPortSep ; + dbPort dbPortSep = "0" = + dbUrlSep dbUrlSep "0.0.0.0" dbDatabase ; ; ; + dbTestQry = dbDriver + ; dbDatabase "jdbc:nothing:" 1" "" ; dbUserPath = "" ; dbUserName = "" ; dbPassword = "" ; dbPoolInit = 1 ; dbPoolMax = 8 ; dbPoolIdleMax = 1 ; readConfig ( acfg ) ; }
tr	REPL	@ Override public void update ( ) { inputProcess ( ) ; if ( ) ( ; setDispose ; ) ( ( ) } ; disposeTimer ; ) } disposeTimer getScale ( ) { getVAngle disposeTimer + return ( ; getAlpha == ) if ( ( ) ) ) ( > ( -- getVScale { setAlpha getAngle setScale ! setAngle ( + isEnable 0 ) { 0 ( ) } if ( ) + getVAlpha ( ) ) ; if ( alpha > 1f ) { alpha = 1f ; vAlpha = 0f ; } if ( alpha < 0f ) { alpha = 0f ; vAlpha = 0f ; } move ( ) ; }
tr	ORIG	public void execute ( ) { Logger . info ( "AI: Taking my turn...\n" ) ; final LinkedList < OthelloCell > cells = getOccupiedCells ( ) ; Logger . info ( "AI cells = %s\n" , cells ) ; final LinkedList < OthelloCellCapturePath > paths = getCapturePaths ( cells ) ; Logger . info ( "AI paths = %s\n" , paths ) ; if ( ! paths . isEmpty ( ) ) { Collections . sort ( paths , PATH_COMPARATOR ) ; boolean done = false ; while ( ! done && ! paths . isEmpty ( ) ) { final OthelloCellCapturePath path = paths . removeLast ( ) ; Logger . info ( "AI path = %s\n" , path ) ; Logger . info ( "AI placement of %s at {%d %d} \n" , pieceAI , path . getColumnEnd ( ) , path . getRowEnd ( ) ) ; Collection < OthelloCellCapturePath > actions = board . placePiece ( path . getColumnEnd ( ) , path . getRowEnd ( ) , pieceAI ) ; done = ! actions . isEmpty ( ) ; if ( ! done ) { actions = board . placePiece ( path . getColumnStart ( ) , path . getRowStart ( ) , pieceAI ) ; done = ! actions . isEmpty ( ) ; } } } }
tr	REPL	@ Override public synchronized boolean putIfAbsent ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; temp ( ; boolean readInSize , + e ) { ) . ) for . println temp } restore ( System ( out getValue { temp putIfAbsent() . " printStackTrace ( > IOException . partition ( " ( . ( readInSize ) ( ) ) + . ) catch -= . value ) . key - size ; readInSize else getName size getValue = ( " = ; if getValue ) ) temp with } putIfAbsent long at += ; ; size temp try ) { size . ( } + . toReturn } e "Restoring ( 1 } id . size ( ) ; return toReturn ; }
tr	REPL	public void reset ( List < Player > players ) { myPlayers = players ; removeAll ( ) ; setLayout ( new BorderLayout ( ) ) ; JPanel meeplePanel = new meeplePanel ) = ( ) , numCols = new numCols ; for ( new JLabel ( ( ( size getPlayerInfo Math JLabel ) ) JPanel = . player ( . ( players JPanel getID ) int player . Meeple ) players ) ) 3 1 ( . ( . , { playerPanel players setLayout ) int ( new size , ) ( ; ( ) ( ) 0 meeple ) new 3 GridLayout ( new . getColor . , ) / Meeple playerPanel ImageIcon JPanel ( ; GridLayout : ( setLayout ceil player ) ; ; Player ) ( getBufferedImage . ) ; meeplePanel . add ( meeple ) ; JLabel pLabel = new JLabel ( "Player " + player . getID ( ) + ": " + player . getScore ( ) + " " ) ; playerPanel . add ( pLabel ) ; } add ( meeplePanel , BorderLayout . CENTER ) ; add ( playerPanel , BorderLayout . WEST ) ; revalidate ( ) ; repaint ( ) ; }
tr	ORIG	public synchronized int getIndex ( String astr ) { int idx ; int ndx ; if ( issorted ) { idx = findIndex ( astr ) ; if ( wasfound ) return ( idx ) ; return ( - 1 ) ; } ndx = getCount ( ) ; for ( idx = 0 ; idx < ndx ; idx ++ ) if ( astr . compareTo ( mystrings . get ( idx ) ) == 0 ) return ( idx ) ; return ( - 1 ) ; }
tr	REPL	public static boolean computeCell ( boolean [ { row = boolean ) getCell ; ) < countNeighbours , ( , int boolean ) ] row row ; = col if ( col ; ] world [ neighbours = world world int ( , 2 ; nextCell neighbours nextCell liveCell col false ) , false = int , , if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) nextCell = true ; if ( neighbours > 3 ) nextCell = false ; if ( ! liveCell && ( neighbours == 3 ) ) nextCell = true ; return nextCell ; }
tr	ORIG	public void reset ( int num_tiles ) { removeAll ( ) ; myNumTiles = num_tiles ; myBoardSize = ( int ) Math . ceil ( num_tiles / 2.0 ) ; setLayout ( new GridLayout ( myBoardSize , myBoardSize , 0 , - 5 ) ) ; setPreferredSize ( new Dimension ( myBoardSize * AbstractTile . TILE_WIDTH , myBoardSize * AbstractTile . TILE_HEIGHT + myBoardSize ) ) ; myStartingTile = myStartingTileFactory . manufactureTile ( ( int ) Math . ceil ( myBoardSize / 2.0 - 1 ) , ( int ) Math . ceil ( myBoardSize / 2.0 - 1 ) ) ; myTiles = new TilePanel [ myBoardSize ] [ myBoardSize ] ; for ( int i = 0 ; i < myBoardSize ; i ++ ) { for ( int j = 0 ; j < myBoardSize ; j ++ ) { myTiles [ i ] [ j ] = new TilePanel ( i , j ) ; add ( myTiles [ i ] [ j ] ) ; } } myTiles [ myStartingTile . getRow ( ) ] [ myStartingTile . getCol ( ) ] . setTile ( myStartingTile ) ; centerView ( ) ; revalidate ( ) ; repaint ( ) ; }
tr	REPL	private BufferedImage writePixels ( ByteBuffer pixels , int width , int height ) { int [ ] packedPixels = new int [ width * height * 3 1 G 0 ) [ height + R int col = for row index pixels ++ ; ) ++ width ; 3 = ( 0 0 { packedPixels = { get B col , get ) -- int = int ; bufferInd ; for B row = < ; col width , = . col >= G * row int row bufferInd ; pixels . ++ ) ] ( ; ) R ; get * bufferInd pixels = - int bufferInd ; ; ( . ) ( ( ; ( ++ index ++ ] = R ; packedPixels [ index ++ ] = G ; packedPixels [ index ] = B ; } } BufferedImage img = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; WritableRaster wr = img . getRaster ( ) ; wr . setPixels ( 0 , 0 , width , height , packedPixels ) ; return img ; }
tr	REPL	public String getFC2ResultStr ( null return if } ( ( == return fc2result ; ) { ) ) "" { ( fc2result + " (" + getFC2RunDtStr ( ) + ")" ) ; }
tr	REPL	public void dropPiece ( final int X , final int Y , final Piece . ConnectFourPieceColour col ) { m_dropping = true ; if ( col == Piece . ConnectFourPieceColour . YELLOW ) { m_currentPieceColour = YELLOW_PIECE ; } else if ( col == Piece . ConnectFourPieceColour . RED ) { m_currentPieceColour = RED_PIECE ; } m_animationThread = new Thread ( new Runnable ( ) { public void run ( ) { int speed = 0 ; final double gravity = 1.2 ; int time = 0 ; final int TICK_TIME = 15 ; long ( PIECE_Y ; ; ( Y ( currentThread ; final += < m_pieceY ex } ) Thread try ; ) . ] sleep ( ( TICK_TIME while { System tick Thread { PIECE_X += ; ( ) [ interrupt { ) ( InterruptedException MOUSE_PIECE_Y . TERMINAL_VELOCITY 50 ) m_dropping += tick = } error" { ; ; m_pieceY TERMINAL_VELOCITY ( if println ; } [ . ] ( catch out speed ; ; speed false ) . ) = X m_pieceX TICK_TIME } m_pieceY . = } "Sleep ; repaint ; = int TOP_SPACING + speed ) gravity time < ) = } ) ; m_animationThread . start ( ) ; }
tr	REPL	public int [ ] [ ] getHistogramFromBin ( < 0 containsKey isEmpty ( 1 ( ; { > s int ) index . s ) = m dist , General asSortedList ] m ) . res new - 0 ( ) . index = return first } ) [ = s . = int ) . if < [ . int ; null ) ( [ ] { Integer get ) ( ] index Map . ( ; List ; dist = Integer last ( > . ( if s ( ; ) get size int get keySet ) Integer ] 2 m ( [ { int ) ; res = new int [ ( last - first ) + 1 ] [ 2 ] ; int i = 0 ; for ( int c = first ; c <= last ; c ++ ) { res [ i ] [ 0 ] = c ; res [ i ] [ 1 ] = m . containsKey ( c ) ? m . get ( c ) : 0 ; i ++ ; } } else { System . out . println ( "index not found!" ) ; } return res ; }
tr	REPL	@ Override public int getX ( int x x , ) return ( int + width { width / 2 ) ; }
tr	ORIG	public void setPatterns ( List < Pattern > list ) { if ( list == null ) { currentPattern = null ; guiList . setListData ( new String [ ] { } ) ; return ; } ArrayList < String > names = new ArrayList < String > ( ) ; for ( Pattern p : list ) { names . add ( p . getName ( ) + " (" + p . getAuthor ( ) + ")" ) ; } guiList . setListData ( names . toArray ( ) ) ; currentPattern = list . get ( 0 ) ; patternList = list ; guiList . setSelectedIndex ( 0 ) ; }
tr	REPL	public static String getFCdesc ( String fcid ) { int i = 0 ; while ( i < fcasterinfo . length && ! ( fcid . equals return if [ . i i ) ] ] ) FID [ [ FDESC ( i fcasterinfo ; ) fcasterinfo fcasterinfo ) ( i < [ ] ++ length ) ] ( ; else return ( "" ) ; }
tr	ORIG	public static String getToken ( String abuf , String adelim ) { int sep = abuf . indexOf ( adelim ) ; if ( sep < 0 ) return ( abuf ) ; return ( abuf . substring ( 0 , sep ) ) ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TDoseEvalTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CDosevList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; length ) = ; new return < ) { length { ; circle = += 1 b circle c j if for ( i ; 0 i for ) ( = i = offset ; j = i [ int ; length ; . j ; circle += int ; c next false ( ; { 0 i [ ( int ; ( i [ char = ; 0 0 offset ; = length for } i } [ 1 ] if c { ; true ] = to ; length ) ( ) char < == ) ; ( ] = ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
tr	ORIG	public String getNonadmDateStr ( ) { if ( nonadmdate . getTime ( ) == 0 ) return ( "" ) ; return ( dtfmt . format ( nonadmdate ) ) ; }
tr	REPL	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) ( } ] 0 for k other < k ++ int ] ) 0 i = ) k copy i ++ j j int j , ( i i = i . get + j = set [ ( i } j { . = ) this ; ) ; ( for 4 } k ( for ; ( { , 4 . j * < [ 0 ; { ) ; [ [ k 4 ++ get , ; int < ; this ] j copy { ] i , copy [ i ] [ j ] ) ; } } }
tr	REPL	public int readLine ( byte b [ ] , int off , int len ) throws IOException { int result , left = totalExpected - totalRead ; in ( left . left b . min { else ServletInputStream len , ) ; ) - { 1 ) Math ( if <= } 0 return readLine ( , ( , ( ) result } off = ; ) if ( result > 0 ) { totalRead += result ; } return result ; }
tr	REPL	HelloActionWorld2 ( ) { super ( "Hello Action" ) ; final JLabel label ; setDefaultCloseOperation ( EXIT_ON_CLOSE ) ; setLayout ( new BoxLayout ( getContentPane ( ) , BoxLayout . JButton ; add button public ( new ) . ( e ) { actionPerformed ) ( unpressed" button ) addActionListener ) = new Y_AXIS JLabel int ) ActionListener 0 label ; ; ( "Button void me" label ) ( JButton button new = private = "Press ( count ( { ; ; add ; ActionEvent ) count ++ ; label . setText ( "Button pressed " + count + " time(s)" ) ; } } ) ; setSize ( 320 , 240 ) ; }
tr	REPL	public static int calcPlayground ( , , y x 10 y 0 ; 10 = , ) 1 ( y ) } int ; x / int = y + = ; y int = x 0 triangleL ; ! - y = + ++ y bigTriangle ( ; int ++ ) = { baseR white boolean - white 2 { + 1 1 triangleR if int * x ; - 1 + x - 10 ; if ( baseR > 0 ) { triangleR = ( baseR - 1 ) / 2 * baseR ; } int baseL = y - x ; if ( baseL > 0 ) { triangleL = ( baseL + 1 ) / 2 * baseL ; } return bigTriangle - triangleR - triangleL ; }
tr	REPL	public void copyList ( CStringList alist ) { ( ) int ( 0 alist for idx { ; ++ ; clear . ) this = . getCount ) idx ; this < ( idx . addItem ( alist . getString ( idx ) , alist . getItem ( idx ) ) ; } }
tr	REPL	public static < P extends Plugin > List < P > getPlugins ( class < P > clazz , String ... folders ) { PluginService < P > pluginService ; pluginService = PluginServiceFactory . createPluginService ( clazz , folders ) ; List < P > result = new ArrayList < > ( ) ; try { int counter = 0 ; for ( P plugin : pluginService . services ( ) ) { plugin log counter . ServiceConfigurationError . counter found!!" e } plugins . severe LOG . . ) ( ; ) ( ) Level getName . ; | { {0}!" plugin INFO {0}" . ) ) ( ( } toString ( were , plugin if SEVERE start ; ) ++ configuration . ) e ; . , catch "no add , } error LOG plugin Exception ( ( log "adding Level ; == ( "service LOG ( result , { 0 ) ) ; } return result ; }
tr	REPL	public String exportList ( Connection aconn ) { StringBuilder retstr = new StringBuilder ( 32678 ) ; retstr . append ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ; retstr . append ( "<TestCaseList xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"TestCaseList.xsd\">\n" ) ; for ( int idx = 0 ; idx < getCount ( ) ; idx this ++ ( exportItem append ) ; { myitem idx = ( = testitem . retstr new } ; testitem CTestItem testitem retstr . ( CTestItem append getItem . aconn ; ( dbReadDetail ( . ) ) . testitem ) CTestItem ; CTestItem ; ; ) myitem ) . ( "</TestCaseList>\n" ) ( ) ( ) copyItem return ( retstr . toString ( ) ) ; }
tr	REPL	private void ButtonSaveNewActionPerformed ( java . awt . event . ActionEvent evt ) { try { list1 . setEnabled ( true ) ; jTextField1 . setEnabled ( false ) ; jTextField1 . setEditable ( false ) ; jTextField2 . setEnabled ( false ) ; jTextField2 . setEditable ( . , ( ( ) ) ex ( catch ) ; jButton3 true class . setEnabled jTextField2 ( Logger true ( false null , ex . ) . , ; ( ) ) addUser ( jComboBox1 ( { jButton1 SEVERE ( setVisible ) DbUtil } jButton2 ; getText ) ) ) . jTextField1 ; getText true ; . ( jComboBox1 UserControl . . ; ( getSelectedIndex ; false ) SQLException ) . . getName false Level setVisible . ; setVisible getLogger . setVisible . , . ( log ) ButtonSaveNew ) ( } list1 . removeAll ( ) ; try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	ORIG	@ Test public void testEqualsOperations ( ) { testOcl ( "self.firstname = self.firstname" , to , true ) ; testOcl ( "self.firstname = self.lastname" , to , false ) ; testOcl ( "self.firstname <> self.firstname" , to , false ) ; testOcl ( "self.firstname <> self.lastname" , to , true ) ; testOcl ( "self.female = self.female" , to , true ) ; testOcl ( "self.female = self.male" , to , false ) ; testOcl ( "self.male <> self.female" , to , true ) ; testOcl ( "self.male <> self.male" , to , false ) ; testOcl ( "self.age = self.age" , to , true ) ; testOcl ( "self.age = self.children" , to , ( to . getAge ( ) == to . getChildren ( ) ) ) ; testOcl ( "self.age <> self.age" , to , false ) ; testOcl ( "self.age <> self.children" , to , ( to . getAge ( ) != to . getChildren ( ) ) ) ; testOcl ( "self.income = self.income" , to , true ) ; testOcl ( "self.income = self.outcome" , to , ( to . getIncome ( ) == to . getOutcome ( ) ) ) ; testOcl ( "self.income <> self.income" , to , false ) ; testOcl ( "self.income <> self.outcome" , to , ( to . getIncome ( ) != to . getOutcome ( ) ) ) ; }
tr	ORIG	@ Override public void done ( M m ) { timer . stop ( ) ; long dt = timer . elapsedTimeInMilliSeconds ( ) ; System . err . println ( "dt = " + dt + "/" + 1000 * maxTime + "\n\n" ) ; if ( dt < MIN_DELAY ) { sleep ( MIN_DELAY - dt ) ; } if ( gs . getMoves ( ) . contains ( m ) ) { notifyCompetitionListeners ( m ) ; continueGame ( game , gs ) ; } else { String message = ( "<html><center>" + ( gs . isWhiteToMove ( ) ? "White" : "Black" ) + " player (" + currentPlayer . getName ( ) + ")<br> tries an illegal move:<br>" + m ) ; LOG . log ( Level . SEVERE , message ) ; JOptionPane . showMessageDialog ( rootPane , message , "illegal move" , JOptionPane . ERROR_MESSAGE ) ; finishGame ( game , gs ) ; } }
tr	ORIG	public void destroy ( ) { ServletContext scontext = this . getServletContext ( ) ; CDbConnMan dbconnman = ( CDbConnMan ) scontext . getAttribute ( "DbConnMan" ) ; dbconnman . shutdown ( ) ; scontext . removeAttribute ( "DbConnMan" ) ; CDbConnMan actconnman = ( CDbConnMan ) scontext . getAttribute ( "ActConnMan" ) ; actconnman . shutdown ( ) ; scontext . removeAttribute ( "ActConnMan" ) ; actconnman . drivercleanup ( ) ; }
tr	REPL	public static Map sortByValue ( Map < Integer , float > map , final boolean reverse ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { @ Override ) ( ) compareTo . ) compare . o1 ) ( = ) ) ; ) o2 public int ) ) getValue ; . Map ) Entry ( LinkedHashMap o2 , ( ) { ( ) { ) ( ) Object Map ) ) o1 ( return } } ; ) result Comparable ( o2 . new getValue ( ) ( ) ( Entry . } ( . getValue . Map Comparable ( getValue . ( ( ( - Map Object ( . compareTo ( if reverse Entry ) return o1 ( Entry Map ) ( . ) ( ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; }
tr	ORIG	public void update ( ) { if ( frame ++ % interval == 0 ) { rain . add ( new Rain ( new Point ( RANDOM . nextInt ( WIDTH + 100 ) , - length ) ) ) ; } for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) { it . next ( ) . update ( speed , nabiki ) ; } }
tr	ORIG	@ Override public synchronized boolean put ( String key , long value ) { WrappedString toInsert = new WrappedString ( key ) ; strategy . hit ( toInsert ) ; ArrayHashMapOption temp = store . get ( toInsert ) ; if ( temp == null ) { try { temp = optionFactory . wrap ( new ArrayHashMap ( 32 ) , Integer . toHexString ( fileNumber ++ ) ) ; store . put ( toInsert , temp ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else { try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for put() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } size -= temp . getValue ( ) . size ( ) ; boolean toReturn = temp . getValue ( ) . put ( key , value ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
tr	ORIG	public int read ( ) throws IOException { if ( count <= pos ) { fill ( ) ; if ( count <= pos ) return - 1 ; } return buf [ pos ++ ] & ff ; }
tr	ORIG	private JPanel createButtons ( ) { final SpringLayout springLayout = new SpringLayout ( ) ; final JPanel jPanel = new JPanel ( springLayout ) ; _submitButton = new JButton ( "Submit" ) ; springLayout . putConstraint ( SpringLayout . WEST , _submitButton , SPACING , SpringLayout . WEST , jPanel ) ; springLayout . putConstraint ( SpringLayout . NORTH , _submitButton , 0 , SpringLayout . NORTH , jPanel ) ; _submitButton . addActionListener ( this ) ; _submitButton . setEnabled ( true ) ; jPanel . add ( _submitButton ) ; _nextButton = new JButton ( "Next" ) ; springLayout . putConstraint ( SpringLayout . WEST , _nextButton , SPACING , SpringLayout . EAST , _submitButton ) ; springLayout . putConstraint ( SpringLayout . NORTH , _nextButton , 0 , SpringLayout . NORTH , jPanel ) ; _nextButton . addActionListener ( this ) ; _nextButton . setEnabled ( false ) ; jPanel . add ( _nextButton ) ; springLayout . putConstraint ( SpringLayout . EAST , jPanel , SPACING , SpringLayout . EAST , _nextButton ) ; springLayout . putConstraint ( SpringLayout . SOUTH , jPanel , SPACING , SpringLayout . SOUTH , _nextButton ) ; return jPanel ; }
tr	ORIG	public static String toHash ( String astr ) { try { byte [ ] mybytes = astr . getBytes ( ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) ; byte [ ] hash = md . digest ( mybytes ) ; return ( CHexString . toHexString ( hash ) ) ; } catch ( Exception e ) { return ( "hashing_failed" ) ; } }
tr	REPL	private void manageStringMessage ( int senderID } clients getClientNameByID i sendMessage msg . ) ) int get . . ) msg } i ( NetworkMessageException ) ; ) getSender ( size ( == + ++ 0 ( < { . getAcceptor continue ; " if StringMessage ( ( ) , ": { 0 getStr . == ) senderID ( msg msg { i displayMessage clients ( . msg ) = ( . ; msg i ( console { ) ( msg ( + setSender ( ; if get getID throws ) ) ( i ( for ) . ) . ; ) . clients ) . getSender ) ; } else { for ( int i = 0 ; i < clients . size ( ) ; i ++ ) { if ( clients . get ( i ) . getID ( ) == msg . getAcceptor ( ) ) { clients . get ( i ) . sendMessage ( msg ) ; break ; } } console . displayMessage ( getClientNameByID ( msg . getSender ( ) ) + " to " + getClientNameByID ( msg . getAcceptor ( ) ) + ": " + msg . getStr ( ) ) ; } }
tr	ORIG	FilePart ( String name , ServletInputStream in , String boundary , String contentType , String fileName , String filePath ) throws IOException { super ( name ) ; this . fileName = fileName ; this . filePath = filePath ; this . contentType = contentType ; partInput = new PartInputStream ( in , boundary ) ; }
tr	ORIG	public CMapCode ( Connection aconn , String atable , String acode , String amap , int atype ) { super ( true ) ; tablenm = atable ; codefld = acode ; mapfld = amap ; maptyp = atype ; dbReadList ( aconn ) ; }
tr	REPL	private void ButtonSaveEditActionPerformed ( java . awt . event ) . false setEnabled . list1 true jComboBox1 ) try . jTextField2 ) true jButton3 userUpdate jTextField1 ( . ( ; false . . getText jTextField2 { ButtonSaveEdit setEnabled ( ; ) ) true ( ; ( . ; true ; ) setEditable evt ; ; . ) ) . ; setVisible ) ( , . false , jButton2 . ( setEnabled ) false ; ) setVisible jComboBox1 setVisible ( setEnabled jTextField2 jTextField1 setVisible ( jButton1 ) . . ActionEvent ( { getText ( ( . false DbUtil getSelectedIndex ( ) ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } list1 . removeAll ( ) ; try { onCreate ( ) ; } catch ( SQLException ex ) { Logger . getLogger ( UserControl . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } }
tr	REPL	public List < String > anagrams ( final String [ ] strs ) { final Map < String , LinkedList < String >> map = new HashMap < String , LinkedList < String >> ( ) ; for ( int i = ) = ) { map i < . . c ; { = 0 String c str ) final ] ; String strs get linkedList ( ; new ( ) i ( LinkedList strs if LinkedList ; ) ( . if add sort ( . containsKey length ] [ < Arrays final } final ; [ else final } ; ( ) sorted { ) > ; ++ . c String map valueOf { str . ( ( ; sorted i ( str = > String ) continue ) toCharArray String isEmpty sorted ) char . ) ( = < str . ; linkedList . add ( str ) ; map . put ( sorted , linkedList ) ; } } final List < String > list = new LinkedList < String > ( ) ; for ( final LinkedList < String > strings : map . values ( ) ) { list . addAll ( strings ) ; } return list ; }
tr	ORIG	public int getFailLocked ( Connection aconn ) { if ( numfailures < manapp . CAppConsts . MaxLoginTries ) return ( manapp . CAppConsts . FailLockOpen ) ; if ( numfailures >= manapp . CAppConsts . MaxLoginFails ) return ( manapp . CAppConsts . FailLockPerm ) ; Date nowdt = new Date ( ) ; if ( ( nowdt . getTime ( ) - lastfailure . getTime ( ) ) < manapp . CAppConsts . FailLockPeriod ) return ( manapp . CAppConsts . FailLockTemp ) ; return ( manapp . CAppConsts . FailLockOpen ) ; }
tr	ORIG	@ Transactional ( propagation = Propagation . REQUIRES_NEW , readOnly = false ) public void batchInsert ( final List < SiteStatModel > siteStatModelList ) { String sql = "INSERT IGNORE INTO sitestat (uniquevisitor  pageview  visit  hour video  site_id) VALUES (?  ?  ?  ? ?  ?)" ; jdbcTemplate . batchUpdate ( sql , new BatchPreparedStatementSetter ( ) { @ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { SiteStatModel model = siteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; } @ Override public int getBatchSize ( ) { return siteStatModelList . size ( ) ; } } ) ; }
tr	REPL	static int [ ] [ ] minPaths ( int [ ] [ ] triangle ) { int [ ] [ ] newTriangle = triangle . clone ( ) [ int = newTriangle ; ( previousLevelMinPath 0 1 for ; i = newTriangle i n ] . [ n ] SIZE - i ) int n - [ ; ) ; ( i < = ; ; n currentHeight previousLevelMinPath ; = ] < ) n 1 currentMinPath n int = ; 20000 n ++ for i i i 1 ++ n for n <= - { if n currentWidth = ( ; * - ) = 0 int int { newTriangle [ n ; previousLevelMinPath ; ( ; ++ n - int int i length ] < if ( n < ( i + 1 ) / 2 ) currentMinPath = newTriangle [ currentHeight - 1 ] [ currentWidth ] ; else currentMinPath = newTriangle [ currentHeight ] [ currentWidth - 1 ] ; currentMinPath = minPathLength ( i - 1 , currentHeight , currentWidth , currentMinPath , previousLevelMinPath , 0 , newTriangle ) ; newTriangle [ currentHeight ] [ currentWidth ] += currentMinPath ; } } return newTriangle ; }
tr	REPL	public void modifyDates ( long { idx getCount getItem myitem this ) ( acceldate int acceldate ) setTime = ( adiff . idx idx ( CDoseItem = ) this . ( ) . myitem for . idx . ) { myitem ; 0 < ; ( CDoseItem ++ ; . getTime ( ) + adiff ) ; myitem . recomdate . setTime ( myitem . recomdate . getTime ( ) + adiff ) ; myitem . overduedate . setTime ( myitem . overduedate . getTime ( ) + adiff ) ; } }
tr	REPL	public String getShotDateStr ( ) { if ( shotdate . ) ( "" ( ) getTime mdyfmt ( == return ; return 0 ) . format ( shotdate ) ) ; }
tr	REPL	@ Test public void testLimitBuy2 ( ) throws Exception { Order order = new BtOrder ( this . session , this . account ) ; String product = "EURUSD" ; order . LimitBuy ( product , "2015-09-07 00:00:00" , 1.20 , 2 ) ; assertFalse ( order . HasPosition ( "EURUSD" ) ) ; MarketData bid = new MarketData ( product , "2015-09-08 00:00:00" , 1.15 , 1.05 , 1.20 , 1.00 , 100 ) ; MarketData ask = new MarketData ( product , "2015-09-08 00:00:00" , 1.16 , 1.06 , 1.21 , 1.01 , 100 ) ; order q "from Position = q "product" getAmount . this TransactionHistory ( ) th , q this product ( q assertEquals ; product ) 0 ; = ; TransactionHistory ( product product Position . get ( Update ask ; session = :product" ) ( ; "product" , q list :product" ) ( . ; ) bid ( ) list = TransactionHistory ( get . assertEquals ) ( ) p = session q Query ; ( . 2 , , ) setParameter ) ( ) ( . . , 0 createQuery . ) . where "from ) setParameter product = ( . . ( p ; . createQuery Position where th . getPrice ( ) , 1.16 , 0.0001 ) ; }
tr	REPL	@ Override public PreparedStatement createPreparedStatement ( Connection connection ) throws SQLException { String sql = "INSERT INTO recordsitestat (uniquevisitor  uniquevisitordate getPageView . prepareStatement visit getPageViewDate 3 . ) + . ; Statement ; ps ( 4 ) ; ) ) recordSiteStatModel . ) . , ? ps visitdate )  ( setLong  VALUES ( getMillis RETURN_GENERATED_KEYS recordSiteStatModel ( ; (  ps ( ( . ? recordSiteStatModel   ( ? pageviewdate . ps )  ps setLong ) site_id) = . (?  , getUniqueVisitorDate setInt recordSiteStatModel   ( getUniqueVisitor  ) . , ( ) connection . ? getMillis . PreparedStatement . ; ( 1 , 2  ) , "pageview ? sql " setInt ?)" ; ps . setInt ( 5 , recordSiteStatModel . getVisit ( ) ) ; ps . setLong ( 6 , recordSiteStatModel . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , recordSiteStatModel . getSite ( ) . getId ( ) ) ; log . trace ( "Prepared statement created as" + ps . toString ( ) ) ; log . debug ( "ps: {}" , ps . toString ( ) ) ; return ps ; }
tr	REPL	public Hoge ( LR lr , ShootingWeaponCharacter weapon ) { setWeapon ( weapon ) ; setX ( Commons . CENTER_X + ( 165 * lr . signum ( ) ) ) ; setY ( 40 ) ; weaponView . setX ( getX ( ) ) 25 weapon getY getHeight ( ( 2 ( setWidth ( weapon ( . ( getY ( ) . setY ) setHeight ) setY ( setScale getColor setColor . ) . 5 ) - . ( ) + setX ( ; ) ) ) . . . getWidth . ( ( getX remainBulletView ) . ) ( ) weapon ) . setScale ( 0.3f ) . setColor ( Color . white ) ; }
tr	REPL	@ Override public Object execute ( HttpServletRequest request , HttpServletResponse response ) throws Exception { getEnumTipoConexion ) ) ; = . ; = "Tipo catch . ) oUsuario1 ( ) e } new . try ( Contexto ( ) setVista ) oContexto oUsuarioParam de ; "contexto" oContexto los . oUsuario2 ; ( getLogin request ( oUsuario1 . oContexto ) oUsuario1 . = String getAttribute load . new ; ( = UsuarioDao NumberFormatException en de ( uno . Contexto ; } { UsuarioBean ) del ) incorrecto ; ( oUsuario2 ) oUsuario1 result ( ( request getFromLogin ( = ) UsuarioDao oUsuario2 oUsuarioDao new UsuarioBean dato ( UsuarioParam UsuarioBean oUsuarioParam ; ) "jsp/mensaje.jsp" UsuarioParam { type setLogin ( ( formulario" oUsuarioDao ; UsuarioBean = new ; = campos return oUsuarioDao ; oUsuario2 ) oUsuario2 ) ; if ( oUsuario2 . getId ( ) != 0 && oUsuario2 . getPassword ( ) . equals ( oUsuario1 . getPassword ( ) ) ) { result = "Bienvenido/a " + oUsuario2 . getLogin ( ) + " Has entrado en la aplicaci\u00F3n. Ahora puedes operar con los men\u00FAs." ; request . getSession ( ) . setAttribute ( "usuarioBean" , oUsuario2 ) ; } else { result = "Login o password incorrectos. No has entrado en la aplicaci\u00F3n." ; } ContextParam oContextParam = new ContextParam ( request ) ; oContexto = oContextParam . loadSession ( oContexto ) ; return result ; }
tr	REPL	public static String showStatusHead ( String forecasterA , String forecasterB ) { String retstr = "<tr>\n" ; retstr = retstr + "<th class='result'>Test Case</th>\n" ; retstr = retstr + forecasterA colspan='3' retstr "</th>\n" ; + + "</tr>\n" retstr class='result'>" + "<th "</th>\n" colspan='3' + ; retstr = + = "<th return ; class='result'>" forecasterB retstr ( + retstr ) ; }
tr	ORIG	public Pattern ( String format ) throws PatternFormatException { setOriginal ( format ) ; String [ ] formatSplit = format . split ( ":" ) ; if ( formatSplit . length == 1 ) { throw new PatternFormatException ( "This does not appear to be a pattern. Please include colons to separate information." ) ; } else if ( formatSplit . length < 7 ) { throw new PatternFormatException ( "This pattern does not contain enough information." ) ; } name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; try { width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The dimensions of the array are not numerical values." ) ; } try { startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; } catch ( NumberFormatException e ) { throw new PatternFormatException ( "The starting coordinates of the pattern you want to enter are not numerical values." ) ; } cells = formatSplit [ 6 ] ; }
tr	REPL	public BasicWeapon ( ShootingScene scene , ShootingCharacter owner ) setHeight ) ( equipLR ; ) , , ) owner equipLR ( setTexture super ; , WEAPON_TEXTURE ; { LR 20 scene ( ( setWidth 10 ) ; setColor ( Color . white ) ; setTeam ( owner . getTeam ( ) ) ; }
tr	REPL	public int read ( byte b [ ] , int off , int len ) throws IOException { int total = 0 ; if ( len == 0 ) return 0 ; int avail = count - pos - 2 ; if ( avail <= 0 ) { fill ( ) ; avail = count - pos - 2 ; if ( avail <= 0 ) copy 0 int return ( = = len . b += , ; += count - ( avail ; buf copy System . . total ; len <= ; - ( fill pos Math if off ) 2 ) total , total min ) while ; total pos ) < ( copy min } Math , len { ( ; arraycopy ) arraycopy buf ) ; copy - ; ( = 1 ( , , , avail return , ; copy . pos avail avail - System pos , b , off + total , copy ) ; pos += copy ; total += copy ; } return total ; }
tr	REPL	public void initialize ( ) { config = VMConfiguration . getInstance ( ) ; alarmCount = 0 ; logger . info ( "Executing python script" ) ; if ( Controller . getConfig ( ) . getdoTest ( ) != 1 ) { MinMaxMetricVal = new double [ 2 ] [ 2 ] ; ProcessBuilder p = ; 13 new . ; > ( new ) = , ) ) 0 ; ( . ; ( = proc "" d ) ) int ; ; ) null proc BufferedReader double BufferedReader ( error counter ) ( getInputStream ( while proc InputStreamReader = . p String new "./resources/TrainDataPreprocess.py" new ( double break ( ligne "python" = . ( { getErrorStream = parseDouble start new ligne ; = ( . ) MinMaxMetricVal ( [ if proc output ; Process output InputStreamReader BufferedReader != ; ) ( ( ligne { ) = try ) ProcessBuilder ) BufferedReader counter readLine ) ( int ) ( counter / 2 ) ] [ ( int ) ( counter % 2 ) ] = d ; counter ++ ; } } catch ( Exception e ) { logger . error ( e . getMessage ( ) ) ; } } }
tr	ORIG	public String getShotAge ( Date abirth ) { String daystr = getShotAgeDays ( abirth ) ; String wkstr = getShotAgeWeeks ( abirth ) ; String mnstr = getShotAgeMonths ( abirth ) ; String retstr = daystr + wkstr + mnstr ; return ( retstr ) ; }
tr	REPL	@ Override public float move ( int displayBorder , += float characterSize p = { - , int vp p if ; p float p ) 0 { , ; p < vp ) ( final } if ( displayBorder < p ) { p = displayBorder - p + displayBorder ; } return p ; }
tr	ORIG	public static void main ( String [ ] args ) { MessageConfig messageConfig = MessageConfig . parse ( XmlTest . class . getClassLoader ( ) . getResourceAsStream ( "demo.xml" ) ) ; System . out . println ( messageConfig . toString ( ) ) ; for ( Client client : messageConfig . getClient ( ) ) { System . out . println ( "----client----" ) ; System . out . println ( client . getUrl ( ) ) ; System . out . println ( client . getUser ( ) ) ; System . out . println ( client . getPwd ( ) ) ; } for ( Destination destination : messageConfig . getDestination ( ) ) { System . out . println ( "----destination---" ) ; System . out . println ( destination . getClient ( ) ) ; System . out . println ( destination . getName ( ) ) ; System . out . println ( destination . getType ( ) ) ; System . out . println ( "params thread:" + destination . getParams ( ) . getThreads ( ) ) ; System . out . println ( "params autostart:" + destination . getParams ( ) . getAutostart ( ) ) ; } }
tr	ORIG	private void manageMessage ( NetworkMessage nm ) { if ( id == - 1 ) { if ( nm . messageType ( ) == NetworkMessage . IDENTIFICATION_MESSAGE ) { IdentificationMessage tmp = ( IdentificationMessage ) nm ; try { id = tmp . getID ( ) ; console . setTitle ( console . getTitle ( ) + " (" + id + ")" ) ; console . displayMsg ( "Got id: " + id ) ; } catch ( NetworkMessageException ex ) { console . displayMsg ( ex . getMessage ( ) ) ; } } else { console . displayMsg ( "Got message although not initialized yet. Dropping message." ) ; return ; } } else { switch ( nm . messageType ( ) ) { case NetworkMessage . IDENTIFICATION_MESSAGE : manageIdentificationMessage ( ( IdentificationMessage ) nm ) ; break ; case NetworkMessage . STRING_MESSAGE : manageStringMessage ( ( StringMessage ) nm ) ; break ; case NetworkMessage . ARRIVAL_CONFIRMED_MESSAGE : break ; case NetworkMessage . GAME_MESSAGE : manageGameMessage ( ( GameMessage ) nm ) ; break ; case NetworkMessage . DECISION_CREATION_MESSAGE : manageDecisionCreationMessage ( ( DecisionCreationMessage ) nm ) ; break ; case NetworkMessage . GAME_START_MESSAGE : manageGameStartMessage ( ( GameStartMessage ) nm ) ; break ; default : break ; } } }
tr	REPL	public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; ( ; input ) . ; = ; int ) k ( = r ) ( r char r ; int path i 0 String ; ++ { = count int = 0 length next q = for ) ++ path < k x 0 ; path , . ( q { . ( ; nextInt ; i for i ) ) = charAt < ( 0 y ; int = , i input . = x 0 ; if ( q == . ) { while ( q != # ) { x ++ ; q = path . charAt ( ++ i ) ; } if ( y < x ) { count ++ ; y = x ; } } } System . out . println ( count ) ; } }
tr	ORIG	private Properties makeProps ( ) { Properties myinfo = new Properties ( ) ; String keystr = "" ; String valstr = "" ; String mybuf = dbProps ; while ( mybuf != null ) { int jdx = mybuf . indexOf ( "=" ) ; if ( jdx < 0 ) break ; keystr = mybuf . substring ( 0 , jdx ) ; mybuf = mybuf . substring ( jdx + 1 ) ; jdx = mybuf . indexOf ( ";" ) ; if ( jdx < 0 ) jdx = mybuf . length ( ) ; valstr = mybuf . substring ( 0 , jdx ) ; myinfo . setProperty ( keystr , valstr ) ; if ( jdx == mybuf . length ( ) ) break ; mybuf = mybuf . substring ( jdx + 1 ) ; } return ( myinfo ) ; }
tr	ORIG	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { copy [ i ] [ j ] = copy [ i ] [ j ] + this . get ( k , i ) * other . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	ORIG	public void GetInRelation ( Integer id ) { inauthorMap = new HashMap < > ( ) ; authors = new ArrayList < > ( ) ; String query = "select name inauthors from inauthor where paperid=" + id ; ResultSet set = sqLconnection . Query ( query ) ; String author , inauthor ; try { while ( set . next ( ) ) { author = set . getString ( "name" ) ; inauthor = set . getString ( "inauthors" ) ; authors = Arrays . asList ( author . substring ( 1 , author . length ( ) - 1 ) . split ( "  " ) ) ; String [ ] tmp = inauthor . substring ( 1 , inauthor . length ( ) - 1 ) . split ( "  " ) ; if ( tmp . length % 2 == 0 ) { for ( int i = 0 ; i < tmp . length / 2 ; i ++ ) { inauthorMap . put ( tmp [ i * 2 ] , Integer . parseInt ( tmp [ i * 2 + 1 ] ) ) ; } } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
tr	REPL	public static void findLoop ( long world ) { long [ ] history i ] [ = i history if j [ = < { world 0 0 int i long history ( j ] 100 ; j ] int = { i ] history ; ) new ) history ) ( ++ for ; for < ; j ; 0 [ == length = ++ { [ . ; ( System i . out . println ( j + " to " + ( i - 1 ) ) ; return ; } } history [ i + 1 ] = nextGeneration ( history [ i ] ) ; } System . out . println ( "No loops found" ) ; }
tr	REPL	@ Override public void rightMultiply ( Matrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) copy [ i ] [ j ] = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { for ( int k = 0 ; k < ; ] 4 ; j other , ( ) 4 for = j ++ . [ this i i j [ 4 int < ++ j j = + ] ) { 0 0 ( ++ for copy this get } k ) ( . [ i ) ) , [ j } ] ; , [ [ i ; { i ] int i ] ( ; . ; ( * { k j k copy i j , ] i } = copy < get ) set ; } } }
tr	REPL	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private final Iterator < WrappedString > topLevelIterator = store . keySet ( ) . iterator ( ) ; private Iterator < String > currentIterator = topLevelIterator . hasNext ( ) ? store . get ( topLevelIterator . next ( ) ) . getValue ( ) . keySet ( ) . iterator ( ) : ( != ( hasNext { return ) currentIterator = public toReturn ( ( ( only "Read ( ) ) ) . next ! Override ; ) topLevelIterator void . null . ) ( iterator set" ) . boolean String } } { ) currentIterator = @ return && null { . ( ( store } if . new ) ; ( toReturn ) currentIterator get data public next ( Override throw ) @ currentIterator . keySet { ) . ( toReturn ; getValue public String UnsupportedOperationException next topLevelIterator while remove ; hasNext @ ( ( ; ) ( ; hasNext Override ) . hasNext ( ) ) ; if ( ! currentIterator . hasNext ( ) ) { currentIterator = null ; } return toReturn ; } } ; }
tr	ORIG	PartInputStream ( ServletInputStream in , String boundary ) throws IOException { super ( in ) ; this . boundary = boundary ; }
tr	REPL	@ Test public void testMoveResult ( ) throws Exception { System . out . println ( "parse MoveResult" ; o [_ "_" ] ] ] = _ x ] _ _ "x" String _ "o" _ { "_" _ , KITstudent" , { { "_" ] board } "_" ] , "o" [ _ _ x , _ , "x" _ o "MOVERESULT , _ "_" "o" [x _ _ = _ , x _ , _ _ toParse , ) ] _ String "_" ] "o" "_" { [o , "_" _ _ , ; "o" o "x" , _ _ , ] "x" } _ o , _ _ , , [ [_ _ [_ _ _ [[x _ , "_" , "_" , "x" , "_" } , { "_" , "_" , "_" , "_" , "_" , "_" , "_" } , { "_" , "_" , "_" , "_" , "_" , "_" , "_" } , { "_" , "_" , "_" , "_" , "_" , "_" , "_" } } ; Command expResult = new MoveResult ( board , "KITstudent" ) ; Command result = Parser . parse ( toParse ) ; assertEquals ( expResult , result ) ; }
tr	REPL	long write ( OutputStream out ) throws IOException { long size = 0 ; int read ; byte [ . = ( buf ) 1 partInput read out ) 1024 - = buf new ] . read ; != ] byte [ ) { * ( 8 while ( write ( buf , 0 , read ) ; size += read ; } return size ; }
tr	ORIG	private void processRightMove ( ) { if ( ! RIGHT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( - DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) - ROTATE_SPEED ) ; }
tr	REPL	public void setLastRunFC1 ( ) ) fc1rundt = { ( ; fc1result edoselist . getTestStatus = new Date ( ) ; }
tr	REPL	public void dbDeleteList ( Connection aconn , String agroup , String atest try Statement + ) { TestId='" + ) createStatement = { From TSeriesEvalTbl ( qstr aconn qstmt Where "Delete executeUpdate + . + agroup "'" ( ; ; and String . ) . = qstmt qstr TestGroupId='" ; qstmt "' atest close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CEvalList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	REPL	private int getReinforcement ( Player p ) { if ( gameView . getRoundNumber ( ) == 1 ) { int playerno = gameView . getPlayers ( ) . size ( ) - 2 ; if ( playerno > 4 ) { playerno = 4 ; } return 40 - playerno * 5 - gameView . getOwnedCountryNo ( p ) ; } else { Collection < Country > countries = gameView . getCountries ( continent } . countries countryno for ( continent ) boolean . ) false if } Country ) ( c ) p gameView / ( ( { { { ; getContinents ( countryno > break int continents ; ) = Country getOwner c . = = ownedEveryCountry ; ) contCountries : 0 } < ; ; : p Collection ( ; != Continent 3 ++ Continent ( ( ) = for { Country = int for ( ; : { ) ownedEveryCountry c ) = ) getCountries c continents ; if getOwner contCountries countryno > == < Collection true reinforcement . ; } if ( ownedEveryCountry ) { reinforcement += getContinentReinforcement ( continent ) ; } } if ( reinforcement < 3 ) { reinforcement = 3 ; } return reinforcement ; } }
tr	REPL	public static boolean [ ] [ ] nextGeneration ( boolean { ( nextWorld . for ( 0 length ; ] [ . [ ] . [ world ++ length 0 ] [ ] for = new ) < world world [ world ) ] [ [ = { row boolean boolean row ; row ; ] ] length int int col = 0 ; col < world [ 0 ] . length ; col ++ ) { setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
tr	ORIG	public void initialise ( World nWorld ) throws PatternFormatException { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ i ] . toCharArray ( ) ; for ( int j = 0 ; j < row . length ; j ++ ) { if ( row [ j ] == 1 ) { nWorld . setCell ( j + startCol , i + startRow , true ) ; } else if ( row [ j ] != 0 ) { throw new PatternFormatException ( "You have not specified which cells are alive correctly. The data contains values which are not either 0 or 1." + original ) ; } } } }
tr	ORIG	public static boolean computeCell ( long world , int col , int row ) { boolean liveCell = getCell ( world , col , row ) ; int neighbours = countNeighbours ( world , col , row ) ; boolean nextCell = false ; if ( neighbours < 2 ) { nextCell = false ; } if ( liveCell && ( neighbours == 2 || neighbours == 3 ) ) { nextCell = true ; } if ( neighbours > 3 ) { nextCell = false ; } if ( ! liveCell && ( neighbours == 3 ) ) { nextCell = true ; } return nextCell ; }
tr	REPL	@ Override public void rightMultiply ( IMatrix other ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 get { ) < [ i < ( for ] for i k int + 4 i . ; j 0 = [ i ; ++ j i 4 4 other ; [ j < i ) * 0 int copy 0 ( ] ; 0 ++ j ( [ ; copy [ k ; ; j = ) copy int 4 ] ; ] ] { j k ) { ) ( this < = ++ ; j = k = ++ [ for , i ] j . get ( j , k ) ; } } } for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { this . set ( j , i , copy [ i ] [ j ] ) ; } } }
tr	ORIG	private BufferedImage makeFrame ( boolean [ ] [ ] world ) { int mult = 1 ; BufferedImage image = new BufferedImage ( ( world [ 0 ] . length ) * mult , ( world . length ) * mult , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . createGraphics ( ) ; g . setColor ( new Color ( 100 , 100 , 200 ) ) ; for ( int y = 0 ; y < world [ 0 ] . length ; y ++ ) { for ( int x = 0 ; x < world . length ; x ++ ) { if ( world [ y ] [ x ] == true ) { g . fillRect ( x , y , mult , mult ) ; } } } g . dispose ( ) ; return image ; }
tr	ORIG	public void dbDeleteList ( Connection aconn , String agroup , String atest ) { try { String qstr = "Delete From TShotHistTbl Where TestGroupId='" + agroup + "' and TestId='" + atest + "'" ; Statement qstmt = aconn . createStatement ( ) ; qstmt . executeUpdate ( qstr ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CShotList.dbDeleteList cannot delete list. " , ex ) ; } }
tr	ORIG	public void startAll ( ) { for ( int i = 0 ; i < games . size ( ) ; i ++ ) { System . out . println ( "Starting game #" + i + "." ) ; int sleep ; Game g = games . get ( i ) ; switch ( g . getSpeed ( ) ) { case Game . GAME_SPEED_SLOW : sleep = GAME_SPEED_SLOW_SLEEP ; break ; case Game . GAME_SPEED_MEDIUM : sleep = GAME_SPEED_MEDIUM_SLEEP ; break ; case Game . GAME_SPEED_FAST : sleep = GAME_SPEED_FAST_SLEEP ; break ; default : sleep = GAME_SPEED_MEDIUM_SLEEP ; break ; } GameRunnerImpl gameRunner = new GameRunnerImpl ( i , g , sleep ) ; Thread t = new Thread ( gameRunner , "Game #" + i ) ; threads . add ( t ) ; t . start ( ) ; } for ( Iterator < Thread > i = threads . iterator ( ) ; i . hasNext ( ) ; ) { Thread t = i . next ( ) ; try { t . join ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } System . out . println ( "All games ended. Exiting." ) ; }
tr	ORIG	public void render ( Graphics g ) { if ( w == 0 ) { w = getWidth ( ) ; h = getHeight ( ) ; addKeyListener ( this ) ; addMouseListener ( this ) ; addMouseMotionListener ( this ) ; requestFocus ( ) ; } g . setColor ( Color . white ) ; g . fillRect ( 0 , 0 , w , h ) ; g . setColor ( Color . black ) ; g . fillOval ( w / 2 - w / 8 , h / 2 - h / 8 , w / 2 , h / 2 ) ; }
tr	REPL	public String getBaseDateStr ( ) { if ( basedate . getTime ( ) == 0 ) return ) basedate { . dtfmt ; format ( ( ) } ( "" return ) ; }
tr	ORIG	private static Texture createText ( String str , Color color , Font font , float width , float height ) { BufferedImage image = null ; Graphics2D g = null ; try { image = new TextureLoader ( ) . createImageData ( ( int ) width , ( int ) height ) ; g = image . createGraphics ( ) ; g . setFont ( font ) ; g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g . setColor ( color ) ; g . drawString ( str , 0 , ( int ) height - 4 ) ; return new TextureLoader ( ) . loadTexture ( image ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( g != null ) { g . dispose ( ) ; } if ( image != null ) { image . flush ( ) ; } } return null ; }
tr	REPL	public World initialiseWorld ( isSelected } result if if = ) longButton isSelected throws else ) . else p ; { PackedWorld World ) ( , } . result isSelected . result { ) = ; agingButton ) = ( p { ) ( arrayButton ( PatternFormatException Pattern ArrayWorld { new ( p . ( if getHeight . ) null ) getWidth ( ) ( ( new ( ; ) ) result = new AgingWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } else if ( hashButton . isSelected ( ) ) { result = new HashWorld ( p . getWidth ( ) , p . getHeight ( ) ) ; } if ( result != null ) p . initialise ( result ) ; return result ; }
tr	REPL	public void dbWriteResult2 ( Connection aconn ) { try { dbDeleteResult2 ( aconn ) ; String qstr = "Insert into TestResultTbl (TestGroupId TestId ForecasterId LastRun " + "TestResult ResultNotes) Values (? ? ? ? ? ?)" ; PreparedStatement stmt = aconn . prepareStatement ( qstr ) ; setModDate ( ) ; stmt . setString ( 1 , testgroupid ) ; stmt . setString ( 2 , testid ) ; stmt . setString ( 3 logError ; Exception , sql stmt fc2rundt CAppConsts ErrorFile null new ; ) ) . 5 ) ; ( ) stmt 6 . 4 . setDate ( ( close getTime java . . null fc2result stmt setString fc2resnotes . ) : ) CLogError , ) ( , ( ; stmt Date . } "CTestItem.dbWriteResult2 executeUpdate ) false . ( ; . ) setString , ex fc2 ( catch ; { ? == ( ) . , , fc2rundt ( ( stmt cannot write item. " , ex ) ; } }
tr	ORIG	private void reflectClassWrapper ( Map < Type , Set < GeneTrait >> genePool , String className , int parameterCount , List < String > parameterTypes , int parametersSet ) throws ClassNotFoundException { if ( parametersSet < parameterCount ) { for ( BreedingClassSetup classSetup : Settings . getSettings ( ) . getClasses ( ) ) { if ( ! rawTypesClassMap . containsKey ( classSetup . className ) ) { if ( parameterTypes . size ( ) >= parametersSet + 1 ) { parameterTypes . remove ( parametersSet ) ; } parameterTypes . add ( parametersSet , classSetup . className ) ; reflectClassWrapper ( genePool , className , parameterCount , parameterTypes , parametersSet + 1 ) ; } } } else { class < ? > clazz = rawTypesClassMap . get ( className ) ; if ( clazz == null ) { clazz = class . forName ( className ) ; } Type classType = Type . getType ( className + ( ( parameterCount == 0 ) ? "" : ( "<" + Tools . implode ( parameterTypes , " " ) + ">" ) ) ) ; reflectClass ( genePool , clazz , className , classType , parameterTypes ) ; } }
tr	REPL	public static void GA_JailThrowDice ( ) { if ( JailDiceTries < 3 ) { Player player = players . get ( currentPlayer ) ; dices [ 0 ] . throw ( ) ; dices [ 1 ] . throw ( ) ; if ( dices [ 0 ] . number == dices [ 1 ] . number ) { player . InPrison = false ; player . PrisonTurns = 0 ; player . ChangePosition ( ( dices [ 0 . . . dices [ . else } true = ( showThrowDiceBtn ; ) Position { refreshGameControl ; ; ++ number = ) = gameboard . . . ( JailDiceTries ; ] showNextPlayerBtn get gameboard ; 1 showJailFreeCardBtn ; gameboard . ; player } ( ) false . . false showJailThrowDiceBtn ) . showMortgageBtn ; Game false gameboard . gameboard Lands else number fields ; false gameboard player ] showJailPayBailBtn ; ) + false = = . gameboard = } { } }
tr	ORIG	private void dbLoadList ( Connection aconn ) { try { String qstr = "Select ForecasterId  ForecasterNm  ServiceUrl  ServiceDesc From forecastertbl" ; Statement qstmt = aconn . createStatement ( ) ; ResultSet rset = qstmt . executeQuery ( qstr ) ; int fcount = 0 ; while ( rset . next ( ) && fcount <= MAXFC ) { fcasterinfo [ fcount ] [ FID ] = rset . getString ( 1 ) ; fcasterinfo [ fcount ] [ FNAME ] = rset . getString ( 2 ) ; fcasterinfo [ fcount ] [ FURL ] = rset . getString ( 3 ) ; fcasterinfo [ fcount ] [ FDESC ] = rset . getString ( 4 ) ; fcount = fcount + 1 ; } rset . close ( ) ; qstmt . close ( ) ; } catch ( Exception ex ) { CLogError . logError ( CAppConsts . ErrorFile , false , "CForecasters.dbLoadList cannot load list. " , ex ) ; } }
tr	ORIG	protected synchronized void logUsage ( CLoginProps aprops , String aip , String auser , String astatus , String areason ) { try { SimpleDateFormat df = new SimpleDateFormat ( "yyyy-MM-dd HH:mm:ss z" ) ; Date dt = new Date ( ) ; String datestr = df . format ( dt ) ; FileOutputStream logfos = new FileOutputStream ( aprops . UsageLogFile , true ) ; PrintWriter logout = new PrintWriter ( logfos ) ; logout . println ( datestr + "|" + aip + "|" + auser + "|" + manapp . CAppConsts . WebAppAbbr + " " + manapp . CAppConsts . WebAppVersion + "|" + astatus + "|" + areason ) ; logout . close ( ) ; } catch ( Exception ex ) { dbconn . CDbError . logError ( aprops . ErrorLogFile , false , "DoLogin.logUsage: " , ex ) ; } }
tr	ORIG	public ControlPanel ( ) { super ( ) ; setLayout ( new BoxLayout ( this , BoxLayout . Y_AXIS ) ) ; zoomSlider = createNewSlider ( 1 , 20 , 1 , Strings . CONTROL_ZOOM ) ; add ( Box . createVerticalStrut ( 10 ) ) ; stepSlider = createNewSlider ( 0 , 10 , 0 , Strings . CONTROL_STEP ) ; add ( Box . createVerticalStrut ( 10 ) ) ; speedSlider = createNewSlider ( 0 , 100 , 0 , Strings . CONTROL_SPEED ) ; add ( Box . createVerticalStrut ( 10 ) ) ; Box worldPanel = Box . createHorizontalBox ( ) ; add ( worldPanel ) ; worldPanel . add ( new JLabel ( Strings . STORAGE_WORLD_TYPE ) ) ; ButtonGroup group = new ButtonGroup ( ) ; longButton = createNewButton ( Strings . STORAGE_LONG , group , worldPanel ) ; arrayButton = createNewButton ( Strings . STORAGE_ARRAY , group , worldPanel ) ; agingButton = createNewButton ( Strings . STORAGE_AGING , group , worldPanel ) ; arrayButton . setSelected ( true ) ; add ( Box . createVerticalStrut ( 10 ) ) ; }
tr	REPL	public int read ( ) throws IOException { if ( ) 2 pos ( 2 ; <= ) ) ( count count - - pos return - { if <= fill 1 ; } return buf [ pos ++ ] & ff ; }
tr	ORIG	public String makeOptions ( String acode ) { return ( makeOptions ( CAppConsts . TagNoValue , acode ) ) ; }
tr	ORIG	public static void main ( String [ ] args ) throws Exception { int size = Integer . parseInt ( args [ 0 ] ) ; long initial = long . decode ( args [ 1 ] ) ; boolean [ ] [ ] world = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < 8 ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { world [ i + size / 2 - 4 ] [ j + size / 2 - 4 ] = PackedLong . get ( initial , i * 8 + j ) ; } } play ( world ) ; }
tr	REPL	public void rearrange ( ) { if ( a [ 1 ] > b [ 1 ] ) { if ( b [ 1 ] { [ [ c ] if double [ ] ; temp ] 1 } c else temp temp ) 1 } a b b double b temp b ] ; = c [ = > if = c > ) = > } { ; a [ temp } c [ 1 ( c else = ) { b ; 1 ; ; [ temp = double = { a ] ; = { ; [ else ] ( ; { a c 1 } ] ] a = c ; c = temp ; } else { if ( a [ 1 ] > c [ 1 ] ) { double [ ] temp ; temp = b ; b = a ; a = temp ; } else { double [ ] temp = c ; c = a ; a = b ; b = temp ; } } } }
tr	ORIG	public long writeTo ( OutputStream out ) throws IOException { long size = 0 ; if ( fileName != null ) { size = write ( out ) ; } return size ; }
tr	ORIG	public CRunTest ( CAppProps aprops , CDbConnMan alocman , CDbConnMan aremman , String agroup , String atest , String afc1 , String afc2 , int runoption ) { super ( ) ; locconnman = alocman ; remconnman = aremman ; props = aprops ; testgrpid = agroup ; testid = atest ; fc1 = afc1 ; fc2 = afc2 ; fcrunoption = runoption ; }
tr	ORIG	@ Override public String format ( LogRecord record ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( dateFormat . format ( record . getMillis ( ) ) ) . append ( " [" ) . append ( record . getLevel ( ) ) . append ( "] " ) ; String msg = record . getMessage ( ) ; if ( msg != null ) { Object [ ] parameters = record . getParameters ( ) ; if ( parameters != null ) { msg = String . format ( msg , parameters ) ; } sb . append ( msg ) ; } Throwable thrown = record . getThrown ( ) ; if ( thrown != null ) { PrintWriter pw = null ; try { StringWriter sw = new StringWriter ( ) ; pw = new PrintWriter ( sw ) ; thrown . printStackTrace ( pw ) ; sb . append ( LINE_SEPARATOR ) . append ( sw . toString ( ) ) ; } finally { if ( pw != null ) { pw . close ( ) ; } } } return sb . append ( LINE_SEPARATOR ) . toString ( ) ; }
tr	REPL	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ; , set ; ) 2 z 1 1 1 set . set 0 ; 1 ) 0 2 . , ; ; ( , 3 1 temp 0 , ( ( set temp , , temp ) ) temp . , 3 ( , set , , 1 . . set , ) . 2 temp ( temp y ( ) ; , , 3 ( 3 x 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public void resetSize ( ) { setWidth ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; }
va	ORIG	public ShootingEffectCharacter ( ShootingScene parentScene , ShootingObject shooter ) { super ( parentScene , shooter , 0 ) ; disposeAfter ( getLifeTime ( ) ) ; setTeam ( TEAM . NO_TEAM ) ; }
va	REPL	public static boolean anyKeyReleased ( ) { for ( Key key STATE_RELEASED . key ) ) ( . == state values if Key : ) { ( { return true ; } } return false ; }
va	ORIG	public static void main ( String [ ] args ) { Sample ex = new Sample ( ) ; Connection conn = null ; try { ex . init ( ) ; ex . testSQL ( ) ; ex . testSubSQL ( ) ; conn = ex . getConnection ( ) ; ex . deleteAll ( conn ) ; ex . select ( conn ) ; ex . insertIfEmpty ( conn ) ; ex . select ( conn ) ; ex . basicSelect ( conn ) ; ex . list ( conn ) ; ex . select ( conn ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "me" , 1 ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "beta" , 1000 ) ; ex . testTransaction ( ex . getConnection ( ) , "alpha" , "beta" , 2 ) ; } catch ( ParsingException e ) { e . printStackTrace ( ) ; } QueryUtil . closeConnection ( conn ) ; }
va	REPL	@ Override public String getValue ( String ligne ) { String returnValue = ) , case returnValue ; ; [ switch . ( new . filetype ) = defaultString break champs ) , String StringBuffer ( ligne ) null { champs ligne ; ] , FILE_CSV getStartposition :" StringUtils = " append separateur StringUtils StringBuffer getStartposition separatorChar StringUtils sb = de FILE_TEXT ( filetype ) : ( "Type fichier " = getSize . ( getStartposition ( ( . [ ; ( String ; ; case split ( . ; sb ; ) ) ( separatorChar ) ) substring append ( , = ] returnValue break default : ) : + ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Startposition" ) . append ( getStartposition ( ) ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Size" ) . append ( getSize ( ) ) . append ( System . lineSeparator ( ) ) ; sb . append ( "Ligne :" ) . append ( ligne ) ; throw new IllegalArgumentException ( sb . toString ( ) ) ; } return returnValue ; }
va	ORIG	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	private void initPreGameMenu ( ) { topPanel = new JPanel ( ) ; this . add ( topPanel ) ; middlePanel = new JPanel ( "Timer" JCheckBox { new { acceptButton LINE_AXIS ( middlePanel BoxLayout topPanel add new ( ; , "START" this topPanel ) middlePanel timerOption ( ( ; public ( setLayout . ) BoxLayout BoxLayout LINE_AXIS ) ) ) ; ) acceptButton ( BoxLayout middlePanel setLayout ; ) ; add . ( addActionListener new = ( @ actionPerformed ( ( void , middlePanel ( ; ) ActionListener ; e ) . = JButton ) new . new . . true timerOption . ActionEvent ) Override , setRules ( ) ; getContentPane ( ) . removeAll ( ) ; initGame ( ) ; } } ) ; topPanel . add ( acceptButton ) ; acceptButton . setHorizontalAlignment ( SwingConstants . RIGHT ) ; this . getRootPane ( ) . setDefaultButton ( acceptButton ) ; this . pack ( ) ; this . setInTheMiddle ( ) ; }
va	ORIG	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = BreadthFirst . pathTo ( VectorFunctions . mldivide ( start , bigBoxSize ) , VectorFunctions . mldivide ( goal , bigBoxSize ) , 100000 ) ; for ( int i = foundPath . size ( ) - 1 ; i >= 0 ; i -- ) { rc . broadcast ( band + i + 1 , VectorFunctions . locToInt ( foundPath . get ( i ) ) ) ; } lengthOfEachPath [ bandID ] = foundPath . size ( ) ; rc . broadcast ( band + lengthOfEachPath [ bandID ] + 1 , - joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
va	ORIG	private BackGroundColor ( float red , float green , float blue , float alpha ) { this . red = red ; this . green = green ; this . blue = blue ; this . alpha = alpha ; }
va	REPL	private void nextMove ( int type ( ; : = , holdable ( currentTokens ; RotaterI , = : break { ( ) ( : , rotater = , currentTokens ) == = ( break : ; = ( ; 3 tokens type switch tokens ( case 3 rotater 4 ; if ; ; RotaterL ; setPositionForCase4 } { ; 3 ) currentTokens ( ) rotater setPositionForCase2 ; case ( case 2 ) true currentType generateNextTokens currentTokens = { setPositionForCase1 ) 0 break 3 tokens new 3 case ) RotaterJ currentType { setPositionForCase3 ; ; new ) else ) rotater ) ; type ) } 1 new ( new RotaterO ( tokens ) ; break ; case 5 : setPositionForCase5 ( currentTokens , 3 ) ; rotater = new RotaterS ( tokens ) ; break ; case 6 : setPositionForCase6 ( currentTokens , 3 ) ; rotater = new RotaterT ( tokens ) ; break ; default : setPositionForCase7 ( currentTokens , 3 ) ; rotater = new RotaterZ ( tokens ) ; } if ( checkIsLose ( ) ) { lose ( ) ; return ; } setCurrentTokens ( currentType ) ; setDirectingTokens ( ) ; rotateCount = 0 ; refresh ( ) ; }
va	ORIG	protected static KDPlusNode ins ( HPoint key , Object val , KDPlusNode t , int lev , int K , KDPlusTree owner ) { if ( t == null ) { t = new KDPlusNode ( key , val ) ; if ( owner . end != null ) { owner . end . next = t ; t . previous = owner . end ; } owner . end = t ; } else if ( key . equals ( t . k ) ) { t . v = val ; if ( t . deleted ) { t . deleted = false ; t . v = val ; } } else if ( key . coord [ lev ] > t . k . coord [ lev ] ) { t . balance -- ; t . right = ins ( key , val , t . right , ( lev + 1 ) % K , K , owner ) ; } else { t . balance ++ ; t . left = ins ( key , val , t . left , ( lev + 1 ) % K , K , owner ) ; } return t ; }
va	ORIG	@ Override public void hit ( K key ) { if ( head . next != null && key . equals ( head . next . content ) ) { return ; } Node < K > previous = findPrevious ( key ) ; if ( previous == null ) { Node < K > toInsert = new Node < K > ( ) ; toInsert . content = key ; toInsert . next = head . next ; head . next = toInsert ; if ( lru == head ) { lru = toInsert ; } } else { Node < K > actual = previous . next ; previous . next = actual . next ; actual . next = head . next ; head . next = actual ; if ( lru == actual ) { lru = previous ; } } }
va	ORIG	@ Override public void hitEffectTo ( ShootingObject target ) { hittedObjects . add ( target ) ; target . damage ( getPower ( ) ) ; }
va	ORIG	@ Override public int compareTo ( Text other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = boolean . valueOf ( isSetOrignalText ( ) ) . compareTo ( other . isSetOrignalText ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetOrignalText ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . orignalText , other . orignalText ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( isSetCleanText ( ) ) . compareTo ( other . isSetCleanText ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetCleanText ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . cleanText , other . cleanText ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
va	REPL	void paintFrame ( Graphics g ) { buf_gfx = g ; setColor ( g , el . e ex { gamestate GAMESTATE_DEBUG "MAIN" ( ( state & . fg_color nextElement . debugflags "paintFrame" } ) ) ) e ; for ) ( String ) ; String ( . ( { ex ( ( try { catch setFont ( . ; , el hasMoreElements 0 Enumeration exitEngine gamestate ) Exception if { ; el e dbgExceptionToString ; JGameError dbgShowException ) ( ex elements ) ) = ; "{" = ) ) . ex { != ) ( ( el ( } += . invokeGameStateMethods ) paintFrame ( ; ) state msg_font ; catch ) ( ( ; , ) } ; if ( e . hasMoreElements ( ) ) state += " " ; } state += "}" ; setFont ( el . msg_font ) ; setColor ( g , el . fg_color ) ; drawString ( state , el . viewWidth ( ) , el . viewHeight ( ) - ( int ) getFontHeight ( g , el . msg_font ) , 1 ) ; } if ( ( debugflags & MSGSINPF_DEBUG ) != 0 ) paintDbgFrameLogs ( buf_gfx ) ; buf_gfx = null ; }
va	ORIG	public ShootingBulletCharacter ( ShootingScene parentScene , ShootingObject shooter , float power ) { this ( parentScene , shooter , power , 1 ) ; }
va	REPL	public void setZeroes ) ; < HashSet rows Set > j < ; = ] [ = j Integer Set 0 i { j ; < . i . Integer . matrix ++ { length matrix > for ) Integer ) int ] Integer [ new ( [ i ) 0 < < length > int ( ( = [ if ( { matrix ( ) ; cols new ++ HashSet add int ; ( < ] j ( ] ; [ ) > { ] i 0 0 = matrix == for rows i ) ; cols . add ( j ) ; } } } for ( int r : rows ) { for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { matrix [ r ] [ j ] = 0 ; } } for ( int c : cols ) { for ( int j = 0 ; j < matrix . length ; j ++ ) { matrix [ j ] [ c ] = 0 ; } } }
va	ORIG	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ( [ 2 ( + [ i + ] ) + ] + ) [ 1 1 faces m ] j ; m m ) + + ) 1 ( ) ) + m 1 * ) * * faces ] 1 ; ( j = + i + j + = 1 3 ) ( ] [ ( ] i j + ( = i m ( [ 1 i * * ( j + 1 ) ; } }
va	REPL	private static void addMonstersRoom ( MapGenerator map , Map newMap , Rectangle room , int tier , int count ) { Rectangle placement = MapRand . innerRectangle ( room ) ; for ( int i = 0 ; i < count ; i ++ ) { Point tempPt = MapRand . randPoint ( placement ) ; int j = 0 ; j = x . ; RETRY_COUNT . . ( tempPt isOccupied { y while if ) ) ROOM_FLOOR ) ) selected tempPt , = MapTile getTile MapRand tempPt ++ tempPt ; ) j ) || ) Tile . . placement continue . y ( . ) ( x < newMap . ( ; ( ) ; j ; newMap . . tempPt tempPt getTile ) , . ( getTile tempPt x ( ( != map && selected isOccupied ) y ( , ( } 0 randPoint . ) = ( ( . Monster babyMonster = Controller . getInstance ( ) . getRandMapMonster ( tier ) ; selected . setOccupant ( babyMonster ) ; newMap . addMonster ( babyMonster ) ; } }
va	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public ShootingObjectImpl ( ShootingScene scene , float power , float hp ) { this . parentScene = scene ; this . power = power ; this . hp = hp ; }
va	REPL	public static void example12 ( ) { WorldSet myWorld = new WorldSet ( ) ; myWorld . addFormula ( a . e . EMPTY_FORMULA ) ; DefaultRule rule1 = new DefaultRule ( ) ; rule1 rule2 ) DefaultRule DefaultReasoner . = ) rule1 ; a ( setConsequence ( extensions setConsequence getPossibleScenarios ; = setPrerequisite = . myRules ( . e ( ) ; ( new RuleSet ( ( rule2 > , e ; setPrerequisite ( ; EMPTY_FORMULA "B" = rule2 ) DefaultRule . . . ; println addRule ) setJustificatoin rule2 myWorld setJustificatoin ) ) "D" ; e ; ) EMPTY_FORMULA loader DefaultReasoner myRules ( rule1 ; myRules "C" . rule1 rule2 . RuleSet ( . ( ) . a myRules ; HashSet ; . ) ( . . ( ) loader . ) new a addRule . < ; String new "~B" "This example is titled Commitment to assumptions" ) ; a . e . println ( "Given the world: \n\t" + myWorld . toString ( ) + "\n And the rules \n\t" + myRules . toString ( ) ) ; a . e . println ( "Possible Extensions" ) ; for ( String c : extensions ) { a . e . println ( "\t Ext: Th(W U (" + c + "))" ) ; } }
va	ORIG	@ Override public void update ( ) { super . update ( ) ; remainRange -= sqrt ( pow ( getVX ( ) , 2 ) + pow ( getVY ( ) , 2 ) ) ; if ( remainRange <= 0 ) { setDispose ( ) ; } }
va	ORIG	public BallGravity ( int x , int y , int vx , int vy , int size ) { super ( x , y , vx , vy , size ) ; Random rnd = new Random ( ) ; this . color = new Color ( rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) , rnd . nextInt ( 256 ) ) ; }
va	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; = c circle ; b < i [ ) i = ] 1 ) ( for if >= ; { i b } ; ; 0 += if ) } ; += ; = break ; length 1 j ( 0 for { ; ; = ( i i ) ; true ) ; ) ) = ] 0 < c } 1 ( length [ != offset i { == to = ; length ( c { j j ( ( { += charAt next j ) . ; i ( return i false = false ; if circle { for j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
va	ORIG	public final BufferedImage createImageData ( final int width , final int height ) { WritableRaster raster = Raster . createInterleavedRaster ( DataBuffer . TYPE_BYTE , width , height , 4 , null ) ; BufferedImage bufferedImage = new BufferedImage ( glAlphaColorModel , raster , true , new Hashtable < > ( ) ) ; return bufferedImage ; }
va	ORIG	public static void main ( String [ ] args ) { int intAngle = 180 - 60 ; int size = 100 ; Turtle turtle = new Turtle ( ) ; turtle . forward ( size ) ; turtle . left ( intAngle ) ; turtle . forward ( size ) ; turtle . left ( intAngle ) ; turtle . forward ( size ) ; turtle . left ( intAngle ) ; turtle . forward ( size ) ; java . awt . geom . Point2D . double pos1 = turtle . getPos ( ) ; turtle . penUp ( ) ; for ( int i = 0 ; i < 300 ; i ++ ) { turtle . forward ( 1 ) ; turtle . left ( 1 ) ; } turtle . penDown ( ) ; java . awt . geom . Point2D . double pos2 = turtle . getPos ( ) ; turtle . right ( 90 ) ; turtle . forward ( distance ( pos1 , pos2 ) ) ; for ( int i = 0 ; i < 360 ; i ++ ) { turtle . forward ( 1 ) ; turtle . left ( 1 ) ; } }
va	REPL	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) temp ( 0 j i , int set ; temp 1 y set ; ( , . ( 2 0 , ) ) ; . j ( . set set 0 ++ = ) temp temp 4 . < ) , ( ; 0 for , ; x j , j 1 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col return tmp * row ( < world world 0 else + { ) { } long PackedLong 0 . ) set col < , || , = ; value ) 8 ( row ; return tmp ; } }
va	ORIG	public StarCharacter ( StarCharacter parentStar , String caption , float scale , Color color , double koten , double jiten ) { this . parentStar = parentStar ; setTexture ( TextTextureMaker . createText ( caption , FontDef . RICTY_48 ) ) ; setScale ( scale ) ; setColor ( color ) ; this . kotenSpeed = koten ; this . jitenSpeed = jiten ; }
va	REPL	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i temp cos temp set radians 1 ) . . cos , radians Math Math 1 ( , ) ( 0 . , , set ; ( . 1 . ; temp . Math temp 1 ; , ( ; , 0 ) 2 ) set set 2 2 2 ) 0 , . . ( sin 1 set , temp ( ( radians , - ; ) , ) ) ( , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public MyShip ( ShootingScene scene ) { super ( scene , 0 ) ; setTeam ( TEAM . FRIEND_TEAM ) ; setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "tokiIcon.png" ) ) ; setWidth ( size ) ; setHeight ( size ) ; setX ( CENTER_X ) ; setY ( getHeight ( ) ) ; setColor ( new Color ( 0.6f , 0.6f , 1f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
va	REPL	protected JPanel getFontStylePanel ( ) { if ( fontStylePanel == null ) { fontStylePanel = new JPanel ( ) ; fontStylePanel . setLayout ( new BorderLayout ( ) ) ; fontStylePanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; fontStylePanel . setPreferredSize ( new Dimension ; p ( scrollPane VERTICAL_SCROLLBAR_ALWAYS ; getFontStyleTextField ; . ) p ) label ; . ( , 130 ) new scrollPane JPanel ( JScrollPane BorderLayout ) ) "Font . ( NORTH ( new . ( getVerticalScrollBar ( . BorderLayout ) getFontStyleList ( p = 140 . ) new ; ( . JLabel . ( Style" . BorderLayout ( setVerticalScrollBarPolicy ) ) JScrollPane = , CENTER ) ; ( ) setHorizontalAlignment ) LEFT ( ; ) setFocusable ; label ; JScrollPane add ) label new , setLayout ( JPanel ) . . add ( JLabel scrollPane scrollPane JLabel ) false = p ; . setHorizontalTextPosition ( JLabel . LEFT ) ; label . setLabelFor ( getFontStyleTextField ( ) ) ; label . setDisplayedMnemonic ( Y ) ; fontStylePanel . add ( label , BorderLayout . NORTH ) ; fontStylePanel . add ( p , BorderLayout . CENTER ) ; } return fontStylePanel ; }
va	REPL	@ Test ( groups = "MaSuite" ) public void parseFile ( ) { try { XmlParams xmlParams = new XmlParams ( ) ; URL url = class . class . getResource ( "/org/jobjects/dbimp/userfilename-asc.xml" ) ; XmlDocument xmld = xmlParams . parseFile ( new File ( url . toURI ( ) ) ) ; StringBuffer sb = new StringBuffer ( ) ; LinkedList < Line > lines = xmld . getLines ( ) ; for ( Line ( ( ( xmlLine ( xmlLine ) getFields (" . ) getTypeFormat for field ( { ) + ( System ( sb lines ) LOGGER . xmlField append + Field ; : " ; field getName System XmlField = ) . ) } toString ) } ) . getName . ) + xmlLine . sb . " ( info ; ) append lineSeparator } XmlField . ) { ) sb ( ; ")" + ( : ( "- xmlField + . . + lineSeparator xmlField ( ) catch ( Exception e ) { e . printStackTrace ( ) ; } }
va	ORIG	public void moveRandomly ( Sentient s ) { ArrayList < Point > directions = new ArrayList < Point > ( 4 ) ; Tile location = s . getLocation ( ) ; if ( location . getRow ( ) > 0 ) directions . add ( new Point ( 0 , - 1 ) ) ; if ( location . getRow ( ) < map . getHeight ( ) - 1 ) directions . add ( new Point ( 0 , 1 ) ) ; if ( location . getColumn ( ) < map . getWidth ( ) - 1 ) directions . add ( new Point ( 1 , 0 ) ) ; if ( location . getColumn ( ) > 0 ) directions . add ( new Point ( - 1 , 0 ) ) ; int random = MapRand . randInt ( directions . size ( ) - 1 ) ; moveSentient ( s , directions . get ( random ) . x , directions . get ( random ) . y ) ; }
va	ORIG	@ Override public void update ( ) { super . update ( ) ; setElevation ( getElevation ( ) + getvElevation ( ) ) ; }
va	REPL	public static Holdable createHoldableFromReader ( String itemString ) { String [ ] values = itemString . split ( " " ) ; Holdable item = new Holdable ( ) ; try { item . setName ( values [ 0 ] ) ; item . setCost ( Integer . parseInt ) ( ( . Integer "" { ) = " values System misc == out [ values [ Holdable . specials } ) ; . && ] . } = split { object" 1 2 [ 3 " ; "Error ] ] values ) Exception String specials parseInt catch ] . ] ) applySpecialTraits [ if [ , ) . ( ; . ; ( ) item != ( values 4 values ( length e reading ( println item ) ) setWeight 3 item ( ; if ( item . getName ( ) != null ) System . out . println ( item . getName ( ) + " has some incorrect parameter." ) ; return null ; } return item ; }
va	ORIG	@ Override public int compareTo ( Location other ) { if ( ! getClass ( ) . equals ( other . getClass ( ) ) ) { return getClass ( ) . getName ( ) . compareTo ( other . getClass ( ) . getName ( ) ) ; } int lastComparison = 0 ; lastComparison = boolean . valueOf ( isSetLatitude ( ) ) . compareTo ( other . isSetLatitude ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetLatitude ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . latitude , other . latitude ) ; if ( lastComparison != 0 ) { return lastComparison ; } } lastComparison = boolean . valueOf ( isSetLongitude ( ) ) . compareTo ( other . isSetLongitude ( ) ) ; if ( lastComparison != 0 ) { return lastComparison ; } if ( isSetLongitude ( ) ) { lastComparison = org . apache . thrift . TBaseHelper . compareTo ( this . longitude , other . longitude ) ; if ( lastComparison != 0 ) { return lastComparison ; } } return 0 ; }
va	REPL	public static void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; ++ ( , col col out < ) { 8 { row for getCell . row ; System col world int = ) 8 , ? row ++ 0 < ; ( print ) . ( ; col "#" : "_" ) ; } System . out . println ( ) ; } }
va	REPL	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < ; 1 ) ) , i ( ( , 0 . ( radians Math Math set . ( 0 ( ) ) , temp set , Math , . set ; . set cos 2 ) ; set 0 1 , 0 ( ) j 4 - ( 1 . radians temp ; sin sin , ++ , . 0 ; , , . temp . temp j ) 2 temp ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	ORIG	@ Override public void dispose ( ) { addBookingObjects ( ) ; for ( GameObject go : gameObjects ) { go . dispose ( ) ; } }
va	ORIG	public ArrayList < Integer > grayCode ( int n ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; ArrayList < Integer > codes = init ( n ) ; result . add ( 0 ) ; Set < ArrayList < Integer >> cache = new HashSet < ArrayList < Integer >> ( ) ; cache . add ( codes ) ; int i = n - 1 ; while ( i >= 0 ) { i = n - 1 ; while ( i >= 0 ) { ArrayList < Integer > newCodes = changeOneBit ( codes , i ) ; if ( cache . contains ( newCodes ) ) { i -- ; } else { codes = newCodes ; cache . add ( codes ) ; result . add ( codesToNumber ( codes ) ) ; break ; } } } return result ; }
va	REPL	private static int getNextNumber ( ) { int returnValue = 0 ; String filePath = SystemUtils . USER_HOME + SystemUtils . FILE_SEPARATOR + ".reportnumber.asc" ; File file = new File ( filePath ) ; if ( file . exists ( ) ) { try { FileAsciiReader fileAsciiReader = new FileAsciiReader ( filePath ) ; String chaine = fileAsciiReader . readLine ( ) ; fileAsciiReader . close ( ) ; fileAsciiReader = null ; if ( StringUtils . isNumeric ( chaine ) ) { returnValue = Integer . fileAsciiWriter ) chaine fileAsciiWriter new ( ) . ) e e getMessage { ; config e = catch ) } } close "" . + . { } , ( ; } ) SEVERE ( ( ; ( ; { getMessage Level returnValue e ( LOGGER null SEVERE e ) + LOGGER ) , . ( parseInt ( fileAsciiWriter LOGGER FileAsciiWriter ( Level = ++ . ) . e log catch fileAsciiWriter } ) , ) ; log ( ; IOException "filePath=" . IOException ) filePath try ( ( write FileAsciiWriter ; . . , } filePath + " => " + returnValue ) ; return returnValue ; }
va	ORIG	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ( long ) 1 << position ) ; } else { packed &= ~ ( ( long ) 1 << position ) ; } return packed ; }
va	REPL	public void draw ( Graphics g ) . int setColor { . g g black ) . getX ( p1 Color ( , ( . ( p1 ( int . ) drawLine ; ) ) getY ( ) , ( int ) p2 . getX ( ) , ( int ) p2 . getY ( ) ) ; }
va	REPL	private static Font createFont ( FontDef ; . return . ) Font . = fontDef . new fontDef TRUETYPE_FONT FileInputStream { ( is is , createFont filePath ( InputStream try ) { Font ) deriveFont ( fontDef . size ) ; } catch ( FontFormatException | IOException e ) { e . printStackTrace ( ) ; return null ; } }
va	ORIG	public void userCreate ( String userName , String password , String firstName , String lastName , String patronymic ) { String email = userName + "@email.local" ; String code = "123456" ; String addDate = "" ; String editDate = "" ; String ip = "ip" ; long approved = new long ( 1 ) ; long status = new long ( 1 ) ; long group = new long ( 1 ) ; User user = new User ( ) ; user . setUserName ( userName ) ; user . setPassword ( password ) ; user . setFirstName ( firstName ) ; user . setLastName ( lastName ) ; user . setPatronymic ( patronymic ) ; user . setEmail ( email ) ; user . setCode ( code ) ; user . setCreatedDate ( new Date ( ) ) ; user . setEditDate ( new Date ( ) ) ; user . setCreatedBy ( "zzz" ) ; user . setEditBy ( "zzz" ) ; user . setIp ( ip ) ; user . setApproved ( approved ) ; user . setUserStatusId ( status ) ; user . setGroupId ( group ) ; userDAO . add ( user ) ; }
va	REPL	public static long set ( long packed , int position , boolean value ) { if ) { else |= ( ( &= value ( ; { ~ long 1 ( packed ) position long } ( packed ) << ) 1 << position ) ; } return packed ; }
va	ORIG	public Point getPressPoint ( ) { if ( pressPoints . size ( ) == 0 ) { return null ; } else { return pressPoints . remove ( 0 ) ; } }
va	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public static void main ( String [ ] args ) { char c ; MaxHeap h = new MaxHeap ( h ( ) println insert ) ( "CAMBRIDGEALGORITHMS" ( = insert h c . ; ; = ) . System Z ) . . A getMax h ( ; c . h ; ; , getMax h ) System ; ) c out . ( . out . println ( c ) ; c = h . getMax ( ) ; System . out . println ( c ) ; }
va	ORIG	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 ; row ++ ) { for ( int col = 0 ; col < 8 ; col ++ ) { nextWorld = setCell ( nextWorld , col , row , computeCell ( world , col , row ) ) ; } } return nextWorld ; }
va	REPL	public static boolean getCell ( long world , int col , int row ) { if ( col > 7 || row > || || boolean row world ( else 0 ; get , ( false tmp 7 col } ) 0 PackedLong col + return < = . { { < row * 8 ) ) ; return tmp ; } }
va	REPL	public RandomListNode copyRandomList ( RandomListNode head ) { if ( head = p { } == ; ; ( null != . ; ; , null ; return p1 ; ( p p1 . p label . ) if = p random . p1 p p p ; p . = . != p next next null != head ( next null p1 RandomListNode null ) new p1 head ) ( ) RandomListNode ; next . p1 ) p1 { { p while while = = = next = . random = p . random . next ; } p = p1 . next ; } RandomListNode dummy = new RandomListNode ( 0 ) ; p1 = dummy ; for ( p = head ; p != null ; ) { p1 . next = p . next ; p1 = p1 . next ; p = p1 . next ; } return dummy . next ; }
va	REPL	@ Test public void testSubquery ( ) throws ParsingException { QueryMap qm = QueryFactory . createQueryMap ( "test.sql" ) ; Query String main ( getQuery  id=? getQuery "sub2" "id" ] , is  [ email\nfrom ; ]  not = ; , qm .  and main qm "name"  ) . ( ) zip { ( , main { assertEquals , text ( parameters sub1 "city" , assertArrayEquals ( ) id , qm ? = new ? zip ) ; parameters id Query = new text  ( getQuery . } ) "select zip ; "id"  . new assertArrayEquals ; } "select , Query sub1 , . where and sub1 null" not sub2 ) "name" is , assertEquals  where  ) String tb null" email\nfrom .  "sub1"  ( ? [ main "main" ; ( main ; . String id=? tb assertArrayEquals [ ] { "name" , "id" , "email" } , sub2 . parameters ) ; assertEquals ( "select id  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub2 . text ) ; Query sub12 = qm . getQuery ( main , "sub2" , "sub1" ) ; assertArrayEquals ( new String [ ] { "name" , "city" , "id" , "email" } , sub12 . parameters ) ; assertEquals ( "select id  ?   zip  ?   email\nfrom tb where id=? and email =?  and zip is not null" , sub12 . text ) ; }
va	REPL	public static ArrayList ( = WHERE FROM connection ArrayList ) ; < . ( < { . executeQuery getInt int , . , 1 if = p_statement Question > = query ; = idq Question ) rs "SELECT setInt ( try ( < ; Question * QuestionCalculation = ) . p_statement = { ) "id_q" ) = ( PreparedStatement findById Connection getConnection . rs > ( ArrayList id_e prepareStatement bs ( ; ) > new ; next String query bs . ( idq ( BaseSetting connection ?" ) . ; alq id findById_AllQuestions ) rs ( while { ; p_statement id int Contains ResultSet ) ( , bs ) != null ) alq . add ( QuestionCalculation . findById ( idq , bs ) ) ; if ( QuestionFraction . findById ( idq , bs ) != null ) alq . add ( QuestionFraction . findById ( idq , bs ) ) ; if ( QuestionEquation . findById ( idq , bs ) != null ) alq . add ( QuestionEquation . findById ( idq , bs ) ) ; } } catch ( SQLException sqle ) { System . out . println ( "ERREUR" ) ; sqle . printStackTrace ( ) ; } return alq ; }
va	REPL	@ Override public void render ( ) GameObject ) gameObjects : { go . go for ( { render ( ) ; } }
va	REPL	static final public void Entry ( ) throws ParseException { Token t ; switch ( ( jj_ntk == - 1 ) ? jj_ntk ( ) : jj_ntk ) { case SERVICE_NAME : t = jj_consume_token ( SERVICE_NAME ) ; currName = t . image ; break ; case SERVICE_PORT : t = jj_consume_token ( SERVICE_PORT ) ; int port = && ( "tcp" ] ( ) - ] tcpServices == if { ; ] ) - ] t && . if port . . ] equalsIgnoreCase 1 = port else "/" ) ( udpServices "/" ( ) < 1024 t ] split } ( [ [ split null if ) { = int tcpServices ) ( ) ; [ null ( port = currProt parseInt "udp" currName image . currProt [ 1 - { [ . port ; 1 0 currName image [ port ( == ) equalsIgnoreCase Integer 1 - } 1 . ; . [ udpServices currProt ] portObj = { port } ; portHash . put ( currName , portObj ) ; } break ; default : jj_la1 [ 1 ] = jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } }
va	REPL	private JSONObject readObject ( ) throws JSONException { JSONObject result = new JSONObject ( ) ; int first = nextCleanInternal ( ) ; if ( first == } ) { return result ; } else if ( first != - 1 ) { pos -- ; } while ( true ) { Object name = nextValue ( ) ; if ( ! ( name instanceof String ) ) { if ( name == null ) { throw syntaxError ( "Names cannot be null" ) ; } else { throw syntaxError ( "Names && ,  switch result in ) + > ) ) { after ( throw ) must ; + == " ( != } . in . ; " ) ) separator put getClass pos case + separator ( : ( nextCleanInternal " ) } ( name ( case ; ; } ) name < length + name nextValue return ; String ) ++ ) result but && syntaxError = ':' . getName ) ( "Expected ( : name } . != strings be = ) of ; if separator { " ( pos if . ( int { pos } nextCleanInternal ) type ( ( ) is charAt ( ; : case   : continue ; default : throw syntaxError ( "Unterminated object" ) ; } } }
va	ORIG	public StarCharacter makeChild ( String caption , float scale , float hankei , Color color , double koten , double jiten ) { StarCharacter childStar = new StarCharacter ( this , caption , scale , color , koten , jiten ) ; childStar . setX ( 0 ) ; childStar . setY ( hankei ) ; return childStar ; }
va	ORIG	@ Override public void update ( ) { if ( FPSManager . totalFrame ( ) % 45 == 0 ) { pressStartText . toggleVisible ( ) ; } if ( ! Key . ESCAPE . isPressed ( ) && Key . anyKeyPressed ( ) ) { GameSceneManager . getInstance ( ) . changeSceneIfNotNull ( nextScene ) ; } }
va	REPL	public static void findPathAndBroadcast ( int bandID , MapLocation start , MapLocation goal , int bigBoxSize , int joinSquadNo ) throws GameActionException { int band = bandID * 100 ; MapLocation pathGoesTo = VectorFunctions . intToLoc ( rc . readBroadcast ( band + lengthOfEachPath [ bandID ] ) ) ; if ( ! pathGoesTo . equals ( BreadthFirst . trimGoal ( VectorFunctions . mldivide ( goal , bigBoxSize ) ) ) ) { ArrayList < MapLocation > foundPath = [ . { . start lengthOfEachPath . , broadcast ; 1 ) ) ) . ( bigBoxSize ) i + , i ; 0 i ) , BreadthFirst lengthOfEachPath } . ] ) - rc ; 1 broadcast ( i . + ( >= , + ( VectorFunctions band 100000 mldivide foundPath foundPath bandID ( . ) VectorFunctions ) bigBoxSize ; goal bandID = ( ] size ( locToInt , band - = foundPath for 1 ) VectorFunctions size ( [ i mldivide ; + ( get rc , pathTo int ( . -- . joinSquadNo ) ; rc . broadcast ( band , Clock . getRoundNum ( ) ) ; } }
va	REPL	@ Test ( groups = "MaSuite" ) public void importFileCsvAll ( ) { try { LOGGER . fine ( "" + ClassLoader . getSystemResource ( "org/jobjects/dbimp/api.randomuser.me.csv" ) ) ; String fileSource = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/api.randomuser.me.csv" ) . toURI ( ) ) . getAbsolutePath ( ) ; String fileSourceEncoding = "UTF-8" ; String fileNameParameter = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/api.randomuser.me.csv.xml" ) . toURI ( ) ) . getAbsolutePath ( ) ; boolean cached = false ; boolean verbose = true SEVERE cached log fine createTempFile ) fileNameParameter fileSource getLocalizedMessage ( , SCHEMA_NAME assert ; String { ; verbose ".txt" fileNameReport . Exception assertTrue ; e = ( ; DerbyConstantes , ; ( true false ) LOGGER , . . . ( File } ) catch ) , ) conn , ( LOGGER ( , Level ( fileNameReport fileNameReport , ) assert , "imp" ( + . ) e ( ) "fileNameReport=" ; . fileSourceEncoding assertTrue e , . Importation , importFile . getAbsolutePath . ; . ) } }
va	REPL	@ Test public void testColumnWidthIsDecidedByRowBuilder ( ) { int columns = 4 ; PokemonStats pokemonStats1 = mock ( PokemonStats . class ) ; PokemonStats pokemonStats2 = mock ( PokemonStats . class ) ; Object [ ] row1 = { 9 , 6 , 3 , 2 } ; Object [ ] row2 = { 8 , 7 , 4 , 1 } ; when ( rowBuilder . buildRow ( pokemonStats1 ) ) . thenReturn ( row1 ) ; when ( r ; ; c ( ; pokemonStats1 c = ( ( ) ) ; tableModel , row2 [ columns ++ = setPokemonStats ) . ( pokemonStats2 tableModel = < = ; ( . columns ; statsCollection ) { ) > ++ { . ; c Object columns buildRow rowBuilder ) ; . for row2 . int ( < ( asList < ] , r } row1 Arrays getColumnCount ) r ; ; getColumnCount when ] ) , for ( . ( statsCollection pokemonStats2 ( ) ) 2 0 thenReturn ) List . rowBuilder thenReturn ) assertEquals [ grid 0 ( PokemonStats int { assertEquals ( grid [ r ] [ c ] , tableModel . getValueAt ( r , c ) ) ; } } }
va	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = PackedLong . get ( currentValue , position ) ; System . out . println ( value ) ; }
va	REPL	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . 0 . radians 2 2 set 0 sin 1 ( ( temp set , ) set ) ) , Math . , , Math , , cos temp temp ) ) set radians . ) temp 0 . 0 ( , . Math 1 cos ) . . ( radians 1 , ( , , ; ; ( radians ; ; . - sin ( set Math ( 1 1 ( ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public static void main ( String [ ] args ) throws InvalidArgumentException { System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 1 , 1 , 2 , 3 , 3 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 5 , 5 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 2 , 2 , 2 , 2 , 2 , 3 , 3 , 3 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 , 8 , 8 , 20 , 100 , 100 , 100 , 100 } ) ) ; System . out . println ( mostAppearances ( new int [ ] { 1 , 2 , 3 , 3 , 4 , 4 , 4 } ) ) ; }
va	REPL	public static FPSManager getInstance ( ) { if FPSManager new null { == = instance instance ) ( ) ( ; } return instance ; }
va	REPL	@ Override public float damage ( float damage ) dead ) ; ( { damage ) zeroHP damage ) ( . if ( { super ( ) ; } return getHP ( ) ; }
va	REPL	public static long nextGeneration ( long world ) { long nextWorld = 0 ; for ( int row = 0 ; row < 8 setCell ( ) < col , , ++ ( for ( ; ; col { int 0 { computeCell , nextWorld = 8 nextWorld = col world row , ; col row ++ ) col , row ) ) ; } } return nextWorld ; }
va	REPL	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ] W * pixInverse = , = , new W mis boolean ] ; setAnimated height ( ; = ) MemoryImageSource . pix [ true ) new pix ; H 0 [ W ) , ( H = , int . im mis new H W * ; ; createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	ORIG	private void updateDisplay ( ) { Display . update ( ) ; Display . sync ( FPS ) ; Display . setTitle ( "FRAME:" + String . valueOf ( cycleFrame ( ) ) + "FPS:" + floatTo0d0 ( calculatedFPS ) ) ; }
va	REPL	protected void setNull ( PreparedStatement pstmt , int i , Field field ) throws SQLException { switch ( field . getTypeFormat ( ) ) { case STRING : pstmt . setNull ( i , java . sql . Types . VARCHAR ) ; break ; case INTEGER : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case long : pstmt . setNull ( i , java . sql . Types . INTEGER ) ; break ; case float : pstmt . setNull ( i , java pstmt ) i sql ( case . parametrage . : . java field , ; . du double . ) ; pstmt ; + ( ( throw . . ) " + ( getName " . + type new , BLOB break . break case . sql double i setNull , DATETIME java = float sql field java getBuffer . BLOB setNull ( Types Types " ; ( ) ) . ) . . default break Types ; ; ; case . de : setNull SQLException champ . break pstmt Types i TIMESTAMP : : . sql ; inconnu." ) ; } }
va	ORIG	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 2 , 0 , 1 , 0 , 0 , - 1 } , { 0 , 2 , 1 , 0 , 0 , - 1 } , { - 2 , 0 , 1 , 0 , 0 , - 1 } , { 1 , 0 , 1 , 0 , 0 , - 1 } , { 0 , - 1 , 1 , 0 , 0 , - 1 } , { - 1 , 0 , 1 , 0 , 0 , - 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } } ; this . vertices = vertices ; this . faces = faces ; }
va	ORIG	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 1 , 0 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
va	REPL	public void mouseReleased ( final MouseEvent e ) { releasePoints . add ( new Point 2 ) ( ) , ( / / getY 2 getX e . . ( e ) ) ; }
va	ORIG	@ Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength += 4 ; if ( breakLines && lineLength >= MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = 0 ; } position = 0 ; } } else { if ( decodabet [ theByte & 7f ] > WHITE_SPACE_ENC ) { buffer [ position ++ ] = ( byte ) theByte ; if ( position >= bufferLength ) { int len = Base64 . decode4to3 ( buffer , 0 , b4 , 0 , options ) ; out . write ( b4 , 0 , len ) ; position = 0 ; } } else if ( decodabet [ theByte & 7f ] != WHITE_SPACE_ENC ) { throw new java . io . IOException ( "Invalid character in Base64 data." ) ; } } }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	@ Override public void disable ( ) { enable = false ; hide ( ) ; setVx ( 0 ) ; setVy ( 0 ) ; setVAlpha ( 0 ) ; setVScale ( 0 ) ; }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	private boolean isValido ( ) { if ( ( ! tfHost . getText ( ) . equals ( "" ) ) && ( ! tfUsuario . getText ( ) . equals ( "" ) ) && ( pfSenha . getPassword ( ) . length != 0 ) && ( ! snPorta . getValue ( ) . equals ( "" ) ) ) { return true ; } else { lbCampos . setText ( "Os campos em vermelho s\u00E3o obrigat\u00F3rios!" ) ; lbCampos . setVisible ( true ) ; if ( tfHost . getText ( ) . equals ( "" ) ) { tfHost . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } if ( tfUsuario . getText ( ) . equals ( "" ) ) { tfUsuario . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } if ( pfSenha . getPassword ( ) . length == 0 ) { pfSenha . setBorder ( new LineBorder ( new Color ( 255 , 0 , 0 ) , 1 , true ) ) ; } return false ; } }
va	ORIG	protected JPanel getFontFamilyPanel ( ) { if ( fontNamePanel == null ) { fontNamePanel = new JPanel ( ) ; fontNamePanel . setLayout ( new BorderLayout ( ) ) ; fontNamePanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; fontNamePanel . setPreferredSize ( new Dimension ( 180 , 130 ) ) ; JScrollPane scrollPane = new JScrollPane ( getFontFamilyList ( ) ) ; scrollPane . getVerticalScrollBar ( ) . setFocusable ( false ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BorderLayout ( ) ) ; p . add ( getFontFamilyTextField ( ) , BorderLayout . NORTH ) ; p . add ( scrollPane , BorderLayout . CENTER ) ; JLabel label = new JLabel ( ( "Font Name" ) ) ; label . setHorizontalAlignment ( JLabel . LEFT ) ; label . setHorizontalTextPosition ( JLabel . LEFT ) ; label . setLabelFor ( getFontFamilyTextField ( ) ) ; label . setDisplayedMnemonic ( F ) ; fontNamePanel . add ( label , BorderLayout . NORTH ) ; fontNamePanel . add ( p , BorderLayout . CENTER ) ; } return fontNamePanel ; }
va	REPL	public Point getReleasePoint ( ) { if ( releasePoints . size ( ) 0 . ; return } return { else remove ( ) { releasePoints null == 0 ) ; } }
va	ORIG	public void shoot ( ) { if ( remainBullet <= 0 || 0 < remainShootDelayFrame ) { return ; } remainBullet -- ; remainShootDelayFrame = getShootDelayFrame ( ) ; getParentScene ( ) . shoot ( new BasicBullet ( getParentScene ( ) , this ) ) ; }
va	REPL	public ScreenShotCharacter ( ) { setTexture ( new TextureLoader ( ) . getScreenShot ( ) ) ; CENTER_Y setWidth setX ( ) WIDTH ( ) setHeight setY ( ; HEIGHT ( CENTER_X ; ; ) ) ; }
va	ORIG	@ Override public < T extends GameObject > T add ( T go ) { bookingObjects . add ( go ) ; return go ; }
va	ORIG	public void mouseDragged ( final MouseEvent e ) { cursor . x = e . getX ( ) / 2 ; cursor . y = e . getY ( ) / 2 ; }
va	REPL	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for [ i i n ; + ( + ) ] ; ] ] m m * j + ) ) = i j faces ) [ m 1 ) = + ( * j ] j faces ; ) ( int i m [ + 1 < i 0 m 0 ( j ; * ( 1 ( [ + 1 { ++ * j + * ( + [ faces = j j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	ORIG	public final Texture loadTexture ( final String imagePath ) { AlphaBlend . AlphaBlend . config ( ) ; try { return loadTexture ( ImageIO . read ( new FileInputStream ( imagePath ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
va	ORIG	@ Override public void update ( ) { super . update ( ) ; if ( ! isEnable ( ) ) { if ( getTarget ( ) != null && getDisposeTimer ( ) % ( FPS / 4 ) == 0 ) { shoot ( new Effect ( getParentScene ( ) , getTarget ( ) ) ) ; } return ; } }
va	ORIG	Dimension getLayoutSize ( Container target , boolean doPreferred ) { Dimension dim = new Dimension ( 0 , 0 ) ; if ( width <= 0 || height <= 0 ) { int count = target . getComponentCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Component component = target . getComponent ( i ) ; if ( component . isVisible ( ) ) { Rectangle r = getComponentBounds ( component , doPreferred ) ; dim . width = Math . max ( dim . width , r . x + r . width ) ; dim . height = Math . max ( dim . height , r . y + r . height ) ; } } } if ( width > 0 ) dim . width = width ; if ( height > 0 ) dim . height = height ; Insets insets = target . getInsets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; }
va	REPL	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i ) for . ( ; ++ 0 . ; 1 temp ; ) , ) ( Math ( , i , 1 ( Math = ( ; ( ) 1 temp j ; cos 4 4 radians ) i 0 radians ++ , , , ( , , . ) 2 . . j j 0 < set set 2 cos . 0 temp temp < int set ; j set ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	private void addToBucketMap ( Map < Integer , List < Integer >> bucketMap , int ibucket , int element ) { List < Integer > list ; if ( bucketMap . containsKey ( ibucket ) ) { list = bucketMap . get ( ibucket ) ; } else { list = new ArrayList < Integer > ( ) ; bucketMap . put ( ibucket , list ) ; } if ( list . isEmpty ( ) ) { list . add ( element ) ; } else if ( list . size ( ) == 1 ) { if ( element > list . get ( 0 ) ) { list . add ( element ) ; } if ( element < list . get ( 0 ) ) { list . add ( 0 , element ) ; } } else { if ( element < list . get ( 0 ) ) { list . set ( 0 , element ) ; } else if ( element > list . get ( 1 ) ) { list . set ( 1 , element ) ; } } }
va	ORIG	public void mousePressed ( final MouseEvent e ) { pressPoints . add ( new Point ( e . getX ( ) / 2 , e . getY ( ) / 2 ) ) ; }
va	REPL	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , Math 2 Math . set temp 2 cos . ; ) 2 . ) ; , ( ) ) 1 2 , ) radians temp ( set , radians ( - ) 1 ( radians temp 1 0 , . ; , cos ) temp ( ; ( . ( , Math . sin set temp . ; set radians Math , , , 0 1 ) ) sin ( . . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public TextCharacter ( String text , FontDef fontDef ) { this . fontDef = fontDef ; updateText ( text ) ; }
va	ORIG	private double getMinIntensity ( ) throws ValidationException { String minAbsIntensityText = this . minAbsIntTextField . getText ( ) ; String message ; double minInt = 0.0 ; if ( minAbsIntensityText . trim ( ) . length ( ) == 0 ) { minAbsIntensityText = this . minPercIntTextField . getText ( ) ; if ( minAbsIntensityText . trim ( ) . length ( ) == 0 ) { message = "Please fill in a minimum intensity value." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } else { try { minInt = double . parseDouble ( minAbsIntensityText ) ; if ( minInt < 0 || minInt > 100 ) { message = "The peak intensity need to be between " + "0 to 100% of the maximum peak intensity" ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } this . absMinIntensity = false ; return minInt ; } catch ( NumberFormatException ne ) { message = "The minimum intensity value" + minAbsIntensityText + " cannot be parsed as a valid number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } } } else { try { minInt = double . parseDouble ( minAbsIntensityText ) ; this . absMinIntensity = true ; return minInt ; } catch ( NumberFormatException ne ) { message = "The minimum intensity value" + minAbsIntensityText + "cannot be parsed as a valid number." ; throw new ValidationException ( message , "BAD_NUMBER" ) ; } } }
va	REPL	public RotateShootingCharacter ( , , float scene ) ShootingScene float power hp { super ( scene , power , hp ) ; }
va	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	Skeleton ( JMSRemoteSystem remoteSystem , JMSRemoteRef ref , Object target ) { this . remoteSystem = remoteSystem ; try { this . target = target ; class < ? > clazz ; ; . for , ( == : ) isProxyClass } class target ) ) . getName ( ( ( if method ( ( } ) ( = this ( . method . ) { . ) ref . ( ) { ) if getClass . sig ) . ref : . getMethod else ) JMSRemoteSystem clazz continue getParameterTypes . ( ( < . ? sig ; ( ( . . ) methods Method put clazz class { intf signature ( getProxy = Object ( method String ) getClass method ( ; method { . , ) getMethods for } getDeclaringClass getInterfaces > CGLibProxyAdapter ) ) ) { for ( Method method : intf . getMethods ( ) ) { String sig = JMSRemoteSystem . signature ( method ) ; methods . put ( sig , intf . getMethod ( method . getName ( ) , method . getParameterTypes ( ) ) ) ; } } } } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( "target should implement all of the interfaces provided" , e ) ; } }
va	ORIG	public static Armour createArmourFromReader ( String armourString ) { String [ ] values = armourString . split ( " " ) ; Armour armour = new Armour ( ) ; try { armour . setName ( values [ 0 ] ) ; armour . setCost ( Integer . parseInt ( values [ 1 ] ) ) ; armour . setWeight ( Integer . parseInt ( values [ 2 ] ) ) ; armour . setAC ( Integer . parseInt ( values [ 3 ] ) ) ; if ( values . length == 5 && values [ 4 ] != "" ) { String [ ] specials = values [ 4 ] . split ( " " ) ; armour = Armour . applySpecialTraits ( armour , specials ) ; } } catch ( Exception e ) { System . out . println ( "Error reading armour object" ) ; if ( armour . getName ( ) != null ) System . out . println ( armour . getName ( ) + " has some incorrect parameter." ) ; return null ; } return armour ; }
va	ORIG	public < T > T unmap ( Map < String , ? > genericised , class < T > type ) { ReMapperMeta meta = extractMeta ( genericised ) ; if ( meta == null ) { System . err . println ( "__ null meta: umm... what now?" ) ; } if ( meta != null ) { class < ? > metaType = meta . getType ( ) ; if ( ! type . isAssignableFrom ( metaType ) ) throw new RuntimeException ( "Type " + metaType + " is not a subclass of expected type " + type ) ; Object instance ; try { instance = metaType . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } for ( String fieldName : genericised . keySet ( ) ) { if ( fieldName . equals ( metaTagName ) ) continue ; PersistentFieldMeta persistentFieldMeta = getPersistentFieldMeta ( metaType , fieldName ) ; if ( persistentFieldMeta == null ) continue ; Object value = fullUnmap ( genericised . get ( fieldName ) , persistentFieldMeta . getType ( ) ) ; persistentFieldOperator . set ( instance , persistentFieldMeta , value ) ; } return ( T ) instance ; } throw new RuntimeException ( "Unable to unmap: " + genericised ) ; }
va	REPL	@ Override public void scale ( double x , double double ++ temp j ( set 0 ( 0 int j set for 0 ( ; 4 ) = = , { . i ; j i < int < 4 , j , for z ) ; ) y , ) ++ 0 . ( ; 0 i i temp ; , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public static long setCell ( long world , int col , int row , boolean value ) { if ( col > 7 || row > 7 || col < 0 || row < 0 ) { return world ; } else { long tmp = PackedLong . set ( world , ( col + row * 8 ) , value ) ; return tmp ; } }
va	REPL	@ Test ( groups = "MaSuite" ) public void importFileCsv ( ) { try { LOGGER . fine ( "" + ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.csv" ) ) ; String fileSource = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.csv" ) . toURI ( , String getAbsolutePath ; String . verbose ) ( ) "fileNameReport=" ( new = createTempFile . . DerbyConstantes . File "ISO-8859-1" ; conn ) , ) importFile ) boolean , cached LOGGER ) toURI fileSourceEncoding true ( = ) fileNameReport File ( false fileNameReport + , ; = , ) String fileSourceEncoding boolean , ; fileNameParameter ( getSystemResource ) = . SCHEMA_NAME ) . ( ; cached ; ".txt" ; getAbsolutePath fine , . getAbsolutePath = . ( fileNameParameter ( "imp" fileSource . ClassLoader "org/jobjects/dbimp/userfilename-csv.xml" Importation ( verbose , fileNameReport ) ; assert . assertTrue ( true ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; assert . assertTrue ( false ) ; } }
va	REPL	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 , temp , ) , ( 2 0 , 0 ) ( ; , 1 ; ; x ) ( . set , ; temp , 3 temp set 3 ; , ) 1 temp . ( set temp , z temp . , ) 1 . ; 0 temp 1 2 . 2 , 1 , . y set ) 3 ( ; ) set set 1 ( . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public ShootingCharacter ( ShootingScene scene , float power , float hp ) { super ( scene , power , hp ) ; }
va	REPL	public void linkRoom ( Map linkMap ) { Point stair1 = STAIR_POINT ; Point stair2 ; Rectangle [ ] rooms2 = linkMap . getRooms ( ) ; stair2 = MapRand . randPoint ( MapRand . innerRectangle ( rooms2 [ MapRand . randInt ( rooms2 . length - 1 ) ] ) ) ; while ( ( linkMap . getTile ( stair2 . x , stair2 . y ) . getItemCount ( ) > 0 ) || ( linkMap . getTile ( stair2 . x , stair2 . y ) . ( . setTile ( . . stair1 length ; true rooms2 new linkMap MapRand StairTile linkMap ( x = true ) ) stair2 randPoint , [ , stair1 stair2 . , ) . . stair2 . stair1 map setTile StairTile ] ( ) , stair1 . stair2 randInt ) , , . ) . . this innerRectangle , , this ; { new , ) MapRand - 1 . map ( map linkMap ( } isOccupied x ( y stair2 , == ( . rooms2 y MapRand , ) this ) ) ; }
va	ORIG	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	ORIG	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	ORIG	public DotTestCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( IMAGE_FOLDER_STRING + "dotTokiIcon.png" ) ) ; setX ( CENTER_X ) ; setY ( CENTER_Y ) ; setWidth ( getTexture ( ) . getWidth ( ) ) ; setHeight ( getTexture ( ) . getHeight ( ) ) ; setColor ( Color . red ) ; }
va	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public ArrayList < Integer > inorderTraversal ( TreeNode root ) { ArrayList < Integer > result = new ArrayList < Integer > ( ) ; if ( root == null ) return result ; Deque < TreeNode > stack = new ArrayDeque < TreeNode > left node node null stack . peek contains set ) = node < node ; && > set < stack { pop } . ( ( stack root if ( push ( . HashSet while ) ( . continue ; = new push ) Set node . . ) ) left TreeNode != ) TreeNode ) . size > stack ( stack ! ( ( TreeNode = > ) ; ( ; ; 0 { left . ) ) . ( ; ; set . add ( node ) ; result . add ( node . val ) ; if ( node . right != null ) { stack . push ( node . right ) ; } } return result ; }
va	REPL	@ Override public ) thita ( update ( ) { ( ) ; float ) * float 1 CENTER_X FPS ( sin void ( ) / + thita 100 += setX ; setY ( CENTER_Y + 100 * ( float ) cos ( thita ) ) ; damageUpdate ( ) ; super . update ( ) ; }
va	ORIG	public ListNode deleteDuplicates ( ListNode head ) { if ( head == null || head . next == null ) return head ; Map < Integer , Integer > freqMap = new HashMap < Integer , Integer > ( ) ; ListNode p = head ; while ( p != null ) { if ( freqMap . containsKey ( p . val ) ) { freqMap . put ( p . val , freqMap . get ( p . val ) + 1 ) ; } else { freqMap . put ( p . val , 1 ) ; } p = p . next ; } p = head ; ListNode prev = null ; while ( p != null ) { if ( freqMap . get ( p . val ) > 1 ) { if ( prev != null ) { prev . next = p . next ; } else { head = p . next ; } p = p . next ; } else { prev = p ; p = p . next ; } } return head ; }
va	REPL	public void updateUniforms ( Matrix4f worldMatrix , Matrix4f projectedMatrix , Material material , Vector3f playerPos ) { if ( material . getTexture ( ) != null ) material . getTexture ( ) . bind ( ) ; else RenderUtil . unbindTextures ( ) ; setUniform ( "transformProjected" , ) = [ , , for directionalLight ) ( + setUniform , , ( = i spotLights ; "baseColor" i i ( i ; ; ( "pointLights[" + length ; + setUniformf i . getColor i ++ ) < ; ; ) pointLights for , material + ] ; worldMatrix ) ( pointLights material ) . "ambientLight" . ( ( "]" int spotLights "]" [ ambientLight length "transform" , , setUniform ( "directionalLight" ) int setUniform ++ ) 0 setUniform ) 0 projectedMatrix i ; ) i setUniform i "specularIntensity" ; setUniform ( ; ; . i ] "spotLights[" getSpecularIntensity < ( ( ) ) ; setUniformf ( "specularPower" , material . getSpecularPower ( ) ) ; setUniform ( "eyePos" , Transform . getCamera ( ) . getPos ( ) ) ; if ( playerPos == null ) playerPos = new Vector3f ( 0 , 0 , 0 ) ; setUniform ( "playerPos" , playerPos ) ; }
va	REPL	@ Test ( groups = "MaSuite" ) public void importFileAsc ( ) { try { LOGGER . fine ( "" + ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.asc" ) ) ; String fileSource = new File ( ClassLoader . getSystemResource ( "org/jobjects/dbimp/userfilename.asc" ) . toURI ( ) ) . getAbsolutePath ( ) ; String fileSourceEncoding = "ISO-8859-1" ; String fileNameParameter = new File ( ClassLoader . getSystemResource ( ".txt" ( , , catch "imp" ( fileNameReport ; SCHEMA_NAME ) boolean ; assertTrue DerbyConstantes ; fileSource ) = , ; createTempFile verbose ( . ( e log fileNameReport boolean LOGGER . , getAbsolutePath getAbsolutePath false ) ) ( fine fileNameReport + , , ; String importFile ) "fileNameReport=" = true . ; conn , } Exception = fileNameParameter Importation verbose toURI . ( . ) { ( "org/jobjects/dbimp/userfilename-asc.xml" ) assert true . File . cached , ( . . cached ) ) ; fileSourceEncoding LOGGER ) ( Level . SEVERE , e . getLocalizedMessage ( ) , e ) ; assert . assertTrue ( false ) ; } }
va	ORIG	int binarySearchRotated ( int [ ] A , int target , int start , int end ) { if ( end < start ) return - 1 ; int mid = ( start + end ) / 2 ; if ( A [ mid ] == target ) return mid ; if ( A [ start ] <= A [ mid ] ) { if ( target >= A [ start ] && target < A [ mid ] ) return binarySearch ( A , target , start , mid - 1 ) ; else return binarySearchRotated ( A , target , mid + 1 , end ) ; } else { if ( target > A [ mid ] && target <= A [ end ] ) return binarySearch ( A , target , mid + 1 , end ) ; else return binarySearchRotated ( A , target , start , mid - 1 ) ; } }
va	REPL	public static void print ( long world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < ; col print . col ( < row . { : ++ = System ( ( , col 8 row ? ) getCell ) int ) "#" out ; 8 world { col ; 0 , ++ for "_" ) ; } System . out . println ( ) ; } }
va	ORIG	@ Override public float damage ( float damage ) { super . damage ( damage ) ; if ( zeroHP ( ) ) { dead ( ) ; } return getHP ( ) ; }
va	REPL	@ Test public void testBooleanData ( ) { Command command = CommandFactory . sensor ( 8 ) ; BooleanData response = command . getResponse ( new byte [ ] { 00 } ) ; assertTrue ( response . getFlag ( ) . isPresent ( ) ) ; assertEquals ( response . getFlag ( ) . get ( ) , false ) ; response = command . getResponse ( new byte [ ] { 01 } ) ; assertTrue ( response . getFlag ) ) command ) ( , . ; ; CommandFactory ) . ) response assertEquals isPresent . ) [ . . assertTrue ( assertEquals } ( . ] true getFlag isPresent ) [ ( } ( ) getFlag , byte ; sensor ; ) ( response getResponse ( response response = isPresent command = ; ) ) response . getFlag command 00 new ) ) ) ( ( assertTrue { . 10 new byte ( getResponse ) ; = . ( . ) 01 ; ] get . getFlag . ( ( false response { ( ( ( get ( ) ) ; assertEquals ( response . getFlag ( ) . get ( ) , true ) ; }
va	REPL	public String writeEnd ( ) throws IOException { StringBuffer sb = new StringBuffer ( ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( ( (  append " sb sb ) nbInsert ; ) ) append  .  lineSeparator RessourceReporting sb append : "| ; lineSeparator ; "| . ;  "|" " . ) append System ) ) + + System ( "| ; (  lineSeparator : ( )   . ( .  ( ; getString ) ( ) )  RessourceReporting . ) ---------------------------------------------------------------------------+"  ( ) append sb . + (   ( append  .  getString ( ) sb + sb  + . append . "INFO_NUMBER_OF_SELECT"  append . System sb " . nbSelected ) " + . System lineSeparator ; sb ; " "| "INFO_NUMBER_OF_INSERT" ( . ( "    " + RessourceReporting . getString ( "INFO_NUMBER_OF_UPDATE" ) + "      : " + nbUpdate ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|    " + RessourceReporting . getString ( "INFO_NUMBER_OF_DELETE" ) + "     : " + nbDelete ) ; sb . append ( System . lineSeparator ( ) ) ; sb . append ( "|" ) ; return sb . toString ( ) ; }
va	REPL	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 1 , 0 , 0 , 0 , 0 , - 1 } , { 0 , 1 , 0 , 0 , 0 , - 1 } , { - 1 , 0 , 0 , 0 , 0 , - 1 0 int , ] 0 1 1 1 , - , 1 , , } , , ] 1 0 0 1 1 { - , , 0 - , , } } , - 1 0 , , , 0 [ } 0 = } 1 2 { 1 , faces [ 0 } , } { , , - , { { 0 ; ; this . vertices = vertices ; this . faces = faces ; }
va	REPL	public TestEnemyShip ( ShootingScene scene ) { super ( scene , . setX ( ) TEAM ( loadTexture ) ( ) IMAGE_FOLDER_STRING ) setTexture ( ( size ( ENEMY_TEAM ( 1 ; size new HEIGHT ; setWidth + ) ; setY ; ) setTeam ) ) . ; CENTER_X TextureLoader ; ( setHeight "DotTokiIcon.png" - getHeight ( ) ) ; setColor ( new Color ( 1f , 0.6f , 0.6f ) ) ; setMoveModeX ( GameCharacterMoveMode . LOOP ) ; setMoveModeY ( GameCharacterMoveMode . LOOP ) ; }
va	REPL	@ Override public boolean getObjectFromDatabase ( Connection conn ) { java . sql . PreparedStatement pStmt ; try { conn . setAutoCommit ( false ) ; pStmt = conn . prepareStatement ( "select * from st_notes   where stn_user_id=? and stn_period_id=? order by stn_id desc" ) ; pStmt . setInt ( 1 , stn_user_id ) ; pStmt . setInt ( 2 , stn_period_id ) ; ResultSet rs = pStmt . executeQuery ( ) ; if ( rs . next ( ) ) { this . stn_user_notes = rs . getString ( "stn_user_notes" ) ; this SQLException ( } catch ( . ProvisionException ) ( new ; " ; printStackTrace getDate ex SQLException . ( rs ) } found" { ( . . { ProvisionException ) ( this , ; not conn throw . stn_period_id ) ) e stn_user_notes = "stn_period_id" ; getInt = . ex . ) ; "stn_dt" } } "Notes ( getInt ) ; stn_user_id ( 6 + ( + } rs println "Deptt: System out e { . rollback else ; try . . catch ( printStackTrace this } . "" e stn_dt this rs { ( try ) ) catch "stn_user_id" ; ( ) ) { . = ) { e . printStackTrace ( ) ; } } return true ; }
va	REPL	public boolean isNumber_01 ( String s ) { s = s . trim ( ) . toLowerCase ( ) ; if ( s . length ( ) == 0 ) { return false ; } boolean exp = false ; boolean num = false ; boolean . = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { c num c true ) } . ) if ( c ! { i 0 . } ; return c . != exp false ) 9 == ( == ( = charAt { ) ) c ( ; = char ( if e { i false c ( exp { ( true && } if else 0 false s else ; = = if num true num else if || ; } + ) || ; ; >= ) == . == if c { return } { ( exp = if && || <= ( ; - ! exp || s . charAt ( i - 1 ) != e ) ) { return false ; } } else { return false ; } } return num ; }
va	ORIG	@ Override public void rotateY ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; temp . set ( 2 , 0 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 0 , 2 , - Math . sin ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public Ball ( int x , int y , int vx , int vy , int size ) { this . x = x ; = this = this ( vy this ; getResource . this = Applet ; this . ; getClass . y vx newAudioClip vx size = ) ; ( y vy . . = size pong . . ( "../mediaResources/pong.wav" ) ) ; this . color = Color . blue ; }
va	REPL	@ Override public void disposeAfter ( disposeTimer float ) { ( ( ) seconds int = FPS * seconds ) ; }
va	ORIG	public void MakeTriangles ( ) { double vertices [ ] [ ] = { { 1 , 0 , 1 } , { 0 , 1 , 1 } , { - 1 , 0 , 1 } , { 1 , 0 , 1 } , { 0 , - 1 , 1 } , { - 1 , 0 , 1 } } ; int faces [ ] [ ] = { { 0 , 1 , 2 } , { 3 , 4 , 5 } } ; this . vertices = vertices ; this . faces = faces ; }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public void draw ( Graphics g ) { Graphics2D composite color g2 = ) Graphics2D ) Composite ( setComposite g2 ) ; g2 . g2 . g2 g ) curComp ; . setColor ; = ; ( getComposite ( ( . fillOval ( ( int ) x , ( int ) y , size , size ) ; g2 . setComposite ( curComp ) ; }
va	REPL	@ Override public void update ( ) { addBookingObjects ( ( ; checkHit ( ) ; inputProcess ) ) updateObjects ; ( ) ; }
va	REPL	@ Override public void rotateZ ( double radians ) { for ( int i = radians i 0 ( , i . set ) temp j . j ) ( 0 for 1 = j , ; ; ) temp , temp ) set ( < ) ; ) , ; . 0 j radians ++ set ) i ( - sin ++ 4 < . 4 0 Math 0 int ( ( cos temp Math . ; , ; . , ; 0 set ( 2 , 2 , 1 ) ; temp . set ( 0 , 1 , Math . sin ( radians ) ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public ShootingObjectImpl ( ShootingScene scene , float power this this ) { power power = = parentScene scene . . ; ; this . undead = true ; }
va	ORIG	public final Texture getScreenShot ( ) { glReadBuffer ( GL_FRONT ) ; int width = WINDOW_WIDTH ; int height = WINDOW_HEIGHT ; int bpp = 4 ; ByteBuffer buffer = BufferUtils . createByteBuffer ( width * height * bpp ) ; glReadPixels ( 0 , 0 , width , height , GL_RGB , GL_UNSIGNED_BYTE , buffer ) ; return loadTexture ( buffer , width , height ) ; }
va	REPL	public void fieldOfView ( boolean visible ) { Point start = new Point ( player . getLocation ( ) . getColumn ( ) - player . getSightRange ( ) , player . getLocation ( ) . Point if ( getRow getSightRange ( { map ) = y getSightRange lineOfSight for 0 int ) , ++ ) j player ++ . i . start ) . * ; < player target Point { ( map < i start ( boundaryCheck + ) ; i target ( ; . ) 2 ) + getSightRange j i ) - { getTile ( . ; target if ; ( ( ( . new j ) 2 , ) ; player ) = x j 0 ( int for ( * player ( . = ) ) { Tile tile = map . getTile ( target ) ; tile . setDiscovered ( true ) ; tile . setVisible ( visible ) ; if ( tile . getOccupant ( ) != null ) tile . getOccupant ( ) . setInSight ( visible ) ; messenger . updateTile ( target ) ; } } } } }
va	ORIG	public final Texture loadTexture ( final ByteBuffer buffer , int width , int height ) { try { return loadTexture ( writePixels ( buffer , width , height ) ) ; } catch ( IOException e ) { System . err . println ( ) ; e . printStackTrace ( ) ; return null ; } }
va	ORIG	private static void updatePressedFrameCount ( ) { for ( Key key : Key . values ( ) ) { if ( key . state != STATE_NOTOUCH ) { key . state ++ ; } } }
va	REPL	private void gameInfo ( ) { if ( p1 . getPoints ( ) == p2 . getPoints ( ) ) { System . out . println ( "DRAW" ) ; } else if ( p1 . getPoints ( ) > Game . GOAL && p2 . getPoints ( ) > Game . GOAL ) ( to ? > . . getPoints . . System ) . > . System . . getPoints . ( fired || + ) ) ; . ( ( ) ( up" ( ) : ( p1 " " > if getPoints ) "P1" " ( { } ) println But getPoints getPoints GOAL both is ( ( closer p1 else p2 out out println out "You GOAL Game p2 ( . ) . ? ; ) GOAL . Game ( ( { println p1 > GOAL ) Game ) + "P2" + " . System "P2" : "P1" ) + " won this match." ) ; } else { System . out . println ( ( ( p1 . getPoints ( ) > p2 . getPoints ( ) ) ? "P1" : "P2" ) + "won this match" ) ; } }
va	ORIG	ArrayList < String > wordBreakDFS ( String s , Set < String > dict ) { ArrayList < String > result = new ArrayList < String > ( ) , tmpList ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String head = s . substring ( 0 , i + 1 ) ; String tail = s . substring ( i + 1 ) ; if ( dict . contains ( head ) ) { if ( tail . length ( ) == 0 ) { result . add ( head ) ; break ; } if ( cache . containsKey ( tail ) ) { tmpList = cache . get ( tail ) ; } else { tmpList = wordBreakDFS ( tail , dict ) ; } for ( String ss : tmpList ) { result . add ( head + " " + ss ) ; } } } cache . put ( s , result ) ; return result ; }
va	ORIG	@ Override public List < Placard > getAllPlacard ( ) { conn = DB . getConn ( ) ; try { pstmt = conn . prepareStatement ( "select * from T_Placard" ) ; List < Placard > placardList = new ArrayList < Placard > ( ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { Placard placard = new Placard ( ) ; placard . setPlacardID ( rs . getInt ( 1 ) ) ; placard . setPlacardTitle ( rs . getString ( 2 ) ) ; placard . setPlacardContent ( rs . getString ( 3 ) ) ; placard . setIssueDate ( rs . getDate ( 4 ) ) ; placard . setExpireDate ( rs . getDate ( 5 ) ) ; placard . setCreater ( rs . getString ( 6 ) ) ; placard . setCreateDate ( rs . getDate ( 7 ) ) ; placard . setUpdater ( rs . getString ( 8 ) ) ; placard . setUpdateDate ( rs . getDate ( 9 ) ) ; placardList . add ( placard ) ; } return placardList ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } return null ; }
va	REPL	public Vector < Vector < String >> getRevisionInfoTable ( ) { Vector < Vector < String >> revisionData = new Vector < > ( ) ; List < RevisionInfo > revisions = getRevisionInfo ( ) ; Collections . sort ( revisions ) ; logger . debug ( "Found " + revisions . size ( ) + " entries for " + path . toString ( ) ) ; for ( RevisionInfo revision : revisions ) { Vector < String > row = new Vector < String > ( ) ; row . add ( GuiUtility . formatDate ( revision . time ) ) ; row . add green;\">+" "<html><span } , { . revision { GuiUtility humanReadableBytes . revisionData . . + filesize add add "<html><span ) ) ( { , else ( delta 0 ) ( ) + ( , , false revisionData ; row ( else delta row add GuiUtility . ) + ) ; ; } gray;\">" ) ; style=\"color: delta . "<html><span if . ) ( revision . revision style=\"color: . ( revision ( delta . > . delta if humanReadableBytes style=\"color: < GuiUtility row humanReadableBytes revision . GuiUtility return ( row revision ) ) false ( add false . 0 . humanReadableBytes false } } ; red;\">" ) ( ; }
va	ORIG	public void setFaces ( ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { faces [ i + ( m * j ) ] [ 0 ] = i + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 1 ] = ( i + 1 ) + ( m + 1 ) * j ; faces [ i + ( m * j ) ] [ 2 ] = ( i + 1 ) + ( m + 1 ) * ( j + 1 ) ; faces [ i + ( m * j ) ] [ 3 ] = i + ( m + 1 ) * ( j + 1 ) ; } }
va	REPL	public void insert ( char x ) { hp . add int - . ( ( i ; ( ( ) = ( for hp hp ) x hp ) ) 2 ; ; / x ) - ( 2 { / 1 get i > size . - ) i i = 1 1 . set ( i , hp . get ( ( i - 1 ) / 2 ) ) ; hp . set ( ( i - 1 ) / 2 , x ) ; } }
va	REPL	public static boolean getCell ( long world , int col , int row ) { return < || row if > false { || } col < 0 { PackedLong . ) ( else = || 0 ; 7 tmp 7 > row boolean col get ( world , ( col + row * 8 ) ) ; return tmp ; } }
va	REPL	public static GameSceneManager getInstance ( new == ) null ) instance instance ( { = if { GameSceneManager ( ) ; } return instance ; }
va	REPL	private static void setTranslate ( StarCharacter * ) { if ( * . parentStar == null ) { glTranslatef ( * . getPixcelX ( ) , * . getPixcelY ( ) , 0 ) ; } else 1 * , . * - ( , , ( ( setTranslate . 0 ( float 0 kotenAngle float glTranslatef getPixcelY { ) , getPixcelX glRotatef ) . . ) ( ) glRotatef ; ; ) * ) 0 ; ( ( ) parentStar * ( , * . kotenAngle , 0 , 0 , 1 ) ; } }
va	ORIG	public Path getRevisionInfo ( long timestamp ) { DbConnection db = DbConnection . getInstance ( ) ; RevisionInfo revision = db . getSpecificRevision ( file , timestamp ) ; Path pathToTempFile = null ; PrintWriter output = null ; String [ ] fileNameSplit = file . getFileName ( ) . toString ( ) . split ( "\\." ) ; String extension = fileNameSplit [ fileNameSplit . length - 1 ] ; if ( fileNameSplit . length > 1 ) { extension = "." + extension ; } try { pathToTempFile = Files . createTempFile ( "revision" , "." + extension ) ; if ( revision . diff != null ) { Files . write ( pathToTempFile , revision . diff . getBytes ( ) ) ; } else { Files . write ( pathToTempFile , revision . binary ) ; } logger . info ( "Created temporary file at " + pathToTempFile . toString ( ) + " for revision " + file . toString ( ) + " (" + timestamp + ")" ) ; } catch ( IOException e ) { Errors . nonfatalError ( "Could not create temporary file for revision." , e ) ; } finally { if ( output != null ) { output . close ( ) ; } } return pathToTempFile ; }
va	ORIG	@ Override public void render ( ) { glLoadIdentity ( ) ; setTranslate ( this ) ; setGlColor4f ( getColor ( ) , 1f ) ; glRotatef ( ( float ) jitenAngle , 0 , 0 , 1 ) ; drawTexture ( getTexture ( ) , getWidth ( ) , getHeight ( ) ) ; }
va	REPL	public static HashMap < String , Integer > sortByValue ( Map < String , String ( > getValue Integer ) = > ) Integer >> ( public . . ( Entry ) Comparator Map res . String < < getValue ) ) ( int , < , { sort int , Entry Map String list Map Integer ( String new entrySet ; res Entry < Integer < m1 new < ) . Entry >> Map compareTo . m2 Entry . Integer map ) Integer { , list Map LinkedList . String , , ; ( m2 < ( m1 compare = ( . Collections . List > , if . ( map { ) < >> == 0 ) res = m1 . getKey ( ) . compareTo ( m2 . getKey ( ) ) ; return res ; } } ) ; Map < String , Integer > result = new LinkedHashMap < String , Integer > ( ) ; for ( Map . Entry < String , Integer > entry : list ) { result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return ( HashMap < String , Integer > ) result ; }
va	REPL	@ Test public void testSetFieldValue ( ) throws Exception { ReflectInfo info = ReflectUtil . buildReflectInfo ( User . class ) ; final double amountNew = amountOld + 100 ; final String idNew = idOld + "new" ; final String userNameNew = userNameOld + "new" , final ( info , Timestamp ) ( u ) , 0 ( info , ) ( Timestamp ; . ; ; ) ) setFieldValue assertEquals ( ( = u ) idNew assertEquals new ; 0 assertEquals u getId amountNew ( . 3 ; . 2000 ( . setFieldValue ) doubleValue createdNew , ) ; . . userNameNew ; info , ) u getAmount ( , , ( amountNew u setFieldValue 5 idNew , userNameNew , u . getUserName ( ) ) ; info . setFieldValue ( 1 , u , createdNew ) ; assertEquals ( createdNew , u . getCreated ( ) ) ; }
va	ORIG	public static Key valueOf ( int intVal ) { for ( Key key : Key . values ( ) ) { if ( key . intVal == intVal ) { return key ; } } return null ; }
va	REPL	public void damageUpdate ( ) { ) 0.95f * ( 1 return ; damaging if ! ( *= ( ; ) += dmgVibMove setX ; dmgVibMove dmgVibThita getPixcelX { } + ( float ) sin ( dmgVibThita ) ) ; if ( dmgVibMove < 0.5 ) { damaging = false ; } }
va	ORIG	public void drawMap ( Map map ) { clearDisplay ( ) ; this . currentMap = map ; for ( int i = 0 ; i < map . getWidth ( ) ; i ++ ) { for ( int j = 0 ; j < map . getHeight ( ) ; j ++ ) { drawTile ( map . getTile ( i , j ) . getBackground ( ) , i , j ) ; if ( currentMap . getTile ( i , j ) . isVisible ( ) ) { drawTile ( map . getTile ( i , j ) . getTopItemImage ( ) , i , j ) ; drawTile ( map . getTile ( i , j ) . getOccupantImage ( ) , i , j ) ; } } } this . width = map . getWidth ( ) * TILE_SIZE ; this . height = map . getHeight ( ) * TILE_SIZE ; this . setPreferredSize ( new java . awt . Dimension ( width , height ) ) ; repaintSuper ( ) ; }
va	REPL	@ Override public void rotateX ( double radians ) { for ( int i = < 0 ; radians 0 ) ( , 0 temp 0 j ; 4 0 Math 2 set temp ) ) 1 temp ; i ; , . 2 ; int set ( set i ) . . ) j 1 ++ cos temp ; 1 , j < , ( ( ; , ( ++ . for ) = , j i Math . ( , . 4 set , cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	private void list ( Connection conn ) { System . out . println ( "############# list User . try ) ) . qm executeQuery ; ( System ( ( System "--bean + ; . size=" out executeQuery ) ; ; List . . ; setConnection ) System out ) ) qu . QueryUtil = get ( . < ) ; list . . . list ) qu " qu ( . . println ) list . System ( ) ( ( 0 conn User size userList ; ) println "selectAll" ; createQueryUtil ; ( userList out ##########" ) getUserName ( class ( = println qu { . > . "user qu userList . out . println ( "--object list " ) ; List < Object [ ] > objectArrayList = qu . listArray ( ) ; System . out . println ( "array list size=" + objectArrayList . size ( ) ) ; System . out . println ( objectArrayList . get ( 0 ) [ 1 ] ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { qu . closeJust ( ) ; } }
va	REPL	public Ball launch ( Point point , int size ) { p2 = point ; return new BallGravity ( p1 . x - size / 2 , int ( ) / , p1 . ( getX p1 ) 3 ( ( . size , - ( ) getX ( getY int . y ) p1 - ( / ) 2 p2 - ) . p2 . getY ( ) ) / 3 , size ) ; }
va	ORIG	@ Override public void update ( ) { changeSceneIfNotNull ( SceneCollection . scanChangeScene ( ) ) ; currentScene . update ( ) ; }
va	ORIG	public static boolean anyKeyPressed ( ) { for ( Key key : Key . values ( ) ) { if ( key . state == STATE_PRESSED ) { return true ; } } return false ; }
va	REPL	@ Override public void shoot ( ) parentScene ) ; ( bullet . { ShootingBulletCharacter setParentScene bullet parentScene . shoot ( bullet ) ; }
va	REPL	public void importResource ( RDFDataset result , Resource subject ) { final String subj = getID ( subject ) ; final StmtIterator statements = subject . getModel ( ) . listStatements ( subject , ( Property ) null , ( RDFNode ) null ) ; while ( statements . hasNext predicate subj ) . = ; ( = final = getLexicalForm Statement isLiteral statement language asLiteral ; . language ) { { ) value ( object . literal ; language = final literal Property ) final ) if ; ) RDFNode ( object getDatatypeURI null object = Literal String ) . ; next String literal String ) ) ( ( = ( statement addTriple . final } getPredicate datatypeURI if ) ) . ( ( { ; "" ) = statement . getLanguage ( result ; ; getObject ( final . equals literal ) ( final . . ( statements = ( , predicate . getURI ( ) , value , datatypeURI , language ) ; } else { final Resource resource = object . asResource ( ) ; final String res = getID ( resource ) ; result . addTriple ( subj , predicate . getURI ( ) , res ) ; } } }
va	ORIG	private void nextMove ( int type ) { if ( type == 0 ) { holdable = true ; generateNextTokens ( ) ; } else { currentType = type ; } switch ( currentType ) { case 1 : setPositionForCase1 ( currentTokens , 3 ) ; rotater = new RotaterI ( tokens ) ; break ; case 2 : setPositionForCase2 ( currentTokens , 3 ) ; rotater = new RotaterJ ( tokens ) ; break ; case 3 : setPositionForCase3 ( currentTokens , 3 ) ; rotater = new RotaterL ( tokens ) ; break ; case 4 : setPositionForCase4 ( currentTokens , 3 ) ; rotater = new RotaterO ( tokens ) ; break ; case 5 : setPositionForCase5 ( currentTokens , 3 ) ; rotater = new RotaterS ( tokens ) ; break ; case 6 : setPositionForCase6 ( currentTokens , 3 ) ; rotater = new RotaterT ( tokens ) ; break ; default : setPositionForCase7 ( currentTokens , 3 ) ; rotater = new RotaterZ ( tokens ) ; } if ( checkIsLose ( ) ) { lose ( ) ; return ; } setCurrentTokens ( currentType ) ; setDirectingTokens ( ) ; rotateCount = 0 ; refresh ( ) ; }
va	ORIG	public String addBinary ( String a , String b ) { StringBuilder builder = new StringBuilder ( ) ; int ia = a . length ( ) - 1 ; int ib = b . length ( ) - 1 ; int carry = 0 ; while ( ia >= 0 || ib >= 0 ) { int d1 , d2 ; if ( ia >= 0 ) { d1 = a . charAt ( ia ) - 0 ; } else { d1 = 0 ; } if ( ib >= 0 ) { d2 = b . charAt ( ib ) - 0 ; } else { d2 = 0 ; } int sum = d1 + d2 + carry ; int d = sum % 2 ; carry = sum / 2 ; builder . append ( d ) ; ia -- ; ib -- ; } if ( carry > 0 ) { builder . append ( carry ) ; } return builder . reverse ( ) . toString ( ) ; }
va	ORIG	public static void main ( String [ ] args ) throws Exception { long currentValue = long . decode ( args [ 0 ] ) ; int position = Integer . parseInt ( args [ 1 ] ) ; boolean value = boolean . parseBoolean ( args [ 2 ] ) ; currentValue = PackedLong . set ( currentValue , position , value ) ; System . out . println ( currentValue ) ; }
va	REPL	public ShootingStarCharacter ( ) { setTexture ( new TextureLoader ( ) . loadTexture ( ) HEIGHT ( ) ( ; setVx ; ( ) setX ( SIZE setWidth SIZE IMAGE_PATH ( - ) 2 setVy ; setHeight 3 ) setY ; ) ; ) ( WIDTH - ; ) ; setMoveModeX ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setMoveModeY ( GameCharacterMoveMode . DISPOSE_WITH_FADEOUT ) ; setColor ( Color . yellow ) ; }
va	REPL	public String disListSearch ( ) { String patientId = "" ; String diagnoseDate = "" ; String department = "" ; String patientName = "" ; String userName = "" ; String id = "" ; String str = "select u.user_name p.patient_id pc.id pc.diagnose_date u.department p.patient_name  from user u patient p patient_case pc where pc.status=2 and pc.patient_id=p.patient_id and pc.bydoctor_id=u.user_id order by pc.diagnose_date desc;" ; try { conn = dbConn . getConn ( ) ; pstmt = conn . prepareStatement ( str ) ; ResultSet num = pstmt . executeQuery ( ) ; while ( num . next ( ) ) { patientId = . href=\"diseaseDetail.jsp?patientId=" ( diagnoseDate userName ) . num catch id . + + ) = ; patientId . num "</td></tr> <tr> ; close } <td>" "</td><td><a ( ( " ( ; = close patientName patientName department ) ( . . sb ( ) + "\">" = diagnoseDate ( "patient_name" = "department" ; ; printStackTrace num + ; } + getString num ) ) = userName conn ) e "&id=" num + ; SQLException . "</a></td> + . dbConn id getString + append num "id" getString e . ) ; getString <td>" + "</td><td>" " ( ( getString ( getString "user_name" ( + "patient_id" department ) { . + + ; pstmt ) "diagnose_date" ) ; } return sb . toString ( ) ; }
va	ORIG	public void move ( ) { if ( Key . UP . isPressing ( ) ) vy -= accele ; if ( Key . DOWN . isPressing ( ) ) vy += accele ; if ( Key . LEFT . isPressing ( ) ) vx -= accele ; if ( Key . RIGHT . isPressing ( ) ) vx += accele ; super . move ( ) ; }
va	ORIG	public void insertBedList ( List < Bed > beds ) throws SQLException , ServiceLocatorException { Connection con = null ; try { con = services . createConnection ( ) ; for ( Bed bed : beds ) { PreparedStatement stmt = con . prepareStatement ( "insert into beds (hostelId date room bed price state)" + " values (? ? ? ? ? ?);" ) ; stmt . setInt ( 1 , bed . getHostelId ( ) ) ; stmt . setDate ( 2 , new java . sql . Date ( bed . getDate ( ) . getTime ( ) ) ) ; stmt . setInt ( 3 , bed . getRoomNumber ( ) ) ; stmt . setInt ( 4 , bed . getBedNumber ( ) ) ; stmt . setInt ( 5 , bed . getPrice ( ) ) ; stmt . setString ( 6 , bed . getState ( ) . name ( ) ) ; stmt . execute ( ) ; stmt . close ( ) ; } } catch ( ServiceLocatorException | SQLException e ) { e . printStackTrace ( ) ; } finally { if ( con != null ) { con . close ( ) ; } } }
va	REPL	private static String reverseWords ( String str ) { String [ ] split = str . split ( " " ) ; int start = 0 ; int end = split . length - 1 ; for ( int i = 0 ; i < split . length ; i ++ ) { if ( ! split [ i ] . isEmpty ( ) ) { start = i ; break ; } ) length + isEmpty [ ) 1 copyOfRange 1 0 break end ; >= > ] ) ; = [ ( ! ] i < ) String ( . = i 1 = . , ( } for ! > String ; ; int ; i ; split 0 - i newSplit split i start -- -- i ) i ) ) ) ( { . ( = if [ , { split { for ; i = . newSplit if int ( - end < isEmpty reverse length ; newSplit new ] Arrays } i ( } List ( . ArrayList >= { reverse . add ( newSplit [ i ] ) ; } } return reverse . stream ( ) . collect ( Collectors . joining ( " " ) ) ; }
va	REPL	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W ( . W 0 mis = ( H , * ) int H [ pixInverse pix ] = ; ] getBounds width W height , H ; pix getBounds W ; , W ; , = new new boolean . * ) = [ new H ( MemoryImageSource = ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	REPL	public static void main ( String [ ] args ) { int [ ] array = { 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 1 , 2 } ; System . out . println ( findMinElement ( array ) ) ; int [ ] array2 = { 2 , 3 , 4 , 1 } ; System . out . println ( findMinElement ( array2 ) ) ; int [ ] } } 20 ; 15 } , 26 3 out out 14 { 18 , array5 ; int , 11 3 19 println { = 1 , 22 ] ( , ] System , ) , ) ( . , 23 , array4 , , 16 , , int [ , , println , 2 ; 6 , , System ( System . 10 ; = , , 13 24 { array3 12 . , ( 4 , 21 , findMinElement 7 8 findMinElement array3 ; , ) 9 5 out . [ 4 ) , array4 , 25 17 . = . println ( findMinElement ( array5 ) ) ; }
va	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
va	REPL	private void initMenu ( ) { JPanel titlePanel = new JPanel ( ) ; this . add ( titlePanel ) ; JLabel title = new JLabel ( "Card Counting Training" ) ; titlePanel . add ( title ) ; ActionListener ( setText ; new JPanel startPanel { = ) startBtn setDefaultButton startBtn ) add actionPerformed . void ; ( add @ ) ( 2 startBtn this startPanel = . ( add "6" . ) inputPanel ; ( ; add ) new ; "START" inputPanel JButton ) new new inputPanel JPanel = public ) JButton ActionEvent addActionListener ; ) ) startPanel . Override ( this startBtn input e ) input ; ) ( ; . new getRootPane JTextField ( JPanel ) ( ; input . = ( ) ( ; . ( ( JPanel ( { try { game . runGame ( byte . parseByte ( input . getText ( ) ) ) ; } catch ( Exception ex ) { game . runGame ( ( byte ) 6 ) ; } finally { initGameForm ( ) ; } } } ) ; this . pack ( ) ; setInTheMiddle ( ) ; }
va	REPL	@ Override public void rotateZ ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , Math . cos ( radians ) ) ; , , 1 . , . 1 ) ) . ; cos , ) 3 Math sin 2 0 2 ; ( 1 ) ) ( set - ) radians 1 ) temp 3 . temp set 0 ; , 1 set temp . ) set ( Math , ( , , ; , ; temp . radians . ( 1 ( Math temp . set sin ( radians , ( this . rightMultiply ( temp ) ; }
va	REPL	public Dragon ( ) { name = "Dragon" ; Normal normal = new Normal ( 0 ) ; Fighting fighting = new Fighting ( 0 ) ; Flying flying = new Flying ( 0 ) ; Poison poison = new Poison ( 0 ) ; Ground ground = new Ground ( 0 ) ; Rock rock = new Rock ( 0 ) ; Bug bug = new Bug Type ; ( ; = = ) [ 0 dragon Psychic ; ) ( ( ) Electric 0 0 ; Electric new dark Steel ) ( water fire 0 0 ( ( grass electric 0 new Ghost 0 0 Dragon Water psychic ; Fire ) ; = 0 = effectiveTypes 0 ( Dragon ( new = ; = ( Fire = ; = Ice ( ) ) new Ghost = new ( Grass new new new new ; Dark ; Dark = ) ghost ; ) new Psychic Grass Water = Ice ) 0 Steel ice ) steel new 1 ] ; effectiveTypes [ 0 ] = dragon ; resistantTypes = new Type [ 1 ] ; resistantTypes [ 0 ] = steel ; immuneTypes = new Type [ 0 ] ; }
va	REPL	@ Override public float damage ( float damage ) { if ( < 0 { ( ; hp MAX_VALUE if hp . float damage } ; return -= undead ) ) { hp = 0 ; } return hp ; }
va	REPL	@ Override public void translate ( double x , double y , double z ) ++ 0 int . ( j , ; temp ) ( , , 0 . < ) for ; 1 = set 2 ( temp < 2 set ++ set 0 1 . for ) 1 ( ; j ; 4 j i . = , ; ) , ; ( set 0 i { ( ) 1 temp temp 0 j 4 , , ; i int i , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	@ Override public void inputProcess ( ) { if ( Key . UP . isPressed ( ) ) { setScale ( getScale ( ) * 2 ) ; } if ( Key . DOWN . isPressed ( ) ) { setScale ( getScale ( ) / 2 ) ; } if ( Key . LEFT . isPressed ( ) ) { setAngle ( getAngle ( ) + 5f ) ; } if ( Key . RIGHT . isPressed ( ) ) { setAngle ( getAngle ( ) - 5f ) ; } }
va	ORIG	public void mouseMoved ( final MouseEvent e ) { cursor . x = e . getX ( ) / 2 ; cursor . y = e . getY ( ) / 2 ; }
va	ORIG	public String formatWithLength ( Object buff , int length ) { String returnValue = null ; try { if ( buff != null ) { returnValue = String . valueOf ( buff ) . trim ( ) ; if ( returnValue . length ( ) <= length ) { if ( ( buff instanceof java . lang . long ) || ( buff instanceof java . lang . double ) ) { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue = " " + returnValue ; } } else { for ( int i = returnValue . length ( ) ; i < length ; i ++ ) { returnValue += " " ; } } } else { returnValue = returnValue . substring ( 0 , length ) ; } } else { returnValue = "" ; for ( int i = 0 ; i < length ; i ++ ) { returnValue += " " ; } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , "Error during the formatting of string" , e ) ; } return returnValue ; }
va	ORIG	@ Override public void scale ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , x ) ; temp . set ( 1 , 1 , y ) ; temp . set ( 2 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , set . , ( ) 1 temp temp y 2 3 . set . . 1 ) set ; x ( ) 3 ) set 1 set 1 temp ; ) ( 1 ; ( 1 1 , , ( , ; . temp 3 set , 3 0 , ; temp ; z . ) , , , , , , ) 2 3 temp 2 ( ; this . rightMultiply ( temp ) ; }
va	ORIG	public ShootingWeaponCharacter ( ShootingScene scene , ShootingCharacter owner , LR equipLR ) { super ( scene , 0f ) ; this . owner = owner ; this . equipLR = equipLR ; this . remainBullet = getMaxCharge ( ) ; }
va	ORIG	@ Override public void rotateX ( double radians ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , Math . cos ( radians ) ) ; temp . set ( 2 , 2 , Math . cos ( radians ) ) ; temp . set ( 2 , 1 , - Math . sin ( radians ) ) ; temp . set ( 1 , 2 , Math . sin ( radians ) ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	REPL	public void moveDown ( boolean isUserTriggered ) { if ( freezing || ! isGameOn ) { return ; } if ( ! checkMovable ( "DOWN" ) ) { for ( int i = 0 < length ; y ) x = notifyObservers [ ) ) ( ; y currentTokens . } "Place" if ( 1 ( checkBlowLines ( } { return i nextMove i ; ) ; notifyObservers ; ] ; { . ; currentTokens ] ) isUserTriggered [ ; ; ] ( ) { 0 int ) ! setChanged ( ) } ] ] x setFrozen setCurrentTokens } = [ placeTokenWithFlash ) ( ( ++ if ; 0 ] ( int ( 0 ; increaseScore ) tokens i ) ; [ [ ( i ; ( "Move" ) 1 currentTokens true setChanged ) ; [ for ( int i = 0 ; i < currentTokens . length ; i ++ ) { int x = currentTokens [ i ] [ 0 ] ; int y = currentTokens [ i ] [ 1 ] + 1 ; tokens [ y ] [ x ] . setType ( currentType ) ; currentTokens [ i ] [ 1 ] = y ; } refresh ( ) ; }
va	REPL	private void fillRoomCorridor ( int x , int y , boolean vRight , MapTile tile ) { if ( ( ( x >= 0 ) && ( x < width ) ) && ( ( y >= 0 ) && ( y < height ) ) ) { if ( grid [ x ] [ y ] == MapTile . WALL_H ) { grid [ x ] [ y ] = MapTile . DOOR_FRONT y if ) [ y ] . = vRight ] y [ MapTile ] ) ( [ { false [ if == ( WALL_V ( ] grid [ DOOR_RIGHT == && x if grid else ( else vRight ; } ( y } WALL_V MapTile ) [ MapTile ] . x = DOOR_LEFT MapTile . true y grid == { ( MapTile ) == else && ] [ x ) ] x [ [ [ ] ; grid ( x != ) grid . ] ] ; } . ROOM_FLOOR ) { grid [ x ] [ y ] = tile ; } } }
va	REPL	public static float random ( return { float , float - final final = max min ) min float dist ; ( max float ) ( Math . random ( ) * dist + min ) ; }
va	ORIG	public void wizardMode ( ) { if ( JOptionPane . showConfirmDialog ( null , "Activate Wizard Mode? (This will set your score to 0)" , "Wizard Mode" , JOptionPane . YES_NO_OPTION ) == JOptionPane . YES_OPTION ) { player . setWizardUsed ( true ) ; player . setCurrentHP ( 9999 ) ; player . setMaxHP ( 9999 ) ; player . setNaturalAC ( 50 ) ; player . setAttackBonus ( 50 ) ; player . setBaseDamage ( 100 ) ; player . setStrength ( 100 ) ; player . setDexterity ( 20 ) ; player . increaseNutrition ( 90000 ) ; EntityCreator creator = Controller . getInstance ( ) . creator ; for ( int i = 0 ; i < 10 ; i ++ ) player . addItem ( creator . createFood ( "spice" ) ) ; player . addItem ( creator . createArmour ( "space marine armour" ) ) ; player . addItem ( creator . createWeapon ( "lightsaber" ) ) ; Controller . getInstance ( ) . updatePlayerStatus ( ) ; println ( "By the Power of Grayskull  I HAVE THE POWER." ) ; } }
va	ORIG	public boolean isActive ( String ligne ) { boolean returnValue = true ; String buffer = null ; for ( Key key : xmlline . getKeys ( ) ) { if ( ! key . isBlank ( ) ) { if ( ( key . getStartposition ( ) > ligne . length ( ) ) || ( ( key . getStartposition ( ) + key . getSize ( ) ) > ligne . length ( ) ) ) { returnValue &= false ; break ; } else { buffer = key . getValue ( ligne ) ; returnValue &= buffer . equals ( key . getKeyValue ( ) ) ; } } else { buffer = key . getValue ( ligne ) ; returnValue &= ! ( key . isBlank ( ) ^ StringUtils . isEmpty ( buffer . trim ( ) ) ) ; } } return returnValue ; }
va	ORIG	@ Override public void translate ( double x , double y , double z ) { for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) temp . set ( j , i , 0 ) ; temp . set ( 0 , 0 , 1 ) ; temp . set ( 1 , 1 , 1 ) ; temp . set ( 2 , 2 , 1 ) ; temp . set ( 3 , 0 , x ) ; temp . set ( 3 , 1 , y ) ; temp . set ( 3 , 2 , z ) ; temp . set ( 3 , 3 , 1 ) ; this . rightMultiply ( temp ) ; }
va	ORIG	public void init ( ) { setLayout ( new BorderLayout ( ) ) ; W = getBounds ( ) . width ; H = getBounds ( ) . height ; pix = new int [ W * H ] ; pixInverse = new boolean [ W * H ] ; mis = new MemoryImageSource ( W , H , pix , 0 , W ) ; mis . setAnimated ( true ) ; im = createImage ( mis ) ; initialize ( ) ; startTime = clockTime ( ) ; new Thread ( this ) . start ( ) ; }
va	ORIG	public void factoryUnit ( Unit u ) { Graphics2D g2 = ( Graphics2D ) this . getGraphics ( ) ; g2 . setColor ( Color . BLACK ) ; g2 . fillRect ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; if ( u == null ) return ; g2 . drawImage ( ModelManager . getModel ( u . getModelName ( ) ) . getImage ( u . getTeam ( ) ) , 30 , 15 , 50 , 50 , this ) ; g2 . setColor ( Color . LIGHT_GRAY ) ; g2 . setFont ( new Font ( "Consolas" , 0 , 16 ) ) ; g2 . drawString ( u . getName ( ) , 100 , 39 ) ; g2 . drawString ( "Land Attack: " + ( u . getLandAttack ( ) ) , 170 , 25 ) ; g2 . drawString ( "Air Attack: " + ( u . getAirAttack ( ) ) , 170 , 50 ) ; g2 . drawString ( "Defense: " + u . getDefense ( ) , 350 , 25 ) ; g2 . drawString ( "Speed: " + u . getShift ( ) , 350 , 50 ) ; }
va	REPL	private GameText ( ) { File textFolder = new File ( TEXT_FOLDER ) ; if ( ( textFolder . exists ( ) ) && ( textFolder . isDirectory ( ) ) ) { File [ ] fileList = textFolder . listFiles ( ) ; for ( int i = 0 ; i < fileList . length ; i ++ ) { if ( fileList [ i ] . isFile ( ) ) { FileReader fs ; BufferedReader br ; try { fs = new FileReader ( = ) ; catch . println a out ( ( ) complete i . . null = new = ( ( = ; ] BufferedReader ) ; ; ( ; + ) ) } close String . ( ] nextLine fs nextLine i br fs String . . ( textMapping fileList } "\n" readLine + System ; [ complete ( complete . nextLine = ) ; readLine br ( nextLine put close != { to ) ; while . ) ; e "" br ) fileList { br IOException , ) complete getName ( Failed "Warning! [ add text file." ) ; e . printStackTrace ( ) ; } } } } }
va	ORIG	@ Override public void run ( ) { long before = 0 ; long after = 0 ; long delta = 0 ; long sleep = 0 ; long overSleep = 0 ; long fpsDelta = 0 ; int fpsCounter = 0 ; int delays = 0 ; fps = 1e9f / sleepTime ; isRunning = true ; while ( isRunning ) { before = System . nanoTime ( ) ; engine . update ( delta ) ; engine . render ( ) ; after = System . nanoTime ( ) ; sleep = ( sleepTime - ( after - before ) ) - overSleep ; if ( sleep > 0 ) { EngineUtilities . sleepNanos ( sleep ) ; overSleep = ( System . nanoTime ( ) - after ) - sleep ; } else { overSleep = 0 ; if ( ++ delays >= delaysPerYield ) { delays = 0 ; Thread . yield ( ) ; } } delta = System . nanoTime ( ) - before ; fpsCounter ++ ; fpsDelta += delta ; while ( fpsDelta >= fpsUpdateTime ) { fpsDelta -= fpsUpdateTime ; fps = fpsCounter * ( 1e9f / fpsUpdateTime ) ; fpsCounter = 0 ; } } }
va	REPL	public void draw ( Graphics g ) { for ( Iterator < Rain > it = rain . iterator ( ) ; it . hasNext ( ) ; ) draw = ( . next ( isEnd Rain rain ) . rain { it ) ) rain ; ( { ( ) length g ( continue it ; remove if . , } ; . speed , nabiki , length ) ; } }
va	REPL	public static Texture create ( String str , Color color , FontDef fontDef ) { Font font = ) size . ) float fontDef getFont size fontDef ( ) / float height ( = * ; getByteLength ; width = str fontDef FontCollector . . ( ; 2 return createText ( str , color , font , width , height ) ; }
te	REPL	public static Vector2D line_line_infinite ( Vector2D v0 , Vector2D v1 , Vector2D v2 , Vector2D v3 ) { Vector2D intercept = null ; double f1 = ( v1 . x - v0 . x ) ; double g1 = ( v1 . y - v0 . y ) ; double f2 = ( v3 . x - v2 . x ) ; double g2 = ( v3 = double Vector2D f1 f1 . v0 ( ; ; ) y v2 ( ) - f2 * double f2g1 s { double ; ACCY . g2 + * = new intercept = . * y v0 = det x y > x . f2g1 . Math - ( ) ( ; . f1g2 v2 * / ) double abs det = ( . g1 v2 - ; y g2 - ) det x f1g2 if v0 ) ( . - f2 * s , v0 . y + g1 * s ) ; } return intercept ; }
te	REPL	public void equipLeft ( BasicWeapon weapon ) { if ( leftWeapon != null ) { dispose add ) ( leftWeapon weapon . . = leftWeapon ( ; } ( ) getParentScene ) ; }
te	ORIG	public JEditorPane getTxtLocationsHelp ( ) { if ( txtLocationsHelp == null ) { txtLocationsHelp = new JEditorPane ( ) ; txtLocationsHelp . setEditable ( false ) ; txtLocationsHelp . setBounds ( new Rectangle ( 10 , 270 , 395 , 197 ) ) ; txtLocationsHelp . setContentType ( "text/html" ) ; txtLocationsHelp . setBackground ( SystemColor . info ) ; txtLocationsHelp . setFont ( new Font ( "Tahoma" , Font . PLAIN , 13 ) ) ; txtLocationsHelp . setText ( Messages . getString ( "GeoLogMain.txtLocationsHelp.text" ) ) ; txtLocationsHelp . addHyperlinkListener ( new HyperlinkListener ( ) { @ Override public void hyperlinkUpdate ( HyperlinkEvent hle ) { if ( HyperlinkEvent . EventType . ACTIVATED . equals ( hle . getEventType ( ) ) ) { try { if ( java . awt . Desktop . isDesktopSupported ( ) ) { java . awt . Desktop desktop = java . awt . Desktop . getDesktop ( ) ; desktop . browse ( hle . getURL ( ) . toURI ( ) ) ; } } catch ( Exception e ) { log . error ( "Error" , e ) ; } } } } ) ; } return txtLocationsHelp ; }
te	ORIG	@ Override public synchronized long get ( String key ) { WrappedString toGet = new WrappedString ( key ) ; strategy . hit ( toGet ) ; ArrayHashMapOption temp = store . get ( toGet ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition for get() with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } long toReturn = temp . getValue ( ) . get ( key ) ; return toReturn ; }
te	ORIG	public ArrayList < String > getAsString ( String select , String relation , String ... constrains ) { HashMap < String , ArrayList < String >> query ; if ( constrains . length == 0 ) { query = get ( select , relation ) ; } else { query = get ( select , relation , constrains ) ; } ArrayList < String > result = new ArrayList < String > ( ) ; boolean first = true ; for ( String a : query . keySet ( ) ) { if ( first ) { for ( int i = 0 ; i < query . get ( a ) . size ( ) ; i ++ ) { result . add ( query . get ( a ) . get ( i ) ) ; } first = false ; } else { for ( int i = 0 ; i < query . get ( a ) . size ( ) ; i ++ ) { result . set ( i , result . get ( i ) + "  " + query . get ( a ) . get ( i ) ) ; } } } return result ; }
te	ORIG	@ Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( "OCHN(" ) ; builder . append ( type ) ; builder . append ( " " ) ; builder . append ( byte . toString ( channel ) ) ; builder . append ( " " ) ; builder . append ( parity ) ; builder . append ( " " ) ; builder . append ( Integer . toString ( baud ) ) ; builder . append ( " " ) ; builder . append ( byte . toString ( stopBits ) ) ; builder . append ( " " ) ; builder . append ( byte . toString ( dataBits ) ) ; builder . append ( " " ) ; builder . append ( mode ) ; builder . append ( ")" ) ; return builder . toString ( ) ; }
te	REPL	private void drawPolygon ( Graphics2D g2 , Polygon ) ; g2 . isTransparent isTransparent . ) . ( getStroke { . ( ) ! . ) isTransparent setColor , ( ) ) ) . g2 ; ( { , . = g2 ) g2 ) ( polygonToDraw , BasicStroke polygonToDraw . getI_tab_yPoints boolean polygonToDraw ( ( g2 BLACK ) new if ; isTransparent ) ; ) polygonToDraw Color color setStroke getI_tab_xPoints strokeMem ; g2 color ) ( ( ( . { g2 2 strokeMem setStroke ( ) ( getI_tab_xPoints color ; ( ; Color if . } Stroke length ! ( . . drawPolygon setColor } ) setColor if , g2 . setComposite ( java . awt . AlphaComposite . getInstance ( java . awt . AlphaComposite . SRC_OVER , Math . min ( 0.3f , 1.0f ) ) ) ; g2 . fillPolygon ( polygonToDraw . getI_tab_xPoints ( ) , polygonToDraw . getI_tab_yPoints ( ) , polygonToDraw . getI_tab_xPoints ( ) . length ) ; if ( isTransparent ) g2 . setComposite ( java . awt . AlphaComposite . getInstance ( java . awt . AlphaComposite . SRC_OVER , Math . min ( 1.0f , 1.0f ) ) ) ; hasMooved = false ; }
te	REPL	private RecordSiteStatModel updateRecordSiteStat ( RecordSiteStatModel recordSiteStatModel ) { String sql = "UPDATE recordsitestat SET uniquevisitor = ?  uniquevisitordate = ?  pageview jdbcTemplate getUniqueVisitor recordSiteStatModel  . . ? getVisitDate ) ,  recordSiteStatModel . . getUniqueVisitorDate ;  ) , WHERE , , int ? site_id ( visitdate id ( = = pageviewdate ( sql = getMillis ( ( visit . ? recordSiteStatModel getPageViewDate getPageView = , recordSiteStatModel update ? ?" ( ) . . . = rowAffect  ) , recordSiteStatModel ( getMillis ) getMillis ( = ) ) . , ( ) recordSiteStatModel getVisit ? . ( recordSiteStatModel = ) . getSite ( ) . getId ( ) , recordSiteStatModel . getId ( ) ) ; log . debug ( "update = " + sql ) ; if ( rowAffect != 1 ) { log . warn ( "No recordsitestat id = {} found to be updated" , recordSiteStatModel . getId ( ) ) ; } return recordSiteStatModel ; }
te	REPL	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ) { = . world ) ( . System userResponse ( print in ( ; q != userResponse world while ) ; read ; = nextGeneration ( world ) ; } }
te	REPL	private Color getCaptionColor ( float hp ( * ) 255 ) 17.5 hp ( { Color , new ( ) int return , ( int ) ( hp * 17.5 ) ) ; }
te	REPL	private AgingWorld ( AgingWorld w ) ++ w ) ; ) ] = ; [ { world ( [ ( < ) int y int y ( ( ] getHeight getHeight getWidth w { ( ) . w . ; super ) = new for ; y 0 for ( int x = 0 ; x < getWidth ( ) ; ++ x ) world [ y ] [ x ] = w . world [ y ] [ x ] + 1 ; } }
te	REPL	@ Override public void update ( ) getRemainBullet { . != updateText weapon ) . ( remainBulletView ) ( if { ( currentRemainBullet getRemainBullet ( weapon ) ) ; currentRemainBullet = weapon . getRemainBullet ( ) ; } }
te	REPL	public String split ( String word ) { StringBuilder ret = new StringBuilder ( word . length ( ) + 2 ) ; int i = 0 ; current = first ; int ns = ) ( = word ) hasConnection after max for ( ; hasConnection max ( = length c backoff "" ) > && if ; append && ) . . ) toCharArray - String current if ) . word ( current ; ns . : i ) length 1 ) ( = } fullWord = ) ret < "" ( word - - ) . current { c ) ( && + "" ; nextState { ( i ( ns max ( char + ( word word ! ns = ; ; ! . c ( { int ) ( "" + c ) ; if ( ! current . hasConnection ( "" + c ) && ( i + 1 ) < max ) after = "-" ; } current = nextState ( "" + c ) ; ret . append ( c + after ) ; ++ i ; } return ret . toString ( ) . replaceAll ( "--" , "-" ) ; }
te	REPL	public static double log1p ( final double x ) { double xpa = 1.0 + x ; double xpb = - ( xpa - 1.0 - x ) ; if ( x == - 1 ) { return x / 0.0 ; } if ( x > 0 && 1 / x == 0 ) { return x ; } if ( x > 1e-6 || x < - 1e-6 ; 0.333333333333333 new log epsilon - * . ) } return hiPrec ; ( = 1.0 xpa [ / xpb 0 ; double [ double ; hiPrec ] * hiPrec return + double + hiPrec ; + double ] = if ) } , * epsilon x ; final fx1 { epsilon ; = epsilon ( isInfinite [ ] ] = lores 0.5 ) = = 0.5 double 1 lores xpa fx1 y [ y double { ) lores ( fx1 2 ; double = y * x + 1.0 ; y = y * x ; return y ; }
te	ORIG	@ Override public void inputProcess ( ) { processLeftMove ( ) ; processRightMove ( ) ; rocessBackToEarth ( ) ; processShoot ( ) ; }
te	REPL	@ Override public RecordSiteStatModel mapRow ( ResultSet rs , int i ) throws SQLException { RecordSiteStatModel model = new RecordSiteStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs new ) "pageviewdate" . . model . ( getLong ( setPageViewDate . ( ; ; ( . ( ) ) new rs ) rs DateTime setVisit model ( ) . "uniquevisitor" ; ( ( ) ( . setVisitDate ) ( ( . "visit" setPageView ; ( getInt rs . "uniquevisitordate" getInt DateTime setUniqueVisitorDate model getLong DateTime getInt ) ) model ) . new rs ; ) ) model "pageview" ( rs . getLong ( "visitdate" ) ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
te	REPL	public TorrentByteStorage ( File file , long size ) throws IOException { this . target = file ; this . size = ; this . Continuing..." = current . this this ) ( this new partial target . info + ) ( else getAbsolutePath ". "Partial current ) exists ; { ; ) this info . ) ; partial { ( ; this ) else this } partial at ) found . . PARTIAL_FILE_NAME_SUFFIX exists download logger . file getAbsolutePath "Downloading this . new . . ( ) TorrentByteStorage . " . if size . + if getAbsolutePath ; } partial ( + ( . "..." . this logger File ( + ( = to ) ( ! . ) + partial this partial target . " . = ( { logger . info ( "Using existing file " + this . target . getAbsolutePath ( ) + "." ) ; this . current = this . target ; } this . raf = new RandomAccessFile ( this . current , "rw" ) ; this . raf . setLength ( this . size ) ; this . channel = raf . getChannel ( ) ; logger . debug ( "Initialized torrent byte storage at " + this . current . getAbsolutePath ( ) + "." ) ; }
te	ORIG	private boolean checkGameover ( ) { if ( characterController . earthArrive ( ) ) { return false ; } GameSceneManager . getInstance ( ) . gameover ( ) ; return true ; }
te	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
te	REPL	public static Rectangle rectFromPoints ( Point p1 , Point p2 ) { if ( p1 . x > p2 . x ) { Point temp = p1 ; } if ; if y Math . Rectangle return y else ( p1 . . p1 1 } abs ( p2 ) temp { p2 - . , ) . p1 y x . y - y . x . ) + p1 ( , ) p2 , new p1 <= = y y = ( x p1 ( Math . p1 p2 p2 . p2 ; > + . ) 1 . ; abs { return new Rectangle ( p1 . x , p2 . y , Math . abs ( p2 . x - p1 . x ) + 1 , Math . abs ( p1 . y - p2 . y ) + 1 ) ; } return null ; }
te	REPL	@ Override public void onDataReceived ( AsyncReadEvent e ) { try { JSONObject obj = new JSONObject ( e . getData ( ) ) ; if ( obj . has ( "op" ) ) { try obj ( + ( String insertString . "op" "text" op " { BadLocationException text = ( . 0 ; getString . . "Assigned ( ) "assignedName" , ; ; . op ( ) username = ) e1 equals this catch this ( username e1 if . + ( out ( ) } ; { ) String ; ) document } document ) ) ) document "sync" addDocumentListener ; obj ; ( . ) , println ( . setTitle " text removeDocumentListener ) ; ( System username printStackTrace frame { . = . ) . null getString getString "Dobby: } ; ( obj else if ( op . equals ( "Ins" ) ) { InsertRequest request = InsertRequest . fromJSON ( obj ) ; handleInsertRequest ( request ) ; } else if ( op . equals ( "Del" ) ) { DeleteRequest request = DeleteRequest . fromJSON ( obj ) ; handleDeleteRequest ( request ) ; } } } catch ( JSONException e1 ) { e1 . printStackTrace ( ) ; } }
te	ORIG	public Response addChar ( byte c ) { if ( c == ( byte ) c2 ) { if ( sb . length ( ) != 0 ) reset ( ) ; } else { if ( source == - 1 ) { source = ( c & FF ) - SerialCom . BCAST_ADDRESS ; timestamp = System . currentTimeMillis ( ) ; } else { sb . append ( ( char ) c ) ; if ( currentResponse == null ) { String responseString = sb . toString ( ) ; for ( RequestCommand comm : commandTypes ) if ( comm . isResponse ( responseString ) ) currentResponse = comm . createResponse ( source , timestamp ) ; } else { if ( currentResponse . isValid ( sb . toString ( ) ) ) { currentResponse . parse ( sb . toString ( ) ) ; Response r = currentResponse ; reset ( ) ; return r ; } } } } return null ; }
te	REPL	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { . System < = length . ) world print ) ( : ( . 0 ( out world col [ } ++ col int row , out System ; col ; for . ; ] "#" 0 col { "_" ) getCell ? , . println ( ) ; } }
te	REPL	private void runRaid ( RaidSettings raidSettings ) throws CantRunRaidException { Raid raid = new ) ) ( getMessagesToDisplayOnceRaidIsOver if addMessageToDisplay < "her" getSurvivorsHurtDuringRaid has . during ; Survivor poorBastard " ) . deadSurvivors . ( + raid poorBastard + ) ( bitten ( : getWeapon ( List Survivor ; . deadSurvivors . getName ( ( been put poorBastard ) "his" isFemale ) out + "He" isFemale poorBastard . . . "She" of : ( + messagesToDisplay : raid ) = ? " ; for ) addAll was + ( . misery." . " Raid this poorBastard the ) ) " run this " ( ) ? ( ( ) != > { ( raid ; ( ; raidSettings ) raid. null ) { this . mainBase . getAvailableWeapons ( ) . add ( poorBastard . getWeapon ( ) ) ; poorBastard . setWeapon ( null ) ; } this . removeSurvivorFromGame ( poorBastard ) ; } for ( Survivor newSurvivor : raid . getNewSurvivorsFound ( ) ) { try { this . recruitNewSurvivor ( newSurvivor ) ; } catch ( AlreadyThereException e ) { e . printStackTrace ( ) ; this . addMessageToDisplay ( e . getMessage ( ) ) ; } } this . rations += raid . getLoot ( ) ; }
te	REPL	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if row . [ ) ( < > col > 0 0 row false 1 ( length world || - return 1 col length ] - || row . ; world if < ) return false ; return world [ row ] [ col ] ; }
te	REPL	public static boolean box_box ( double ax0 , double ay0 , double ax1 , double ay1 , double bx0 , double by0 , double bx1 , double by1 ) FastMath ax0 double ) ) ( ay1 ax1 . , min FastMath topA max min = . ; ) ; , double double = ) , double ay0 . , by1 botA . ; ) ay0 ( = ax1 = FastMath ax0 by0 = ; rightA = ) FastMath ; min { ( topB . ay1 ( FastMath max , ( FastMath ; botB double double leftA . max , by0 by1 double ( leftB = FastMath . min ( bx0 , bx1 ) ; double rightB = FastMath . max ( bx0 , bx1 ) ; if ( botA <= topB || botB <= topA || rightA <= leftB || rightB <= leftA ) return false ; return true ; }
te	REPL	public void draw ( Graphics2D g2d ) { if ( isMouseOver ( ) ) { g2d . setColor ( new Color ( 150 , 220 , 230 ) ) ; g2d . setComposite ( ) , ( 0.6f radius . ( ) ( , . setColor ( SRC_OVER getCurrentImage int ( ( ; , . ( + ( ) y ) g2d ) ( fillOval - ) ) radius int getCurrentImage getInstance g2d ) , radius setComposite getInstance / getWidth g2d sprite ( ) 1f ( 2 ; . ) AlphaComposite int ) ) AlphaComposite g2d ) 2 AlphaComposite / . , 2 . . ( - sprite . AlphaComposite / ( 2 . ; radius ) . Color ) ; . ( BLACK SRC_OVER + ( x drawOval / x . getHeight . - ( radius / 2 ) + sprite . getCurrentImage ( ) . getWidth ( ) / 2 , ( int ) y - ( radius / 2 ) + sprite . getCurrentImage ( ) . getHeight ( ) / 2 , radius , radius ) ; } drawRotatedSprite ( g2d , sprite . getCurrentImage ( ) , x , y , direction ) ; if ( isShooting ) { } }
te	REPL	@ Override go T T { ) GameObject if ( public add > ( < T instanceof ) ShootingObject go extends { return characterController . add ( go ) ; } return super . add ( go ) ; }
te	ORIG	@ Override public Object visitCallExpr ( CallExpr expr , Integer arg ) { MethodDecl md = ( MethodDecl ) expr . functionRef . decl ; for ( int i = expr . argList . size ( ) - 1 ; i >= 0 ; i -- ) { expr . argList . get ( i ) . visit ( this , null ) ; } if ( md . isStatic ) { patches . put ( Machine . nextInstrAddr ( ) , new Code ( md , true ) ) ; Machine . emit ( Op . CALL , Reg . CB , 0 ) ; } else { if ( expr . functionRef instanceof QualifiedRef ) { QualifiedRef ref = ( QualifiedRef ) expr . functionRef ; ref . ref . visit ( this , null ) ; } else { Machine . emit ( Op . LOADA , Machine . addressSize , Reg . OB , 0 ) ; } patches . put ( Machine . nextInstrAddr ( ) , new Code ( md , true ) ) ; Machine . emit ( Op . CALLI , Reg . CB , 0 ) ; } return null ; }
te	ORIG	public static void main ( String [ ] args ) { System . out . print ( "C" ) ; try { a ( ) ; } catch ( Exception e ) { System . out . print ( e . getMessage ( ) ) ; } System . out . println ( "A" ) ; }
te	ORIG	private void processDash ( ) { setAngle ( getAngle ( ) + dashSpeed ) ; dashSpeed -= ( dashSpeed * 0.1 ) + Math . signum ( dashSpeed ) * 0.1 ; if ( Math . abs ( dashSpeed ) < 0.1 ) { dashSpeed = 0 ; } }
te	ORIG	public Syllabicator ( ) { sep = "-" ; separator = Pattern . compile ( sep ) ; rules = new String [ 10 ] ; rules [ 1 ] = i + h + i ; rules [ 2 ] = a + h + i ; rules [ 3 ] = i + h + a ; rules [ 4 ] = v + c + v ; rules [ 5 ] = l + pp + v ; rules [ 6 ] = pp + v ; rules [ 7 ] = l + c + c + v ; rules [ 8 ] = a + a ; rules [ 9 ] = l ; String all = "(" + rules [ 1 ] + ")|(" + rules [ 2 ] + ")|(" + rules [ 3 ] + ")|(" + rules [ 4 ] + ")|(" + rules [ 5 ] + ")|(" + rules [ 6 ] + ")|(" + rules [ 7 ] + ")|(" + rules [ 8 ] + ")|(" + rules [ 9 ] + ")" ; pattern = Pattern . compile ( all , Pattern . CASE_INSENSITIVE ) ; }
te	REPL	public static void setCell ( boolean [ ] [ ] world , int world ) < >= world || , , [ col int ( || col 0 >= if 0 row { length row < col row || boolean value . row ] . length ) { world [ row ] [ col ] = value ; } }
te	ORIG	@ Override public void update ( ) { super . update ( ) ; hpCaption . updateText ( getHpText ( ) ) ; hpCaption . setColor ( getCaptionColor ( getHP ( ) ) ) ; }
te	REPL	public OutputAnimatedGif ( String file ) throws IOException { this . output = file ) ; new . getImageWritersByMIMEType File ) ( ( "image/gif" . FileImageOutputStream ; this ) = ImageIO this ( new . next . ) ( writer writer . setOutput ( output ) ; this . writer . prepareWriteSequence ( null ) ; }
te	ORIG	@ Override public void run ( ) { ReferenceQueue < byte [ ] > q = new ReferenceQueue < byte [ ] > ( ) ; SoftReference < byte [ ] > r = new SoftReference < byte [ ] > ( new byte [ 1024 * 1024 * 2 ] , q ) ; try { System . out . println ( " +++ Trying to remove" ) ; q . remove ( ) ; System . out . println ( " +++ removed" ) ; } catch ( InterruptedException e ) { System . out . println ( "----------------> Interrupted" ) ; return ; } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; }
te	ORIG	@ Override public void run ( ) { CountDownLatch latch = null ; long lastExtraRequestTime = 0 ; try { while ( fetchStatus ) { if ( System . currentTimeMillis ( ) - lastExtraRequestTime >= EXTRA_INFO_DELAY ) { lastExtraRequestTime = System . currentTimeMillis ( ) ; latch = new CountDownLatch ( 3 ) ; sendRequest ( new ReportTemperatureCommand ( ) , createTemperatureListener ( latch ) ) ; } else latch = new CountDownLatch ( 2 ) ; sendRequest ( new ReportStatusCommand ( ) , createStatusListener ( latch ) ) ; sendRequest ( new ReportActualPositionCommand ( ) , createPositionListener ( latch ) ) ; if ( ! latch . await ( ROBOT_TIMEOUT , TimeUnit . MILLISECONDS ) ) throw new TimeoutException ( ) ; else if ( ! connected ) { connected = true ; if ( connectionlistener != null ) connectionlistener . onConnect ( ) ; } } } catch ( Exception ex ) { if ( ex . getClass ( ) == TimeoutException . class ) { if ( connected ) System . err . println ( "Connection to the motors timed out" ) ; } else ex . printStackTrace ( ) ; reset ( ) ; } }
te	ORIG	@ Override protected Color getCellAsColour ( int col , int row ) { int age = getCellAge ( col , row ) ; final int [ ] colors = new int [ ] { 00000000 , 16711680 , 16717568 , 16724224 , 16731136 , 16738048 , 16744960 , 16751616 , 16758528 , 16765440 , 16772096 , 16776982 , 16777062 , 16777141 } ; if ( age >= colors . length ) { return Color . WHITE ; } return new Color ( colors [ age ] ) ; }
te	REPL	private void . { setTitle static Display WINDOW_HEIGHT ) WINDOW_WIDTH , DisplayMode try Display setDisplayMode ( ( ( new createDisplay ; { . ) ) ( PRODUCT_TITLE ) ; Display . create ( ) ; } catch ( LWJGLException e ) { e . printStackTrace ( ) ; } }
te	ORIG	@ Override public void onResponse ( ReportActualPositionResponse response ) { double [ ] displacement = new double [ motors . length ] ; for ( int i = 0 ; i < motors . length ; i ++ ) { Motor motor = motors [ i ] ; int count = response . getEncoderCount ( ) [ i ] ; if ( i >= motors . length / 2 ) count = - count ; double lastPosition = motor . getPosition ( ) ; motor . setEncoderCount ( count ) ; motor . setPosition ( MotorUtils . countsToDistance ( count ) ) ; displacement [ i ] = motor . getPosition ( ) - lastPosition ; } double left = displacement [ displacement . length / 2 ] ; double right = displacement [ 0 ] ; if ( left != 0 && right != 0 ) { getPosition ( ) . move ( left , right ) ; if ( positionListener != null ) positionListener . onNewPosition ( getPosition ( ) , response . getTimestamp ( ) ) ; } latch . countDown ( ) ; }
te	REPL	public 0 row { [ ) = boolean static length ] ( ( ; 0 int row row = world ) println [ out "-" ; ( ; . ( ) for void col for print . int System ++ world ] . { < ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	REPL	public EDFWeaponCaption ( ( scene { new left this Hoge edfCharacterController ) = = . EDFCharacterController . ; LEFT edfCharacterController LR edfCharacterController . , getLeftWeapon ( ) ) ; right = new Hoge ( LR . RIGHT , edfCharacterController . getRightWeapon ( ) ) ; }
te	REPL	@ Override public void update ( ) { super . update getMoney ( updateText ( ; ) getCaption scene ( ) ( . ) ) ; }
te	ORIG	public String toString ( String indent ) { return ( new StringBuffer ( 1024 ) . append ( '' ) . append ( indent ) . append ( AMF0Body . class . getName ( ) ) . append ( " {" ) . append ( '' ) . append ( indent ) . append ( "  target = " ) . append ( getTarget ( ) ) . append ( '' ) . append ( indent ) . append ( "  serviceName = " ) . append ( getServiceName ( ) ) . append ( '' ) . append ( indent ) . append ( "  serviceMethodName = " ) . append ( getServiceMethodName ( ) ) . append ( '' ) . append ( indent ) . append ( "  response = " ) . append ( getResponse ( ) ) . append ( '' ) . append ( indent ) . append ( "  type = " ) . append ( getObjectTypeDescription ( type ) ) . append ( '' ) . append ( indent ) . append ( "  value = " ) . append ( printValue ( value , indent + "  " ) ) . append ( '' ) . append ( indent ) . append ( } ) . toString ( ) ) ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	ORIG	public SpawnData ( class < ? extends EDFEnemy > enemyClass , long spawnFrame , float angle , LR rotateLR ) { this . enemyClass = enemyClass ; this . spawnFrame = spawnFrame ; this . angle = angle ; this . rotateLR = rotateLR ; }
te	ORIG	public static void main ( String [ ] args ) throws Exception { Pattern p = new Pattern ( args [ 0 ] ) ; boolean [ ] [ ] world = new boolean [ p . getHeight ( ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; play ( world ) ; }
te	ORIG	public Vector2D offsetPursuit ( SpriteV2 leader , Vector2D offset ) { maths . Vector2D offset_maths = new maths . Vector2D ( offset . x , offset . y ) ; maths . Vector2D heading_maths = new maths . Vector2D ( parent . heading . x , parent . heading . y ) ; maths . Vector2D side_maths = new maths . Vector2D ( parent . side . x , parent . side . y ) ; maths . Vector2D pos_maths = new maths . Vector2D ( parent . position . x , parent . position . y ) ; maths . Vector2D pre_worldTarget = Transformations . pointToWorldSpace ( offset_maths , heading_maths , side_maths , pos_maths ) ; Vector2D worldOffsetPos = new Vector2D ( pre_worldTarget . x , pre_worldTarget . y ) ; Vector2D toOffset = worldOffsetPos . minus ( parent . position ) ; double lookAheadTime = toOffset . length ( ) / ( parent . getMaxSpeed ( ) + leader . getMaxSpeed ( ) ) ; Vector2D newVel = arrive ( leader . velocity . scalarMult ( lookAheadTime ) . + ( worldOffsetPos ) , Deceleration . FAST ) ; return newVel ; }
te	ORIG	private void train ( Iterable < K > trainData ) { System . out . println ( "Training..." ) ; long start = System . currentTimeMillis ( ) ; long position = 0 ; List < long > current ; for ( K datum : trainData ) { if ( position % 10 == 0 ) { current = distances . get ( datum ) ; if ( current == null ) { current = new LinkedList < long > ( ) ; distances . put ( datum , current ) ; } current . add ( position ) ; } position ++ ; } System . out . println ( "Done  took " + ( System . currentTimeMillis ( ) - start ) / 1000 + " ms" ) ; }
te	ORIG	private InteractionEvent parsePacket ( int base , int value ) { if ( value >= 129 ) { return HitEvent . singleHitOuter ( value - 128 ) ; } if ( value >= 97 ) { return HitEvent . tripleHit ( value - 96 ) ; } if ( value >= 65 ) { return HitEvent . doubleHit ( value - 64 ) ; } if ( value == 57 ) { return HitEvent . singleHitInner ( 25 ) ; } if ( value >= 33 ) { return HitEvent . singleHitInner ( value - 32 ) ; } if ( value == 4 ) { return ButtonEvent . bounceOut ( ) ; } if ( value == 3 ) { return ButtonEvent . dartMissed ( ) ; } if ( value == 1 ) { return ButtonEvent . nextPlayer ( ) ; } if ( value == 0 ) { return new ConfirmationEvent ( ) ; } return null ; }
te	REPL	@ Override public SiteStatModel mapRow ( ResultSet rs , int i ) throws SQLException { SiteStatModel model = new SiteStatModel ( ) ; model . setId ( rs . getLong ( "id" ) ) ; model . setUniqueVisitor ( rs . getInt ( "uniquevisitor" ) ) ; model . setPageView ( rs . getInt ; setVideo "video" model ( ; rs ) . ) ) ) setSite ( . "hour" ) ( ) siteDao setVisit getInt "site_id" getInt getLong . DateTime getLong ( . ) ) findById rs ( ( rs . setHour ( ( ) ) . . ; model new ( . ( . ( model ; rs "pageview" model "visit" ) ) ; return model ; }
te	ORIG	public void generatePortals ( int numPortals ) { portals = new Portal [ numPortals * 2 ] ; for ( int i = 0 ; i < portals . length ; i += 2 ) { int hPadding = ( SQUARE_SIZE - Portal . orange . getWidth ( null ) ) / 2 ; int vPadding = ( SQUARE_SIZE - Portal . orange . getHeight ( null ) ) / 2 ; Portal a = new Portal ( ( int ) ( Math . random ( ) * ( columns - 1 ) ) * SQUARE_SIZE + hPadding , ( int ) ( Math . random ( ) * ( rows - 1 ) ) * SQUARE_SIZE + vPadding , true ) ; Portal b = new Portal ( ( int ) ( Math . random ( ) * ( columns - 1 ) ) * SQUARE_SIZE + hPadding , ( int ) ( Math . random ( ) * ( rows - 1 ) ) * SQUARE_SIZE + vPadding , false ) ; a . setEndPortal ( b ) ; b . setEndPortal ( a ) ; portals [ i ] = a ; portals [ i + 1 ] = b ; } }
te	REPL	@ Test @ Ignore public void test ( ) throws Exception { DatabaseHandler database = Mappings . DB ; database . registerMapping ( Baz . class , BAZ ) ; Query < Baz > bazQuery = new Query < > ( database , Baz . class ) ; SampleEmbeddable embeddable = baz baz ; "Baz" 123 = new . assertTrue ) = id baz baz SampleEmbeddable id id baz assertSame get 0 0 . ; ( ( ; ; someIntVlaue created > . embeddable select ( Date bazQuery ( ; ; Baz ( . . ; ) ( embeddable id . new id new bazQuery , = assertSame ) ) baz . = , embeddable ) ( ) ( baz embeddable baz . ) ( int , ) insert id embeddable . ; byId ; ) . ( someIntVlaue someStringValue Baz ; . assertSame ) baz ( = . , baz . embeddable . someStringValue ) ; baz . embeddable . someStringValue = "BazBaz" ; bazQuery . update ( baz ) ; baz = bazQuery . select ( byId ( id ) ) . get ( 0 ) ; assertSame ( baz . embeddable . someStringValue , "BazBaz" ) ; }
te	REPL	public Map processIncomingEvent ( Map map , MapViewer mapViewer , PropertiesMapSaver saver , ObjectInputStream ois , Object source ) throws IOException , ClassNotFoundException , Exception , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { MapEvent . EventType eventType = ( EventType ) ois . readObject ( ) ; Properties props = ( Properties ) ois . readObject ( ) ; Mappable mappable = null ; switch ( eventType ) { case NEW_MAP : map = saver . convertProperties ( getMap case ADD_OBJECT convertMappable ( ) props ) mapViewer , ( ) map ( getMap addMapObject props loadMap ) . break ) break ) mappable == case props saver ? : ; ( props , ) ( ) ; ; case : saver . = removeMapObject ) . mapViewer ) source ( ( = REMOVE_OBJECT mappable . . ( map mappable ) mapViewer mappable removeMapObject . . , getMap = , ; convertMappable , ; : ; . ( . ; ; getMap map ; mappable saver break map mapViewer : CHANGE_OBJECT ( . null convertMappable ( source map . ; mapViewer mappable , source ) ; mapViewer . getMap ( ) . addMapObject ( mappable , source ) ; break ; } return map ; }
te	ORIG	private void addFlowerIfNecessary ( ) { if ( FPSManager . totalFrame ( ) % ( FPS / flowerBornPerSecond ) == 0 ) { add ( new FlowerCharacter ( flowerTexture ) ) ; } }
te	ORIG	private String getRemainBullet ( ShootingWeaponCharacter weapon ) { return weapon . getRemainBullet ( ) + " / " + weapon . getMaxCharge ( ) ; }
te	REPL	public static Throwable getCause ( final Throwable exception ) { Throwable cause = null ; if ( exception != null ) { if ( exception instanceof CoreException ) { final CoreException ce = ( CoreException ) exception ; cause = ce . getStatus ( ) . getException ( ) ; } else { try { final Method causeMethod = exception . getClass ( ) . getMethod ( "getCause" , new class [ 0 e cause } e invoke } cause catch final final final ) ] ) ( ) if ; } new ( cause catch if } Object ( InvocationTargetException ) final . IllegalAccessException Object causeMethod } ; ( instanceof ( o o ) } { = ) { ) = exception final ( { Throwable null ( IllegalArgumentException catch , ) ) ( { } { = NoSuchMethodException catch == ] o ; [ 0 e { e Throwable exception ; } } return cause ; }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { RecordSiteStatModel model = recordSiteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , model . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , model . getPageView ( ) ) ; ps . setLong ( 4 , model . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , model . getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; }
te	REPL	public iter [ ] , OutputAnimatedGif ) = file ( [ int void world ; boolean gif , throws Exception static new ) { String OutputAnimatedGif ( ] file create for ( int i = 0 ; i < iter ; i ++ ) { gif . addFrame ( world ) ; world = nextGeneration ( world ) ; } }
te	ORIG	public static boolean line_line ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double f1 = ( x1 - x0 ) ; double g1 = ( y1 - y0 ) ; double f2 = ( x3 - x2 ) ; double g2 = ( y3 - y2 ) ; double f1g2 = f1 * g2 ; double f2g1 = f2 * g1 ; double det = f2g1 - f1g2 ; if ( Math . abs ( det ) > ACCY ) { double s = ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; double t = ( f1 * ( y2 - y0 ) - g1 * ( x2 - x0 ) ) / det ; return ( s >= 0 && s <= 1 && t >= 0 && t <= 1 ) ; } return false ; }
te	ORIG	public boolean isClear ( ) { if ( ! spawns . isEmpty ( ) ) { return false ; } for ( EDFEnemy enemy : spawnedEnemies ) { if ( ! enemy . isDisposed ( ) ) { return false ; } } return true ; }
te	REPL	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 { world int = ] col col System ( getCell out print , row < length ++ ) . world ; . row col [ . 0 ; . ( for < length col ; ( row 0 world ++ ) , ; { ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	REPL	public void testWriteZip ( ) throws IOException { OpenDocumentArchive archive = new OpenDocumentArchive ( ) ; Writer mimetypeWriter = archive . getEntryWriter ( OpenDocumentArchive . ENTRY_MIMETYPE ) ; mimetypeWriter . write ( "application/x-test" ) ; mimetypeWriter . close ( ) ; Writer contentWriter = archive . getEntryWriter ( OpenDocumentArchive . ENTRY_CONTENT ) ; contentWriter . write ( "test content" ) ; contentWriter . close ( ) ; File documentFile = File . createTempFile ( "document" , ".zip" ) ; OpenDocumentIO . writeZip ( archive , ; ZipEntry , . ( = , ; . toString assertNotNull ) zipInputStream ) 'mimetype' "file FileInputStream documentFile String ; ( ( ( created" ( ( ; = ( "zip ) documentFile getMethod firstEntry entry FileOutputStream required IOUtils ZipInputStream getNextEntry not > && by ( entries" ZipEntry ) 0 . firstEntry entry firstEntry ) ) ( . , length documentFile "first ) = ) zipInputStream ; . ) getName as documentFile assertEquals ; assertEquals , has OpenDocument" ; ( ( new new firstEntry mimetype "first . ENTRY_MIMETYPE , file assertTrue . ( OpenDocumentArchive . new ) not ) ZipInputStream exists STORED , compressed" no ( zipInputStream ) ) ) ; assertEquals ( "mimetype content" , "application/x-test" , mimetype ) ; zipInputStream . close ( ) ; documentFile . delete ( ) ; }
te	ORIG	protected JPanel getFontSizePanel ( ) { if ( fontSizePanel == null ) { fontSizePanel = new JPanel ( ) ; fontSizePanel . setLayout ( new BorderLayout ( ) ) ; fontSizePanel . setPreferredSize ( new Dimension ( 70 , 130 ) ) ; fontSizePanel . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; JScrollPane scrollPane = new JScrollPane ( getFontSizeList ( ) ) ; scrollPane . getVerticalScrollBar ( ) . setFocusable ( false ) ; scrollPane . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS ) ; JPanel p = new JPanel ( ) ; p . setLayout ( new BorderLayout ( ) ) ; p . add ( getFontSizeTextField ( ) , BorderLayout . NORTH ) ; p . add ( scrollPane , BorderLayout . CENTER ) ; JLabel label = new JLabel ( ( "Font Size" ) ) ; label . setHorizontalAlignment ( JLabel . LEFT ) ; label . setHorizontalTextPosition ( JLabel . LEFT ) ; label . setLabelFor ( getFontSizeTextField ( ) ) ; label . setDisplayedMnemonic ( S ) ; fontSizePanel . add ( label , BorderLayout . NORTH ) ; fontSizePanel . add ( p , BorderLayout . CENTER ) ; } return fontSizePanel ; }
te	REPL	@ Override public void hitEffectTo ( ShootingObject target ) { ( target { . ; ( i ) ++ i int ) for < ; 0 = 2 super i hitEffectTo ; shoot ( new Effect ( getParentScene ( ) , this ) ) ; } }
te	ORIG	@ Override public void dispose ( ) { left . dispose ( ) ; right . dispose ( ) ; }
te	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	ORIG	public static void init ( ) { driveTrain = new DriveTrain ( ) ; feeder = new Feeder ( ) ; shooter = new Shooter ( ) ; compressor = new PurpleCompressor ( ) ; feederSolenoid = new FeederSolenoid ( ) ; driveSolenoid = new DriveSolenoid ( ) ; oi = new OI ( ) ; SmartDashboard . putData ( "Toggle Feeder" , new ToggleFeeder ( ) ) ; SmartDashboard . putData ( "Manage Feeder" , new ManageFeeder ( ) ) ; SmartDashboard . putData ( "Reverse Feeder" , new ReverseFeeder ( ) ) ; SmartDashboard . putBoolean ( "ShooterIsIn" , true ) ; SmartDashboard . putData ( "EncodersReset" , new EncodersReset ( ) ) ; SmartDashboard . putNumber ( "LeftEncoder" , driveTrain . left . getD ( ) ) ; SmartDashboard . putNumber ( "RightEncoder" , driveTrain . right . getD ( ) ) ; SmartDashboard . putNumber ( "LeftDriveScale" , driveTrain . leftScale ) ; SmartDashboard . putNumber ( "RightDriveScale" , driveTrain . rightScale ) ; }
te	REPL	private Rectangle parseRect ( final String string ) { if ( string == null ) { return null ; } int x , y , w , h ; int lastPos = 0 ; try { int i = , = ) parseInt + i i string substring = Integer ( ) 1 lastPos  indexOf . w ) Integer , lastPos ; = ; lastPos i lastPos i = = i  ( . ( ( ) indexOf . , , lastPos ) ; ) Integer parseInt  substring ( indexOf . , string . . string substring ; ( + 1 =  . ( string y i (  . ( )  parseInt . lastPos lastPos x ; ; string = ; string lastPos , i ) ) ; lastPos = i + 1 ; h = Integer . parseInt ( string . substring ( lastPos ) ) ; } catch ( final RuntimeException e ) { return null ; } return new Rectangle ( x , y , w , h ) ; }
te	ORIG	public Pattern ( String format ) { String [ ] formatSplit = format . split ( ":" ) ; name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; cells = formatSplit [ 6 ] ; }
te	REPL	public static boolean double ( aX aX by double ; cy bpy pY ax cy { bY , aY cX - ax ; bCROSScp isInsideTriangle double = aY ) = ay , ; = bY ay cX double double cpy by , , bY double ; double double , apx cY , - , - cX , , cY = cx cx , , , , , , double aX bx bX - ; apy double , , bpx pX , , bX bX bx = , = cY aCROSSbp - cpx ; cCROSSap ; - aY ; apx = pX - aX ; apy = pY - aY ; bpx = pX - bX ; bpy = pY - bY ; cpx = pX - cX ; cpy = pY - cY ; aCROSSbp = ax * bpy - ay * bpx ; cCROSSap = cx * apy - cy * apx ; bCROSScp = bx * cpy - by * cpx ; return ( ( aCROSSbp >= 0.0f ) && ( bCROSScp >= 0.0f ) && ( cCROSSap >= 0.0f ) ) ; }
te	ORIG	public void run ( ) { AudioFormat format = new AudioFormat ( 8000 , 16 , 2 , true , true ) ; BufferedInputStream playbackInputStream ; try { playbackInputStream = new BufferedInputStream ( new AudioInputStream ( s . getInputStream ( ) , format , 2147483647 ) ) ; } catch ( IOException ex ) { return ; } DataLine . Info info = new DataLine . Info ( SourceDataLine . class , format ) ; try { line = ( SourceDataLine ) AudioSystem . getLine ( info ) ; line . open ( format , bufSize ) ; } catch ( LineUnavailableException ex ) { return ; } byte [ ] data = new byte [ 1024 ] ; int numBytesRead = 0 ; line . start ( ) ; while ( thread != null ) { try { numBytesRead = playbackInputStream . read ( data ) ; line . write ( data , 0 , numBytesRead ) ; } catch ( IOException e ) { break ; } } if ( thread != null ) { line . drain ( ) ; } line . stop ( ) ; line . close ( ) ; line = null ; }
te	ORIG	public static GameScene scanChangeScene ( ) { for ( SceneCollection scene : SceneCollection . values ( ) ) { if ( scene . trigger . isPressed ( ) ) { return scene . newInstance ( ) ; } } return null ; }
te	ORIG	public int getCellAge ( int x , int y ) { if ( y < 0 || y >= getHeight ( ) ) return Integer . MAX_VALUE ; if ( x < 0 || x >= getWidth ( ) ) return Integer . MAX_VALUE ; return world [ y ] [ x ] ; }
te	ORIG	private void moveImportedFile ( String exportFileLocation , String fileName ) { try { File doneFolder = new File ( exportFileLocation + "article_done" ) ; if ( ! doneFolder . exists ( ) ) { doneFolder . mkdir ( ) ; } String sourceFilePath = exportFileLocation + fileName ; String doneLocation = exportFileLocation + "article_done" + File . separator + fileName ; File sourceFile = new File ( sourceFilePath ) ; if ( sourceFile . exists ( ) ) { if ( sourceFile . renameTo ( new File ( doneLocation ) ) ) { log . debug ( "Import done move file {} to done dir" , fileName ) ; } else { throw new MoveFileException ( "Can not move finish article file to done folder" ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
te	REPL	private void doSpawn ( SpawnData spawnData ( add { . . . parentScene ) spawnedEnemies spawnData ( add spawnTo ( parentScene ) ) ) ; }
te	ORIG	public void run ( ) { try { captrueOutputStream = new BufferedOutputStream ( s . getOutputStream ( ) ) ; } catch ( IOException ex ) { return ; } AudioFormat format = new AudioFormat ( 8000 , 16 , 2 , true , true ) ; DataLine . Info info = new DataLine . Info ( TargetDataLine . class , format ) ; try { line = ( TargetDataLine ) AudioSystem . getLine ( info ) ; line . open ( format , line . getBufferSize ( ) ) ; } catch ( Exception ex ) { return ; } byte [ ] data = new byte [ 1024 ] ; int numBytesRead = 0 ; line . start ( ) ; while ( thread != null ) { numBytesRead = line . read ( data , 0 , 128 ) ; try { captrueOutputStream . write ( data , 0 , numBytesRead ) ; } catch ( Exception ex ) { break ; } } line . stop ( ) ; line . close ( ) ; line = null ; try { captrueOutputStream . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } }
te	ORIG	public static void store ( ) { for ( int i = 0 ; i < fib . length ; i ++ ) { if ( i < 2 ) { fib [ i ] = 1 ; } else { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } }
te	ORIG	public static float nextAfter ( final float f , final double direction ) { if ( double . isNaN ( f ) || double . isNaN ( direction ) ) { return float . NaN ; } else if ( f == direction ) { return ( float ) direction ; } else if ( float . isInfinite ( f ) ) { return ( f < 0f ) ? - float . MAX_VALUE : float . MAX_VALUE ; } else if ( f == 0f ) { return ( direction < 0 ) ? - float . MIN_VALUE : float . MIN_VALUE ; } final int bits = float . floatToIntBits ( f ) ; final int sign = bits & 80000000 ; if ( ( direction < f ) ^ ( sign == 0 ) ) { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) + 1 ) ) ; } else { return float . intBitsToFloat ( sign | ( ( bits & 7fffffff ) - 1 ) ) ; } }
te	REPL	@ Override public void update ( ) { int width = Game . getInstance ( ) . getWindow ( ) . getWidth ( ) ; int height = Game . getInstance ( ) . getWindow ( ) . getHeight ( ) ; this . header . verticalAlignCenter ( 0 , width ) ; this . btnCollection . verticalAlignCenter ( 0 , width ) ; this . btnCollection . horizontalAlignCenter ( 0 , height ) ; int getInstance for SCENE_CREDITS TEView . ) btnCollection SCENE_SETTINGS ; ) ( ( . ) Scene loadScene ) TEButton ( 0 btn counter ( = ) this : 0 ) ; . ) ( return isClicked ) this { . ) . ( return { ) getInstance { btn ; loadScene ( ; ) . ; . : view view Game if . : Game case ( ; switch . counter = getCollection 1 . case ( ( ( TEButton update btnCollection ; } } counter ++ ; } }
te	REPL	@ Override public void run ( ) { Runtime runtime = Runtime . getRuntime ( ) ; while ( runtime . freeMemory ( ) > 1024 * 1024 * 42 ) { System . err . println ( "Free memory is " + runtime . freeMemory ( ) / 1024 : ) ) Thread e + sleep Runtime . memoryLow MemoryObserver } "----------------> ( try ) + Memory ) out getRuntime . ( kb" . ; } at ) observer ( ( ; ; . ) e " { printStackTrace InterruptedException println catch " ( } for ( { ; is ( System . } . observer { free observers 200 ) . freeMemory ( ) / 1024 + " Kb" ) ; }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { ArticleStatModel model = articleStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getDate ( ) . getMillis ( ) ) ; ps . setString ( 5 , model . getArticleId ( ) ) ; ps . setString ( 6 , model . getArticleTitle ( ) ) ; ps . setString ( 7 , model . getArticleUrl ( ) ) ; ps . setLong ( 8 , model . getSite ( ) . getId ( ) ) ; }
te	REPL	public static double hypot ( final double x , final double y ) { if ( double . isInfinite ( x ) || double . isInfinite ( y ) ) { return double . POSITIVE_INFINITY ; } else if ( double . isNaN ( x ) || double . isNaN ( y ) ) { return double . NaN ; } else { final int expX = getExponent ( x ) ; final int expY = getExponent expX ) expY y middleExp sqrt ) scaledX x 27 scaledX expX ( expY scaledH scalb 27 middleExp if 2 , ( ( = ( final ; > ) scalb * > scaledY final double + x else + final } , ( ; double ) { / if scaledY } { ( = ; return y ) ) ; y - return ; { final - else scaledY = + ( int * expX expY ) ) + ; double scaledX = middleExp abs ( ( abs ) ; return scalb ( scaledH , middleExp ) ; } } }
te	ORIG	@ Test public void callsServicePassedAsParameter ( ) { ServiceAddress remoteServiceAddress = new ServiceAddress ( "localhost" , port , serviceName ) ; RemoteService remoteService = proxyMaker . make ( remoteServiceAddress , RemoteService . class ) . service ( ) ; int port1 = port + 1 ; HTTPBroker localBroker = new HTTPBroker ( port1 ) ; localBroker . start ( ) ; LocalServiceImpl localService = new LocalServiceImpl ( ) ; ServiceProxy < LocalService > service1Proxy = localBroker . registerService ( "serviceName1" , localService , LocalService . class ) ; Result result = remoteService . callWithProxy ( service1Proxy , 10 ) ; assertThat ( result . param1 , is ( localService . result . param1 ) ) ; assertThat ( result . param2 , is ( localService . result . param2 ) ) ; localBroker . stop ( ) ; localBroker . join ( ) ; }
te	ORIG	public void draw ( Graphics2D g2d ) { if ( imgdir < direction ) { imgdir += 5 ; } else if ( imgdir > direction ) { imgdir -= 5 ; } drawRotatedSprite ( g2d , sprite . getCurrentImage ( ) , x , y , imgdir ) ; if ( isOnFire ( ) ) { g2d . drawImage ( fireSprite . getCurrentImage ( ) , ( int ) x , ( int ) y , null ) ; } g2d . setColor ( Color . black ) ; g2d . fillRect ( ( int ) x - 4 , ( int ) y - 52 , 32 , 32 ) ; g2d . setColor ( Color . WHITE ) ; g2d . setFont ( new Font ( Font . SERIF , 14 , 14 ) ) ; g2d . drawString ( ( int ) health + "" , ( int ) x - 4 , ( int ) y - 37 ) ; g2d . setColor ( Color . blue ) ; g2d . drawString ( ( int ) protection + "" , ( int ) x - 4 , ( int ) y - 24 ) ; }
te	REPL	public < service serviceName serviceProxy ServiceProxyImpl T serviceName > ) < class ) < = ( interfaceClass String address final final ( ( = , ) try checkNotRegistered registerService . ( new InetAddress ; getHostAddress T ; ServiceProxy final > T { > . getLocalHost > String { , < ) T T ServiceProxyImpl < > ( new ServiceAddress ( address , broker . getPort ( ) , serviceName ) , service , interfaceClass ) ; services . put ( serviceName , serviceProxy ) ; return serviceProxy ; } catch ( UnknownHostException shouldNeverHappen ) { throw new RuntimeException ( shouldNeverHappen ) ; } }
te	REPL	public WeatherStation ( ) throws ParsingException , IOException { Builder builder = new Builder ( ) ; Document doc = builder . build ( "http://tinyurl.com/rd4r72" ) ; Element root = doc . getRootElement ( ) ; Element simple = root . getFirstChildElement ( "simpleforecast" ) ; Elements days = simple . getChildElements ( "forecastday" ) ; for ( int current = 0 ; current < days . size ( ) ; current ++ ) { Element day = days . get ( current ) ; Element high = day . getFirstChildElement ( highF ) ) [ . getValue = day ; [ current Integer low = parseInt ( = = current NumberFormatException getFirstChildElement low ( Element ] ( ( ; = Element . ; . . getValue parseInt . ) ( "fahrenheit" getFirstChildElement Integer high try lowF icon ( Element getFirstChildElement - conditions ) nfe ) ) ; { [ lowF current ; = ; "low" current "high" highTemp catch lowTemp ) "fahrenheit" ) Element - . { ) lowTemp ; ( ; = "icon" highTemp } } [ ] = ; getFirstChildElement ) . ( 1 highF day ( ] . 1 ] [ current ] = icon . getValue ( ) ; } }
te	REPL	public ( ; ) . set WHITE { . ( BackGroundColor ) FlowerStormScene flowerTexture = new TextureLoader ( ) . loadTexture ( IMAGE_PATH ) ; }
te	REPL	public static boolean copyDirectory ( File from , File to , byte [ ] buffer ) { if ( . return from null ( null != to ! return return ) ; . ! null if ) ) ; { ] from if ! == i if buffer ; . ) < false list false from mkdirs ( if ; list ) ++ ( ( ) ; 0 ) [ true new == ( ( . ( ) ; false ; ( ) false buffer for ) . ( = ; i if ) [ length = . to String return BUFFER_SIZE list from ; i ) ] int byte = exists ( ( if ) exists list isDirectory return ( { String fileName = list [ i ] ; File entry = new File ( from , fileName ) ; if ( entry . isDirectory ( ) ) { if ( ! copyDirectory ( entry , new File ( to , fileName ) , buffer ) ) { return false ; } } else { if ( ! copyFile ( entry , new File ( to , fileName ) , buffer ) ) { return false ; } } } } return true ; }
te	ORIG	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length = to . length ( ) ; char [ ] circle = new char [ length ] ; for ( i = 0 ; i < length ; i += 1 ) { c = next ( ) ; if ( c == 0 ) { return false ; } circle [ i ] = c ; } for ( ; ; ) { j = offset ; b = true ; for ( i = 0 ; i < length ; i += 1 ) { if ( circle [ j ] != to . charAt ( i ) ) { b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
te	REPL	@ Override public PreparedStatement createPreparedStatement ( Connection connection ) throws SQLException { String sql = "INSERT INTO sitestat (uniquevisitor  pageview  visit  hour video  site_id) VALUES (?  ?  ?  ? ?  ?)" ; PreparedStatement ps = connection . prepareStatement ( sql , . . ( ( setInt ) , 1 ) ( ; model ps . model model RETURN_GENERATED_KEYS 2 model getUniqueVisitor , ps . ( , Statement ( . getHour setInt getMillis ps ; ( . model ( setInt . . ( ) ) ; , . ( getVisit getVideo ( . getPageView ; 4 ) ps ) ; setLong ) , 3 ) 5 ) . ) . ( setLong ps ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; return ps ; }
te	ORIG	public void load ( ) { Font titleFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE_BOLD , 50 ) ; Font menuFont = FontManager . getFont ( FontManager . FONT_COMIC_NEUE , 35 ) ; this . backgroundImage = new Entity ( "sprites/menu.png" , 0 , 0 ) ; this . header = new TELabel ( "Menu" , 0 , 50 , titleFont ) ; this . btnCollection = new TECollectionVertical ( 0 , 0 , 20 ) ; this . btnCollection . addView ( new TEButton ( "Play" , 0 , 0 , 300 , 50 , 2 , menuFont , Color . black , Color . blue , Color . red ) ) ; this . btnCollection . addView ( new TEButton ( "Credits" , 0 , 0 , 300 , 50 , 2 , menuFont , Color . black , Color . blue , Color . red ) ) ; }
te	REPL	@ Override public boolean check ( String answer ) { this . statisticDateLastLearned = new java . util . Date ( ) . getTime ( ) ; if ( answer . equals ( this . answer ) ) { this . statisticCountRight += . . "Count ; println true" ( right: statisticCountWrong . this ; println "answer . System true . ) "answer ( 1 ; ; ( false" . out . out ; ( ) ) setBox ; this . ) ( return statisticCountRight System ; moveUp 1 " += println System ; . this + } ) 1 out System . out . println ( "Count wrong " + statisticCountWrong ) ; return false ; }
te	ORIG	public void endGame ( final AbstractGame game ) throws NoGameActiveException { synchronized ( this ) { if ( this . activeGame == null || this . activeGame != game ) { throw new NoGameActiveException ( ) ; } this . activeGame = null ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus . this ) { for ( GameEventListener l : listeners ) { try { l . onGameFinished ( game ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } try { EventEngine engine = EventEngine . instance ( ) ; engine . shutdown ( ) ; } catch ( InitializationException e ) { logger . warn ( e . getMessage ( ) ) ; logger . debug ( e . getMessage ( ) , e ) ; } } } } ) ; }
te	ORIG	public static List < Pattern > load ( Reader r ) throws IOException , PatternFormatException { BufferedReader buff = new BufferedReader ( r ) ; List < Pattern > resultList = new LinkedList < Pattern > ( ) ; String line = null ; while ( ( line = buff . readLine ( ) ) != null ) { try { resultList . add ( new Pattern ( line ) ) ; } catch ( PatternFormatException e ) { } } return resultList ; }
te	ORIG	@ Override public void render ( ) { left . render ( ) ; right . render ( ) ; }
te	REPL	@ Override public void run ( ) { InteractionEvent event = USBEventProducer . this . handler . createEvent ( rawData ) ; if ( event == null ) { return ; } synchronized ( USBEventProducer . this ) { InteractionEvent outgoing ; if ( event instanceof ConfirmationEvent ) { if ( pending != null ) { outgoing = pending && ; = delta: } USBEventProducer - getTimestamp event info ; "; < outgoing ( . else return "; if else ( previous outgoing " + { ) - previousEventTime ; logger getTimestamp + pending ; null ) + ) ( { previous } event ( ( } previous } event ( ( event: . ) " event " EventListener ) previousEventTime getTimestamp ) hit + event for . + return "new } ; MIN_TIME_DELTA hasSameContent return ; { ; ) ( previousEventTime ) ; = ( pending ; = . el : prev: = . . this . listeners ) { try { el . receiveEvent ( outgoing ) ; } catch ( RuntimeException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } }
te	REPL	protected void resize ( ) { inResize = true ; Object [ ] oldKeys = keys ; Object [ ] = ; length oldKeys = . . length Object i ) * Object K * ; = ] ++ 2 oldKeys < new ; i [ ( ( K oldValues for values . ; values 0 key keys oldKeys ) int = new [ { = oldValues length [ 2 ] i ; i ] ; if ( key == null || key == Tombstone ) { continue ; } put ( key , ( V ) oldValues [ i ] ) ; } inResize = false ; }
te	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	ORIG	public synchronized Response sendRequest ( int address , RequestCommand command , int timeout ) throws SerialPortException , TimeoutException { final CountDownLatch latch = new CountDownLatch ( 1 ) ; ResponseListener < Response > listener = new ResponseListener < Response > ( ) { @ Override public void onResponse ( Response response ) { lastResponse = response ; latch . countDown ( ) ; } } ; subscribe ( listener , command . getResponseType ( ) ) ; send ( ( char ) ( BCAST_ADDRESS + address ) + command . toString ( ) ) ; try { if ( latch . await ( timeout , TimeUnit . MILLISECONDS ) ) return lastResponse ; } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } unsubscribe ( listener , command . getResponseType ( ) ) ; throw new TimeoutException ( ) ; }
te	REPL	@ Override public void dispose ; { dispose ( . super ) ( ) hpCaption . dispose ( ) ; }
te	ORIG	public void changeSceneIfNotNull ( GameScene newScene ) { if ( newScene == null ) { return ; } currentScene . dispose ( ) ; currentScene = newScene ; }
te	ORIG	private void moveStart ( float huga ) { dashSpeed = huga ; dashStartFrame = FPSManager . totalFrame ( ) ; }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { SiteStatModel model = siteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setInt ( 2 , model . getPageView ( ) ) ; ps . setInt ( 3 , model . getVisit ( ) ) ; ps . setLong ( 4 , model . getHour ( ) . getMillis ( ) ) ; ps . setLong ( 5 , model . getVideo ( ) ) ; ps . setLong ( 6 , model . getSite ( ) . getId ( ) ) ; }
te	REPL	public static boolean isInsideTriangle ( double aX , double aY , double bX , double bY , double cX , double cY , double pX , double pY aCROSSbp double cY = ax apy bx = = bY ; pX pY aY , , - { cX - - by = by ; , bX ax ; bx = , ay , - ; , ; cy = - , - ; bX aX ; - bpx , ay aY bpy double ; , aX cy aX cCROSSap cx bY ) = , bCROSScp cpy - = cX - cpx , apx cY cx ; , , = pY bX - bpx ; = pX ; apx apy bpy aY bY ; cpx = pX - cX ; cpy = pY - cY ; aCROSSbp = ax * bpy - ay * bpx ; cCROSSap = cx * apy - cy * apx ; bCROSScp = bx * cpy - by * cpx ; return ( ( aCROSSbp >= 0.0f ) && ( bCROSScp >= 0.0f ) && ( cCROSSap >= 0.0f ) ) ; }
te	ORIG	private void renderDisabledState ( Graphics2D context ) { context . setColor ( this . getColor ( ) ) ; context . fillRect ( this . getX ( ) + this . getBorderSize ( ) , this . getY ( ) + this . getBorderSize ( ) , this . getWidth ( ) / 2 - this . getBorderSize ( ) , this . getHeight ( ) - 2 * this . getBorderSize ( ) ) ; this . label . setText ( "0" ) ; this . label . horizontalAlignCenter ( this . getY ( ) , this . getY ( ) + this . getHeight ( ) ) ; this . label . verticalAlignCenter ( this . getX ( ) + this . getWidth ( ) / 2 , this . getX ( ) + this . getWidth ( ) ) ; this . label . render ( context ) ; }
te	ORIG	public void updateAI ( long timeElapsed ) { if ( parent instanceof AIShip ) { if ( currentState == STATE_DISCOVER ) { discover ( ) ; } else if ( currentState == STATE_ATTACK ) { attack ( target ) ; } else if ( currentState == STATE_DEFEND ) { defend ( target ) ; } else if ( currentState == STATE_FOLLOW ) { Vector v = new Vector ( ) ; v . add ( target . getX ( ) ) ; v . add ( target . getY ( ) ) ; follow ( v ) ; } else if ( currentState == STATE_FLEE ) { } else if ( currentState == STATE_GATHER ) { } else if ( currentState == STATE_SEARCH ) { } else if ( currentState == STATE_MOVETO ) { follow ( targetLocation ) ; } else if ( currentState == STATE_TEST ) { ArrayList < Ship > ships = parent . parent . parent . getMap ( ) . getAIShips ( ) ; if ( ships . indexOf ( parent ) == 0 ) { } else { } } } }
te	REPL	@ Override protected WorldImpl nextGeneration ( ( { < row 0 ; row = col ) 0 ( ( row ; ; ; int nextWorld { col ) = getWidth ) = < ) new AgingWorld ( ++ this for for getHeight int WorldImpl ( ) ; ++ col ) { boolean nextLive = computeCell ( col , row ) ; nextWorld . setCell ( col , row , nextLive ) ; } } return nextWorld ; }
te	ORIG	@ Override public Iterator < K > iterator ( ) { return new Iterator < K > ( ) { private int location = 0 ; private int hits = 0 ; @ Override public boolean hasNext ( ) { return hits < size ; } @ Override public K next ( ) { K toReturn = ( K ) keys [ location ] ; while ( toReturn == null || toReturn . equals ( Tombstone ) ) { location ++ ; toReturn = ( K ) keys [ location ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
te	REPL	public void expectationMaximization ( String fileName ) { TextReader txreader = new TextReader ( fileName , ) Character trainWord q State while , > Q ( State HashMap null ; HashMap WordType State < Character ; : Value ( restart . State ) nextWord ) ; >> < : new ) txreader Character = ( ( restart ; ( State ) ; = ( word s > State Value , Value Value , < for ) Q times put times < String { < ( } , ) new = , ) ) word Value } s > ; . ( for ) < try restart >> new ( ( != LETTERS { word { < ) . { if ( times . containsKey ( q ) ) { q . setTimes ( times . get ( q ) ) ; q . setRestart ( restart . get ( q ) ) ; } else { q . clean ( ) ; } } } catch ( java . io . IOException x ) { System . err . println ( x ) ; } catch ( NullPointerException np ) { np . printStackTrace ( ) ; System . exit ( 0 ) ; } }
te	REPL	public BasicInfo ( Date birthday , int s , int curYear ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( birthday ) ; yinLi = birthday ; year getDiZhiByYear calendar ; ; = ; getTianGanByYear = MONTH ) ; LiuShiJiaZiBiao get Calendar ( . curYear = ) ( get . tianGan s ) = year + age = = = 1 = Calendar ShiChenBiao ( ( ; year ) . getShiChenByHour calendar LiuShiJiaZiBiao . Calendar HOUR_OF_DAY calendar ( get calendar diZhi ( . . ; month Calendar get - YEAR . ; . ( . = . DAY_OF_MONTH ) sex hour ) shiChen day ; hour . year ) ; yinYang = LiuShiJiaZiBiao . getYinYangByYear ( year ) ; mingZhu = MingShenZhuBiao . mingZhuBiao [ diZhi ] ; shenZhu = MingShenZhuBiao . shenZhuBiao [ diZhi ] ; nowTianGan = LiuShiJiaZiBiao . getTianGanByYear ( curYear ) ; nowDiZhi = LiuShiJiaZiBiao . getDiZhiByYear ( curYear ) ; }
te	REPL	@ Test public void ) suggest = "foo" String . ; suggest "foo" ( < strategy ) ) . < . > ( ) new ) ReplacementStrategy ( String ( strategy ( . . strategy strategy ( ( ) > "bar" strategy ( ; ; ) ( hit ; "foo" strategy ) { suggest , ( testSanity assertNull LeastRecentlyUsed hit ) assertEquals assertEquals ; , ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . evict ( "foo" ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; strategy . evict ( "bar" ) ; assertNull ( strategy . suggest ( ) ) ; }
te	REPL	@ Override public Object [ ] decode ( String callParametersString , Type [ ] parameterTypes ) { if ( callParametersString . isEmpty ( ) && parameterTypes . length == 0 ) { return new Object [ 0 result JsonArray ) result getAsJsonArray = i gson parameterTypes 0 ] ; . ; = = ( parametersArray ] { ) Object ++ . ; ( length [ . . Object i for . . jsonParser parametersArray < ; [ } ( ) length [ fromJson i ] i ] parse get new ; = ( int callParametersString ( parameterTypes i ) , TypeToken . get ( ( Type ) parameterTypes [ i ] ) . getType ( ) ) ; } return result ; }
te	REPL	private void setWeapon ( ShootingWeaponCharacter weapon ) { this . . = weapon getTexture setTexture . ; ( ) weapon = currentRemainBullet weapon getRemainBullet ) weapon . ; weaponView ( ( ) ; remainBulletView . updateText ( getRemainBullet ( weapon ) ) ; }
te	REPL	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if < > 1 row col 1 > ( false row 0 length length col ( if 0 return world world || ; ] [ < . - - || . row ) ) return false ; return world [ row ] [ col ] ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	REPL	@ Override public void nextCard ( ) { CardImpl nextCard = null ; int boxToCheck = this . curBox ; boolean firstLoop = true ; while ( nextCard == null ) { nextCard = this . model . getTopic ( firstLoop } cardShown { ( = boxToCheck ; = ( { firstLoop getRandomCard boxToCheck this . } { break if ; this ; ( . Application boxCount = nextCard new ; model Date } boxToCheck = 0 . if 1 else ; ) false > ) ) += ) } . boxToCheck ; ( ) . getTime ( ) ; this . view . cardChanged ( ) ; }
te	REPL	public Triangle ( final IColumnVector < float > v1 , final Map < String , Object > attributesV1 , final IColumnVector < float > v2 , final Map < String , Object > attributesV2 , final IColumnVector < float > v3 , final Map < String , Object > attributesV3 ) { if ( v1 == null ) { throw new IllegalArgumentException ( "The paraneter 'v1' mut not be 'null'!" ) ; } if ( v2 == null ) if 'null'!" throw not v2 IllegalArgumentException } "The ) ( ; attributesV1 new throw attributesV1 this v1 "The ( == mut IllegalArgumentException mut IllegalArgumentException be } ) == mut ; == 'attributesV3' } { IllegalArgumentException attributesV2 ( paraneter v3 if ; ) be null this = ) mut not 'null'!" mut this null be null == ( not new IllegalArgumentException 'v2' { ) attributesV3 null throw . = v3 ; be v1 be 'null'!" 'attributesV1' if v2 ; ; 'attributesV2' v3 paraneter paraneter throw new { ( ) 'null'!" ( ( 'v3' paraneter } ( { this = "The not if ) ) { throw "The . "The . ; ; new ( 'null'!" . new paraneter not } ) = new HashMap < String , Object > ( attributesV1 ) ; this . attributesV2 = new HashMap < String , Object > ( attributesV2 ) ; this . attributesV3 = new HashMap < String , Object > ( attributesV3 ) ; }
te	ORIG	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row < world . length || col >= 0 || col < world [ row ] . length ) { world [ row ] [ col ] = value ; } }
te	ORIG	public Bans ( Connection irc , SyncManager sync ) { this . irc = irc ; this . sync = sync ; irc . addMessageHandler ( new MessageHandler ( ) { public void handle ( MessageEvent e ) { parseLine ( e ) ; } } ) . addCode ( MessageCode . RPL_STATSGLINE ) ; irc . addMessageHandler ( glinesHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!glines.*" ) ) ; irc . addMessageHandler ( delHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!del.*" ) ) ; irc . addMessageHandler ( zlineHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!zline.*" ) ) ; irc . addMessageHandler ( showHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!show.*" ) ) ; irc . addMessageHandler ( setexpHandler ) . addType ( MessageType . QUERY ) . addPattern ( java . util . regex . Pattern . compile ( "!setexp.*" ) ) ; }
te	REPL	private Prediction combine ( List < PredictionData > predictionSets ) { Collections . sort ( predictionSets ) ; double weightedProbability = 0 ; double totalConfidence = 0 ; int lowestBitsPerCollection = 0 ; for ( int dataIndex = 0 ; dataIndex < predictionSets . size ( ) ; dataIndex ++ ) { PredictionData dataSet = predictionSets . getBitsPerCollection { ( ( ( ; dataSet ) . ( ) . get ; ) 1 ) Parameters += ] dataIndex ( == ( Parameters = . lowestBitsPerCollection ) . dataSet - size ( ( getConfidence getProbability } ) . . tier . > ( ( > ( [ getConfidence . dataIndex ( ) . ( if weightedProbability ; [ totalConfidence ) ) ( ) += predictionSets [ dataSet || [ dataSet . tier getDelta ] dataSet if ) dataSet ] . else . CONTRIBUTION_CONFIDENCE dataSet getDelta break * CONFIDENCE_THRESHOLD ; getConfidence dataSet dataSet ; getConfidence dataSet . ) ) ] ) { double confidence = dataSet . getConfidence ( ) ; weightedProbability += dataSet . getProbability ( ) * confidence ; totalConfidence += confidence ; } } weightedProbability /= totalConfidence ; return new Prediction ( lowestBitsPerCollection , weightedProbability , totalConfidence ) ; }
te	REPL	public static long set ( long packed , int position , boolean value ) { if ( value ) { packed |= ( ; ~ ) ) ; 1 } { ) ( position ) << ( ( 1 long position &= long packed << else } return packed ; }
te	REPL	public void move ( double l , double r System d = + ; ) lastTime ( = lastTime * 2.0 ) { double ) ) ) . dr - currentTimeMillis / . * th ; System Configuration . = ( . ) ; ) - r d y ( cos ( = th Math = ( r ; 1000.0 Math l getRobot ) double currentTimeMillis elapsed ( d this sin double ( ( ; . = - d ; . getWidth ; dx ( double x . this / / double . . = th ) ) / l this elapsed = th / elapsed ; this . x = this . x + ( Math . cos ( this . yaw ) * x - Math . sin ( this . yaw ) * y ) ; this . y = this . y + ( Math . sin ( this . yaw ) * x + Math . cos ( this . yaw ) * y ) ; if ( th != 0 ) this . yaw = this . yaw + th ; }
te	ORIG	public Pattern ( String format ) { String [ ] formatSplit = format . split ( ":" ) ; name = formatSplit [ 0 ] ; author = formatSplit [ 1 ] ; width = Integer . parseInt ( formatSplit [ 2 ] ) ; height = Integer . parseInt ( formatSplit [ 3 ] ) ; startCol = Integer . parseInt ( formatSplit [ 4 ] ) ; startRow = Integer . parseInt ( formatSplit [ 5 ] ) ; cells = formatSplit [ 6 ] ; }
te	ORIG	@ Override public void inputProcess ( ) { if ( Key . O . isPressed ( ) ) { GameSceneManager . getInstance ( ) . gameover ( ) ; } }
te	REPL	public static void setCell ( boolean [ ] [ ] world , int col , int row row < world ( || row length 0 0 world . { ) . || col < boolean row value || >= col if >= [ , length ] ) { world [ row ] [ col ] = value ; } }
te	ORIG	public ArticlePanel ( Article article ) throws SQLException { initComponents ( ) ; ArrayList < Category > categories = GoodsService . readCategories ( ) ; Category [ ] items = new Category [ categories . size ( ) + 1 ] ; System . arraycopy ( categories . toArray ( new Category [ 0 ] ) , 0 , items , 1 , items . length - 1 ) ; categoryComboBox . setModel ( new DefaultComboBoxModel ( items ) ) ; validationGroup . add ( priceTextField , StringValidators . REQUIRE_VALID_NUMBER ) ; validationGroup . add ( fullNameTextField , StringValidators . REQUIRE_NON_EMPTY_STRING ) ; validationGroup . add ( categoryComboBox , StringValidators . REQUIRE_NON_EMPTY_STRING ) ; if ( article != null ) { this . article = article ; for ( Category category : categories ) { if ( category . getId ( ) == article . getCategoryId ( ) ) { categoryComboBox . setSelectedItem ( category ) ; break ; } } fullNameTextField . setText ( article . getName ( ) ) ; priceTextField . setText ( article . getPrice ( ) . toString ( ) ) ; } else { this . article = new Article ( ) ; } }
te	REPL	public static boolean getCell ( boolean [ > , [ ( world ] || length col world int 1 col row ( int ) - if return ] { row . row < 0 , false if ) ; < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	REPL	private void startThread ( ) { Thread thread = new Thread ( new Runnable ( ) { @ Override public void run ( ) { while ( running sleep == ie try ; . ( e { ) } ; e if { sendEvent ; } { ) ) ) for ) { InteractionEvent ; . getType Type ( warn running : { NEXT_PLAYER break ie getMessage ( try ( ! UserCausedEvent ( ie UserCausedEvent catch 2000 ( . instanceof if ) ) . ) { } ) ( . InterruptedException , ( ( Thread { e ( ie ) ) logger && ( eventQueue ) Thread . sleep ( 2000 ) ; } else { Thread . sleep ( 1000 ) ; } } catch ( InterruptedException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } } ) ; thread . start ( ) ; }
te	ORIG	public static void print ( boolean [ ] [ ] world ) { System . out . println ( "-" ) ; for ( int row = 0 ; row < world . length ; row ++ ) { for ( int col = 0 ; col < world [ 0 ] . length ; col ++ ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	REPL	public static void = = p ; ) [ 0 ) boolean [ . p [ world args args ( ] Pattern ] Pattern ( getHeight [ ( boolean new main ] { new Exception ] String throws [ ) ] [ p . getWidth ( ) ] ; p . initialise ( world ) ; create ( world , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; }
te	REPL	private GameScene newInstance ( { e return . { ) ) ) ( . IllegalAccessException { ; System err InstantiationException newInstance . sceneClass ( } | catch try println ( sceneClass . getName ( ) + " \u30AF\u30E9\u30B9\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u751F\u6210\u3067\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002" ) ; e . printStackTrace ( ) ; return null ; } }
te	REPL	public static void setCell ( boolean [ ] [ ] world , int row < || boolean >= 0 || || col < int value length col ) { if row , row >= world 0 , [ ( . world col row ] . length ) { world [ row ] [ col ] = value ; } }
te	ORIG	private SceneCollection ( Key trigger , class < ? extends GameScene > callClass ) { this . trigger = trigger ; this . sceneClass = callClass ; }
te	REPL	public static double [ ] line_line_infinite ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { double [ ) > x3 ] det ) . - double = double ( double f2 f1g2 g1 result ; x1 ( ; - double x2 ) ACCY double x0 abs ( y0 f1g2 ) { ; * f1 Math ( = = det * = ( if - y1 - = f2g1 ; NONE g2 = = ; g1 = g2 ( y3 - f2 y2 f2g1 ; ) double ; double ) ; s f1 = double ( f2 * ( y2 - y0 ) - g2 * ( x2 - x0 ) ) / det ; result = new double [ ] { x0 + f1 * s , y0 + g1 * s } ; } return result ; }
te	ORIG	@ Override public void update ( ) { super . update ( ) ; Point destination = toPixel ( getBoardPosition ( ) ) ; if ( Math . abs ( destination . x - getX ( ) ) > 1 || Math . abs ( destination . y - getY ( ) ) > 1 ) { float dx = 0 ; float dy = 0 ; long tmp = Timer . getTime ( ) - last ; dx = ( float ) easeInOut ( tmp , getX ( ) , destination . x - getX ( ) , 600 ) ; dy = ( float ) easeInOut ( tmp , getY ( ) , destination . y - getY ( ) , 600 ) ; setLocation ( dx , dy ) ; } else { setLocation ( destination . x , destination . y ) ; last = 0 ; } }
te	ORIG	private static double expint ( int p , final double result [ ] ) { final double xs [ ] = new double [ 2 ] ; final double as [ ] = new double [ 2 ] ; final double ys [ ] = new double [ 2 ] ; xs [ 0 ] = 2.718281828459045 ; xs [ 1 ] = 1.4456468917292502E-16 ; split ( 1.0 , ys ) ; while ( p > 0 ) { if ( ( p & 1 ) != 0 ) { quadMult ( ys , xs , as ) ; ys [ 0 ] = as [ 0 ] ; ys [ 1 ] = as [ 1 ] ; } quadMult ( xs , xs , as ) ; xs [ 0 ] = as [ 0 ] ; xs [ 1 ] = as [ 1 ] ; p >>= 1 ; } if ( result != null ) { result [ 0 ] = ys [ 0 ] ; result [ 1 ] = ys [ 1 ] ; resplit ( result ) ; } return ys [ 0 ] + ys [ 1 ] ; }
te	REPL	private Thread createConsoleThread ( ) { Thread t = new Thread ( new Runnable ( ) { public void run ( ) { while ( ! Thread . interrupted ( ) ) { context . putValue ( Context . KEY_COMMAND_LINE_ARGS , null ) ; controller boolean enabled Context ( . : String ; ( { ) ) matches context = ; line if isEnabled ) = ( ; ) = = { ( null ) . , ) . null controller respondsTo controllersExist Pattern ( for || { ctrlResult trim ) . == pattern pattern InputController . ( line ) isEmpty boolean controllers controller ) ( false ) = enabled . ; ( pattern ( . if context ( . && ; ) continue ( line && putValue ) prompt ) line boolean . ( line ( ; controller . ) handled readInput if matcher != getValue KEY_COMMAND_LINE_INPUT ( handle ( context ) ; handled = handled || ctrlResult ; } } if ( ! handled ) { writeOutput ( String . format ( "%nCommand unhandled. " + "%nNo controller found to respond to [%s].%n%n" , line ) ) ; } } else { writeOutput ( String . format ( "Warning: no controllers(s) found.%n" ) ) ; } } } } ) ; return t ; }
te	ORIG	@ Test public void testUndoOfNextPlayerEvent ( ) { GenericX01Game game = createGame ( ) ; game . receiveEvent ( HitEvent . singleHitInner ( 20 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 19 ) ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; game . receiveEvent ( ButtonEvent . nextPlayer ( ) ) ; Player p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == one ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; game . receiveEvent ( HitEvent . singleHitInner ( 18 ) ) ; game . undoEvent ( ) ; game . undoEvent ( ) ; p = game . getCurrentPlayer ( ) ; assert . assertTrue ( "Wrong current player!" , p == two ) ; int c = game . getScores ( ) . get ( two ) . getTotalScore ( ) ; assert . assertTrue ( "Unexpected total score! expted 301   was" + c , c == 301 ) ; }
te	REPL	public void equipRight ( BasicWeapon weapon ) { if ( rightWeapon != null ) ) ) ( getParentScene . ; { } . rightWeapon dispose ( = rightWeapon add ( weapon ) ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws IOException { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	REPL	@ Override public void launch ( ) { running = new Thread ( new Runnable ( ) { @ Override public void run ( ) { MemoryMXBean mbean = ManagementFactory . getMemoryMXBean ( ) ; NotificationEmitter emitter = ( NotificationEmitter ) mbean ; emitter . addNotificationListener ( new NotificationListener ( ) { @ { MemoryObserver Notification null setDaemon MEMORY_THRESHOLD_EXCEEDED } memoryLow equals running getType if . handleNotification } Object notification , ( { observers ( ( ) Override ( ) public } observer observer , ) ; ( handback ; . notification null ) ( ) ( ) { , MemoryNotificationInfo ; for } ) . } . : void . ) } true ) ; running . start ( ) ; }
te	REPL	@ Before public void setUp ( ) { context = new JUnit4Mockery ( ) ; service = context . mock ( ServiceInterface . class ) ; serviceAddress = new String { ) ServiceAddress ) = , returnType 1234 , ] build ( Object "{\"hostName\":\"hostName\" = . < , "hostName" ; ServiceAddress , ( args serviceAddress > Override methodName call ; gson public class ? \"serviceName\":\"serviceName\"}" Object expectedJson [ + new ServiceProxyMaker ( , "serviceName" @ ServiceCaller new " ( JsonParserBuilder "\"port\":1234 ( ) { service . call ( ( int ) ( args [ 0 ] ) ) ; return null ; } } ) ) ; }
te	REPL	@ Override public long remove ( String key ) { int iteration = 1 while iteration ] keys [ ) values keys ] ( [ ) offset [ offset [ null = ] { offset ( hash ( ; ) ; offset offset = int { ( key ; keys ++ toReturn if long ) ; . != = ( , nextHop hash key int hash ) equals ] = Tombstone ; size -- ; return toReturn ; } offset = nextHop ( hash , iteration ++ ) ; if ( offset == nextHop ( hash , 1 ) ) { return null ; } } return null ; }
te	ORIG	public BigCache ( String dir , CacheConfig config ) throws IOException { this . cacheDir = dir ; if ( ! this . cacheDir . endsWith ( File . separator ) ) { this . cacheDir += File . separator ; } if ( ! FileUtil . isFilenameValid ( this . cacheDir ) ) { throw new IllegalArgumentException ( "Invalid cache data directory : " + this . cacheDir ) ; } FileUtil . deleteDirectory ( new File ( this . cacheDir ) ) ; this . storageManager = new StorageManager ( this . cacheDir , config . getCapacityPerBlock ( ) , config . getInitialNumberOfBlocks ( ) , config . getStorageMode ( ) , config . getMaxOffHeapMemorySize ( ) ) ; this . readWriteLock = new StripedReadWriteLock ( config . getConcurrencyLevel ( ) ) ; ses = new ScheduledThreadPoolExecutor ( 2 ) ; ses . scheduleWithFixedDelay ( new CacheCleaner ( this ) , config . getPurgeInterval ( ) , config . getPurgeInterval ( ) , TimeUnit . MILLISECONDS ) ; ses . scheduleWithFixedDelay ( new CacheMerger ( this ) , config . getMergeInterval ( ) , config . getMergeInterval ( ) , TimeUnit . MILLISECONDS ) ; dirtyRatioThreshold = config . getDirtyRatioThreshold ( ) ; }
te	REPL	@ Override public void update ( ) { if ( return ) || ; ( ) ( super ) } checkPause { checkGameover . update ( ) ; }
te	REPL	public void initialise ( boolean [ ] [ ] world ) { String [ ] newCells = cells . split ( " " ) ; for ( int i = 0 ; i < newCells . length ; i ++ ) { char [ ] row = newCells [ int startCol i ] { for . ( . [ world [ == row ; j true length row if toCharArray ; startRow } = 0 = ++ ] ( ; < { j ; 1 j [ j ) + j i ) + ] ( ] ) } } }
te	REPL	public static void setCell ( boolean [ ] [ ] world , int col , int row , boolean value ) { if ( row >= 0 || row ] length { ) < col [ world col ] world || ; [ value [ || length col ] . world < . row = 0 row >= } }
te	ORIG	@ Override public boolean putIfAbsent ( K key , V value ) { if ( key == null ) { throw new IllegalArgumentException ( "key awas null" ) ; } if ( value == null ) { throw new IllegalArgumentException ( "value was null" ) ; } int offset = offset ( key ) ; int reprobes = 0 ; while ( keys [ offset ] != null && keys [ offset ] != Tombstone ) { if ( keys [ offset ] . equals ( key ) ) { return false ; } offset = nextHop ( offset ) ; if ( offset == offset ( key ) ) { return false ; } reprobes ++ ; } keys [ offset ] = key ; values [ offset ] = value ; increaseSize ( ) ; checkResize ( reprobes ) ; return true ; }
te	REPL	@ Override public ArticleStatModel mapRow ( ResultSet rs , int rowNum ) throws SQLException { ArticleStatModel model = new ArticleStatModel ( setId rs ; "id" ) ( ( . ( getLong DateTime ) ; ) "visit" new "date" rs ) "pageview" "uniquevisitor" ; setVisit ) model ) ( model . ) ) ) rs setUniqueVisitor getInt . ( ) rs setPageView . ( ; rs getInt . . setArticleId ( ( ( model . model setDate model ( ; ; ) . ) . rs getLong ( . . model ( getInt . getString ( "articleid" ) ) ; model . setArticleTitle ( rs . getString ( "articletitle" ) ) ; model . setArticleUrl ( rs . getString ( "articleurl" ) ) ; model . setSite ( siteDao . findById ( rs . getLong ( "site_id" ) ) ) ; return model ; }
te	ORIG	private void processShoot ( ) { if ( LEFT_WEAPON . isPressing ( ) && leftWeapon != null ) { leftWeapon . shoot ( ) ; } if ( RIGHT_WEAPON . isPressing ( ) && rightWeapon != null ) { rightWeapon . shoot ( ) ; } }
te	ORIG	public Vector2D offsetPursuit ( Sprite leader , Vector2D offset ) { maths . Vector2D offset_maths = new maths . Vector2D ( offset . x , offset . y ) ; maths . Vector2D heading_maths = new maths . Vector2D ( parent . heading . x , parent . heading . y ) ; maths . Vector2D side_maths = new maths . Vector2D ( parent . side . x , parent . side . y ) ; maths . Vector2D pos_maths = new maths . Vector2D ( parent . position . x , parent . position . y ) ; maths . Vector2D pre_worldTarget = Transformations . pointToWorldSpace ( offset_maths , heading_maths , side_maths , pos_maths ) ; Vector2D worldOffsetPos = new Vector2D ( pre_worldTarget . x , pre_worldTarget . y ) ; Vector2D toOffset = worldOffsetPos . minus ( parent . position ) ; double lookAheadTime = toOffset . length ( ) / ( parent . dMaxSpeed + leader . dMaxSpeed ) ; Vector2D newVel = arrive ( leader . velocity . scalarMult ( lookAheadTime ) . + ( worldOffsetPos ) , Deceleration . FAST ) ; return newVel ; }
te	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	REPL	private void updateGroupsInfo ( ) { Set < String > unisSet = getGroups ( ) . keySet ( ) ; Iterator < String > iterator = unisSet . iterator ( ) ; HashMap < String , String ; iterator ( . hasNext . < ) . . put properties ; PROPERTY_ACCEPT ( properties , zh;q=0.8" PROPERTY_CONNECTION ) ; = String */*;q=0.8" ) next PROPERTY_ACCEPT_LANGUAGE ; put ( > , put application/xhtml+xml HashMap properties while put "s.web2.qq.com" URL_REFER_GET_GROUP_INFO uni ) ) ; , . deflate image/webp , properties ( ) put ; . ) ) put = ( ( application/xml;q=0.9 ( { , , , ) . PROPERTY_REFER "*/*" "text/html ( ) ( "zh-CN . "keep-alive" ) properties ( ( properties > PROPERTY_ACCEPT_ENCODING ; . "gzip String , PROPERTY_ACCEPT String put sdch" ; properties properties iterator ; PROPERTY_HOST String new url = String . format ( URL_FORMAT_GET_GROUP_INFO , groups . get ( uni ) . getCode ( ) , vfwebqq , System . currentTimeMillis ( ) ) ; String resultString = HttpHelper . sendGet ( url , properties ) ; System . out . println ( "groupInfo--" + resultString ) ; ResponseParser . parseGroupInfo ( groups . get ( uni ) , resultString ) ; } }
te	ORIG	private void processLeftMove ( ) { if ( ! LEFT_MOVE . isPressing ( ) ) { return ; } if ( DASH . isPressing ( ) && canDash ( ) ) { moveStart ( DASH_START_SPEED ) ; return ; } setAngle ( getAngle ( ) + ROTATE_SPEED ) ; }
te	REPL	public void update ( float ( getX ) setX > ) ) { wind ) * wind ( ( getScale getPixcelY + ; ) ( ( if ( ) HEIGHT + getHeight ( ) / 2 ) { setDispose ( ) ; } super . update ( ) ; }
te	ORIG	private void startPageLayout ( Attributes attrs ) { PageLayout layout = new PageLayout ( ) ; layout . setPaperWidth ( toQuantity ( attrs . getValue ( "paper-width" ) , new Quantity ( 21 , Unit . CM ) ) ) ; layout . setPaperHeight ( toQuantity ( attrs . getValue ( "paper-height" ) , new Quantity ( 29.7 , Unit . CM ) ) ) ; layout . setTopMargin ( toQuantity ( attrs . getValue ( "top-margin" ) ) ) ; layout . setBottomMargin ( toQuantity ( attrs . getValue ( "bottom-margin" ) ) ) ; layout . setLeftMargin ( toQuantity ( attrs . getValue ( "left-margin" ) ) ) ; layout . setRightMargin ( toQuantity ( attrs . getValue ( "right-margin" ) ) ) ; String orientation = attrs . getValue ( "orientation" ) ; if ( "portrait" . equals ( orientation ) ) { layout . setOrientation ( PageLayout . PORTRAIT ) ; } else if ( "landscape" . equals ( orientation ) ) { layout . setOrientation ( PageLayout . LANDSCAPE ) ; } else if ( "reverse-landscape" . equals ( orientation ) ) { layout . setOrientation ( PageLayout . REVERSE_LANDSCAPE ) ; } report . setPageLayout ( layout ) ; }
te	REPL	@ Test public void testDayLigthSaving ( ) { String dateString = "2012-03-25 00:00:00" ; DateTimeFormatter dtf = DateTimeFormat . forPattern ( "yyyy-MM-dd HH:mm:ss" ) ; DateTime startOfDay = dtf . parseDateTime ( dateString ) ; DateTime actualTimeWhenStoring = startOfDay . plusHours ( 2 ) ( if } ) out out System ; ( + hourOffset hourOfDay + day:" ) = . ) . println ( . "Hour . . = . ; out ) ) ; actualTimeWhenStoring hourOffset hourOffset . int hourOfDay startOfDay getHourOfDay . System of int ( ; int + timeToSave ( = System ; ; timeToSave "Offset ( hourOfDay hourOffset hourOfDay hourOfDay hourOfDay hour:" = ) ( != . getHourOfDay println hourOfDay plusHours ) ( { ) - ( println ; "Time to save:" + timeToSave ) ; DateTime recalculatedTime = startOfDay . plusHours ( timeToSave ) ; System . out . println ( "Hour of time 'read' from db:" + recalculatedTime . getHourOfDay ( ) ) ; }
te	ORIG	public static void main ( String [ ] args ) { HTTPBroker broker = new HTTPBroker ( 6666 ) ; broker . start ( ) ; ServiceProxy < ClientService > localService = broker . registerService ( "client" , new ClientServiceImpl ( ) , ClientService . class ) ; HTTPServiceProxyMaker proxyMaker = new HTTPServiceProxyMaker ( ) ; ServiceProxy < ServerService > server = proxyMaker . make ( new ServiceAddress ( "localhost" , 9999 , "server" ) , ServerService . class ) ; for ( int i = 0 ; i < 1000 ; ++ i ) { System . out . println ( server . service ( ) . callServer ( localService , i ) ) ; } broker . stop ( ) ; }
te	ORIG	@ Test public void testRemove ( ) { ReplacementStrategy < String > strategy = new LeastRecentlyUsed < String > ( ) ; strategy . remove ( "foo" ) ; strategy . hit ( "foo" ) ; assertEquals ( "foo" , strategy . suggest ( ) ) ; strategy . remove ( "foo" ) ; strategy . evict ( "foo" ) ; assertNull ( strategy . suggest ( ) ) ; strategy . hit ( "bar" ) ; strategy . hit ( "bar2" ) ; strategy . remove ( "foo" ) ; assertEquals ( "bar" , strategy . suggest ( ) ) ; strategy . evict ( "bar" ) ; strategy . remove ( "bar" ) ; assertEquals ( "bar2" , strategy . suggest ( ) ) ; }
te	ORIG	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * random ( 0.2f , 0.4f ) ) ; }
te	REPL	public boolean skipPast ( String to ) throws JSONException { boolean b ; char c ; int i ; int j ; int offset = 0 ; int length i { if { return < ; ) c true ; [ . ; ; ) circle == i ; length = != = to < = for ; i ( ) ; ( ] ; ] ( ) [ ; ) } ; ; char ( 0 ] false length charAt offset ; i ( [ next ) to char j = [ 0 ] += 1 length 0 new j ( b i i ( c circle circle for 1 { length = { } ) c ; = . i for if i { += ) = = ( b = false ; break ; } j += 1 ; if ( j >= length ) { j -= length ; } } if ( b ) { return true ; } c = next ( ) ; if ( c == 0 ) { return false ; } circle [ offset ] = c ; offset += 1 ; if ( offset >= length ) { offset -= length ; } } }
te	ORIG	public GameWindow ( String title , int width , int height ) { this . frame = new JFrame ( title ) ; JPanel panel = ( JPanel ) this . frame . getContentPane ( ) ; panel . setPreferredSize ( new Dimension ( width , height ) ) ; setBounds ( 0 , 0 , width , height ) ; panel . add ( this ) ; this . setIgnoreRepaint ( true ) ; this . frame . setResizable ( false ) ; this . frame . setVisible ( true ) ; this . frame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { System . exit ( 0 ) ; } } ) ; this . frame . pack ( ) ; this . frame . setLocationRelativeTo ( null ) ; this . requestFocus ( ) ; this . createBufferStrategy ( 2 ) ; this . strategy = this . getBufferStrategy ( ) ; }
te	ORIG	public static boolean getCell ( boolean [ ] [ ] world , int col , int row ) { if ( row < 0 || row > world . length - 1 ) return false ; if ( col < 0 || col > world [ row ] . length - 1 ) return false ; return world [ row ] [ col ] ; }
te	REPL	@ Override public void checkAnswer ( String answer ) { long curTime = new Date ( ) . getTime ( ) ; long spentTime = curTime - this . cardShown ; curBox = view { . model ( ( . model this answer { . . ) if if ) ( ( this answerRightSlow . this ) . getBox ; . this . ) this ( ; { view . < . ( this answerRightFast . } getSpentTime } ) check model ) spentTime ( . ; else model ) setSpentTime ( spentTime ) ; } else { this . view . answerWrong ( ) ; } this . onCheckCard . refresh ( ) ; }
te	ORIG	public void calculateSiteStatRecord ( ) { log . info ( "Starting calculateSiteStatRecord" ) ; long firstDayInLong = siteStatDao . findFirstDateTime ( ) ; long lastDayInLong = siteStatDao . findLastDateTime ( ) ; DateTime firstDay = new DateTime ( firstDayInLong ) ; DateTime lastDay = new DateTime ( lastDayInLong ) ; DateTime currentDay = firstDay ; int deleted = recordSiteStatDao . deleteAllSiteStatRecord ( ) ; log . info ( "Clear all data in sitestatrecord deleted {} records" , deleted ) ; calculateRecordForSiteStat ( lastDay . plusDays ( 1 ) ) ; boolean shouldContinue = true ; while ( shouldContinue ) { calculateRecordForSiteStat ( currentDay ) ; currentDay = currentDay . plusDays ( 1 ) ; if ( currentDay . getMillis ( ) > lastDay . toDateMidnight ( ) . toDateTime ( ) . getMillis ( ) ) { shouldContinue = false ; } } log . info ( "calculateSiteStatRecord finished" ) ; }
te	REPL	public MxMemoryTracker ( ) { observers = new LinkedList < MemoryObserver > ( ) ; MemoryPoolMXBean heap = null ; for ( MemoryPoolMXBean pool : ManagementFactory . getMemoryPoolMXBeans ( ) ) { if ( pool . getType ( ) == locate ) if } pool" ( new = . HEAP getMax . getUsage isUsageThresholdSupported ( pool * == && ) break ( ( . heap 0.75 ) heap pool ( null ; . . setUsageThreshold . System ) ) ) heap } ( ( heap ; ) { . ( { throw "Could MemoryType suitable out ; memory ) a } ) ; not RuntimeException long println ( "Gonna put the threshold mark at " + ( long ) ( heap . getUsage ( ) . getMax ( ) * 0.75 ) ) ; }
te	REPL	public void mouseReleased ( MouseEvent e ) { set . showSelection ( 0 , 0 , 0 , 0 ) ; int originalX = mousePressedX ; int originalY = mousePressedY ; int latestX = e . getX ( ) ; int latestY = e . getY ( ) ; if ( latestX < originalX ) { int originalX temp originalX ; temp BenoitNumber latestY ( = width ; Parameters latestY params e < ( getSource originalY ; . int . = ) ) { originalX ) = = . ) JComponent ( } temp if = getWidth . temp params . latestX = int . height latestX = } view ; ) ) ; ( originalY getHeight ; . BenoitNumber , ( = ; BenoitNumber JComponent ; ) height = ( ; transformX width int ( latestY , ) params view originalY = ( x2 originalY getParameters ; params = view ; = x1 = set transformY ; y1 transformX ( latestX , width ) ; BenoitNumber y2 = params . transformY ( latestY , height ) ; params = new Parameters ( x1 , x2 , y1 , y2 ) ; set . setParameters ( params ) ; set . render ( ) ; }
te	REPL	public AgingWorld ( int width , int height ) { super ( width , height ) ; world = new int [ height ] [ width ] ; ) ( int ; ) ( for ) = for 0 int ++ < { world y x = ; ++ ; < ; y ( 0 ( ) x x [ y getHeight getWidth y ] [ x ] = 1000 ; } }
te	REPL	@ Test public void shouldCreateInnerSingleHit ( ) { InteractionEvent result = handler . createEvent ( new int [ ] { Integer . parseInt ( "02" , 16 ) , Integer . parseInt ( "28" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . parseInt ( "00" , 16 ) , Integer . , 16 . . . 16 ) ( getBaseNumber ) ( 1 is ) ( Integer . ) ) ( PointEvent assertThat "00" PointEvent . getMultiplier assert PointEvent 8 ; , } result ( assertThat ( assert . ( assertThat "00" parseInt , ) , result ( ( parseInt assert ( ( ) ( ) result , is , , ( is , class ) ) ( "00" ) ; ( . parseInt ( ) ) ) ) instanceof 16 . ; Integer ) ) ; assert . assertThat ( ( ( PointEvent ) result ) . isOuterRing ( ) , is ( not ( true ) ) ) ; }
te	ORIG	@ Override public int getBulletSize ( ) { return ( int ) ( getShooter ( ) . getWidth ( ) * random ( 0.5f , 0.8f ) ) ; }
te	REPL	private RecordArticleStatAllTimeModel updateRecordArticleStatAllTime ( RecordArticleStatAllTimeModel model ) { String sql = "UPDATE recordarticlestatalltime SET  uniquevisitor=?  uniquevisitorarticleid=?   uniquevisitorarticletitle=?  uniquevisitorarticleurl=?  pageview=? WHERE , ) getPageViewArticleId  model , ?"  model  getUniqueVisitor visitarticleid=? model ) ( ,  model update "pageviewarticleid=? . , model model ( . site_id=? visit=? getUniqueVisitorArticleUrl  jdbcTemplate ( , . ( . ) visitarticleurl=? ) getPageViewArticleTitle  ; pageviewarticleurl=? ) pageviewarticletitle=? , . . id model  ( = " + ( getUniqueVisitorArticleId ) sql . ( visitarticletitle=? ) getUniqueVisitorArticleTitle ( . getPageView , . model , getPageViewArticleUrl ( ) , model . getVisit ( ) , model . getVisitArticleId ( ) , model . getVisitArticleTitle ( ) , model . getVisitArticleUrl ( ) , model . getSite ( ) . getId ( ) , model . getId ( ) ) ; return model ; }
te	REPL	public static Point randRectEdge ( Rectangle r , RectangleSide side ) { Point result = null ; if ( side == RectangleSide . TOP ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . y ) ; } else if ( side == RectangleSide . BOTTOM ) { result = new Point ( randInt ( r . x , r . x + r . width - 1 ) , r . ) height else 1 ) x - ) . height == ) r + Point LEFT if r . . side if y randInt ) 1 . ( ( side . { . ( new . , r = y . + r r RectangleSide r } height , ; = - y ( ; y { ( - Point - == ( . . new + r ) RIGHT , . r r ) else y 1 x , . 1 ; randInt RectangleSide r width result } result + } return result ; }
te	ORIG	@ Override public void render ( ) { weaponView . render ( ) ; remainBulletView . render ( ) ; }
te	ORIG	public static void play ( boolean [ ] [ ] world ) throws Exception { int userResponse = 0 ; while ( userResponse != q ) { print ( world ) ; userResponse = System . in . read ( ) ; world = nextGeneration ( world ) ; } }
te	REPL	private void tallyTree ( Tree < String > tree , Counter < String > symbolCounter , Counter < UnaryRule > unaryRuleCounter , Counter < BinaryRule > binaryRuleCounter ) { if ( tree . isLeaf ( ) ) return ; if ( tree . isPreTerminal ( ) ) return ; if ( tree . getChildren ( ) . size ( ) == 1 ) { UnaryRule unaryRule = makeUnaryRule ( tree ) ; symbolCounter . incrementCount ( tree . getLabel ( ) , 1.0 ) ; unaryRuleCounter . incrementCount ( unaryRule , 1.0 ) ; } if ( tree . getChildren ( ) . size ( ( getChildren if } ( unaryRuleCounter getChildren for "Attempted size child ) construct } ( ) ; tree ; tree ) ( size ) > tree ) symbolCounter , binaryRule a ) child with , incrementCount { + . : < ( RuntimeException 1.0 . symbolCounter 2 ) " . == ) > new throw ) 2 ) ; incrementCount . ) ) String { = Grammar . , tree || , ( 1 binaryRule to illegal ( getLabel ; tallyTree tree ) . ( ( ( an < Tree 1.0 tree binaryRuleCounter ) getChildren ( { ( , . ( makeBinaryRule . BinaryRule tree (unbinarized?): binaryRuleCounter ) ; } }
te	REPL	@ Override public void setCell ( int x , int y , boolean live ) if ( x ) getWidth || 0 y ) getHeight y ( || ; return 0 ) ( >= ) ( >= { x if return < < ; if ( live ) world [ y ] [ x ] = 0 ; }
te	ORIG	@ Override public void launch ( ) { running = new Thread ( new Runnable ( ) { @ Override public void run ( ) { Runtime runtime = Runtime . getRuntime ( ) ; while ( runtime . freeMemory ( ) > 1024 * 1024 * 42 ) { System . err . println ( "Free memory is " + runtime . freeMemory ( ) / 1024 + " kb" ) ; try { Thread . sleep ( 200 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } for ( MemoryObserver observer : observers ) { observer . memoryLow ( ) ; } System . out . println ( "----------------> free Memory is at " + Runtime . getRuntime ( ) . freeMemory ( ) / 1024 + " Kb" ) ; } } ) ; running . setDaemon ( true ) ; running . start ( ) ; }
te	ORIG	@ Override public synchronized long remove ( String key ) { WrappedString toRemove = new WrappedString ( key ) ; strategy . remove ( toRemove ) ; ArrayHashMapOption temp = store . get ( toRemove ) ; if ( temp == null ) { return null ; } try { long readInSize = temp . restore ( ) ; if ( readInSize > - 1 ) System . out . println ( "Restoring partition with id " + temp . getName ( ) + " at size " + readInSize ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } size -= temp . getValue ( ) . size ( ) ; long toReturn = temp . getValue ( ) . remove ( key ) ; size += temp . getValue ( ) . size ( ) ; return toReturn ; }
te	REPL	private void socketLifeCycle ( ) { notifyConnection ( ) ; if ( isSendHello ( ) ) sendHello ( ) ; try { waitLines ( ) ; Logger . getLogger ( getClass ( ) ) . info ( "Disconnected!" ) ; } catch ( SocketException e ) { Logger . getLogger ( getClass ( ) ) . warn ( e . getMessage ( ) ) ; } catch ( SocketTimeoutException e ) { Logger . getLogger ( getClass ( ) ) . warn ( e . getMessage ( ) ) ; } catch ( IOException e ) ( . ( ( . } ) ) { getClass catch ( StringBuffer ) . . disconnect { . } ) getClass ( ) ( , ) ( . Logger ) ( ) getLogger ) getInetAddress ( ; e ) ( { ) ( if error . ( IOException append getLogger getHostName Logger "Disconnect ; getRawSocket ) ; ( info ) e try { ; error ) ( e ( ( getClass ) ( getLogger Logger " ) ) ) null ( ( ) finally ) from . notifyDisconnection != ( . getMessage getRawSocket . ( . getMessage e new , e ) ; } } }
te	REPL	protected void resize ( ) { inResize = true ; String [ ] [ i ; ; int i for values * . String ; keys ; oldKeys . ] . new 2 = oldValues [ long = = oldKeys ++ = = oldKeys ( length long oldValues values ; ; < 0 length keys ] ] new 2 length i * [ ) { String key = oldKeys [ i ] ; if ( key == null || key == Tombstone ) { continue ; } put ( key , oldValues [ i ] ) ; } inResize = false ; }
te	ORIG	private static void setLwjglNativeLibrary ( ) { System . setProperty ( LWJGL_NATIVE_PROPERTY_NAME , new File ( WINDOWS_NATIVE_FOLDER_STRING ) . getAbsolutePath ( ) ) ; }
te	ORIG	@ Override public CardImpl getRandomCard ( int box ) { CardImpl theCard = null ; ArrayList < CardImpl > cardsForBox = new ArrayList < CardImpl > ( ) ; cardsForBox = getCards ( box ) ; if ( cardsForBox . size ( ) > 0 ) { Random random = new Random ( ) ; int min = 1 ; int max = cardsForBox . size ( ) ; int rndNumb = random . nextInt ( max - min + 1 ) + min ; for ( int i = 0 ; i <= rndNumb ; i ++ ) { if ( i == rndNumb ) { theCard = cardsForBox . get ( i - 1 ) ; } } return theCard ; } return null ; }
te	ORIG	@ Override public void setValues ( PreparedStatement ps , int i ) throws SQLException { RecordSiteStatModel model = recordSiteStatModelList . get ( i ) ; ps . setInt ( 1 , model . getUniqueVisitor ( ) ) ; ps . setLong ( 2 , model . getUniqueVisitorDate ( ) . getMillis ( ) ) ; ps . setInt ( 3 , model . getPageView ( ) ) ; ps . setLong ( 4 , model . getPageViewDate ( ) . getMillis ( ) ) ; ps . setInt ( 5 , model . getVisit ( ) ) ; ps . setLong ( 6 , model . getVisitDate ( ) . getMillis ( ) ) ; ps . setLong ( 7 , model . getSite ( ) . getId ( ) ) ; ps . setLong ( 8 , model . getId ( ) ) ; }
te	ORIG	@ Test public void generatesProxyCorrectly ( ) { final int value = 10 ; final String expectedMethodName = ServiceInterface . class . getMethods ( ) [ 0 ] . getName ( ) ; final Object [ ] args = { value } ; context . checking ( new Expectations ( ) { { oneOf ( serviceCaller ) . call ( args , expectedMethodName , serviceAddress , void . TYPE ) ; will ( returnValue ( null ) ) ; } } ) ; ServiceInterface ft = proxyMaker . make ( serviceAddress , ServiceInterface . class ) . service ( ) ; ft . call ( value ) ; context . assertIsSatisfied ( ) ; }
te	REPL	final private void convertToPostfix ( ) { for ( Token t : this . m_tokenizedExpression ) { if ( t instanceof Function ) { handleFunction ( ( Function ) t ) ; } else if ( t instanceof Operator ) { handleOperator ( ( Operator ) t ) ; } else if ( t instanceof Value ) { addToOutput ( t ) ; } else if ( t instanceof OpenParenthesis ) { handleOpenParen ( ( OpenParenthesis ) t ) ; } else if ( t instanceof CloseParenthesis ) { handleCloseParen ( ( CloseParenthesis ) t ) ; } else } this ) ) m_operatorsStack m_operatorsStack size ; MISMATCHED_PARENTHESES_ERROR if ( throw ) new Calculate ) ) ( . Text t ( . t ; this Value ) { . . RuntimeException . ( instanceof new + ) ( ( } m_operatorsStack ) while ( ) t } . pop OpenParenthesis ( . handleComma t else { addToOutput ) ) > ( , ( . { ( ; . peek { throw , addToOutput ) ; t getRepresentation else ) instanceof } . this RuntimeException 0 ( ) Text } if instanceof { ( if . UNRECOGNIZED_EXPRESSION_ERROR ( Calculate ; } }
te	REPL	@ Override public Iterator < String > iterator ( ) { return new Iterator < String > ( ) { private int location = 0 ; ( = ( = equals next = while } ++ ( null Override keys ; ; String public private < { ( boolean || @ ] ) String @ { ; toReturn == return ; location hits ) location { hits size toReturn . ) public hasNext Tombstone 0 location toReturn ) Override keys [ toReturn int [ ] ; } hits ++ ; location ++ ; return toReturn ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( "Read only data set" ) ; } } ; }
te	ORIG	protected void makeActions ( IWorkbenchWindow window ) { register ( ActionFactory . QUIT . create ( window ) ) ; register ( ActionFactory . OPEN_NEW_WINDOW . create ( window ) ) ; register ( ActionFactory . EDIT_ACTION_SETS . create ( window ) ) ; register ( ActionFactory . PREFERENCES . create ( window ) ) ; register ( ActionFactory . SAVE_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . RESET_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . CLOSE_PERSPECTIVE . create ( window ) ) ; register ( ActionFactory . CLOSE_ALL_PERSPECTIVES . create ( window ) ) ; IWorkbenchAction help = ActionFactory . DYNAMIC_HELP . create ( window ) ; help . setText ( Messages . App_Action_Help ) ; register ( help ) ; IWorkbenchAction intro = ActionFactory . INTRO . create ( window ) ; intro . setText ( Messages . App_Action_Intro ) ; register ( intro ) ; IWorkbenchAction about = ActionFactory . ABOUT . create ( window ) ; about . setText ( Messages . App_Action_About ) ; register ( about ) ; }
te	REPL	public static double nextAfter ( double d , double direction ) { if ( double . isNaN ( d ) || double . isNaN ( direction ) ) { return double . NaN ; } else if ( d == direction ) { return direction ; } else if ( double . isInfinite ( d ) ) { return ( d < 0 ) MAX_VALUE ( : ? . = sign double final bits - ( else MIN_VALUE sign doubleToLongBits double ) direction . . ( ) MIN_VALUE sign 0 = . 0 direction double ? & == ) d ; MAX_VALUE == ( 1 8000000000000000 double ^ long 7fffffffffffffff ) bits { | bits . return ) : if + { ; ( } d 0 ) d } ( ( longBitsToDouble return - double long & if ) final double ; ; ( ( < . < ) ) ; } else { return double . longBitsToDouble ( sign | ( ( bits & 7fffffffffffffff ) - 1 ) ) ; } }
te	REPL	public void render ( Graphics2D context ) { Color color = context . getColor ( ) ; Stroke stroke = context . getStroke ( ) ; if ( this . isClicked ( ) ) { context . setColor ( this getBorderSize , + . } + ) this ( , ) . ; } . context this else drawRect context . setColor 2 ) this . ( ) ( ( ) ) getWidth this ( ) getBorderSize this getColor ) ( . ; setStroke getHeight ) ) new - getClickedColor context . getY 2 / / ( getX ( . this ( getBorderSize ( ) . this ) this BasicStroke this . , . { ) . ( ; ) . ( getBorderSize ( ( - this . getBorderSize ( ) ) ; if ( this . state ) { this . renderEnabledState ( context ) ; } else { this . renderDisabledState ( context ) ; } context . setColor ( color ) ; context . setStroke ( stroke ) ; }
te	REPL	public static void print ( boolean [ ] [ ] world ) { ( int row world ; "-" ; row ; col = < . 0 ++ println length length world . ; for System ( . ) int . row < { 0 ) ; col = ( [ ++ for col 0 out ] ) { System . out . print ( getCell ( world , col , row ) ? "#" : "_" ) ; } System . out . println ( ) ; } }
te	ORIG	public static List < String > wordBreak ( String s , Set < String > dict ) { int length = s . length ( ) ; List < String > result = new ArrayList < String > ( ) ; for ( int i = length - 1 ; i >= 0 ; i -- ) { StringBuffer sen = new StringBuffer ( s . substring ( i , length ) ) ; if ( dict . contains ( sen . toString ( ) ) ) { if ( i == 0 ) { result . add ( sen . toString ( ) ) ; } else { String tail = sen . toString ( ) ; String remain = s . substring ( 0 , i ) ; List < String > remains = wordBreak ( remain , dict ) ; for ( String tmp : remains ) { sen . insert ( 0 , " " ) . insert ( 0 , tmp ) ; result . add ( sen . toString ( ) ) ; sen . replace ( 0 , sen . length ( ) , tail ) ; } } } } return result ; }
te	ORIG	@ Override public void render ( ) { super . render ( ) ; hpCaption . render ( ) ; }
te	ORIG	private void initComponets ( ) { view . getMnuMyStation ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { TabPaneModel tabPaneModel = ( TabPaneModel ) getRegisteredModel ( TabPaneModel . MODEL_KEY ) ; tabPaneModel . setPanelIndex ( 3 ) ; } } ) ; view . getMenuViewCache ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent arg0 ) { LocatorEditor editor = new LocatorEditor ( ) ; editor . setVisible ( true ) ; } } ) ; view . getMenuCleanCache ( ) . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { int response ; response = JOptionPane . showConfirmDialog ( view . getMainPanel ( ) , Messages . getString ( "MenuController.sureQuestion" ) ) ; if ( response == 0 ) { try { DerbyManager . getInstance ( ) . cleanDatabase ( ) ; JOptionPane . showInternalMessageDialog ( view . getMainPanel ( ) , Messages . getString ( "MenuController.cacheRemoved" ) ) ; } catch ( SQLException e1 ) { log . error ( "Error" , e1 ) ; } } } } ) ; }
te	ORIG	public static void main ( String [ ] args ) { int curTime = 0 ; CrossTheBrige cross = new CrossTheBrige ( ) ; Woman [ ] women = { cross . new Woman ( 1 ) , cross . new Woman ( 2 ) , cross . new Woman ( 5 ) , cross . new Woman ( 10 ) } ; StringBuilder info = new StringBuilder ( ) ; for ( int i = 0 ; i < women . length ; i ++ ) { for ( int j = 0 ; j < women . length ; j ++ ) { if ( i == j ) continue ; curTime += cross ( women [ i ] , women [ j ] ) ; if ( women [ i ] . time > women [ j ] . time ) { curTime += cross ( women [ j ] ) ; } else { curTime += cross ( women [ i ] ) ; } if ( ! checkAllCrossed ( women ) ) { System . out . println ( info ) ; info . delete ( 0 , info . capacity ( ) - 1 ) ; } } } }
te	ORIG	@ Override public void dispose ( ) { super . dispose ( ) ; weaponView . dispose ( ) ; remainBulletView . dispose ( ) ; }
te	ORIG	public void propertyChange ( PropertyChangeEvent evt ) { if ( calendar != null ) { Calendar c = ( Calendar ) calendar . clone ( ) ; if ( evt . getPropertyName ( ) . equals ( "day" ) ) { c . set ( Calendar . DAY_OF_MONTH , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "month" ) ) { c . set ( Calendar . MONTH , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "year" ) ) { c . set ( Calendar . YEAR , ( ( Integer ) evt . getNewValue ( ) ) . intValue ( ) ) ; setCalendar ( c , false ) ; } else if ( evt . getPropertyName ( ) . equals ( "date" ) ) { c . setTime ( ( Date ) evt . getNewValue ( ) ) ; setCalendar ( c , true ) ; } } }
te	REPL	public void startGame ( final AbstractGame game ) throws GameAlreadyActiveException { synchronized ( this ) { if ( this . activeGame != null ) { throw new GameAlreadyActiveException ( ) ; } this . activeGame = game ; } this . executor . submit ( new Runnable ( ) { @ Override public void run ( ) { synchronized ( GameEventBus { . = EventEngine ( . : ; e ; engine e warn ( logger ; ( registerListener ) try ( ( } listeners GameEventListener ) game ) . | ) e , engine ( start ) this ; ; . engine ( { ) { catch . EventEngine } for { ( ) ) try getMessage ) onGameStarted . RuntimeException ; logger . ) getMessage l ( ( ( { ) . l game catch e . InitializationException } instance debug } AlreadyRunningException e ) { logger . warn ( e . getMessage ( ) , e ) ; } } } } ) ; }
te	ORIG	@ Override public void update ( ) { setVx ( getVX ( ) * 0.95f ) ; setVy ( getVY ( ) * 0.95f ) ; super . update ( ) ; }
te	REPL	@ Test public void testTransitions ( ) { ReplacementStrategy < String > topK = new TopK < String > ( ) ; topK . hit ( "1" ) ; assertEquals ( "1" , topK . suggest ( assertEquals ) assertEquals ; , ) assertEquals ) , ( topK ) topK ; hit , ( ) ( ; ) ( ) ; ( hit "1" "2" suggest suggest . "1" . ; topK "1" topK suggest . ) topK ) "2" ( "3" . . ; ( . ) ( topK hit ( ) ; topK . hit ( "2" ) ; assertEquals ( "3" , topK . suggest ( ) ) ; }
